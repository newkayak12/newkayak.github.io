<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | newkayak12.github.io</title>
	<meta name="description"
		content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>

  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "network-2024-05-22-nginx-series-01-reverseproxy-html": {
        "title": "[nginx Series] 01 Reverseproxy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - NginxNginx 기본 + ReverseProxyReverseProxy에 대한 기본 내용 참조 Configserver {    listen 80;    server_name www.example.com;## 띄어쓰기 민감한 편    if ($http_x_forwarded_proto = 'http'){            return 301 https://$host$request_uri;    }}server {    listen 443;    server_name www.example.com;    root /{rootPath};    index index.html;        location /api {        proxy_pass http://localhost:8080;    }}Syntaxnginx -t 로 syntax 점검을 받을 수도 있다.",
        "url": "//network/2024/05/22/nginx-series-01-ReverseProxy.html"
      }
      ,
    
      "network-2024-05-22-network-series-02-tls-html": {
        "title": "[network Series] 02 Tls",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TLSTLS(Transport Layer Security)TLS 란전송 계층 보안(TLS)은 인터넷 상의 커뮤니케이션을 위한 개인 정보와 데이터 보안을 용이하게 하기 위해 설계되어 널리 채택된 보안 프로토콜입니다.TLS의 주요 사용 사례는 웹 사이트를 로드하는 웹 브라우저와 같이 웹 응용 프로그램과 서버 간의 커뮤니케이션을 암호화하는 것입니다.어떤 일을 하는가?  암호화 : 제3자로부터 전송되는 데이터를 숨깁니다.  인증 : 정보를 교환하는 당사자가 요청된 당사자임을 보장합니다.  무결성 : 데이터가 위조되거나 변조되지 않았는지 확인합니다.TLS vs. SSLTLS는 Netscape가 개발한 SSL(Secure Sockets Layer)이라고 불리는 이전의 암호화 프로토콜에서 발전한 것입니다. TLS 버전 1.0은 SSL 버전 3.1로서 개발을 시작했지만 Netscape와 더 이상 연관이 없음을 명시하기 위해서 발표 전에 프로토콜의 이름이 변경되었습니다.이러한 역사 때문에 용어 TLS와 SSL은 가끔 서로 바꿔서 사용됩니다.TLS vs. HTTPSHTTPS는 HTTP 프로토콜 상위에서 TLS 암호화를 구현한 것으로 모든 웹 사이트와 다른 웹 서비스에서 사용됩니다. 따라서 HTTPS를 사용하는 웹 사이트는 TLS 암호화를 이용합니다.TLS 인증서란웹 사이트나 응용 프로그램이 TLS를 사용하기 위해서는 원본 서버에 TLS 인증서가 설치되어 있어야 합니다(위에서 설명한 이름 혼동 때문에 이 인증서는 “SSL 인증서”라고도 알려져 있습니다).인증 기관이 도메인을 소유한 사람 혹은 비즈니스에게 TLS 인증서를 발행합니다.인증서는 서버의 공개 키와 더불어 누가 도메인 소유자인지에 대한 중요한 정보를 포함하며, 이 두 가지는 모두 서버의 신원을 확인하는 데 중요합니다.어떤 과정으로 작동하는가?TLS 연결은 TLS Handshake로 알려진 일련의 순서를 사용하여 초기화됩니다.사용자가 TLS를 사용하는 웹 사이트를 돌아다니면 사용자 장치(클라이언트 장치로도 알려짐)와 웹 서버 간에 TLS Handshake가 시작됩니다.TLS Handshake 동안 사용자 장치와 웹 서버는 다음과 같은 일을 수행합니다.  사용할 TLS 버전(TLS 1.0, 1.2, 1.3 등)을 지정합니다  사용할 암호 제품군(아래 참고)을 결정합니다  서버의 TLS 인증서를 사용하여 서버의 신원을 인증합니다.  Handshake가 완료된 후 키 간의 메시지를 암호화하기 위한 세션 키를 생성합니다.TLS Handshake는 각 커뮤니케이션 세션을 위한 암호 제품군을 구축합니다.암호 제품군은 공유된 암호화 키 또는 세션 키와 같은 세부 정보를 명시하는 알고리즘 집합으로 해당 특정 세션에 사용됩니다. 공개 키 암호화로 알려진 기술 덕분에 TLS는 암호화되지 않은 채널을 통해 일치하는 세션 키를 설정할 수 있습니다.Handshake는 또한 인증을 처리하며, 이는 대개 클라이언트에게 신원을 증명하는 서버로 구성됩니다.이는 공개 키를 사용하여 수행됩니다. 공개 키는 단방향 암호화를 사용하는 암호화 키로,공개 키를 가진 누구나 신뢰성을 보장하기 위해 서버의 개인 키로 암호화된 데이터를 해독할 수 있음을 의미하지만 원래 발신자만 개인 키를 사용해 데이터를 암호화할 수 있습니다.서버의 공개 키는 TLS 인증서의 일부입니다.데이터카 암호화되고 인증되고 나면, 메시지 인증 코드(MAC)와 함께 서명됩니다. 수신자는 데이터의 무결성을 보장하기 위해 MAC를 확인할 수 있습니다. 이는 아스피린 병에서 발견할 수 있는 일종의 부정 조작 방지 포장과 같은 것입니다. 소비자는 구매할 때 포장이 손상되지 않았으면 아무도 약에 손대지 않았다는 것을 알 수 있습니다.TLS가 미치는 영향TLS의 최신 버전은 웹 응용 프로그램 성능에 거의 영향을 미치지 않습니다.TLS 연결을 설정하는 데 수반되는 복잡한 프로세스 때문에 로드 시간과 계산 능력이 소모되어야 합니다. 데이터가 전송되기 전에 클라이언트와 서버는 왔다 갔다 몇 번 커뮤니케이션해야 하며, 이는 클라이언트와 서버 모두를 위한 메모리뿐만 아니라 웹 응용 프로그램을 위한 귀중한 밀리세컨드의 로딩 시간을 소모합니다.그러나 대신에 TLS Handshake가 생성한 잠재적인 지연을 완화하는 것을 돕는 기술이 있습니다. 하나는 TLS Handshake가 완료되기 전에 서버와 클라이언트가 데이터 전송을 시작하도록 하는 TLS False Start입니다.TLS를 빠르게 하기 위한 또 다른 기술은 이전에 커뮤니케이션한 적이 있는 서버와 클라이언트가 간략화된 Handshake를 사용하도록 허용하는 TLS Session Resumption입니다.이러한 개선 사항은 TLS를 로딩 시간에 현저하게 영향을 미쳐서는 안 되는 매우 빠른 프로토콜로 만드는 데 도움을 주었습니다. TLS와 연관된 계산 비용은 오늘날 표준에 따르면 거의 무시해도 좋은 정도입니다.2018년에 발표된 TLS 1.3은 TLS를 더 빠르게 만들었습니다. TLS 1.3의 TLS Handshake는 몇 밀리세컨드로 프로세스를 단축하며 2회 왕복 대신 1회 왕복(또는 왔다 갔다하는 커뮤니케이션)만을 요구합니다.사용자가 전에 웹 사이트에 연결한 적이 있으면, TLS Handshake는 0회 왕복을 할 수 있으며, 이는 속도를 더 빠르게 할 수 있습니다.https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/https://en.wikipedia.org/wiki/Transport_Layer_Security",
        "url": "//network/2024/05/22/network-series-02-TLS.html"
      }
      ,
    
      "network-2024-05-22-network-series-01-subnet-html": {
        "title": "[network Series] 01 Subnet",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - IPIPv4, IPv6IPv4####.####.####.###0 ~ 255 (2^8)으로 구성되며4옥텟으로 구분되는 형식을 `IPv4`라고 한다.총 32비트의 주소 공간을 제공한다.    192   .    168   .     0    .    1 11000000 . 10101000 . 00000000 . 00000001|--------|                       |--------|8비트(=1바이트)                     옥텟(Octet)|-----------------------------------------|      IPv4 주소 : 8비트 * 4 = 32비트(4바이트)      IPv6IPv6의 128비트 주소공간은 다음과 같이 16비트(2옥텟)를 16진수로 표현하여8자리로 나타낸다.(8옥텟)2001:0db8:85a3:08d3:1319:8a2e:0370:7334러나 대부분의 자리가 0의 숫자를 갖게 되므로, 0000을 하나의 0으로 축약하거나,혹은 아예 연속되는 0의 그룹을 없애고 ':' 만을 남길 수 있다.따라서 아래의 IPv6 주소들은 모두 같은 주소를 나타낸다.2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0000:0000:0000::1428:57ab2001:0DB8:0:0:0:0:1428:57ab2001:0DB8:0::0:1428:57ab2001:0DB8::1428:57ab특수 주소 공간::/128 - 이 주소는 모든 값을 0으로 설정한 특수한 주소이다. 가상적으로만 사용된다. IP 미설정 상태의 발신 주소이다..::1/128 - 자기 자신의 주소를 가리키는 루프백 주소이다. 프로그램에서 이 주소로 패킷을 전송하면 네트워크는 전송자에게로 패킷을 반송한다. IPv4의 127.0.0.1 주소와 동일하다.::/96 - IPv4 호환 주소를 위해 사용되는 주소공간이다.::ffff:0:0/96 - IPv4 매핑 주소를 위해 사용되는 주소공간이다.fc00::/7 - IPv6 유니캐스트를 위한 주소공간이다.fe80::/10 - link-local address를 위한 주소공간이다. IPv4의 자동 설정 IP 주소인 169.254.x.x 에 해당한다.fec0::/10 - site-local address를 위한 주소공간이다. 네트워크 내부에서만 유효한 주소이며, 2004년 10월 RFC3879에서 폐기되어 더 이상 사용되지 않는다.ff00::/8 - IPv6 멀티캐스트를 위한 주소공간이다. IPv4의 브로드캐스트는 더 이상 지원되지 않으며, IPv6에서는 대신 멀티캐스트를 사용해야 한다.네트워크주소와 호스트주소IP 주소는 네트워크 주소와 호스트 주소 두 부분으로 나뉘게 됩니다.네트워크 주소는 호스트(단말)들을 모은 네트워크를 지칭하는 주소를 뜻합니다.네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 합니다.호스트 주소는 하나의 네트워크 내에 존재하는 호스트(단말)를 구분하기 위한 주소를 뜻합니다.그런데 IP 주소에서 네트워크 주소와 호스트 주소를 구분하는 경계점이 고정되어있지 않습니다.그렇다보니 필요한 호스트 IP 개수에 따라 네트워크의 크기를 다르게 할당할 수 있도록 클래스 라는 개념을 도입했는데요.클래스는 A, B, C, D, E 클래스가 존재하며 각각의 클래스에 할당되는 IP 주소 갯수와 역할이 다릅니다.A 클래스 -&gt; 네트워크.호스트.호스트.호스트B 클래스 -&gt; 네트워크.네트워크.호스트.호스트C 클래스 -&gt; 네트워크.네트워크.네트워크.호스트A 클래스 -&gt; 1~127.0.0.0 (로컬호스트)B 클래스 -&gt; 128~191.0.0.0C 클래스 -&gt; 192~223.0.0.0D 클래스 -&gt; 224~239.0.0.0중요한 점은 클래스 기반으로는 사용하지 않는다는 점이다.클래스 기반보다 네트워크 주소를 세밀하게 분할하고 할당하기위해서 네트워크 크기에 맞춰 1비트 단위로 네트워크를 상세히 분할하는 방법을 사용하는데요.클래스 개념 자체를 버리는 클래스리스(Classless) 기반의 주소 체계를 사용합니다.클래스 리스클래스리스에서는 구분자가 필요한데 이를 서브넷 마스크(Subnet Mask)라고 합니다.넷 마스크는 IP주소를 네트워크 포션 / 호스트 포션으로 나누는데 사용되는 숫자 조합입니다. 서브넷 마스크는 IP 주소와 같은 길이의 비트로 구성되며,이진수(Binary)로 표현했을 때 네트워크 포션은 1로, 호스트 포션은 0으로 설정됩니다.즉, 가령 210.100.100.1의 서브넷 마스크가 255.255.255.0이라면,255.255.255.0은 1111 1111. 1111 1111. 1111 1111. 0000 0000과 같습니다.여기서 1인 부분은 네트워크를, 0인 부분은 해당 네트워크 내에 속해있는 호스트를 나타내므로 IP주소와 서브넷 마스크를 논리적 AND 연산 결과 값이 바로 서브넷이 됩니다. 하나의 주소를 서브넷 마스크를 씌워서 작은 네트워크로 만드는 것을 서브넷팅(Subnetting)이라고 합니다.210.100.100.1\t=\t1101 0010. 0110 0100. 0110 0100. 0000 0001\t=\tIP주소255.255.255.0\t=\t1111 1111. 1111 1111. 1111 1111. 0000 0000\t=\t서브넷 마스크210.100.100.0\t=\t1101 0010. 0110 0100. 0110 0100. 0000 0000\t=\t서브넷 (AND 연산 결과)이러면 호스트와 네트워크의 경계를 알 수 있다.출처: medium.com출처: tistory.com표기법일반적인 표기법으로는 CIDR 표기법이 사용되며, IP 주소 뒤에 슬래시와 비트 수를 숫자로 표기합니다. 예를 들어, 192.168.0.0/24와 같이 나타낼 수 있으며,이 표기법에서 192.168.0.0은 네트워크 ID를 의미하고,/24는 서브넷 마스크의 길이를 나타냅니다. 24비트 서브넷 마스크는 첫 24비트가 네트워크 ID이고 나머지 8비트가 호스트 ID임을 의미합니다.따라서 192.168.0.0/24는 192.168.0.0부터 192.168.0.255 까지의 IP 주소 범위를 나타냅니다. 여기서 네트워크 ID와 브로드캐스트 주소를 제외하고실제로 호스트에 할당할 수 있는 IP 주소의 범위는 192.168.0.1 ~ 192.168.0.254가 됩니다.본론그래서 ip/32, ip/24는 무엇인가?IP 주소의 범위를 표현하기 위한 방식이다. 이진수 몇 자리까지 고정값으로 두는지에 대한 정의다.            Subnet      Subnet Mask (Dec)      Host 수                  /8      255.0.0.0      16,777,216              /9      255.128.0.0      8,388,608              /10      255.192.0.0      4,194,304              /11      255.224.0.0      2,097,152              /12      255.240.0.0      1,048,576              /13      255.248.0.0      524,288              /14      255.252.0.0      262,144              /15      255.254.0.0      131,072              /16      255.255.0.0      65,536              /17      255.255.128.0      32,768              /18      255.255.192.0      16,384              /19      255.255.224.0      8,192              /20      255.255.240.0      4,096              /21      255.255.248.0      2,048              /22      255.255.252.0      1,024              /23      255.255.254.0      512              /24      255.255.255.0      256              /25      255.255.255.128      128              /26      255.255.255.192      64              /27      255.255.255.224      32              /28      255.255.255.240      16              /29      255.255.255.248      8              /30      255.255.255.252      4              /31      255.255.255.254      2              /32      255.255.255.255      1      ",
        "url": "//network/2024/05/22/network-series-01-Subnet.html"
      }
      ,
    
      "apache-2024-05-22-httpd-series-01-reverseproxy-html": {
        "title": "[httpd Series] 01 Reverseproxy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - HTTPD CONFIGReverseProxyProxy는 Forward / Reverse Proxy 두가지가 있는데,보통 Forward Proxy는 사내망 Client에서 외부에 있는 웹서버를 접근할 때 사용되며(미리 Proxy 지정이 필요함),Reverse Proxy는 Client에서 웹서버에 접근 할 때, 내부망에 위치한 WAS서버를 대신하여 요청한 Request에 대해 Response를 하는 구조이다.아파치와 톰캣에 리버스 프록시(reverse proxy) 환경을 구축하는 이유는 톰캣에 올린 웹 서비스의 서버 ip를 외부 사용자로부터 감추기 위한 것이며(보안), 로드밸런싱 기능으로 트래픽 분산을 하여 서버의 가용성을 유지하기 위해서 인프라를 구성하기 위해서 이다.&lt;VirtualHost *:80&gt;\t\t# Forward Proxy 경우 On / Reverse Proxy Off\tProxyRequests Off\t# 호스트가 받은 HTTP 요청을 Proxy 요청시 사용    # Reverse 경우 On으로 해야함\tProxyPreserveHost On\t# Proxy에 연결할 URL     # ServerHost:localhost -&gt; Apache -&gt; ProxyPass URL\tProxyPass / http://192.168.10.146:8080/service/ # 뒤에 슬래쉬는 붙여줘야함\t# WAS 가 redirect HTTP 응답을 보냈을 경우 Location, Content-Location HTTP 헤더를 수정 클라이언트에 전달한다.\t# reverse proxy가 이 헤더를 수정하지 않으면 클라이언트는 redirect 시 제대로 연결할 수 없으므로 꼭 설정해야 한다.\tProxyPassReverse / http://192.168.10.146:8080/service/\t# 로드밸런싱 - 경로 분기\t&lt;Location /html&gt;\t\tProxyPass http://192.168.10.146:8080/html/\t\tProxyPassReverse http://192.168.10.146:8080/html/\t&lt;/Location&gt;        &lt;Location /user&gt;\t\tProxyPass http://192.168.10.146:8080/user/\t\tProxyPassReverse http://192.168.10.146:8080/user/\t&lt;/Location&gt;\t&lt;/VirtualHost&gt;",
        "url": "//apache/2024/05/22/httpd-series-01-ReverseProxy.html"
      }
      ,
    
      "gradle-2024-05-22-gradle-series-summary-html": {
        "title": "[gradle Series] Summary",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Gradle SummaryGradle 기본 정리Gradle?Groovy라는 도메인 언어를 사용하는 빌드 스크립트(태스크로 정의되는)로 정의된 빌드 도구이다. 추가적으로 종속성 관리를 지원한다.특징  유연성: Java, Kotlin, Android 등 다양한 프로그래밍 언어와 플랫폼을 지원한다.  성능 : Maven보다 효율적이며, 증분 빌드를 지원한다.  종속성 관리  빌드 라이프 사이클 관리 : 컴파일, 테스트, 배포를 위한 패키징까지 빌드 라이프사이클의 모든 단계를 지원구성  빌드: 소스컴파일, 테스트 실행, 실행 파일 빌드, 배포를 위한 바이너리 패키징 등 소프트웨어 개발의 다양한 단계를 자동화하는 작업 또는 일련의 작업,이는 빌드 스크립트에 정의되며, Gradle DSL로 작성되며 보통 build.gradle로 명명된다.  태스크: Gradle의 기본 작업 단위, 고유한 이름을 가질 수 있다.  플러그인: 빌드 스크립트에 추가하여 추가 기능을 제공할 수 있게 하는 재사용 가능한 기능    plugins { id 'java'}        구성: 프로젝트를 위한 종속성이 명명된 집합, compile, testCompile, runtime, testRuntime 등 여러 유형을 지원한다.``` groovydependencies { compile ‘junit:junit:5.0.1’ ## 컴파일 단계에서 사용 , deprecated된 구성 runtime .. ## 애플리케이션 실행에서 사용, 컴파일에는 중요하지 않지만 애플리케이션 실행에는 필요한 경우 implementation … ## 소스코드를 구현하는 데 필요한 종속성에 사용, 컴파일, 런타임에 모두 종속성 사요 가능 testImplementation … ## 소스코드를 테스트에 사용}5. 레포지토리: 의존성을 다운로드할 수 있는 위치를 명명한다. `mavenCenter()`, `jcenter()`등이 있다.6. 프로젝트: 소프트웨어 애플리케이션 또는 구성 요소를 나타내는 엔티## 빌드 스크립트 구조- 태스크: gradle이 실행해야하는 작업을 정의한다. ```groovytask clean(type: Delete) {    delete rootProject.buildDir}task build(type: Jar) {    from sourceSets.main.output    archiveBaseName.set(appName)    archiveVersion.set(version)}  소스셋: 소스코드가 포함된 디렉토리를 정의한다.    sourceSets {  main {      java {          srcDir'src/main/java'      }      resources {          srcDir'src/main/resources'      }  }  test {      java {          srcDir'src/test/java'      }      resources {          srcDir'src/test/resources'      }  }}      태스크  javaCompile: 자바 소스 코드를 클래스로 컴파일한다. 소스 및 대상 호환성, 클래스 경로, 종속성 등과 같은 옵션을 지원    task compileJava(type: JavaCompile) {  sourceCompatibility = 1.8  targetCompatibility = 1.8      sourceSets.main.java.srcDirs.each {      def file = it.toString()      options.compilerArgs += [\"-classpath\", file]  }}        test: 테스트를 실행한다.    task test(type: Test) {  testClassesDirs = sourceSets.test.output.classesDirs  classpath = sourceSets.test.runtimeClasspath  reports.html.destination file(\"${buildDir}/test-results\")}        jar: JAR를 생성한다.    task buildJar(type: Jar) {  baseName = 'myproject'  version = '1.0'  from sourceSets.main.output}        JavaExec: 자파 프로그램 실행    task runMain(type: JavaExec) {  classpath = sourceSets.main.runtimeClasspath  main = 'com.example.Main'  args = ['arg1', 'arg2']}        Copy: 소스 디렉토리에서 대상 디렉토리로 파일 및 디렉토리를 복사한다.    task copyFiles(type: Copy) {  from 'src/main/resources'  into 'build/resources/main'  include '**/*.properties'  filter { line -&gt; line.replaceAll('FOO', 'BAR') }}      태스크의 순서task myTask {    doFirst {    // runs before any other actions    }    doLast {    // runs after all actions are complete    }    finalizedBy anotherTask    dependsOn someTask}someTask -&gt; doFirst -&gt; task -&gt; doLast -&gt; anotherTask 순으로 실행된다.태스크 옵션  -D : 작업 구성 또는 종료에서 액세스할 수 있는 시스템 속성을 정의  -P : 프로젝트 객체 또는 작업의 클로저에서 액세스할 수 있는 프로젝트 속성을 정의  -x : 작업을 제외한다.Gradle Properties빌드 프로세스의 다양한 측면을 구성하는 데 사용하는 Key:Value 쌍 빌드스크립트 전체에서 액세스할 수 있다.gradle.propertiesappName=my-appversion=1.0.0java.home=/usr/share/java/bin",
        "url": "//gradle/2024/05/22/gradle-series-Summary.html"
      }
      ,
    
      "git-2024-05-22-git-series-03-convention-html": {
        "title": "[git Series] 03 Convention",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ConventionConvention메시지 컨베션  제목과 본문을 한 줄 띄워서 분리하기  제목은 영문 기준 50자 이내  제목 첫 글자는 대문자  제목 끝 . 금지  본문은 무엇, 왜에 맞춰 작성  태그: 제목(한 줄 띄우기)본문(한 줄 띄우기)꼬리말태그|     TagName      |                          Description                          ||:—————-:|:————————————————————-:||       Feat       |                           새로운 기능 추가                           ||       Fix        |                             버그 수정                             ||      Design      |                        CSS, UI 디자인 변경                         || !BREAKING CHANGE |                           큰 API 변경                            ||     !HOTFIX      |                            HOTFIX                             ||      Style       |               코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우                ||     Refactor     |                         프로덕션 코드 리팩토링                          ||     Comment      |                        필요한 주석 추가 및 변경                         ||       Docs       |                             문서 수정                             ||       Test       |         테스트 코드, 리펙토링 테스트 코드 추가 (ProductionCode 변경 X)          ||      Chore       | 빌드 업무 수정, 패키지 매니저 수정, 패키지 관리자 구성 등 업데이트 (ProductionCode 변경 X) ||      Rename      |                          파일/ 폴더명 수정                           ||      Remove      |                             파일 삭제                             |깃 모지| Git moji |  코드   | 설명||:——–:|:—–:|:—-:||    🎨    | :art: |코드의 구조/형태 개선||    ⚡     |:zap:|성능 개선||    🔥    |:fire:|코드/파일 삭제||    🐛    |:bug:|버그 수정||    ✨     |:sparkles:|새 기능||    📝    |:memo:|문서 추가/수정||    💄    |:lipstick:|UI/스타일 파일 추가/수정||    🎉    |:tada:|프로젝트 시작||    ✅     |:white_check_mark:|테스트 추가/수정||    🔒    |:lock:|보안 이슈 수정||    🔖    |:bookmark:|릴리즈/버전 태그||    💚    |:green_heart:|CI 빌드 수정||    📌    |:pushpin:|특정 버전 의존성 고정||    👷    |:construction_worker:|CI 빌드 시스템 추가/수정||    📈    |:chart_with_upwards_trend:|분석, 추적 코드 추가/수정||    ♻     |:recycle:|코드 리팩토링||    ➕     |:heavy_plus_sign:|의존성 추가||    ➖     |:heavy_minus_sign:|의존성 제거||    🔧    |:wrench:|구성 파일 추가/삭제||    🔨    |:hammer:|개발 스크립트 추가/수정||    🌐    |:globe_with_meridians:|국제화/현지화||    💩    |:poop:|똥싼 코드||    ⏪     |:rewind:|변경 내용 되돌리기||    🔀    |:twisted_rightwards_arrows:|브랜치 합병||    📦    |:package:|컴파일된 파일 추가/수정||    👽    |:alien:|외부 API 변화로 인한 수정||    🚚    |:truck:|리소스 이동, 이름 변경||    📄    |:page_facing_up:|라이센스 추가/수정||    💡    |:bulb:|주석 추가/수정||    🍻    |:beers:|술 취해서 쓴 코드||    🗃    |:card_file_box:|데이버베이스 관련 수정||    🔊    |:loud_sound:|로그 추가/수정||    🙈    |:see_no_evil:| .gitignore 추가/수정|",
        "url": "//git/2024/05/22/git-series-03-Convention.html"
      }
      ,
    
      "git-2024-05-22-git-series-02-summary-html": {
        "title": "[git Series] 02 Summary",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Summaryconfig # 현재 위치에서 지역 저장소를 생성$ git init # 깃 환경에서 사용자 이름을 [사용자명]으로 지정$ git config --global user.name \"[사용자명]\" # 깃 환경에서 사용자 이메일을 [사용자이메일명]으로 지정$ git config --global user.email \"[사용자이메일명]\"stage  # [파일명.확장자명]을 스테이지에 올림$ git add [파일명.확장자명]  # 상태를 확인$ git status  # 파일 add 취소$ git restore --staged 파일명  # 전체 add 취소$ git reset HEADcommit  # 커밋 메시지 [메시지명]을 붙여 커밋$ git commit -m \"[메시지명]\"$ git commit -am \"[메시지명]\" # 스테이징과 커밋을 동시에 진행  # 최근 순서대로 커밋을 취소$ git reset HEAD^ # 현재 HEAD의 이전 커밋으로 되돌리기$ git reset HEAD~n # 현재로 부터 n 번째 이전 커밋으로 되돌리기  # 롤백할 커밋을 지정$ git reset [커밋 해시]# - reset의 3가지 옵션$ git reset --soft [커밋ID]  # head 만 바뀜$ git reset --mixed [커밋ID] # staging 도 그 때로 바뀜$ git reset --hard [커밋ID] # working디렉토리/staging 모두 그 때로 바꿈   # 커밋을 삭제하지않고 이전 커밋을 새로 복사 추가하는 식으로 롤백$ git revert [커밋 해시] # 해당 커밋 이전상태로 되돌린다라는 명령  # 커밋 수정하는 법# ... 파일 수정 한 뒤$ git add .$ git commit --amend # 최신 커밋 수정log  # 커밋 내역 확인$ git log           # 전체 이력을 보여준다.$ git shortlog     $ git log --oneline # 커밋과 커밋 메시지를 조회$ git log -p        # 이력을 보여줄 때, 변경된 데이터도 보여준다.$ git log [filename] # 특정 파일에 대한 이력을 보여준다.$ git log -p [filename] # 특정 파일의 이력과 변경된 데이터를 보여준다.$ git log --stat    # 커밋마다 파일의 추가/삭제된 통계데이터를 보여줌$ git log --graph   # 브랜치 분기 및 병합내용을 아스키 그래프로 보여줌  # 특정 커밋 내역 확인$ git show [커밋 id]  # 최근 버전과 작업 폴더의 수정 파일 사이의 차이를 출력$ git diff               # modified 상태의 file과 마지막 commit 비교$ git diff --staged      # staged 상태의 file과 마지막 commit 비교$ git diff --color-words # 변경사항을 color 풀하게 비교$ git diff [브랜치이름]    # 현재브랜치와 선택된 브랜치와 차이점 비교$ git diff [이전커밋 id] [이후커밋 id] # 커밋 비교( Alias git config --global alias.graph 'log --oneline --graph --all --decorate' )            git log 명령어 예시      설명                  git log      HEAD와 관련된 commit들이 자세하게 나옴              git log –oneline      간단히 commit 해시와 제목만 보고 싶을 때              git log –oneline –graph –decorate      HEAD와 관련된 commit들을 조금 더 자세히 보고 싶을 때              git log –oneline –graph –all –decorate      모든 branch들을 보고 싶을 때 사용하는 명령어              git log –oneline -n7      내 branch의 최신 commit을 7개만 보고 싶을 때 사용      remote  # 원격 저장소에 연결$ git remote add origin [github 레포지 주소]  # 옵션 종류 보기$ git remote --help  # 추가한 원격저장소의 목록 확인 $ git remote$ git remote -v # 상세히  # 특정 원격 저장소의 정보를 확인할 수 있다.$ git remote show 이름  # 원격저장소 이름 변경$ git remote rename 기존이름 변경할이름  # 원격저장소를 제거$ git remote rm 이름  # 지역 저장소의 커밋을 맨 처음 원격 저장소에 올리는 경우$ git push -u origin master  # -u로 등록한 후에 지역 저장소의 커밋을 원격 저장소에 올리는 경우(업로드)$ git push$ git push origin master  # 원격 저장소의 커밋을 지역 저장소로 가져옴$ git pull origin master  # 원격 저장소 복제하기$ git clone [원격 저장소 주소]  # 원격 저장소의 커밋을 가져오기만 하고 merge하지 않는다$ git fetch# 이후엔 diff 로 비교$ git diff test origin/test # 브랜치 이름이 test일 경우 예시  # 원격저장소 삭제(끊기)$ git remote remove originremove  # 로컬저장소 원격저장소 둘다 파일 삭제$ git rm [filename]      # 원격저장소 파일만 삭제. 로컬저장소 파일은 냅둠$ git rm --cached [filename]# -rf (recursive, force)branch  # 브랜치 확인$ git branch                 # 브랜치 추가 / 삭제$ git branch [branch name]  $ git branch -d [branch name] # -delete  # 브랜치로 이동$ git switch [branch name]$ git checkout [branch name]  # 브랜치 추가하고 바로 이동$ git switch -c [branch name]$ git checkout -b [branch name]  # 현재 브랜치에서 다른 브랜치를 merge$ git merge [branch name]cherry-pick  # 만일 내가 X 브랜치에 있고   # 브랜치 Y의 커밋 중 76ae30ef와 13af32cc만 골라 현재 브랜치인 X에 적용하고 싶을때$ git cherry-pick 76ae30ef 13af32ccstash  # staged, modified 상태의 파일을 저장$ git stash       # stash로 저장한 리스트를 출력$ git stash list           # 가장 최근에 저장한 stash를 반영$ git stash apply      $ git stash apply stash@{1}  # 지정한 stash를 반영  # 지정한 stash를 삭제$ git stash drop stash@{1}  # stash를 반영하고 자동 삭제$ git stash poptag  light weight 태그 : 단순 커밋 태그용. 커밋을 바로 가리킴  annotated 태그 : 태그 메세지도 첨부할수 있어 자체 해시값을 가짐. ^{}이 커밋을 가리킴  # 태그 추가$ git tag [태그이름]           $ git tag [태그이름] [커밋번호]  # 특정 해쉬에 태그 추가$ git tag -a [태그이름] [커밋번호] # 특정 해쉬에 annotated 태그 추가  # 태그 조회$ git tag$ git tag -l 'v1.*'  # 와일드카드 패턴으로 검색조회$ git show [태그이름]  # 특정 태그 조회$ git show-ref --tags  # 해쉬값과 태그 조회blame# git 프로젝트에서 어떤 코드를 누가 수정했는지, 어떤 commit으로 수정이 되었는지 궁금할 때#  해당 파일에 대한 모든 수정 내역$ git blame &lt;파일명&gt;#  author name과 timestamp는 출력하지 않음.$ git blame -s &lt;파일명&gt;#  description과 수정사항을 보여줌$ git show &lt;커밋번호&gt;#  파일내용을 start부터 end 라인까지의 수정 내역만 보여줌$ git blame -L &lt;start,end&gt; &lt;파일명&gt; https://inpa.tistory.com/entry/GIT-⚡%EF%B8%8F-핵심-명령어-요약-🚩-총정리 ",
        "url": "//git/2024/05/22/git-series-02-Summary.html"
      }
      ,
    
      "git-2024-05-22-git-series-01-command-html": {
        "title": "[git Series] 01 Command",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Commandloggit log –all –oneline –graph : 그래프 확인Remote            command      description                  git remote -v      워킹 트리에 등록돼 있는 원격 저장소 목록 노출              git remote add [remoteName] [remoteUrl]      원격 저장소를 지정한 이름으로 등록              git remote rename [prevName] [newName]      원격 저장소의 이름을 새로운 이름으로 변경              git remote remove [remoteName]      지정한 원격저장소를 삭제      fetch/ pull/ push            command      description                  git fetch [remoteName] [branchName]      원격 저장소의 커밋과 브랜치, 태그들의 로컬 저장소를 가져온다. 워킹 트리의 내용이 변하지 않는다.              git pull [remoteName] [branchName]      fetch + merge              git push [-u remoteName, branchName]      해당 브랜치의 커밋을 원격 저장소로 업로드한다.              git push [remoteName] –all      로컬 저장소의 모든 브랜치와 커밋들을 한꺼번에 원격저장소로 업로드한다.              git push [remoteName] –tags      로컬 저장소의 모든 태그들을 원격 저장소로 업로드한다.      clean working tree            command      description                  git clean  -f -d [file or folderName]      untracked 상태 파일을 삭제한다. 파일 또는 경로 명시하지 않으면 모든 untracked를 정리      reset|           command            |                             description                             ||:—————————-:|:——————————————————————-:|| git reset –hard [checksum]  |         hard reset이라고 부른다. 해당 커밋으로 돌리고 싶을 때 사용, 워킹 트리도 초기화          || git reset –mixed [checksum] |               옵션이 없으면 mixed가 기본, 워킹 트리는 남고 스테이지만 초기화                || git reset –soft [checksum]  | soft reset이라고 부르고 HEAD만 이동한다.  커밋은 돌아가지만 스테이지와 워킹 트리의 내용은 변경되지 않는다. |            구분      soft      mixed(기본)      hard                  현재 브랜치 (HEAD)      초기화      초기화      초기화              스테이지      남아있음      초기화      초기화              워킹트리 변경사항      남아있음      남아있음      초기화      reflogreflog는 로컬 저장소의 커밋 또는 브랜치의 변경 사항을 기록해 놓은 로그를 의미한다.            command      description                  git reflog [-n 숫자]      relog를 보여주는 명령 -n 숫자로 갯수를 제한해서 볼 수 있다.      amend이건 커밋을 고칠 때는 –amend를 사용하면 된다. 이를 사용하는 경우는  HEAD가 가리키는 커밋, 즉 현재 커밋을 수정하고 싶을 때  커밋 메시지를 바꾸고자 할 때  이전 커밋의 파일 내용을 수정하고 싶을 때  이전 커밋에 중요 파일을 추가하지 않은 경우diff변경 사항을 비교할 때 사용한다.            command      description                  git diff [a] [b]      a를 토대로 b에 추가된 차이를 보여준다. 옵션을 생략하면 아직 스테이지에 추가되지 않은 변경 사항을 보여주는데, 신규 파일(untracked)는 보여주지 않는다.      git diff –check공백 문자를 체크하는데 유용하게 사용할 수 있는 명령어다.-Xmerge나 rebase에 -X [ours|theirs]를 사용하면 어떤 것을 기준으로 작업할지 정할 수 있다.rebase -i[–interactive]            command      description                  git rebase -i       HEAD와 지정한 커밋 사이의 커밋들의 히스토리를 수정한다. 옵션으로 지정한 커밋은 수정에서 제외되고 후손들만 편집이 가능하다.  p( pick ) : 해당 커밋을 그대로 변경 없이 사용  r( reword ) : 해당 커밋을 사용. 단 커밋 메시지를 편집  e( edit ) : 해당 커밋을 사용 단 커밋을 수정할 수 있도록 된다.  s( squash ) : 커밋을 사용. 단 내용은 부모 커밋에 합쳐지고 커밋은 사라진 것처럼 보임  d ( drop ) : 해당 커밋을 제거      cherry-pickgit cherry-pick은 다른 브랜치에 있는 특정 커밋을 골라 현재 브랜치에 합칠 때 사용한다.stash작업 폴더의 변경 내용을 넣어두는 명령어 git stash를 사용하면 stash 스택(.git/refs/stash)에 저장한다.stash는 변경사항을 커밋하기도, 삭제하기도 애매한 상황에서 사용한다.            command      description                  git stash [-u]      변경 사항을 스택에 저장하고 현재 작업 폴더를 clean 상태로 만든다. -u를 사용하면 untracked도 저장한다.              git stash list      stash 리스트를 확인하다.              git stash pop [stash 객체]      stash 스택에 있는 변경사항을 현재 작업 폴더에 반영한다. 반영된 stash는 제거한다. 옵션을 붙이면 해당 객체를 아니면 마지막의 객체를 꺼내온다.              git stash apply [stash 객체]      pop과 유사하지만 스택에서 제거하지는 않는다.              git stash drop [stash 객체]      지정한 stash를 제거한다.              git stash clear      스택의 모든 stash를 삭제              git stash branch [stash 객체]      마지막 체크아웃된 커밋에 stash 내용 반영해서 새로운 브랜치 생성 (테스트 할 떄 유용)        다른 브랜치에서 작업했을 때?git status -ugit checkout -b temporaryBranchgit stash popadd            command      description                  git add –patch [fileName]      변경 사항의 일부만 커밋하고 싶을 때 사용할 수 있다. ? : 도움말 y: 현재 변경사항(hunk)를 스테이징 n: 현재 변경 사항을 스테이징 하지 않는다. e: 직접 스테이지에 올릴 내용을 편집 q: 변경 사항을 무시하고 종료      untracked 파일 일부 변경 사항 커밋| command                | description                                      ||:———————–|:————————————————-|| git add –N [fileName] | untracked 상태의 파일을 스테이지에 올린다. 단 내용은 올리지 않고 상태만 변경 |add –interactive [-i]add에 인터렉티브한 작업을 선택할 수 있다.git blame으로 히스토리 조회            command      description                  git blame [-L &lt;시작줄, 끝줄&gt;]       해당 파일을 변경했던 커밋 히스토리를 보여준다. -L로 시작 - 끝 줄을 지정하고 특정 범위만 조회할 수도 있다.      filter-branch로 히스토리 파일 삭제| command                                                 | description                 ||:——————————————————–|:—————————-|| git filter-branch –tree-filter ‘rm -f ' HEAD | HEAD로부터 모든 히스토리에 지정한 파일을 삭제 |git alias단축 명령어 생성git config –global alias.st status -&gt; git st (==git status)git config –global alias.graph “ log –oneline –graph –all “-&gt; git graph -n5global ignore  ignore 생성  git conifg –global core.excludesfiles ~/path  git reflogcheckout, commit들에 대한 내역을 볼 수 있다.만일 local에 commit만 하고 reset –hard를 했다면 reflog로 찾아서 git reset –hard [revisionNumber]로 되돌려 놓을 수 있다.",
        "url": "//git/2024/05/22/git-series-01-command.html"
      }
      ,
    
      "ci-cd-2024-05-22-ci-cd-series-02-deploy-html": {
        "title": "[ci:cd Series] 02 Deploy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DeployDeploy1. Rollingkubernetes에서 공부했던 Rolling이다. 하나씩 변경점을 반영하며 전파되는 형식단점으로 부하 계산을 잘못하면 문제가 될 수 있다.  (70, 70, 70) -&gt; (0, 105, 105)2. BlueGreen일전에 jojoldu의 책에서 nginx로 새로운 서버로 포트만 바꿔주던 식의 신, 구 서버 스위칭 형식이다. 단점으로 구/ 신버전을 모두 유지해야 하므로 리소스가 2배가 된다.3. Canary독가스 검사하는 카나리아에서 차용한 듯특정 서버만 배포하고 배포된 서버로 트래픽을 늘려서 문제가 없으면점진적 배포를 하는 방식이다. 결과적으로 모든 서버에 배포한다.",
        "url": "//ci/cd/2024/05/22/ci-cd-series-02-Deploy.html"
      }
      ,
    
      "ci-cd-2024-05-22-ci-cd-series-01-cicd-html": {
        "title": "[ci:cd Series] 01 Cicd",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CI/CDCI/CDJunit기본 개념pipeline일련의 Job으로 구성된 단위이다.Job파이프 라인을 구성하는 최소 작업 단위다.VariablesJob에서 사용하거나 다른 곳에 재사용 할 때 지정할 수 있는 환경 변수의 한 유형이다.Runnerpipeline을 따라 Job을 실행시키는 주체다. 러너의 종류로는 1. 공유 러너, 2. 그룹 러너, 3. 지정 러너가 있다.Artifacts일련의 단계에서 나온 산출물이다.예시## 파이프라인의 단계stages:  - test  - build  - packing  - deploy## 해당 파이프라인에서 사용할 로컬 변수variables:  STAGE_TARGET_PATH: /home/service  STAGE_NAME: $STAGE_NAME  STAGE_TARGET_SERVER: $STAGE_TARGET_SERVER  ##Jobtest:  ## 단계  stage: test  ##어떤 이미지를 사용 할 것이며  image: gradle-8.6.0-jdk17  ##어떤 상황에서 실행되는가  when: always  ##트리거가 되는 브랜치  only:    - stage    - master  ##태그  tags:    - test_work  before_script:    - pwd    - chmod +x gradlew  script:    - echo [INFO] TEST PROJECT $CI_PROJECT_NAME    - ./gradlew testbuild: ##Job  ## 단계  stage: build  ##어떤 이미지를 사용 할 것이며  image: gradle:7.6-jdk11-alpine  ##어떤 상황에서 실행되는가  when: on_success   ## 선행되어야만 하는 작업  needs:    - job: test  ##트리거가 되는 브랜치  only:    - stage    - master  ##job에 대한 태그  tags:    - build_work  # 스크립트 이전 실행  before_script:    - pwd    ## 자바HOME을 유동적으로 변경(Gradle -&gt; 2024-05-22-[gradle-series]-Summary.md)    - cp $JAVA_HOME_11 gradle.properties    - chmod +x gradlew    - ./gradlew clean  #스크립트  script:    - echo [INFO] BUILD PROJECT $CI_PROJECT_NAME    - ./gradlew generateDbJooqSchemaSource\"    - ./gradlew -x generateDbJooqSchemaSource bootjar  --continue\"    - echo [INFO] RENAME FILE    - cp build/libs/*.jar $CI_PROJECT_NAME.jar  ## 빌드 결과물을 저장할 아티팩트  artifacts:    paths:      - build/libs/*.jar    expire_in: 1 daysstage:  stage: deploy  needs:    - job: build      artifacts: true  when: on_success  only:    - stage  script:    - echo [INFO] DEPLOY STAGE_MODE $CI_PROJECT_NAME    - echo [INFO] move to ${STAGE_TARGET_SERVER}    - cp build/libs/*.jar $CI_PROJECT_NAME.jar     ## 파일로 된 전역 변수 가져와서    - cat $STAGE_TARGET_SERVER_KEY     ##권한 하향    - chmod 400 $STAGE_TARGET_SERVER_KEY            ## 파일 만들고 전송하고 하는 일련의 과정    - echo ssh -i $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} mkdir -p ${STAGE_TARGET_PATH}    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} mkdir -p ${STAGE_TARGET_PATH}    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} &lt;&lt; EOT    - cd ${STAGE_TARGET_PATH}    - |      exist=`ls | grep $CI_PROJECT_NAME.jar | wc -l`      if [ $exist &gt; 0 ]        then          echo create backupFile as $CI_PROJECT_NAME.jar_{CI_COMMIT_TIMESTAMP}          mv ${STAGE_TARGET_PATH}/$CI_PROJECT_NAME.jar ${STAGE_TARGET_PATH}/$CI_PROJECT_NAME.jar_${CI_COMMIT_TIMESTAMP}      fi    - scp -i  $STAGE_TARGET_SERVER_KEY $CI_PROJECT_NAME.jar ${STAGE_NAME}@${STAGE_TARGET_SERVER}:${STAGE_TARGET_PATH}    - cat $START    - scp -i  $STAGE_TARGET_SERVER_KEY $START ${STAGE_NAME}@${STAGE_TARGET_SERVER}:${STAGE_TARGET_PATH}/start.sh    - cat $STAGE_TARGET_SERVER_KEY    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} chmod 755 ${STAGE_TARGET_PATH}/start.sh    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} &lt;&lt; EOT    - cd ${STAGE_TARGET_PATH}    - ./start.sh    - EOT    - echo Congratulation. All done!deploy_as_production:  stage: deploy  needs:    - job: build      artifacts: true  when: on_success  only:    - master  script:    - echo [INFO] DEPLOY PRODUCTION_MODE $CI_PROJECT_NAME",
        "url": "//ci/cd/2024/05/22/ci-cd-series-01-CICD.html"
      }
      ,
    
      "aws-2024-05-22-aws-series-01-model-html": {
        "title": "[aws Series] 01 Model",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Price ModelPrice ModelAWS EC2 인스턴스에 대한 요금을 지불하는 방법에는 온 디맨드 인스턴스, 예약 인스턴스, 스팟 인스턴스 및 전용 호스트의 네 가지 방법이 존재한다.온 디멘드 (On-Demand Pricing)온 디맨드 인스턴스를 사용하면 실행하는 인스턴스에 따라 시간당 또는 초당 컴퓨팅 용량을 지불하게 된다.이를 수요에 반응한다고 말하는데, 그냥 쓴만큼 낸다라고 이해하면 된다.가장 기본적인 초보용 요금제이며, 장기 약정 없이 시간 단위로 인스턴스를 사용하기 때문에 보편적으로 가장 많이 선택하는 요금제이며, 인스턴스 생성 시에 과금이 시작되고 종료(반납)을 하면 정산되는 방식이다.애플리케이션 요구 사항을 충족하기 위해 컴퓨팅 용량을 늘리거나 줄일 수 있으며 사용하는 인스턴스에 대해 지정된 시간당 요금 만 지불하면 된다.  레드햇 같은 오픈소스가 아닌 인스턴스 - 시간당 지불  아마존 리눅스, 오픈소스 기반 - 초당 지불온 디멘드 이용 고객권장되는 소비자층은 다음과 같다.  선불 결제 또는 장기 약정없이 Amazon EC2의 저렴한 비용과 유연성을 선호하는 사용자  중단 할 수 없는 단기, 예측할 수 없는 워크로드가 있는 애플리케이션  Amazon EC2에서 처음으로 개발 또는 테스트중인 애플리케이션예약 인스턴스 (Resserved Instance - RI Pricing)미리 일정 기간(1년 ~ 3년)을 약정해서 쓰는 방식이다. 즉, 선납금을 납부하는 방식이다.최대 75% 정도 저렴하다. 당연히 온디멘드의 쓴만큼 내는 유연성을 희생해서 할인을 받는 격으로 생각하면 된다.예약 인스턴스를 특정 가용 영역에 지정하면 용량 예약이 제공되므로 필요할 때 예약한 인스턴스를 시작할 수 있다.예를들어 만일 회사가 수요일날 특히 서버자원을 많이 쓴다면 수요일은 자원을 늘려야 한다. 그러면 예약 인스턴스를 수요일날 늘리게끔 설정을 하면 돈을 아낄 수 있는 원리이다.즉, 예측 가능한 사용량이 있는 애플리케이션의 경우 예약 인스턴스는 온 디맨드 인스턴스와 비교하여 상당한 비용을 절감 할 수 있는 것이다.몇년동안 얼만큼 사용 예정 계획이 확실할때 사용하면 좋은 요금제이다.일정 규모의 인스턴스를 항상 사용하기 떄문에 주로 큰 기업들이 이용하는 편이다.예약 인스턴스 이용 고객  수요가 꾸준한 애플리케이션  예약 용량이 필요할 수 있는 애플리케이션  총 컴퓨팅 비용을 절감하기 위해 1년 또는 3년 동안 EC2를 사용하기로 약정할 수 있는 고객스팟 인스턴스 (Spot Instances Pricing)스팟 인스턴스는 경매 형식으로 시장에 남는 인스턴스를 구매해서 쓰는 방식인 요금제이다.이게 무슨 소리냐 하면은, aws에서는 항상 인스턴스를 빵빵하게 확보해 놓고 있는데, 사람들이 안쓰면 손해이기 때문에 aws 입장에서는 재고가 남은 인스턴스들을 소비 하기위해서 남은 것들을 저렴하게 내놓아서 소비자들이 그걸 입찰해서 이용하는 방식인 것이다.온디맨드 요금보다 90% 할인된 가격으로 내놓으니 가장 저렴한 요금 정책이라고 말할 수 있다.하지만 문제는 언제 반납해야할지 모른다는 것이다.남는 인스턴스가 아까워서 싸게 판매하는 취지는, 만일 언제 비싼 요금을 내고 사용하는 고객들의 인스턴스 수요가 많아지면, 이들에게 제공하기 위해 곧바로 다시 회수 해간다는 의미를 내포한다.정말로 어느순간 AWS가 인스턴스를 가져가버려 정작 내 서비스가 잠시동안 끊겨버리는 순간이 올수 있다는 말이다.물론 인스턴스 수요가 적어지면 다시 인스턴스를 할당받아 내 애플리케이션을 다시 서비스가 가능하다.따라서 반환 시간이 예측이 불가능하기에, 인스턴스가 확보되고 종료되는 것을 반복해도 문제없는 애플리케이션에 적합하며 주로 빅데이터 처리, ML등 많은 인스턴스가 필요한 작업에 사용된다. (최대 90% 저렴하니까)스팟 인스턴스 원리아래의 그래프를 보자.고객들이 인스턴스를 많이 쓰면 스팟 인스턴스 가격(노랑선)이 올라가게 된다.일단 먼저 내가 원하는 지정 가격(초록선)을 정한다.이 지정가격 보다 비싸지면 반납해서 인스턴스를 중지시키고, 가격이 싸지면 다시 인스턴스를 사용한다는 원리이다.  수요에 따라 스팟 인스턴스의 가격은 계속 변동한다.  내가 지정한 가격보다 현재 가격이 낮다면 인스턴스를 할당받고 사용한다.  내가 지정한 가격보다 현재 가격이 높다면 반환된다.  다시 가격이 낮아지면 사용한다.스팟 인스턴스 이용 고객  시작 및 종료 시간이 자유로운(유연한, flexible) 응용 애플리케이션          지금 내가 급하게 사용할 필요없고, 사용할때를 기다리고 내가 원하는 가격에 입찰되어 내가 사용할 수 있을때, 그때 해도 되는 것들에 활용하면 적합        컴퓨팅 가격이 매우 저렴해야만 수익이 나는 애플리케이션  대량의 서버 용량 추가로 긴급히 컴퓨팅 파워가 필요한 사용자전용 호스트실제 물리적인 서버를 임대하는 요금제이다.aws 인스턴스 자체가 가상환경에서 사용하는 컴퓨터인데, 그 반대라고 보면 된다.즉, 가상화된 서버에서  EC2를 빌리는 것이 아닌 지정된 물리서버에서 EC2가 대여가 된다보안적인 이유, 규정(라이센스)에 따른 이유, 퍼포먼스를 위한 이유(CPU Steal 등) 등으로 사용된다.간단히 말하자면 가상 컴퓨팅은 구조적 한계 때문에 여러사람들이 사용하면 퍼포먼스 하락 요소가 있기 때문이다.전용 호스트 이용 고객EC2에서 Microsoft 및 Oracle 같은 공급업체의 적격 소프트웨어 라이선스를 사용할 경우기존의 물리적 서버에서 EC2를 사용할 경우요금 정책  가격순서          스팟 인스턴스 &lt; 예약 인스턴스 &lt; 온디맨드 &lt; 전용 호스트2, EC2의 가격모델과 EBS와는 별도로 요금이 청구된다. (EBS는 사용한만큼 지불)        기타 데이터 통신 등의 비용은 별도로 청구 (참고로 AWS는 AWS 바깥으로 나가는 트래픽에 대해서만 요금 부과)          예를들어 50테라바이트의 파일을 업로드할때는 무료단, 그 파일을 다운받을때 요금 청구      출처: https://inpa.tistory.com/entry/AWS-📚-EC2-가격-요금-모델-원리-💰-파헤치기 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//aws/2024/05/22/aws-series-01-Model.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-16-xargs-vs-pipe-html": {
        "title": "[linux Series] 16 Xargs_vs_pipe",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - xars vs. pipexars vs. pipexars  기본적인 명령어 뒤에 파이프로 추가하여 사용  파이프 이전에 명령을 인자로 받아 명령어를 실행하는 구조xargs를 사용하는 가장 기본적인 예는 pipe to xargs를 사용하여 공백으로 구분된 여러 문자열을 전달하고 해당 문자열을 인수로 사용할 명령을 실행하는 것이다.# file1 file2 file3 이라는 문자열을 touch 의 인수로 넘겨주어,# touch file1 file2 file3 명령을 수행한것과 같은 결과를 준다. (빈파일 3개 생성)echo \"file1 file2 file3\" | xargs touchoptions|    option     |                                         description                                         ||:————-:|:——————————————————————————————-:||      -a       |                                   표준 입력 대신 파일에서 항목을 읽는다.                                    ||      -O       |                                      공백이나 특수문자 찾을 때 사용                                      ||    -printO    |                                   파일 사이의 공백을 \\O로 분리자로 출력                                    ||      -d       |                                  입력된 문자를 그대로 사용(따옴표, 백슬래시)                                  ||      -n       |                                       지정된 숫자만큼 행을 출력                                        ||      -p       |                         각 명령 행 실행 여부, 터미널에서 행을 읽어들이는 것에 대한 여부를 묻는다.                         ||      -P       |                                하나의 명령에 프로세스를 지정 (-n과 같이 사용)                                 ||      -t       |                                xargs를 통해 구성된 명령어를 표준 에러로 출력                                 ||      -s       | 한 라인에 들어갈 수 있는 문자열 수를 지정(기본적으로 128k 안으로 문자열을 만들어 하나의 명령으로 실행하나 해당 옵션으로 1024k까지 사용 가능하게 한다.) ||      -x       |                                   -s로 지정한 크기가 초과되면 종료시킨다.                                   || –show-limits |                            xargs의 버퍼 크기 선택 및 -s 옵션에 대한 길이 제한 출력                             ||      -E       |                                     문자열 끝을 eof-str로 설정                                      ||      -I       |                    xargs에 전달된 라인 전체를 뒤에 나오는 명령어의 인자로 사용 (라인 전체는 {}로 표기)                     ||      -l       |                         명령어 뒤 공백을 다음 행이 아닌 논리적으로 이어진 명령으로 인식하게 한다.                          |예제# /tmp 디랙토리 아래 core라는 파일을 찾아 삭제$ find /tmp -name core -type f -print | xargs rm -f# ls를 이용하여 text파일을 모두 읽어와 하나의 파일로 병합$ ls *.txt | xargs cat &gt;&gt; abc.txt# 디렉토리에서 txt파일을 우선 찾은 다음 이름에 abcd를 포함하는 파일을 또 찾음$ find ~/ -type f | grep -H “*.txt$” | xargs grep -H “abcd”# 파일안에 url이 있을 경우 해당 인자들을 모두 wget으로 넘겨 다운받는다$ cat url-list.txt | xargs wget -c# 모든 jpg파일을 찾아 images.tar.gz로 압축$ find / -name “*.jpg” -type -f -print | xargs tar -cvzf images.tar.gz# ls 로 출력된 모든 이미지를 하나씩 인자로 받아 외장하드로 복사$ ls *.jpg | xargs -n1 -I{} cp {} /external-hard-drive/tmpxargs vs. pipe  파이프 ‘|’ 는 앞의 결과를 인자로 받는게 아니다.파이프 ‘|’ 는 앞의 표준출력을 다음 프로그램의 표준입력으로 연결하는 것이다.파이프 ‘|’ 와의 조합으로 표준출력을 다음 프로그램의 ‘인자’로 넘길려면 xargs 를 사용한다.xargs 프로그램은 실행할 대상프로그램을 인자로 받고, xargs 프로그램의 표준입력을 실행 대상프로그램의 인자로 전달하여 실행한다.예시  &lt;&lt;&lt; 뒤에는 문자열이나 변수가 바로 붙는다&lt; 는 표준입력 리다이렉션이다.vi err.txterr:wqecho err.txt | cat ## err.txt## 파일명 자체를 echo err.txt | xargs cat ## err## 파일을출처: https://inpa.tistory.com/entry/LINUX-📚-xargs-명령-파이프-와-차이점-완벽-정리-표준입력-인자-차이 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-16-xargs_vs_pipe.html"
      }
      ,
    
      "2024-05-21-linux-series-15-volume-html": {
        "title": "[linux Series] 15 Volume",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "layout: postcategories: [LINUX]—from Dictionary - Volume  aws 재시작으로 볼륨 마운트 해제되어서 해결하면서 찾은Volume  lsblk : 블록 장치를 나열하는 유틸리티 추가 정보를 보려면 lsblk -f  blkid : 블록 디바이스의 uuid를 출력  hwinfo: 하드웨어, 특히 스토리지 디스크에 대한 정보를 볼 수 있는 유틸리티이다. hwinfo --disk | --short | --block                              mount : mount [-o [옵션]] &lt;partition          disk&gt;  (* 영구 마운트 : /etc/fstab에 추가)                      unmount: umount [-o [옵션]] Device의 종류Block Device : Block 단위로 입출력을 하는 Device, Block은 File System의 섹터를 의미Character Device : Character 단위, 즉 바이트 단위로 입출력을 하는 Device, 데이터 관리 기능을 가진 응용 프로그램Network Device : 네트워크 층과 연결되어 있음(루프백 장치, 랜카드와 같은...)|           |      blockDevice       |                   characterDevice                    ||:———:|:———————-:|:—————————————————-:|| 데이터 전송 단위 | Block(File System의 섹터) |                 Character(문자, Byte)                  ||       전송 버퍼 처리     |    System Buffer 사용    |                    응용 프로그램 Buffer                    ||       대표 장치     |        HDD, SSD        |                키보드, 마우스, 모니터, 프린터 등..                 ||         주요 특징  |      File System       | 자체적으로 데이터를 관리하기 위한 기능을 가진  응용 프로그램 사용(DBMS….) |블록 디바이스(Block Device) 요청 처리 방식리눅스 커널은 블록 디바이스를 효율적으로 처리하기 위해 처리할 내용을 큐에 모아두었다가 일정 시간이 지나거나 임계치에 도달하면 블록 디바이스 드라이버에 처리를 요구, 블록 디바이스 드라이버에 요구하는 처리 함수는 두 가지 형식으로 존재(커널 처리에 있어서 두 가지가 동시에 일어나는 경우는 없음)",
        "url": "//2024/05/21/linux-series-15-Volume.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-14-vieditor-html": {
        "title": "[linux Series] 14 Vieditor",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VIVI/ VIMvi –version어떤 vi가 설치됐는지 확인할 수 있다.VIM - Vi IMproved 9.0 (2022 Jun 28, compiled Dec 20 2023 18:58:31)macOS version - arm64Included patches: 1-2136Compiled by root@apple.comNormal version without GUI.  Features included (+) or not (-):+acl               +file_in_path      +mouse_urxvt       -tag_any_white-arabic            +find_in_path      +mouse_xterm       -tcl+autocmd           +float             +multi_byte        +termguicolors+autochdir         +folding           +multi_lang        +terminal-autoservername    -footer            -mzscheme          +terminfo-balloon_eval      +fork()            +netbeans_intg     +termresponse-balloon_eval_term -gettext           +num64             +textobjects-browse            -hangul_input      +packages          +textprop++builtin_terms    +iconv             +path_extra        +timers+byte_offset       +insert_expand     -perl              +title+channel           +ipv6              +persistent_undo   -toolbar+cindent           +job               +popupwin          +user_commands-clientserver      +jumplist          +postscript        -vartabs+clipboard         -keymap            +printer           +vertsplit+cmdline_compl     +lambda            -profile           +vim9script+cmdline_hist      -langmap           -python            +viminfo+cmdline_info      +libcall           -python3           +virtualedit+comments          +linebreak         +quickfix          +visual+conceal           +lispindent        +reltime           +visualextra+cryptv            +listcmds          -rightleft         +vreplace+cscope            +localmap          -ruby              +wildignore+cursorbind        -lua               +scrollbind        +wildmenu+cursorshape       +menu              +signs             +windows+dialog_con        +mksession         +smartindent       +writebackup+diff              +modify_fname      -sodium            -X11+digraphs          +mouse             -sound             -xattr-dnd               -mouseshape        +spell             -xfontset-ebcdic            +mouse_dec         +startuptime       -xim-emacs_tags        -mouse_gpm         +statusline        -xpm+eval              -mouse_jsbterm     -sun_workshop      -xsmp+ex_extra          +mouse_netterm     +syntax            -xterm_clipboard+extra_search      +mouse_sgr         +tag_binary        -xterm_save-farsi             -mouse_sysmouse    -tag_old_static       system vimrc file: \"$VIM/vimrc\"     user vimrc file: \"$HOME/.vimrc\" 2nd user vimrc file: \"~/.vim/vimrc\"      user exrc file: \"$HOME/.exrc\"       defaults file: \"$VIMRUNTIME/defaults.vim\"  fall-back for $VIM: \"/usr/share/vim\"Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H   -DMACOS_X_UNIX  -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1      Linking: gcc   -L/usr/local/lib -o vim        -lm -lncurses  -liconv -framework Cocoa           예시로 +clipboard 여부에 따라 vi에서 클립보드 사용이 불가할 수도 있다.이래서 그냥 대고 복사가 안됐던 것이기도 하다.vi 내용 삭제 명령어            명령어      설명                  x      커서가 있는 문자 한글자 삭제 (반대인 del은 윈도우와 똑같다)              nx      커서가 있는 위치부터 n개의 문자를 삭제              dw      현재 커서에 있는 한 단어 삭제              dd      커서가 있는 라인(행) 삭제              ndd      커서가 있는 라인부터 n개의 라인 삭제              db      커서의 위치에서 거꾸로 한 단어 삭제              D      커서 오른쪽 행 삭제              :5,10d      5~10번째 행 삭제      vi 되돌리기 명령어            명령어      설명                  u      이전 명령 취소 (되돌리기)              U      행 변경 사항 취소, 이전의 최종 행 취소              .      이전 최종 명령 반복      vi 복붙 및 이동 명령어            명령어      설명                  yy      커서가 위치한 줄 복사              Y      행 yank 또는 복사              yh      커서의 왼쪽 문자 복사              yl      커서에 위치한 문자 복사              yi      커서가 위치한 줄과 그 아랫줄 복사              yk      커서가 위치한 줄과 그 윗줄 복사              p      붙여넣기 (행 위로 삽입)              P      붙여넣기 (행 아래에 삽입)              :1,2 co 3      1~2행을 3행 다음으로 복사              :4,5 m 6      4~5행을 6행 위로 이동      # 한줄 복사해당 라인에서 'yy' 누르면 캐시에 저장이 된다.붙여넣기를 원하는 곳으로 이동하여 'p'를 누르면 커서 다음 라인에 붙여넣기가 된다.# 블럭 복사'v'키를 누른 후 커서를 이동하여 블력을 설정한다.(putty의 경우 블럭이 설정되는 모습이 보이나, ssh의 경우 블럭 모습이 나타나지 않으나 실제로는 설정되고 있다.)원하는 부분을 블럭으로 설정한 뒤(설정 완료키는 없다) 'y'키를 누르면 캐시에 복사가 된다.같은 방법으로 원하는 곳으로 이동하여 'p'를 누르면 커서 다음 라인에 붙여넣기가 된다.vi 행 번호 표시            명령어      설명                  :set nu 또는 :set number      에디터의 각 행의 좌측에 행 번호 표시.              :set nonu      에디터의 각 행의 좌측 행 번호 숨기기      vi 검색 명령어            명령어      설명                  /{검색할 문자열}      오른쪽 아래 방향으로 문자열 검색              ?{검색할 문자열}      왼쪽 위 방향으로 문자열 검색              n      문자열의 다음으로 계속 검색              N      문자열의 이전으로 계속 검색      vi 저장 및 종료            명령어      설명                  :w      변경사항 저장              :w      {파일명}\t변경사항 입력한 파일명으로 저장              :wq      변경사항 보관 후 vi 종료.              ZZ      명령과 같음. :w(기록)과 :q(종료) 를 연속적으로 수행.              ZZ      변경사항 보관 후 vi 종료.임시 버퍼의 내용을 vi로 호출할때 사용되었던 파일에 기록한 후 vi를 빠져나옴.              :q!      변경 내용을 저장하지 않고 종료              :q      작업한게 없으면 그대로 종료              :e!      마지막으로 저장했던 내용 이후의 수정한 것들을 취소하고 다시 편집상태로      vi 내용 바꾸기 명령어            명령어      설명                  :s/[대상문자열]/[바꿀문자열]      커서가 위치한 행에서 첫번째로 나오는 대상문자열을 바꿀문자열로 치환              :%s[대상문자열]/[바꿀문자열]      파일 전체에서 모든 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]      범위 내 모든 각 행에서 첫번쨰로 나오는 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]g      범위 내 모든 행에서 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]gc      범위 내 모든 행에서 대상문자열을 바꿀문자열로 바꾸되 수정할 지 여부를 묻는다      vi 화면 정리            명령어      설명                  Ctrl + l      불필요한 화면정리 후 다시 표시      vi 파일 명령어            명령어      설명      ex                  :r {파일명}      커서 다음에 파일 삽입      :r test.txt              :{행번호} r {파일명}      입력한 파일을 입력한 행번호 다음에 삽입      :10 r test.txt      vi  기타 명령어            문자      설명                  .      현재 line              %      전체 line              $      파일 맨끝 line              1,$      %              2,3      2 ~ 3 line      https://inpa.tistory.com/entry/LINUX-📚-Vi-Vim-에디터-다루기-명령어-💯-정리#vi_내용_삭제_명령어",
        "url": "//linux/2024/05/21/linux-series-14-ViEditor.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-13-tree-html": {
        "title": "[linux Series] 13 Tree",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Linux fileTreeLinuxbin, sbin  bin : user command binaries -&gt; 커맨드 라인 인터페이스 관련된 명령어 실행 파일을 포함 ( ex. cat, cd, ls … )  sbin : system command binaries -&gt; 시스템을 컨트롤하기 위한 파일들 ( ex. systemctl, reboot)연관된 디렉토리 종류는 usr/bin, usr/sbin, usr/local/bin, usr/local/sbin  bin: cd, ls 등의 사용자 커맨드 파일이 위치한 디렉토리 (필수적인 파일만 관리)  sbin: systemctl 등의 시스템 커맨드 파일이 위치한 디렉토리 (필수적인 파일만 관리)  usr/bin: 필요에 의해 설치된 사용자 커맨드 파일이 위치한 디렉토리 (yum 등 패키지 관리자가 관리)  usr/sbin: 필요에 의해 설치된 시스템 커맨드 파일이 위치한 디렉토리 (yum 등 패키지 관리자가 관리)  usr/local/bin: 기타 사용자 커맨드 파일이 위치한 디렉토리 (사용자 또는 설치 파일이 해당 디렉토리에 파일 설치)  usr/local/sbin: 기타 시스템 커맨드 파일이 위치한 디렉토리 (사용자 또는 설치 파일이 해당 디렉토리에 파일 설치)PATHOS 어디서든 해당 위치에 접근할 수 있게 만드는 환경변수이다. 위의 6개 디렉토리는 모두 환경 변수에 등록되어 있어서 해당 폴더들 내부에 있다면바로 명령어로 실행할 수 있다.lib, lib64lib, lib64는 시스템 부팅이나 bin, sbin 디렉토리에 있는 바이너리 파일들 실행에 필요한 공유 라이브러리 디렉토리다.etcetc는 설정 파일을 관리한다. .d를 붙여서 디렉토리인 것을 구별하기도 하는 경우가 있다. 설정 파일은 .conf라는 이름의 형식으로 많이 관리 되어 있다.varvariable data를 뜻한다. 시스템 로그나 웹 로그 파일들을 포함한다.usruniversal system resource 혹은 user의 약자라고 하기도 한다. 리눅스의 여러 사용자들이 공유하는 파일들을 관리한다.optoptional을 의미한다.home, roothome은 개별 사용자의 디렉토리를 관리하는 디렉토리다. 만약 ec2-user라는 이름의 사용자를 만들면 /home/ec2-user라는 디렉토리가 생성된다.FHS( Filesystem Hierarchy Standard ) - 기타 디렉토리media, mnt시스템이 마운팅되는 디렉토리 media는 os가 관리하는 디렉토리 mnt는 커맨드라인으로 마운트하는 디렉토리boot부팅에 필요한 파일들을 포함하는 디렉토리dev마우스 등 디바이스 관련 파일이 존재하는 디렉토리sys디바이스를 관리하기 위한 가상 파일 시스템 디렉토리proc현재 실행 중인 프로세스에 대한 정보를 관리하는 디렉토리runRun-time variable data를 관리한다. 부팅 후 시스템 정보를 관리하는 디렉토리srvFTP, WWW 또는 CVS(???) 같은 특정 서비스의 데이터 파일 위치를 포함한 디렉토리tmp임시 파일을 저장하기 위한 디렉토리 재부팅 시 삭제, 정기적으로 10일 정도 간격으로 삭제된다.lost+found파일 시스템의 복구에 사용되는 데이터 조각들을 포함하고 있다. 재부팅이나 파일 시스템 체크 커맨드 등을 이용할 때 참조https://inpa.tistory.com/entry/LINUX-📚-리눅스-디렉토리-구조#",
        "url": "//linux/2024/05/21/linux-series-13-Tree.html"
      }
      ,
    
      "2024-05-21-linux-series-12-systeminfo-html": {
        "title": "[linux Series] 12 Systeminfo",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "layout: postcategories: [LINUX]—from Dictionary - SystemInfocat /proc/cpuinfoCPU 정보를 열람할 수 있다.processor       : 0BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 1BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 2BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 3BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3Hardware        : BCM2835Revision        : c03114Serial          : 10000000e19a2b57Model           : Raspberry Pi 4 Model B Rev 1.4ex)#코어 수grep -c processor /proc/cpuinfo # 물리 CPU 개수$ grep ^processor /proc/cpuinfo  | wc -l&gt; 4 # 현재 PC의 물리 CPU 수는 4개.# CPU 당 물리 코어 개수$ grep 'cpu cores' /proc/cpuinfo | tail -1&gt; 4 # 현재 PC의 CPU 당 물리 코어 개수는 4개# Hyper Threading 여부$ cat /proc/cpuinfo | egrep 'siblings|cpu cores' | head -2&gt; siblings     :    4&gt; cpu cores    :    4lscpu/proc/cpu를 더 간단하게 볼 수 있는 명령top-n : 지정한 숫자만큼 화면 출력을 갱신한 후 수행-u : 지정한 사용자의 프로세스를 모니터링-b : 출력 결과를 파일이나 다른 프로그램으로 전달-d : 화면 갱신 주기를 초 단위로 설정-p : 지정한 PID 프로시스를 모니터링free전체 메모리(사용하고 있는 메모리, 남은 메모리, 버퍼 메모리)에 대한 상태를 확인-b : byte 단위 표시-m : mb 단위 표시-g : gb 단위 표시-k : kb 단위 표시-l : 최고/최저 메모리 상황 구분해서 표현-s N : N초마다 출력df디스크 남은 용량(disk free) 확인-k : kb-m : mb-h : human(??)du현재 디렉토리에서 서브 디렉토리까지 사용량(disk usage) 확인-a : 하위 디렉토리에 포함된 파일까지 모든 파일 사용정보 용량 표시-s : 지정한 디렉토리 내에 존재하는 모든 파일, 서브 디렉토리의 합 -h : 깔끔하게hostname -I호스트 네임 출력ifconfig== ipconfig[enp0s3] : 네트워크 인터페이스[flags] : 네트워크 카드의 상태 표시[mtu] : 네트워크 인터페이스의 최대 전송 단위(Maximum Transfer Unit)[inet] : 네트워크 인터페이스에 할당된 IP 주소[netmask] : 네트워크 인터페이스에 할당된 넷마스크 주소[broadcast] : 네트워크 인터페이스에 할당된 브로드캐스트 주소[inet6] : 네트워크 인터페이스에 할당된 IPv6 주소[prefixlen] : IP 주소에서 서브 넷 마스크로 사용될 비트 수[scopeid] : IPv6의 범위. LOOPBACK / LINKLOCAL / SITELOCAL / COMPATv4 / GLOBAL[ether] : 네트워크 인터페이스의 하드웨어 주소[RX packets] : 받은 패킷 정보[TX packets] : 보낸 패킷 정보[collision] : 충돌된 패킷 수[Interrupt] : 네트워크 인터페이스가 사용하는 인터럽트 번호ip aifconfig와 흡사하지만 UP&amp;DOWN 정보, ip, mac 정보 확인 가능",
        "url": "//2024/05/21/linux-series-12-SystemInfo.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-11-symbolic-html": {
        "title": "[linux Series] 11 Symbolic",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Symbolic linkHardLink vs. Symbolic Link(softLink)먼저 리눅스에는 inode라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료구ㄷ조이다. 모든 파일과 디렉토리는 inode를 가지고 있다. 그리고 여기에는 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 있다.inode는 실제 파일 내용을 갖고 있는 것이 아니라 파일의 내용을 갖고 있는 주소를 포함한다.776844 app  388947 config  259817 cronLog  389047 file  260194 homebridge  128107 pi  260893 projectspi@ubuntu:/home$HardLink하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다. 따라서 원본 파일이 사라지더라도 데이터만 살아 있다면 원본 파일에 접근 가능하다.  동일한 파일 시스템 내에서만 하드 링크 생성 가능  디렉터리 링크 불가능  대상파일과 동일한 inode 번호와 허가권을 가짐  대상 파일을 옮기거나 삭제해도 대상 파일을 참조한다.  소프트링크는 원본의 존폐에 따라 사용할 수 있지만 하드링크는 원본이 삭제되더라도 원본과 동일한 내용의 파일을 가지므로 자원을 공유하면서도 데이터를 안전하게 관리하고자할 때 사용한다.# 하드링크 생성$ ln [대상파일] [하드링크파일]Symbolic(soft) link심볼릭 링크는 생성하면 또 다른 inode를 생성해서 이를 바라본다.  심볼릭 링크는 하드 링크의 단점을 보완하려고 탄생  파일 시스템과 대상 파일이 존재하는 파일 시스템이 달라도 생성 가능하다.  하드 링크는 파일만 참조 가능하고 디렉토리는 참조 불가하지만 심볼릭 링크는 가능하다.  대상 파일과 심볼릭 링크 파일은 서로 inode 번호와 파일 허가권이 다르다.  대상 파일의 inode가 아닌 이상 파일의 데이터 경로만을 참조  원본이 존폐 여부에 영향을 받는다.  파일 종류 l로 시작한다.# 심볼릭 링크 생성$ ln -s [대상파일] [심볼릭링크파일]",
        "url": "//linux/2024/05/21/linux-series-11-Symbolic.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-10-status-html": {
        "title": "[linux Series] 10 Status",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - status  프로젝트 중 OOM 으로 모니터링할 필요가 있어서 찾은vmstat(Virtual Memory STAT)리눅스의 프로세스, 메모리, 페이징, I/O 블록, CPU 활동 사항 출력-n\t주기적으로 헤더를 출력하지 말고, 한번만 헤더를 출력-a (active)\tbuffer와 cache대신 active/inactivate로 메모리사용량 결과 출력-t (timestamp)\t날짜 + 시간을 출력-w  (wide)\t출력결과의 너비를 맞춤-d  (disk)\t디스크 상태조회",
        "url": "//linux/2024/05/21/linux-series-10-Status.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-09-shellscript-html": {
        "title": "[linux Series] 09 Shellscript",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ShellScript  CICD 등 작업 중 찾은 문서ShellScriptShell 문법 검사기쉘 종류#!/usr/bin/bash ## 어떤 쉘로 스크립트를 실행할지 정의echo $(which bash)실행 방법  권한 주고 실행    $ vi script.sh# ... 작성후 종료$ chmod +x script.sh or chmod 755 script.sh$ ./script.sh # 쉘 스크립트 실행        bash로 실행```shell$ vi script.sh    … 작성후 종료  bash script.sh## Declare variables변수의 타입에는 로컬변수와 전역변수, 환경변수, 예약변수, 매개변수 등 다양히이 존재한다.- 변수는 대, 소문자를 구별한다.- 변수의 이름은 숫자를 포함할 수 있지만, 숫자로 시작할 수 없다.- 변수에는 모든 값을 문자열로 저장된다.- 변수에는 자료형을 기입하지 않는다. (int number, char names[10]), 즉 아무런 값을 다 넣을 수 있다.- 값을 사용할 때는 변수명 앞에 특수문자 \"$\"를 사용한다. (Ex. echo ${data})- 값을 대입(삽입)할 때는 특수문자 \"$\"를 사용하지 않는다. (Ex. data=mac)- 변수를 생성할 때는 \"=\" 대입문자 앞뒤로 공백이 없어야 한다. (Ex. data=\"abcd\")## Local/ Global variables기본적으로 변수 선언하면 전역이다. 함수 내부에서만 지역변수다. ```shell# 기본적으로 전역 변수로 지정string=\"hello world\"function string_test() {    # local을 붙여야 지역변수로 인식. 만일 local을 빼면 전역변수 덮어쓰기가 되버림    local string=\"hello local @@\"    echo ${string}}# 함수 호출string_test # &gt; hello local @@echo ${string} # &gt; hello world# 변수 초기화unset stringType# -r 읽기 전용 타입 (상수 const라고 보면 된다)declare -r var1readonly var1# -i 정수형 타입declare -i numbernumber=3echo \"number = $number\"     # number = 3# -a 배열 타입declare -a indices# -A 연관배열(MAP) 타입declare -A map# -f 함수 타입declare -f# -x 환경변수(export) 지정declare -x var3 # 스크립트 외부 환경에서도 이 변수를 쓸 수 있게 해준다.Environment variables쉘 스크립트에서 변수 명 앞에 export을 붙여주면 환경 변수(environment variable)로 설정되어 자식 스크립트에서 사용 가능하다.다만 환경 변수 사용시 시스템에 미리 정의된 예약 변수(reserved variable)와 변수명이 겹치지 않게 주의하자.Parameter./test($0) a($1) b($2) …shell 실행 시 매개변수를 받을 수 있다. $와 숫자 조합으로 표현한다.  $0은 scriptName으로 고정 $숫자로 변수를 받을 수 있다.  $#는 변수 개수  $*는 전체 인자  $!는 실행을 백그라운드로 보내진 마지막 프로그램 프로세스 번호  $$는 PID  $?는 리턴 값Reserved variables변수| 설명:—:|:—:HOME| 사용자 홈 디렉토리PATH| 실행 파일의 경로여러분이 chmod, mkdir 등의 명령어들은 /bin이나 /usr/bin, /sbin에 위치하는데, 이 경로들을 PATH 지정하면 여러분들은 굳이 /bin/chmod를 입력하지 않고, chmod 입력만 해주면 된다.LANG| 프로그램 실행 시 지원되는 언어UID| 사용자의 UIDSHELL| 사용자가 로그인시 실행되는 쉘USER| 사용자의 계정 이름FUNCNAME| 현재 실행되고 있는 함수 이름TERM| 로그인 터미널command  set : 셸 변수를 출력하는 명령어  env : 환경 변수를 출력하는 명령어  export : 특정 변수의 범위를 환경 변수의 데이터 공간으로 전송하여 자식 프로세스에서도 특정 변수를 사용 가능하게 한다. 전역 변수의 개념  unset : 선언된 변수를 제거한다.operation  expr  let  $(())expr  expr는 역따옴표를 반드시 감싸준다. 역따옴표 대신 $(( )) 해줘도 동작은 한다.  expr을 사용할 때 피연산자와 연산자 사이에 공백이 필요하다.  산술 연산할때 우선순위를 지정하기위해 괄호를 사용하려면 \\처리를 해줘야 한다.  곱셈 문자 *는 \\처리를 해주어야 한다.```shell#!/bin/bashnumber1=10number2=20plus=expr $number1 + $number2 minus=expr $number1 - $number2mul=expr $number1 \\* $number2 # 곱셈에는 * 를 이용한다.div=expr $number1 / $number2rem=expr $number1 % $number2echo “plus:     ${plus}”echo “minus:    ${minus}”echo “mul:      ${mul}”echo “div:      ${div}”echo “rem:      ${rem}”### let```shellnum1=42num2=9 let re=num1+num2 #Addecho \"add:$re\"let re=num1-num2 #Subecho \"sub:$re\"let re=num1*num2 #Mulecho \"mul:$re\"let re=num1/num2 #Divecho \"div:$re\"let re=num1%num2 #Modecho \"mod:$re\"$(())num1=42num2=9 echo add:$((num1+num2))echo sub:$((num1-num2))echo mul:$((num1*num2))echo div:$((num1/num2))echo mod:$((num1%num2))block annotation&lt;코드라인&gt;: &lt;&lt; \"END\"              #주석 시작echo \"여기서부터 \"echo \"test_01\"echo \"test_02\"echo \"test_03\"echo \"test_04\"echo \"test_05\"echo \"test_06\"echo \"test_07\"echo \"여기까지 주석처리 됨\"END                    #주석 끝echo \"여기는 주석이 안되어 있어 출력 \"vi 에디터로 여러줄 주석 방법기본 여러줄 주석 문법이 별로라면, vi 단축키를 이용한 주석 처리 방법이 있다.  vi 편집기를 열고  ctrl + v를 눌러 비주얼 모드로 진입한다. (비주얼 모드는 vim 이 설치 되어 있어야 한다.)  주석을 처리하고자 하는 라인까지 방향키 또는  vi방향키를 이용하여 이동한다.  shift + i 누르고 #을 입력한다.  esc 키를 여러번 누른다.  주석 처리 됨을 확인한다.if배쉬의 if문의 특이한 점은 fi 와 대괄호[ ] 이다.여타 언어와 달리 중괄호를 안쓰기 떄문에 fi로 if문의 끝을 알려주어야 하며,주의해야 할 점은 if문 뒤에 나오는 대괄호 [ ] 와 조건식 사이에는 반드시 공백이 존재해야 한다.if [ 값1 조건식 값2 ]then    수행1else    수행2fi# 가독성 좋기 위해 then을 if [] 와 붙여쓰려면 반드시 세미콜론 ; 을 써야한다.if [ 값1 조건식 값2 ]; then    수행1else    수행2fi비교 연산문자1 = 문자2             # 문자1 과 문자2가 일치 (sql같이 = 하나만 써도 일치로 인식)문자1 == 문자2            # 문자1 과 문자2가 일치문자1 != 문자2            # 문자1 과 문자2가 일치하지 않음-z 문자                   # 문자가 null 이면 참-n 문자                   # 문자가 null 이 아니면 참문자 == 패턴              # 문자열이 패턴과 일치문자 != 패턴              # 문자열이 패턴과 일치하지 않음값1 -eq 값2             # 값이 같음(equal)값1 -ne 값2             # 값이 같지 않음(not equal)값1 -lt 값2             # 값1이 값2보다 작음(less than)값1 -le 값2             # 값1이 값2보다 작거나 같음(less or equal)값1 -gt 값2             # 값1이 값2보다 큼(greater than)값1 -ge 값2             # 값1이 값2보다 크거나 같음(greater or equal)  이중 괄호  (( expression ))expression 에는 수식이나 비교 표현식이 들어갈 수 있다.수식| 설명:—:|:—:!|논리 부정~|비트 부정**|지수화&lt;&lt;|비트 왼쪽 쉬프트&gt;&gt;|비트 오른쪽 쉬프트&amp;|비트 단위AND||비트 단위 OR&amp;&amp; |논리 AND|| |논리 ORnum++ |후위증가num-- |후위감소++num |전위증가--num |전위감소num1=35num2=48# 이중 소괄호를 쓰면 조건문을 문자 대신 기호로 표현 가능하다. 단, 소괄호 안에 따옴표 쓰면 안된다.if (( ${num1} &lt; ${num2} )); then    echo \"yes\"fiif (( ($num1 * $num2) - $num2 &gt; 200 )); then\techo \"&gt;200\"else\techo \"&lt;200\"fi파일 검사 연산  이중 대괄호  [[ “1.8.3” == 1.7.* ]]&amp;&amp;, ||, = ~ * (정규식 매칭) 과 같은 확장 expression test 기능을 대괄호 내에 사용할 수 있게 한다.그냥 대괄호의 개선버젼 정도로 생각하면 된다.switch-casecase ${var} in    \"linux\") echo \"리눅스\" ;; # 변수var값이 linux라면 실행     \"unix\") echo \"유닉스\" ;;        \"windows\") echo \"윈도우즈\" ;;        \"MacOS\") echo \"맥OS\" ;;        *) echo \"머야\" ;; # default 부분esacCOUNTRY=koreacase $COUNTRY in  \"korea\"|\"japan\"|\"china\") # or 연산도 가능하다    echo \"$COUNTRY is Asia\"    ;;  \"USA\"|\"Canada\"|\"Mexico\")    echo \"$COUNTRY is Ameria\"    ;;  * )    echo \"I don't know where is $COUNTRY\"    ;;esacfor statementfor#!/bin/bash## FOR# 초기값; 조건값; 증가값을 사용한 정통적인 for문for ((i=1; i&lt;=4; i++)); do    echo $idonefor-in#!/bin/bash# 루프 돌 데이터에 띄어쓰기가 있으면 각각 돌음for x in 1 2 3 4 5do\techo \"${x}\"done# 변수를 사용한 반복문data=\"1 2 3 4 5\"for x in $datado\techo ${x}done# !/bin/bash# 루프 돌 데이터에 띄어쓰기가 있으면 각각 돌음for x in 1 2 3 4 5do\techo \"${x}\"done# 변수를 사용한 반복문data=\"1 2 3 4 5\"for x in $datado\techo ${x}done# 배열을 사용한 반복문arr=(1 2 3 4 5)for i in \"${arr[@]}\" # arr[@] : 배열 전체 출력do\techo \"${i}\"done# sequence를 통한 for문. seq라는 프로세스가 순서대로 숫자를 출력해 주는 역할을 bash에 사용한 것이다.for num in `seq 1 5`do  echo $numdone# range를 사용한 반복문. {..} 중괄호와 점 두개를 쓰면 range처리가 된다.for x in {1..5}do\techo ${x}done# 배열을 사용한 반복문arr=(1 2 3 4 5)for i in \"${arr[@]}\" # arr[@] : 배열 전체 출력do\techo \"${i}\"done##FOR-IN# sequence를 통한 for문. seq라는 프로세스가 순서대로 숫자를 출력해 주는 역할을 bash에 사용한 것이다.for num in `seq 1 5`do  echo $numdone# range를 사용한 반복문. {..} 중괄호와 점 두개를 쓰면 range처리가 된다.for x in {1..5}do\techo ${x}doneexample# 파일 리스트 출력for line in `ls` # 역따옴표 써서 ls를 문자가 아닌 하나의 명령어로 실행do echo $line # 해당 위치에 파일이나 디렉토리들이 출력done# 한줄 문법 (한줄로 쓰면 터미널에서 직접 스크립트를 실행 할 수 있다)for line in `ls`; do echo $line; donewhilecount=0while [ ${count} -le 5 ]; do    echo ${count}    count=$(( ${count}+1 ))donecount=0while (( ${count} &lt;= 5 ));  # 이중괄호 사용하면 논리기호 사용 가능do    echo ${count}    count=$(( ${count}+1 ))doneArray#!/bin/bash# 배열의 크기 지정없이 배열 변수 선언# 굳이 'declare -a' 명령으로 선언하지 않아도 바로 배열 변수 사용 가능함declare -a arrayarr=(\"test1\" \"test2\" \"test3\") # 배열 선언 및 지정echo ${arr[0]}  # test1# 기존 배열에 1개의 배열 값 추가 3가지 방법arr[3]=\"test4\" arr+=(\"test5\")arr[${#arr[@]}]=\"test6\" # 배열 길이를 인덱스로 사용해 pushecho ${arr[@]}  # arr의 모든 데이터 출력echo ${arr[*]}  # arr의 모든 데이터 출력echo ${#arr[@]} # arr 배열 길이 출력echo ${arr[@]:2:3} # 2부터 3개의 요소Map# 연관배열 생성declare -A map=([hello]='world' [long]='long long long string' [what is it]=123)declare -p map # 연관배열 정보 출력# &gt; declare -A map=([long]=\"long long long string\" [\"what is it\"]=\"123\" [hello]=\"world\" )echo \"map[hello]=${map[hello]}\" # &gt; map[hello]=worldkey=hello # 변수를 인덱스로 넣어줘도 된다. (MAP의 특성)echo \"map[key]=${map[${key}]}\" # &gt; map[key]=worldScannerecho -n \"String input : \"read [변수명] # &lt;- 터미널에서 입력된 인풋값이 변수에 저장되게 된다.echo \"user input : $변수명 # 입력된 값 출력function다른 프로그래밍 언어와 달리 쉘 스크립트에서는 함수명 앞 function은 써주지 않아도 알아서 인식된다. 또한, 함수를 호출할때는 괄호를 써주지 않고 호출해야한다는 점이 다르다.그리고 함수 호출 코드는 함수 코드보다 반드시 뒤에 있어야 된다. 함수 코드 보다 앞에서 호출 시 오류가 발생하기 때문이다.#!/bin/bashfunc(){\techo \"func()\"}function string_test() {    echo \"string test\"    echo \"인자값: ${@}\"}#함수 호출func# 함수에 인자값 전달하기(공백의로 뛰어서 2개의 인자값을 넘김)string_test \"hello\" \"world\"인자는 공백으로 구분하여 하나씩 넣으면 된다.function test3(){    param1=$1    param2=$2    echo $param1 # a    echo $param2 # b    echo $@ # 파라미터 전체 출력}test3 \"a\" \"b\"종료 상태종료 코드란, exit 명령으로 프로그램을 종료시키면서 사용자에게 프로그램 종료의 이유를 알리기 위하여 반환하는 값이다.쉘 스크립트 내에서 exit 명령어가 실행되면 스크립트가 종료되며 부모 프로세스에 종료 상태를 전달할 수 있는데 이 값은 프로그램 내에서 임의로 지정할 수도 있다.#!/bin/bashexit 16 # 강제 종료echo \"wtf\" # 실행안됨0 은 성공 이외는 모두 오류다.Shell command(command substitution)$() 안의 실행문을 실행하고 그 결과를 $()으로 리턴한다.#!/bin/bash# 그냥 date 문자열 출력echo date# 백틱으로 감싸주면 date 명령어가 실행되게 된다.echo `date`# $()도 마찬가지echo $(date)# shell executionecho \"I'm in `pwd`\"echo \"I'm in $(pwd)\"출처: https://inpa.tistory.com/entry/LINUX-쉘-프로그래밍-핵심-문법-총정리 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-09-ShellScript.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-08-permission-html": {
        "title": "[linux Series] 08 Permission",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Permission  서버 반영/CICD 작업 중 권한 문제로 고생해서 정리Permissionuser : 파일 소유주group : 파일을 만든 소유주가 속한 그룹의 사용자other : 기타 사용자            문자 값      파일      디렉토리                  r(4)      파일에 대한 읽기 권한. 열기, 읽기 허용      디렉토리 내의 파일을 나열할 수 있게 허용              w(2)      파일에 대한 쓰기 권한. 쓰기, 잘라내기 허용  이름 변경이나 파일 삭제 허용하지 않음. 파일 삭제나 파일 이름 변경은 디렉토리 속성에 의해 결정됨      디렉토리 내의 파일들을 생성, 삭제, 이름변경이 가능하도록 허용              x(1)      파일에 대한 실행 권한 파일이 프로그램으로 처리되고 파일이 실행되도록 허용 스크립트 언어에서 작성된 프로그램 파일들은 읽기 가능으로 설정 되어 있어야만 실행 가능함      디렉토리 내에서 탐색을 위해 이동 할 수 있도록 허용 (디렉토리에 들어올 수 있도록 허용 )      chmod : 허가권 변경-R, --recursive\t특정 디렉터리 내의 파일과 디렉터리에 대해 재귀적으로 허가권 변경-C, --changes\t변경된 파일이나 디렉터리에 대한 자세한 정보를 출력-f , --silent, --quite\t대부분의 에러메시지 출력을 제한--reference\t모드 대신 파일에 지정한 모드를 사용 chown : 사용자 및 그룹 소유권 변경chown [options] owner:[group] filesoption-R, --recursive\t특정 디렉터리 내의 파일과 디렉터리에 대해 재귀적으로 허가권 변경-C, --changes\t변경된 파일이나 디렉터리에 대한 자세한 정보를 출력-f , --silent, --quite\t대부분의 에러메시지 출력을 제한--reference\t모드 대신 파일에 지정한 모드를 사용 chgrp : 파일이나 디렉토리의 그룹 소유권만 변경chgrp [options] group filehttps://inpa.tistory.com/entry/LINUX-📚-파일-권한-소유권허가권-💯-정리#",
        "url": "//linux/2024/05/21/linux-series-08-Permission.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-07-network-html": {
        "title": "[linux Series] 07 Network",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - NetstatNetstatnetstat [option] [|grep portNumber or ServiceName]options  -l (listen) : 연결 가능한 상태  -n (number port) : port  -t (tcp) : tcp  -u (udp) : udp  -p (pid) : PID  -a (all) : all  -i : 이더넷 카드별 정상/ 에러/ 드랍 송수신 패킷 수 확인  -r : 라우팅 테이블  -s : 네트워크 통계nslookupDNS 관련 확인하기 위해서 사용traceroutetraceroute는 목적지에 도달하기까지 경로를 추적한다.",
        "url": "//linux/2024/05/21/linux-series-07-Network.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-06-journalctl-html": {
        "title": "[linux Series] 06 Journalctl",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Journalctl  당시 프로젝트 중 oom이 잦아서 아마존 리눅스에서 로그를 보려하는데amazonlinux가 /var/log/messages에 로그를 저장을 안해서 찾아본 문서AmazonLinux /var/log/messages 에 로그가 없어서journalctl 이란?  systemd의 서비스 로그를 확인할 수 있다.  systemd-journald.service에 의해서 systemd의 정보들을 분석한다.옵션  -a : 표시할 수 없는 문자가 있거나 매우 긴 경우에도 모든 Log 내용을 출력  -b : 마지막 부팅 후의 Log만 출력  -r : 최신항목이 먼저 표시되도록 역순으로 출력  -c : 커서가 지정한 저널의 위치부터 Log 표시를 시작  -f : 가장 최근 Log만 표시하고 새롭게 추가되는 Log는 계속 출력  -k : 커널 메시지만 출력 (dmesg랑 같음)  -q : 일반 사용자로 실행될 때 접근할 수 없는 시스템 저널에 관한 경고메시지를 표시하지 않음  -u : unit으로 systemctl list-units에서 출력되는 첫번째 항목  -p : 메시지의 우선순위로 log level을 의미  emerg=0, alert=1, crit=2, err=3, warning=4, notice=5, info=6, debug=7  -o : Log 출력 형식을 설정          short : 기본값으로 syslog파일의 형식과 동일하다. 한 행에 하나의 Log만 출력      short-iso : short와 비슷하지만 ISO 8601의 시간 형식으로 출력      short-precise : short와 비슷하지만 마이크로 초 단위로 시간 출력      short-monotonic : short와 비슷하지만 단조로운 시간 형식으로 출력      verbose : 전체 Log를 모두 자세하게 출력      export : Log내용을 내보낸다. (백업 및 전송에 적합한 바이너리 스트림으로 직렬화)      json : 한줄에 하나씩 JSON 데이터 구조로 형식화      json-pretty : JSON 데이터 구조로 형식화 하지만 여러줄로 형식을 지정하여 사람이 읽을 수 있게 한다.      json-see : JSON 데이터 구조로 형식화 하지만 Server-Sent Events에 적합한 형식으로 한다.      cat : 매우 간결한 출력을 생성하며 메타 데이터가 없고 Log만 표시하며 시간은 표시하지 않음        -l : 출력되는 Log의 필드를 줄일때 사용, 기본값은 전체 필드를 표시하여 사용자가 해당 필드를 붙이거나 자를 수 있도록 한다.  _UID= 33 : 33번 UID를 가진 프로세스에 대한 Log를 출력  --disk-usage : 저널 파일의 디스크 사용량을 표시 (압춘된 모든 더널 파일과 사용중인 저널 파일의 합계를 표시)설정파일vi /etc/systemd/journald.conf[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitInterval=30s#RateLimitBurst=1000#SystemMaxUse=    -&gt; journal log 파일의 최대 Size를 지정#SystemKeepFree=#SystemMaxFileSize=#RuntimeMaxUse=#RuntimeKeepFree=#RuntimeMaxFileSize=#MaxRetentionSec=#MaxFileSec=1month  -&gt; journal log 파일의 최대보관일수를 지정#ForwardToSyslog=yes#ForwardToKMsg=no#ForwardToConsole=no#ForwardToWall=yes#TTYPath=/dev/console#MaxLevelStore=debug#MaxLevelSyslog=debug#MaxLevelKMsg=notice#MaxLevelConsole=info#MaxLevelWall=emerg사용법  마지막 부팅 후 로그 보기    journalctl -b    오늘 날짜 로그 보기    journalctl –since=today    특정 기간별 로그 보기    journalctl –since “2017-05-25 00:00:00” –until “2017-05-30 10:30:00”    journalctl –since “1 hour ago”    journalctl –since “2 days ago”    특정 서비스 데몬 로그 보기    journalctl -u sshd    특정 이벤트 속성 조회    journalctl -p crit    특정 서비스데몬 및 속성과 날짜 로그 보기    journalctl -u libvirtd –since=yesterday -p err    Error 로그 자세히 보기    journalctl -p err -o verbose    특정 이벤트 조회    journalctl /sbin/crond    밑에서부터 로그 보기    journalctl -f    journalctl -r -b    UID 로 검색 (id)journalctl _UID=108journalctl이 느릴때(btrfs)  Log의 크기를 확인    journalctl –disk-usage    로그를 저장하는 파일 데이터베이스에 단편화를 확인    filefrag /var/log/journal//    단편화를 제거    btrfs fi defrag -v -f -clzo /var/log/journal//  ",
        "url": "//linux/2024/05/21/linux-series-06-Journalctl.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-05-input-output-html": {
        "title": "[linux Series] 05 Input_output",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Input/ OutputInput/ Output명령을 재지정해서 파일로부터 입력받거나 파일로 출력하는 등 출력, 입력 방향을 변경할수 있다.      표준 입력(stdin) : 표준 입력이라고 부르는 곳에서 입력 내용을 가져옴, 기본적으로 키보드에 직접 연결    표준 출력(stdout) : 명령이나 프로그램 등의 실행 결과를 표준 출력에 전송, 기본적으로 화면과 연결 되어 있고 디스크파일에 따로 저장하지 않음    표준 오류(stderr) : 명령이나 프로그램 등의 상태 및 오류 메시지를 표준 에러에 전송, 기본적으로 화면과 연결되어 있고 디스크파일에 따로 저장하지 않음  Output Redirection  명령의 실행 결과나 에러 상황을 화면에 출력하지 않고 파일로 저장  &gt; 연산자를 사용한 표준 출력 재지정 (파일명 앞에 &gt; 연산자를 사용)  &gt; 연산자로 출력 방향을 지정할 때 목적 파일은 항상 처음부터 다시 작성된다. (파일 덮어씀)  만일 파일 내용을 초기화 안시키고 이어서 쓰고싶다면, &gt;&gt; 연산자로 이어쓰기 를 지정한다. &gt;&gt;연산자는 기존 파일에 있는 정보에 이어서 추가적으로 내용을 기입 해준다.연산 조합$ 명령 &gt;&amp; 파일명 # : 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력$ 명령 &gt;&gt;&amp; 파일명 # : 명령이 실행된 표준 출력의 결과와 에러를 파일로 덧붙여 출력$ 명령 &gt;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과를 파일로 출력$ 명령 &gt;&amp;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력$ 명령 &gt;&gt;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 파일에 덧붙여 출력$ 명령 &gt;&gt;&amp;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일에 덧붙여 출력Input Redirection  키보드 입력을 파일에서 받도록 대체 하는 것  &lt; 연산자를 사용해서 키보드로 연결한 표준 입력 방향을 파일로 변경  cat 명령어를 사용하는 것과 동일한 결과를 나타냄Error Redirection명령어 실행에서 에러가 발생했을때, 원래동작은 그냥 화면에 출력하고 끝이지만,명령어를 통해 출력되는 에러 내용을 파일등으로 저장 및 출력하도록 재지정하는 것이다.$ ls -l nullfile 2&gt; err.txt# ls -l nullfile은 실패하는 명령어이다. nullfile이 디렉토리에 없을경우 실패하게 된다.# 그러한 실패err를 (2)표준오류 지정을 통해 err.txt파일에 저장한다# 표준 입력 : 0# 표준 출력 : 1# 표준 오류 : 2pipe표준 출력을 표준 입력으로 받는 것 즉, 명령어의 결과를 다시 어떤 명령어의 입력으로 받을 때 사용한다.  둘 이상의 명령을 함께 묶어 출력의 결과를 다른 프로그램의 입력으로 전환 하는 기능  즉, 명령어의 표준 출력을 또 다른 명령어의 표준 입력과 연결  명령어와 명령어의 연결은 | 기호를 사용  | 기호 앞의 명령 결과가 뒤의 명령에 입력 데이터로 사용cat /etc/passwd | grep \"root\" # == grep \"root\" /etc/passwd# /etc/passwd의 내용이 grep의 입력값으로 받아 root를 필터링# 디렉토리 개수 확인하기 $ ll | grep \"^d\" | wc -l# * ll = ls -l : List 형태로 출력# * grep \"^d\" : d로 시작하는 행 필터링 (행의 앞글자 d는 directory를 의미)# * wc -l은 행의 개수를 출력# -&gt; ll로 디렉토리 파일들을 출력하고, 그 출력 내용을 d로 시작되는 파일만 필터링하고, 필터링 된 내용의 개수를 출력출처: https://inpa.tistory.com/entry/LINUX-📚-입출력-재지정-파이프-명령어-정리 [Inpa Dev 👨‍💻:티스토리]EOT/ EOFBash 쉘에서 HEREDOC 구문의 전형적인 형식직접 입력한 텍스트를 파일에 저장할 때 주로 사용한다.시작 및 종료를 알리는 키워드로는 흔히 EOF(또는 EOT)를 쓰는데, 임의로 정하는 것이므로 다른 것(예: AAA, HELLO)도 가능하다.EOF는 End of File, EOT는 End of Text이라는 의미이다.cat &lt;&lt;EOF &gt; file1.txt&gt; hello&gt; world&gt; EOFuser01@localhost:~$ cat file1.txthelloworld",
        "url": "//linux/2024/05/21/linux-series-05-Input_Output.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-04-grep-html": {
        "title": "[linux Series] 04 Grep",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GrepGrep참조Input/Ouput Redirection사전 지식Regexp            메타문자      의미      예시      설명                                ^      행의 시작      $ grep ‘^linux’      linux로 시작하는 행                            $      행의 끝      $ grep ‘linux$’      linux로 끝나는 행                            ＼&lt;      단어의 시작      $ grep ‘＼&lt;linux’      linux로 시작하는 단어를 포함하는 행                            ＼&gt;      단어의 끝      $ grep ‘linux＼&gt;’      linux로 끝나는 단어를 포함하는 행                            .      임의의 모든 문자 종류 하나      $ grep ‘l…x’      l과 x사이에 세글자만 있을 수 있음                            ?      문자가 한개가 있거나 없거나      $ grep ‘lin?x’      ?에 문자하나가 들어가는 것을 검색                            *      문자가 여러개 들어가거나 없거나      $ grep ‘linux’$ grep ‘lin’$ grep ‘lx’$ grep ‘linux’      linux를 모두 검색(여러 파일의 이름을 표현할 때 사용하고, 단독으로 * 사용하면 모든 파일을 나타냄)                            |      or 기호      $ grep ‘ab      cd      ef’      ab나 cd나 ef 셋 중 하나라도 들어있으면 검색              ＼()      특정 기호 or 메타 문자를 무시(문자 그 자체를 나타냄)      $ grep ‘lin＼.＼x’      .문자를 대응하는 것이 아니라 lin.x라는 문자를 검색                            []      []는 안에 내용을 넣어 그 문자들 중 한문자를 의미      $ grep ‘linux[123]’      linux1, linux2, linux3을 검색                            [0-9], [a-z]      숫자나 알파벳은 범위로 설정 가능      $ grep ‘linux[0-9]’      linux1부터 linux9까지 검색                            [^]      []안에 있는 ^는 부정을 의미안에 있는 문자를 제외한다는 뜻      $ grep ‘linux[^1-3]’      linux1 부터 linux3까지를 제외한 문자 검색                            ＼&lt;＼&gt;      ＼&lt;는 단어의 시작＼&gt;는 단어의 끝(위에 있는 지시자 합친것)      $ grep ‘＼&lt;linux＼&gt;’      linux로 시작하는 단어, linux로 끝나는 단어 검색예를 들어 alinux2와 같이 중간에 linux가 있는 것은 안됨                            a＼{n＼}      문자 a를 n번 반복      $ grep ‘a＼{2＼}’      a 문자가 2번 연속 반복되는 것을 검색                            a＼{n,＼}      문자 a를 적어도 n번 이상 반복 (콤마가 있음)      $ grep ‘a＼{2,＼}’      a 문자가 최소한 2번 이상 반복되는 것을 검색                            a＼{m,n＼}      문자 a를 m번 이상 n번 이하로 반복 (반복 범위 지정)      $ grep ‘a＼{2,4＼}’      a 문자가 2번 이상 4번 이하로 반복되는 부분                            ＼(..＼)      다음 사용을 위해 태그를 붙이는 역할최대 9개까지 사용가능      $ grep ＼(linux＼)A＼1B      linuxA에 ＼1이 태그되어linuxAlinuxB로 대응                    출처: https://inpa.tistory.com/entry/LINUX-📚-정규표현식-과-grep-명령어-정복하기-패턴-검색-확장브래킷 [Inpa Dev 👨‍💻:티스토리]Bracket브래킷|의미:—:|:—:[:alnum:]|A-Z, a-z, 0-9 알파벳 문자와 숫자로 이루어진 문자열[:alpha:]|A-Z, a-z 알파벳 문자[:blank:]|\\x09 스페이스와 탭[:cntrl:]|컨트롤 제어 문자[:digit:]|0-9 숫자[:graph:]|!-~ 공백이 아닌 문자(스페이스, 제어 문자들을 제외한 문자)[:lower:]|a-z 소문자[:print:]|graph와 유사하지만 스페이스 문자를 포함[:punct:]|!-/:-@[-‘{-~ 문장 부호 문자[:space:]|\\t\\v\\f 모든 공백 문자(newline 줄바꿈, 스페이스, 탭)[:upper:]|A-Z 대문자[:xdigit:]|16진수에서 사용할 수 있는 숫자vi 에서 정규표현식으로 검색/없이$ # 없이로 끝나는 문자열 검색/...세 # 4개 문자로 구성된 문자열 중 마지막 문자가 “세”로 끝나는 문자열 검색/o*ve # o로 시작되는 문자부터 ve로 끝나는 모든 문자열 검색/[Ll]ove # Love, lovegrepgrep 은 입력으로 전달된 파일의 내용 혹은 디렉토리에서, 파일 내용이나 파일 이름의 특정 문자열 패턴을 찾고자 할 때 사용하는 명령어다.  grep 은 global / regular expression / print에서 각각의 머릿 글자를 따 온 것이며, find와 함께 리눅스에서 가장 많이 사용되는 명령어 중 하나이다.            명령어      설명      정규 표현식 사용 유무                  grep      다중 패턴      O              egrep(grep -e)      정규 표현식 패턴      O              fgrep(grep -f      문자열 표현식 패턴      X      $ grep [OPTION...] PATTERN [FILE...]#    -E        : PATTERN을 확장 정규 표현식(Extended RegEx)으로 해석.#    -F        : PATTERN을 정규 표현식(RegEx)이 아닌 일반 문자열로 해석.#    -G        : PATTERN을 기본 정규 표현식(Basic RegEx)으로 해석.#    -P        : PATTERN을 Perl 정규 표현식(Perl RegEx)으로 해석.#    -e        : 매칭을 위한 PATTERN 전달.#    -f        : 파일에 기록된 내용을 PATTERN으로 사용.#    -i        : 대/소문자 무시.#    -v        : 매칭되는 PATTERN이 존재하지 않는 라인 선택.#    -w        : 단어(word) 단위로 매칭.#    -x        : 라인(line) 단위로 매칭.#    -z        : 라인을 newline(\\n)이 아닌 NULL(\\0)로 구분.#    -m        : 최대 검색 결과 갯수 제한.#    -b        : 패턴이 매치된 각 라인(-o 사용 시 문자열)의 바이트 옵셋 출력.#    -n        : 검색 결과 출력 라인 앞에 라인 번호 출력.#    -H        : 검색 결과 출력 라인 앞에 파일 이름 표시.#    -h        : 검색 결과 출력 시, 파일 이름 무시.#    -o        : 매치되는 문자열만 표시.#    -q        : 검색 결과 출력하지 않음.#    -a        : 바이너리 파일을 텍스트 파일처럼 처리.#    -I        : 바이너리 파일은 검사하지 않음.#    -d        : 디렉토리 처리 방식 지정. (read, recurse, skip)#    -D        : 장치 파일 처리 방식 지정. (read, skip)#    -r        : 하위 디렉토리 탐색.#    -R        : 심볼릭 링크를 따라가며 모든 하위 디렉토리 탐색.#    -L        : PATTERN이 존재하지 않는 파일 이름만 표시.#    -l        : 패턴이 존재하는 파일 이름만 표시.#    -c        : 파일 당 패턴이 일치하는 라인의 갯수 출력.예시# 날짜 기준이 생성일이라고  할 때, 첫 날짜는 검색하고자 하는 날짜, 두번째는 검색하고자 하는 다음날 날짜$ find . -name *.log -newerct yyyy-MM-dd ! -newerct yyyy-MM-dd -exec grep -Hni '검색어' {} \\;pipe와 사용# 현재 프로세스를 출력에서 \"java\"라는 문자열을 포함하는 라인만 표시 $ ps -ef | grep \"java\"# 어플리케이션의 로그를 tail 하면서 \"error\" 문자열을 포함하는 라인 표시$ tail -f application.log | grep -i \"error\"# netstat명령어로 네트워크 상태를 모니터링하는데 그중 tcp만 확인$ netstat | grep \"tcp\"# 어플리케이션 로그중 \"error\" 문자열을 포함하는 라인을 한 화면씩 표시$ grep \"error\" application.log | more# mylog.txt 파일에서 Apple과 Banana이 있는 문자열들을 탐색$ cat mylog.txt | grep 'Apple' | grep 'Banana'find와 사용$ find . -name \"찾고 싶은 파일이름\" | xargs grep -n \"찾고 싶은 글자\"  xargs 의미  파이프 다음에 쓰이는 xargs는 파이프를 통해 넘어온 결과물을 다음 명령어에 매개변수로 던져주는 역할을 한다.출처: https://inpa.tistory.com/entry/LINUX-📚-정규표현식-과-grep-명령어-정복하기-패턴-검색-확장브래킷 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-04-Grep.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-03-environment-html": {
        "title": "[linux Series] 03 Environment",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnvironmentEnvironment0. 환경 변수 확인printenv [변수명]pringenv HOME1. 변수 설정1.1 쉘 변수현재 쉘에만 적용되는 변수Test=\"TestVariables\"set|grep Test1.2 환경 변수시스템 전체에서 사용 가능한 변수이자 자식쉘에도 상속된다.export Test=\"TestVariables\"1.2.1 /etc/profilebash 로그인 쉘에 진입할 때 로드export JAVA_HOME=\"/path/to/java/home\"export PATH=$PATH:$JAVA_HOME/bin1.2.2 ~/.bashrc사용자별 쉘 구성 파일2. 설정 해제unset [변수명]",
        "url": "//linux/2024/05/21/linux-series-03-Environment.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-02-compress-html": {
        "title": "[linux Series] 02 Compress",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Compresstar/ Compress/ gzip/ bzip2/ xz/ zip리눅스와 윈도우 파일 압축 방식리눅스는 윈도우와 다르게 압축과 대상 파일을 묶는 것을 따로 한다. 윈도우는 묶으면서 동시에 압축하는 반면 리눅스는 압축하거나 관리할 파일들을 먼저 하나의 파일로 묶고(아카이빙) 묶인 파일을 따로 압축한다.아카이브linux는 묶는 것과 압축을 따로 한다. 한 파일로 묶는 것을 아카이브(archive)라고 하며 확장자는 .tar(tape archive)를 가진다.그리고 tar를 다시 gzip으로 압축해서 .tar.gz 확장자를 볼 수 있다.tar(tape archive) 명령어tar [OPTION] [ArchiveFileName] [FILE|PATH]| 옵션  |\t동작||:—:|:—:|| -f\t |대상파일을 tar 아카이브 지정 (기본 옵션)| | -c\t |tar 아카이브 생성. 기존 아카이브 덮어 쓰기 (파일 묶을 때 사용)| | -x\t |tar 아카이브에서 파일 추출(파일 풀 때 사용)| | -v\t |처리되는 과정(파일 정보)을 자세하게 나열| | -z\t |gzip 압축 적용 옵션| | -j\t |bzip2 압축 적용 옵션| | -t\t |tar 아카이브에 포함된 내용 확인| | -C\t |대상 디렉토리 경로 지정| | -A\t |아카이브 파일을 tar 아카이브에 추가| | -d\t |tar 아카이브와 파일 시스템 간 차이점 검색| | -r\t |tar 아카이브 마지막에 파일들 추가| | -u\t |tar 아카이브에 새롭게 추가된 파일만 추가| | -k\t |tar 아카이브 추출 시, 기존 파일 유지| | -U\t |tar 아카이브 추출 전, 기존 파일 삭제| | -w\t |모든 진행 과정에 대해 확인 요청. (interactive)| | -e\t |첫 번째 에러 발생 시 중지|리눅스 압축 형식            압축형태      기본형태      축약      간략설명                  gzip      .tar.gz      .tgz      zip과 같은 압축 알고리즘을 사용하지만 더 용량이 작음.(다른 파일끼리의 중복되는 부분을 하나로 압축이 가능하기 때문)              xzip      .tar.xz      .txz      LZMA2 압축 알고리즘을 사용하는 7-zip은 윈도우에서만 제공하는데 유닉스에 제공하기위해 사용됨 압축효율이 가장 좋음.              bzip      .tar.bz2      .tb2, .tbz, .tbz2      용량이 클 때, gzip에 비해 압축률은 좋지만 비교적 느림              Z      .tar.Z      .tZ      ASCII나 바이너리 파일을 의미              lzma      .tar.lzma      .tlz      bzip2보다 더 높은 압축률 제공(최대 4GB)              lzma      .tar.lz      -      LZMA 알고리즘에 기초함 무결성을 확인하기 위한 CRC 체크섬이 지원됨      ",
        "url": "//linux/2024/05/21/linux-series-02-Compress.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-01-command-html": {
        "title": "[linux Series] 01 Command",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Commandhistory이전에 사용했던 명령어들의 내역이 출력됨ctrl + s/ ctrl + qctrl + s : 터미널의 문자 출력을 중단하는 터미널 제어 키ctrl + q : 제어 해제tail -f | grepgrep과 함께 사용하면 의미 있는 행만 표시할 수도 있다.z-z를 사용하면 tar, gzip으로 압축된 파일을 그대로 읽을 수 있다.zcat, zmore, zgrep, zdifflessless는 파일 크기가 클수록 효과를 발휘한다. cat, vi보다 좋은 선택이 될 수 있다. 내부에서 검색어 검색, 페이지 이동, 줄 번호 표시 등을 할 수 있다.yes |yes | 명령어 를 사용하면 뒤 명령어에 yes로 자동으로 인식하게 해준다.grep -Pri특정 텍스트가 포함된 파일이 있는지 한번에 확인하려는 경우manman [명령어]로 메뉴얼 출력 가능하다.touch파일의 날짜와 시간을 수정하는 명령어간혹 0바이트 파일을 만들기 위해서 사용하기도 한다.-t 옵션으로 서버 시간이 아닌 시간을 지정해서 날짜를 변경할 수도 있다.",
        "url": "//linux/2024/05/21/linux-series-01-Command.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-04-oop-html": {
        "title": "[java Others Series] 04.oop",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - OOPDOOP ( Object-Oriented Programming )장점  코드의 재사용성이 높아진다.  유지보수가 쉽다.  코드가 간결해진다.    단점    처리 시간이 비교적 오래 걸린다.  프로그램을 설계할 때 많은 고민과 시간을 투자해야한다.원칙  S (SRP : Single Responsibility Principle) : 한 클래스는 하나의 책임만 가져야 한다.  O (OCP : Open/Closed Principle) : 확장에는 열려(Open) 있으나, 변경에는 닫혀(Closed)있어야 한다.  L (LSP : Liskov’s Substitution Principle) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.  I (ISP : Interface Segregation Principle) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.  D (DIP : Dependency Inversion Principle) : 추상화에 의존한다. 구체화에 의존하면 안된다.특징  캡슐화          실제로 구현 부분을 외부에 드러나지 않도록 하는 것변수와 메소드를 하나로 묶음데이터를 외부에서 직접 접근하지 않고 함수를 통해서만 접근      ex) public, private, protectedpublic : 클래스 외부에서 접근 가능private : 클래스 내부에서만 접근 가능protected : 상속받은 자식 클래스에서만 접근 가능        상속          자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것기능의 일부분을 변경하는 경우 자식 클래스에서 상속받아 수정 및 사용함상속은 캡슐화를 유지, 클래스의 재사용이 용이하도록 해 준다.        추상화          인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현하는 것        다형성          어떤 변수,메소드가 상황에 따라 다른 결과를 내는 것      ",
        "url": "//java_others/2024/05/20/java-others-series-04.OOP.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-03-coupling-cohesion-html": {
        "title": "[java Others Series] 03.coupling&amp;cohesion",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Coupling &amp; CohesionCoupling &amp; Cohesion일반적으로 문제를 작은 부분으로 쪼개어서 하나씩 풀어나가게 될 것인데, 이 때 문제를 작은 부분으로 쪼개나가는 것을 모듈화라고 한다.각각의 모듈은 주어진 기능만을 독립적으로 수행하기 때문에 재사용성이 높고 코드의 이해/수정이 용이하기 때문이다.결론적으로 결합도는 모듈과 모듈 간의 의존 정도를 의미하고, 응집도는 한 모듈 내의 구성요소들 간의 연관 정도를 의미한다.결합도결합도는 모듈(클래스 파일)간의 상호 의존 정도 또는 연관된 관계의 끈끈함 정도를 의미한다고 보면 된다. (결합도를 의존도라고 부르기도 한다)예를 들면 결합도가 높은 클래스는 다른 클래스와 연관 관계가 끈끈하여, 만일 하나의 클래스의 구조를 변경하게 된다면 그에 연관된 클래스들도 싹 변경해야 할수도 있고,객체 사용 코드도 변경해야 할 수도 있어서, 유지보수 측면에서 매우 마이너스적인 요소로 작용된다. 좋은 소프트웨어는 낮은 결합도(low coupling)를 가지고 있다고 말할 수 있다.  [결합도가 낮은 클래스의 특징]      Open Closed Principle의 원칙을 잘 지킨 클래스 (확장에는 열려있고 변경에는 닫혀 있는 클래스)    다형성을 잘 지킨 클래스  단계 종류    세기    종류    내용    약함   ↓   강함    자료 결합도 (Data Coupling)    모듈간의 인터페이스로 전달되는 파라미터(데이터)를 통해서만 상호 작용이 일어나는 경우 결합도가 제일 낮고 제일 좋은 형태이다.    스탬프 결합도 (Stamp Coupling)    모듈간의 인터페이스로 배열이나 객체, 자료 구조 등이 전달되는 경우    제어 결합도 (Control Coupling)    어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우    외부 결합도 (External Coupling)    어떤 모듈이 외부에 있는 다른 모듈의 데이터를 참조하는 경우 (데이터, 통신 프로토콜 등)    공통 결합도 (Common Coupling)    여러 개의 모듈이 하나의 공통 데이터 영역(전역 변수 참조 및 갱신)을 사용하는 경우    내용 결합도 (Content Coupling)    어떤 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우 결합도가 제일 높고 제일 좋지 않은 형태이다.자료 결합도  가장 결합도가 낮고, 가장 좋은 형태  모듈끼리 단순히 데이터를 주고 받는 경우 (기능 수행에 있어서 로직을 제어하거나 하지 않는 순수한 자료형 요소의 데이터를 주고 받는 것)  한 모듈을 변경하더라도 다른 모듈에는 영향을 끼치지 않는 결합 형태스탬프 결합도  두 모듈이 인터페이스로 배열이나 오브젝트와 같은 동일한 자료 구조를 참조하는 형태의 결합도  만일 모듈에 쓰일 자료구조 형태가 변경되면 그것을 참조하는 모든 모듈에 영향을 주게 됨제어 결합도  어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우  상위 모듈이 하위 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우  제어 결합은 정보은닉을 위배하는 결합으로, 한 모듈이 다른 모듈 내부에 관여하여 관계가 복잡해짐외부 결합도  모듈이 외부에 있는 다른 모듈의 데이터를 참조할 때의 결합도  외부의 데이터, 통신 프로토콜 등을 공유할때 발생 (참조할 데이터가 외부 모듈에 위치할때)  어떤 외부 모듈에서 반환한 값을 다른 모듈에서 참조하는 경우  참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다공통 결합도  여러 개의 모듈이 하나의 공통 데이터 영역을 사용하는 결합도  대표적으로 전역 변수(global variable)를 예로 들 수 있음 (전역 변수의 변경이 여러 모듈에 영향을 줌)  공통 데이터 영역의 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미침  위의 외부 결합도와 유사하게 볼수 있으나 공통 데이터가 외부냐 내부냐에 따라 차이가 있다.  공통 결합도가 외부 결합도 보다 결합도가 높은 이유는, 전역 변수의 값에 따라 결국은 외부의 모듈 반환값 까지 결정될 수 있는 가능성이 있기 때문에 외부 결합도 보다 더 결합도가 높도록 평가된다고 보면 된다.내용 결합도  가장 높은 결합도를 갖으며, 가장 좋지 않은 결합 형태  어떤 모듈이 사용하려면 다른 모듈의 내부 기능과 데이터를 직접 참조해 그대로 가져와 사용하거나 수정하는 경우  이렇게 되면 A모듈, B모듈 모두 코드를 알고 있어야 하며 A모듈이 변경되면 B모듈도 영향을 미쳐 변경해야 함응집도응집도는 하나의 클래스가 기능에 집중하기 위한 모든 정보와 역할을 갖고 있어야 한다는 의미이다.정확히 응집도는 한 모듈 내의 구성 요소 간의 밀접한 정도를 의미하는데, 한 모듈이 하나의 기능(책임)을 갖고있는 것은 응집도가 높은 것이고, 한 모듈이 여러 기능을 갖고 있는 것은 응집도가 낮은 것이다.  [응집도가 높은 클래스의 특징]      단일 책임을 가진 클래스 (Single Responsibility Principle)    다른 클래스와 잘 협력하는 클래스      세기    종류    내용    강함   ↓   약함    기능적 응집도 (Functional Cohesion)            모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우        응집도가 제일 높고 제일 좋은 형태이다.        순차적 응집도 (Sequential Cohesion)    모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우        교환적 응집도 (Communication Cohesion)    동일한 입력과 출력을 사용해 다른 기능을 수행하는 활동들이 모여있을 경우    절차적 응집도 (Procedural Cohesion)    모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우    시간적 응집도(Temporal Cohesion)    연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우    논리적 응집도(Logical Cohesion)    유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우    우연적 응집도(Coincidental Cohesion)    모듈 내부의 각 구성요소들이 연관이 없을 경우    응집도가 제일 낮고 제일 좋지 않은 형태이다.기능적 응집도  가장 응집도가 높은 형태로 가장 좋은 형태이다.  모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우  대입 되는 변수가 공통적으로 사용되는 경우  대표적인 예로 수학 연산에 관련된 모듈들을 모은 Math 클래스를 들 수 있다.순차적 응집도  모듈 내에서 한 활동으로 부터 나온 출력값이 다음 활동의 입력 데이터로 사용할 경우  어떤 모듈이 특정 파일을 읽고 처리하는 기능을 하는 등과 같다교환적 응집도  통신적 응집도 라고도 불림  동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있는 경우  메소드 호출에 공통된 파라미터가 입력되는 경우  순차적 응집도와 차이점은 대신에 처리 순서가 중요치 않다는 것이다.절차적 응집도  모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소가 그 기능을 순차적으로 수행할 경우  하나의 클래스에 있는 메소드들을 여러 개 호출하는 경우시간적 응집도  일시적 응집고 라고도 불림  각 기능 요소들이 순서에 상관없이 특정 시점에 반드시 수행되는 경우  연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우  메소드 호출이 일어나지 않고 변수의 초기화만 실행되거나, Exception 에러 로그를 보내거나 등논리적 응집도  유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우  논리적으로 비슷한 기능을 수행하지만 서로의 관계는 밀접하지 않은 형태  switch문이 쓰여 case에 따라 비슷하지만 다른 작업을 수행하는 경우우연적 응집도  가장 좋지 않은 응집도  모듈 내부의 각 구성 요소들이 서로 관련없는 요소로만 구성된 경우",
        "url": "//java_others/2024/05/20/java-others-series-03.Coupling&amp;Cohesion.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-02-composition-html": {
        "title": "[java Others Series] 02.composition",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CompositionComposition상속과 합성 개념 정리            상속(Inheritance)      합성(Composition)                  부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결      두 객체 사이의 의존성은 런타임에 해결              is-a 관계      has-a 관계              부모클래스의 구현에 의존 결합도가 높음.      구현에 의존하지 않음.  내부에 포함되는 객체의 구현이 아닌 인터페이스에 의존.              클래스 사이의 정적인 관계      객체 사이의 동적인 관계              부모 클래스 안에 구현된 코드 자체를 물려 받아 재사용      포함되는 객체의 퍼블릭 인터페이스를 재사용      상속상속(Inheritance)은 객체 지향 4가지 특징중 하나로서 클래스 기반의 프로그래밍에서 가장 먼저 배우는 개념일 것이다.클래스 상속을 통해 자식 클래스는 부모 클래스의 자원을 물려 받게 되며, 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다.그래서 상속 관계를 is-a 관계라도 표현하기도 한다.상속을 사용하는 경우는 명확한 is - a 관계에 있는 경우, 그리고 상위 클래스가 확장할 목적으로 설게되었고 문서화도 잘되어 있는 경우에 사용하면 좋다.그러나 상속을 제대로 활용하려면 부모 클래스의 내부 구현에 대해서 상세하게 알아야 하므로 결합도가 높아진다. 또한 상속 관계는 컴파일 타임에 결정되고, 고정되기 때문에코드를 실행하는 도중에 변경할 수 없다.따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하게 된다면 모든 조합별로 클래스를 하나하나 추가해주어야 한다. 이것을 클래스 폭발 문제라 한다.합성합성 기법은 기존 클래스를 상속을 통한 확장하는 대신에, 필드로 클래스의 인스턴스를 참조하게 만드는 설계이다.예를들어 서로 관련없는 이질적인 클래스의 관계에서, 한 클래스가 다른 클래스의 기능을 사용하여 구현해야 한다면합성의 방식을 사용한다고 보면 된다.상속의 문제점1. 결합도가 높아진다.상속을 하면 부모 - 자식 관계가 컴파일 시점에 결정된다.2. 불필요한 기능 상속3. 부모 클래스의 결함이 그대로 넘어온다.4. 부모 -자식 클래스의 동시 수정 문제개념적 결합으로 인해, 부모 클래스를 변경할 때 자식도 같이 변경해야 한다.5. 메소드 오버라이딩 오동작자식 클래스에서 부모의 public을 이용할 떄 의도하지 않은 동작을 수반할 수 있다. 이는 캡슐화를 위반한 것이다.6. 불필요한 인터페이스 상속 문제7. 클래스 폭발새롭게 만든 클래스에 하나의 기존 기능을 연결하기 위해서 상속을 해야하고, 또 상속을 하고… 이런 경우를 클래스 폭발이라고 한다.8. 단일 상속의 한계C에서 문제로 다중 상속을 제한했는데 이로 인해서 클래스 폭발이 유발된다.합성의 장점1. 결합도를 낮출 수 있다.2. 합성 관계는 실행 시점에 동적으로 변경할 수 있다.3. 불필요한 인터페이스 상속 문제를 해결할 수 있다.4. 메소드 오버라이딩 오동작을 방지할 수 있다.5. 단일 상속 문제를 해소할 수 있다.",
        "url": "//java_others/2024/05/20/java-others-series-02.Composition.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-01-solid-html": {
        "title": "[java Others Series] 01.solid",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SOLIDSOLID  SRP(Single Responsibility Principle): 단일 책임 원칙  OCP(Open Closed Priciple): 개방 폐쇄 원칙  LSP(Listov Substitution Priciple): 리스코프 치환 원칙  ISP(Interface Segregation Principle): 인터페이스 분리 원칙  DIP(Dependency Inversion Principle): 의존 역전 원칙1. SRP단일 책임 원칙은 클래스(객체)는 단 하나의 책임만 가져야 한다는 원칙이다.여기서 ‘책임’ 이라는 의미는 하나의 ‘기능 담당’으로 보면 된다.즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러개 설계하라는 원칙이다.만일 하나의 클래스에 기능(책임)이 여러개 있다면 기능 변경(수정) 이 일어났을때 수정해야할 코드가 많아진다.예를 들어 A를 고쳤더니 B를 수정해야하고 또 C를 수정해야하고, C를 수정했더니 다시 A로 돌아가서 수정해야 하는, 마치 책임이 순환되는 형태가 되어버린다.따라서 SRP 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있게 된다.최종적으로 단일 책임 원칙의 목적은 프로그램의 유지보수 성을 높이기 위한 설계 기법이다.이때 책임의 범위는 딱 정해져있는 것이 아니고, 어떤 프로그램을 개발하느냐에 따라 개발자마다 생각 기준이 달라질 수 있다.class Employee {    String name;    String positon;    Employee(String name, String position) {        this.name = name;        this.positon = position;    }\t// * 초과 근무 시간을 계산하는 메서드 (두 팀에서 공유하여 사용)    void calculateExtraHour() {        // ...    }    // * 급여를 계산하는 메서드 (회계팀에서 사용)    void calculatePay() {        // ...        this.calculateExtraHour();        // ...    }    // * 근무시간을 계산하는 메서드 (인사팀에서 사용)    void reportHours() {        // ...        this.calculateExtraHour();        // ...    }    // * 변경된 정보를 DB에 저장하는 메서드 (기술팀에서 사용)    void saveDababase() {        // ...    }}2. OCPOCP 원칙은 클래스는 ‘확장에 열려있어야 하며, 수정에는 닫혀있어야 한다’ 를 뜻한다.기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법이다.[ 확장에 열려있다 ] - 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음[ 변경에 닫혀있다 ] - 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함.어렵게 생각할 필요없이, OCP 원칙은 추상화 사용을 통한 관계 구축을 권장을 의미하는 것이다.즉, 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙class Animal {\tString type;        Animal(String type) {    \tthis.type = type;    }}// 동물 타입을 받아 각 동물에 맞춰 울음소리를 내게 하는 클래스 모듈class HelloAnimal {    void hello(Animal animal) {        if(animal.type.equals(\"Cat\")) {            System.out.println(\"냐옹\");        } else if(animal.type.equals(\"Dog\")) {            System.out.println(\"멍멍\");        }    }}public class Main {    public static void main(String[] args) {        HelloAnimal hello = new HelloAnimal();                Animal cat = new Animal(\"Cat\");        Animal dog = new Animal(\"Dog\");        hello.hello(cat); // 냐옹        hello.hello(dog); // 멍멍    }}3. LSPLSP 원칙은 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙이다.쉽게 말하면 LSP는 다형성 원리를 이용하기 위한 원칙 개념으로 보면 된다.간단히 말하면 리스코프 치환 원칙이란, 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미하는 것이다.따라서 기본적으로 LSP 원칙은 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야한다.왜냐하면 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문이다.void myData() {\t// Collection 인터페이스 타입으로 변수 선언    Collection data = new LinkedList();    data = new HashSet(); // 중간에 전혀 다른 자료형 클래스를 할당해도 호환됨        modify(data); // 메소드 실행}void modify(Collection data){    list.add(1); // 인터페이스 구현 구조가 잘 잡혀있기 때문에 add 메소드 동작이 각기 자료형에 맞게 보장됨    // ...}4. ISPISP 원칙은 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙이다.SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조하는 것으로 보면 된다.즉, SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계하는 원칙.ISP 원칙은 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표이다.다만 ISP 원칙의 주의해야 할점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말아야 한다.(인터페이스는 한번 구성하였으면 왠만해선 변하면 안되는 정책 개념)interface ISmartPhone {    void call(String number); // 통화 기능    void message(String number, String text); // 문제 메세지 전송 기능    void wirelessCharge(); // 무선 충전 기능    void AR(); // 증강 현실(AR) 기능    void biometrics(); // 생체 인식 기능}class S20 implements ISmartPhone {    public void call(String number) {    }    public void message(String number, String text) {    }    public void wirelessCharge() {    }    public void AR() {    }    public void biometrics() {    }}class S21 implements ISmartPhone {    public void call(String number) {    }    public void message(String number, String text) {    }    public void wirelessCharge() {    }    public void AR() {    }    public void biometrics() {    }}5. DIPDIP 원칙은 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 것// 인터페이스interface Toy {}class Robot implements Toy {}class Lego implements Toy {}class Doll implements Toy {}// 클라이언트class Kid {\tToy toy; // 합성        void setToY(Toy toy) {    \tthis.toy = toy;    }        void play() {}}// 메인 메소드public class Main {\tpublic static void main(String[] args) {        Kid boy = Kid();                // 1. 아이가 로봇을 가지고 놀 때        Toy toy = new Robot();        boy.setToy(toy);        boy.play();                // ...                // 2. 아이가 레고를 가지고 놀 때        Toy toy = new Lego();        boy.setToy(toy);        boy.play();    }}",
        "url": "//java_others/2024/05/20/java-others-series-01.SOLID.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-20-enumfactorymethod-html": {
        "title": "[deisgn Pattern Series] 20 Enumfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Enum Factory MethodEnumFactoryMethodFactoryMethod 단점을 보완하기 위한 패턴이다.Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 모두 구현해야 된다는 점이다.즉, 제품 객체가 50개면 공장 객체도 50개를 구현해야 된다는 말이다.또한 기본적으로 팩토리 클래스는 한번 인스턴스화 하고 제품 객체를 생성하는 역할만 하면 되지 여러개 생성될수 있는 낭비적인 가능성이 있기 때문에 싱글톤을 일일히 적용하여야 하며 이로인해 코드가 복잡해진 다는 문제점도 있었다.이러한 문제점을 Enum으로 팩토리 메서드 패턴을 구성해 준다면, 일일히 서브 공장 클래스 구현 없이 하나의 enum Factory에서 SOLID 원칙 위반 없이 팩토리 클래스를 구성해 줄 수 있다.그러나 단점은 클래스 상속이 필요할때, enum 외의 클래스 상속은 불가능하기 때문에 다시 일반 클래스로 재구성 해야된다는 한계점이 존재한다.기존 팩토리 메서드 패턴Factory Method 패턴에서 유의할 부분은 Factory 인스턴스가 여러번 생성될 필요가 없다는 점이다.공장 객체는 한번만 생성되면 필요할때마다 제품 객체들을 얼마든지 생성할수 있기 때문에 괜히 매번 제품을 생성할때마다 인스턴스화 하면 GC에 의해 STW(Stop The World)가 일어나는 원인이 된다.Enum으로 구현한 팩토리 메소드 패턴Enum 확장 기능을 이용해 싱글톤을 구성해 줄수 도 있다. 왜냐하면 Enum 타입 자체가 public static final 이기 때문에 따로 싱글톤을 구현하지 않아도 단일한 객체만 생성됨이 보장되기 때문이다.enum EnumShapeFactory {    RECTANGLE {        public Shape createShape() {            return new Rectangle();        }    },    CIRCLE {        public Shape createShape() {            return new Circle();        }    };    public Shape create(String color) {        Shape shape = createShape();        shape.setColor(color);        return shape;    }    // 팩토리 메서드    abstract protected Shape createShape();}class Client {    public static void main(String[] args) {        Shape rectangle = EnumShapeFactory.RECTANGLE.create(\"red\");        rectangle.draw();        Shape circle = EnumShapeFactory.CIRCLE.create(\"yellow\");        circle.draw();    }}",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-20-EnumFactoryMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-19-dynamicfactory-html": {
        "title": "[deisgn Pattern Series] 19 Dynamicfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Dynamic FactoryDynamic FactoryFactory Method의 단점을 보완하기 위한 패턴기존 팩토리 메서드 패턴오리지날 Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 1:1 매칭으로 모두 구현해야 된다는 점이다. 그래서 제품 객체가 50개면 공장 객체도 50개를 구현해야 한다. 이는 곧 클래스 폭발로 이어지며 코드 복잡도를 증가시킨다.다이나믹 팩토리 패턴 적용자바의 Class 클래스를 이용한 Reflection APIVisit Website 기법을 이용하여 유형을 동적으로 등록하고 인스턴스를 초기화 하는 패턴이 바로 Dynamic Factory 패턴이다.이를 이용해 팩토리 메서드의 서브 클래싱 부피가 늘어나는 한계를 해결 할 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-19-DynamicFactory.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-18-templatecallback-html": {
        "title": "[deisgn Pattern Series] 18 Templatecallback",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Template CallbackTemplate Callback탬플릿 콜백 패턴(Template Callback Pattern)은 스프링 프레임워크에서 DI(Dependency injection) 의존성 주입에서 사용하는 특별한 전략 패턴이다.스프링의 JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate과 같은곳에 사용된다.존의 전략 패턴은 변화되는 전략 알고리즘 부분을 컴파일 타임에서 클래스로 만든뒤 구현체를 주입해 주어야 되지만, 템플릿 콜백 패턴은 런타임 타임에서 익명 클래스를 이용해 동적으로 전략 알고리즘을 주입한다.용어도 그냥 전략 패턴에서의 컨텍스트(Context)를 템플릿으로 치환한 것일 뿐이며 콜백은 익명 클래스를 만들어진 메서드를 칭하는 것이다.정리하자면 템플릿 콜백 패턴은 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 패턴이라고 보면 된다.흐름// 콜백interface Callback {    int execute(final int n);}// 템플릿class Template {    int workflow(Callback cb) {        System.out.println(\"Workflow 시작\");        int num = 100;        int result = cb.execute(num);        return result;    }}// 클라이언트public class Client {    public static void main(String[] args) {        int x = 100;        int y = 20;        Template t = new Template();        int result = t.workflow(new Callback() {            @Override            public int execute(final int n) {                return n * n;            }        });        System.out.println(result); // 100 * 100 = 10000    }}특징  전략 패턴과 스프링의 의존성 주입(DI)의 장점을 익명 내부 클래스 사용 전략과 결합해 독특하게 활용되는 패턴장점  전략패턴은 따로 전략 알고리즘을 정해놓은 별도의 전략 클래스가 필요했지만, 템플릿-콜백 패턴은 별도의 전략 클래스 없이, 전략을 사용하는 메소드에 매개변수값으로 전략 로직을 넘겨 실행하기 때문에 전략 객체를 일일히 만들 필요가 없다.  외부에서 어떤 전략을 사용하는지 감추고 중요한 부분에 집중할 수 있다.단점  스프링 클라이언트에서 DI를 사용하지 않게 되면, Bean으로 등록되지 않아 싱글톤 객체가 되지 않게 된다.  인터페이스를 사용하지만 실제 사용할 클래스를 직접 선언하기 때문에 결합도가 증가하게 된다. 다만, 그렇다고 해서 무리하게 결합도를 낮추는 행위를 할 필요는 없다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-18-TemplateCallback.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-17-staticfactorymethod-html": {
        "title": "[deisgn Pattern Series] 17 Staticfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Static Factory MethodStatic Factory Method정적 팩토리 메서드(Static Factory Method) 패턴은 개발자가 구성한 Static Method를 통해 간접적으로 생성자를 호출하는 객체를 생성하는 디자인 패턴이다. 우리는 지금까지 객체를 인스턴스화 할때 직접적으로 생성자(Constructor)를 호출하여 생성하였는데, 별도의 객체 생성의 역할을 하는 클래스 메서드를 통해 간접적으로 객체 생성을 유도하는 것이다. 그리고 이 정적 메서드를 통칭적으로 정적 팩토리 메서드 패턴이라고 부르는 것이다.class Book {    private String title;        // 생성자를 private화 하여 외부에서 생성자 호출 차단    private Book(String title) { this.title = title; }        // 정적 팩토리 메서드    public static Book titleOf(String title) {        return new Book(title); // 메서드에서 생성자를 호출하고 리턴함    }}특징1. 생성 목적에 대한 이름 표현이 가능하다.지금까지 클래스를 설계할때 다양한 타입의 객체를 생성하기 위해, 생성 목적에 따라 생성자를 오버로딩하여 구분하여 사용해왔다.하지만 문제는 이러한 객체를 new 키워드를 통해 생성자로 생성하려면, 개발자는 해당 생성자의 인자 순서와 내부 구조를 알고 있어야 목적에 맞게 객체를 생성할수가 있다는 번거로움이 있다.class Car {    private String brand;    private String color;    // private 생성자    private Car(String brand, String color) {        this.brand = brand;        this.color = color;    }    // 정적 팩토리 메서드 (매개변수 하나는 from 네이밍)    public static Car brandBlackFrom(String brand) {        return new Car(brand, \"black\");    }    // 정적 팩토리 메서드 (매개변수 여러개는 of 네이밍)    public static Car brandColorOf(String brand, String color) {        return new Car(brand, color);    }}2. 인스턴스에 대해 통제 및 관리가 가능하다.메서드를 통해 한단계 거쳐 간접적으로 객체를 생성하기 때문에, 기본적으로 전반적인 객체 생성 및 통제 관리를 할 수 있게 된다.즉, 필요에 따라 항상 새로운 객체를 생성해서 반환할 수도 있고, 아니면 객체 하나만 만들어두고 이를 공유하여 재사용하게 하여 불필요한 객체를 생성하는 것을 방지 할 수 있는 것이다.대표적인 예시가 Singleton이다.class Singleton {    private static Singleton instance;    private Singleton() {}    // 정적 팩토리 메서드    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}다른 예로는 인스턴스에 대한 캐싱(Caching) 절차 구조를 정적 팩토리 메서드로 구현할 수 있다. 인스턴스에 대해 캐싱을 한다면 필요한 인스턴스만 뽑아 재사용하여 메모리를 절약할 수 있게 된다.이렇게 인스턴스를 통제하는 것은 인스턴스가 단 하나뿐임을 보장하는 것이고, Flyweight 디자인 패턴의 근간이 되게 된다.3. 하위 자료형 객체를 반환할 수 있다.클래스의 다형성의 특징을 응용한 정적 팩토리 메서드 특징이다. 메서드 호출을 통해 얻을 객체의 인스턴스를 자유롭게 선택할수 있는 유연성을 갖는 것이다.interface SmarPhone {}class Galaxy implements SmarPhone {}class IPhone implements SmarPhone {}class Huawei implements SmarPhone {}class SmartPhones {    public static SmarPhone getSamsungPhone() {        return new Galaxy();    }    public static SmarPhone getApplePhone() {        return new IPhone();    }    public static SmarPhone getChinesePhone() {        return new Huawei();    }}4. 인자에 따라 다른 객체를 반환하도록 분기할 수 있다.메서드이니 매개변수를 받을수 있을테고, 메서드 블록 내에서 분기문을 통해 여러 자식 타입의 인스턴스를 반환하도록 응용 구성이 가능하다.interface SmarPhone {    public static SmarPhone getPhone(int price) {        if(price &gt; 100000) {            return new IPhone();        }        if(price &gt; 50000) {            return new Galaxy();        }        return new Huawei();    }}5. 객체 생성을 캡슐화 할 수 있다.생성자를 사용하는 경우 외부에 내부 구현을 드러내야 하는데, 정적 팩토리 메서드는 구현부를 외부로 부터 숨길 수 있어 캡슐화(encapsulation) 및 정보 은닉(information hiding)을 할수 있다는 특징이 있다.또한 노출하지 않는다는 특징은 정보 은닉성을 가지기도 하지만 동시에 사용하고 있는 구현체를 숨겨 의존성을 제거해주는 장점도 지니고 있다.interface Grade {    String toText();}class A implements Grade {    @Override    public String toText() {return \"A\";}}class B implements Grade {    @Override    public String toText() {return \"B\";}}class C implements Grade {    @Override    public String toText() {return \"C\";}}class D implements Grade {    @Override    public String toText() {return \"D\";}}class F implements Grade {    @Override    public String toText() {return \"F\";}}class GradeCalculator {    // 정적 팩토리 메서드    public static Grade of(int score) {        if (score &gt;= 90) {            return new A();        } else if (score &gt;= 80) {            return new B();        } else if (score &gt;= 70) {            return new C();        } else if (score &gt;= 60) {            return new D();        } else {            return new F();        }    }}Static Factory Method 네이밍 규칙  from : 하나의 매개 변수를 받아서 객체를 생성  of : 여러개의 매개 변수를 받아서 객체를 생성                              getInstance          instance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음                                                  newInstance          create : 항상 새로운 인스턴스를 생성                      get[OrderType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음  new[OrderType] : 항상 다른 타입의 새로운 인스턴스를 생성실제 사용 예시  Optional.of()  List.of()  Integer.valueOf()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-17-StaticFactoryMethod.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-series-16-singleton-html": {
        "title": "[deisgn Pattern Series] 16 Singleton",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "layout: postcategories: [DESIGN_PATTERN]—from Dictionary - SingletonSingleton// Basicpublic class Singleton {    private static Singleton instance;        private Singleton() { }        public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) { // 쓰레드 동시 접근 시 문제가 발생            instance = new Singleton(); // 쓰레드 동시 접근 시 여러 번 생성        }                return instance;    }}// Synchronizedpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static synchronized Singleton getInstance() {        if ( Objects.isNull( instance ) ) {             instance = new Singleton();         }        //인스턴스 생성이 된 이후에도 락을 건다. 불필요!        return instance;    }}//DCL(Double-Checked-Locking) public class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {                        synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                    /**                     * 아래와 같은 재배치가 있을 수 있다.                     * some_space = allocate space for Singleton Obj;                     *                      *   instancce = some_sapce;                     *                      * create finished                     */                }            }        }        //락을 거는 부분을 최소한으로         //소스코드 상으로 문제가 없지만 컴파일러에 따라 재배치(reordering) 문제가 발생하기도 한다.         return instance;    }}//volatilepublic class Singleton {        private volatile static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {            synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                }            }        }        //문제 없음         return instance;    }}//static 초기화 이용public class Singleton {    private static Singleton instance;        static {        instance = new Singleton();  //클래스 로드 시점에 생성해서 하나임을 보장한다.    }        private Singleton() { }    public static synchronized Singleton getInstance() {        return instance;    }        // 해당 instance를 사용 여부와 상관없이 생성한다. 낭비!}//LazyHolder staticpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        return LazyHolder.INSTANCE;    }        private static class LazyHolder {        private static final Singleton INSTANCE = new Singleton();    }    //THREAD-SAFE + LAZY}",
        "url": "//2024/05/19/deisgn-pattern-series-16-Singleton.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-15-stategy-html": {
        "title": "[deisgn Pattern Series] 15 Stategy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StrategyStrategy전략 패턴은 실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴 이다.여기서 ‘전략’이란 일종의 알고리즘이 될 수 도 있으며, 기능이나 동작이 될 수도 있는 특정한 목표를 수행하기 위한 행동 계획을 말한다.즉, 어떤 일을 수행하는 알고리즘이 여러가지 일때, 동작들을 미리 전략으로 정의함으로써 손쉽게 전략을 교체할 수 있는, 알고리즘 변형이 빈번하게 필요한 경우에 적합한 패턴이다.  전략 알고리즘 객체들 : 알고리즘, 행위, 동작을 객체로 정의한 구현체  전략 인터페이스 : 모든 전략 구현제에 대한 공용 인터페이스  컨텍스트(Context) : 알고리즘을 실행해야 할 때마다 해당 알고리즘과 연결된 전략 객체의 메소드를 호출.  클라이언트 : 특정 전략 객체를 컨텍스트에 전달 함으로써 전략을 등록하거나 변경하여 전략 알고리즘을 실행한 결과를 누린다.특징정의  동일 계열의 알고리즘군을 정의하고  각각의 알고리즘을 캡슐화하여  이들을 상호 교환이 가능하도록 만든다.  알고리즘을 사용하는 클라이언트와 상관없이 독립적으로  알고리즘을 다양하게 변경할 수 있게 한다.흐름// 전략(추상화된 알고리즘)interface IStrategy {    void doSomething();}// 전략 알고리즘 Aclass ConcreteStrateyA implements IStrategy {    public void doSomething() {}}// 전략 알고리즘 Bclass ConcreteStrateyB implements IStrategy {    public void doSomething() {}}// 컨텍스트(전략 등록/실행)class Context {    IStrategy Strategy; // 전략 인터페이스를 합성(composition)    // 전략 교체 메소드    void setStrategy(IStrategy Strategy) {        this.Strategy = Strategy;    }    // 전략 실행 메소드    void doSomething() {        this.Strategy.doSomething();    }}사용 시기  전략 알고리즘의 여러 버전 또는 변형이 필요할 때 클래스화를 통해 관리  알고리즘 코드가 노출되어서는 안 되는 데이터에 액세스 하거나 데이터를 활용할 때 (캡슐화)  알고리즘의 동작이 런타임에 실시간으로 교체 되어야 할 때주의점  알고리즘이 많아질수록 관리해야할 객체의 수가 늘어난다는 단점이 있다.  만일 어플리케이션 특성이 알고리즘이 많지 않고 자주 변경되지 않는다면, 새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다.  개발자는 적절한 전략을 선택하기 위해 전략 간의 차이점을 명확이 알고 있어야 한다.실사용 예제  Collections의 sort() 메서드에 의해 구현되는 compare() 메서드에 이용  javax.servlet.http.HttpServlet에서 service() 메서드와 모든 doXXX() 메서드에 이용  javax.servlet.Filter의 doFilter() 메서드에 이용",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-15-Stategy.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-14-templatemethod-html": {
        "title": "[deisgn Pattern Series] 14 Templatemethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TemplateMethodTemplateMethod템플릿 메서드(Template Method) 패턴은 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.즉, 변하지 않는 기능(템플릿)은 상위 클래스에 만들어두고 자주 변경되며 확장할 기능은 하위 클래스에서 만들도록 하여, 상위의 메소드 실행 동작 순서는 고정하면서 세부 실행 내용은 다양화 될 수 있는 경우에 사용된다.템플릿 메소드 패턴은 상속이라는 기술을 극대화하여, 알고리즘의 뼈대를 맞추는 것에 초점을 둔다. 이미 수많은 프레임워크에서 많은 부분에 템플릿 메소드 패턴 코드가 우리도 모르게 적용되어 있다.  AbstractClass(추상 클래스) : 템플릿 메소드를 구현하고, 템플릿 메소드에서 돌아가는 추상 메소드를 선언한다. 이 추상 메소드는 하위 클래스인 ConcreteClass 역할에 의해 구현된다.  ConcreteClass(구현 클래스) : AbstractClass를 상속하고 추상 메소드를 구체적으로 구현한다. ConcreteClass에서 구현한 메소드는 AbstractClass의 템플릿 메소드에서 호출된다.흐름abstract class AbstractTemplate {    // 템플릿 메소드 : 메서드 앞에 final 키워드를 붙이면 자식 클래스에서 오버라이딩이 불가능함.\t// 자식 클래스에서 상위 템플릿을 오버라이딩해서 자기마음대로 바꾸도록 하는 행위를 원천 봉쇄    public final void templateMethod() {        // 상속하여 구현되면 실행될 메소드들        step1();        step2();                if(hook()) { // 안의 로직을 실행하거나 실행하지 않음            // ...        }                step3();    }    boolean hook() {        return true;    }    // 상속하여 사용할 것이기 때문에 protected 접근제어자 설정    protected abstract void step1();    protected abstract void step2();    protected abstract void step3();}class ImplementationA extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}}class ImplementationB extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}    // hook 메소드를 오버라이드 해서 false로 하여 템플릿에서 마지막 로직이 실행되지 않도록 설정    @Override    protected boolean hook() {        return false;    }}특징사용 시기  클라이언트가 알고리즘의 특정 단계만 확장하고, 전체 알고리즘이나 해당 구조는 확장하지 않도록 할때  동일한 기능은 상위 클래스에서 정의하면서 확장, 변화가 필요한 부분만 하위 클래스에서 구현할 때장점  클라이언트가 대규모 알고리즘의 특정 부분만 재정의하도록 하여, 알고리즘의 다른 부분에 발생하는 변경 사항의 영향을 덜 받도록 한다.  상위 추상클래스로 로직을 공통화 하여 코드의 중복을 줄일 수 있다.  서브 클래스의 역할을 줄이고, 핵심 로직을 상위 클래스에서 관리하므로서 관리가 용이해진다          헐리우드 원칙 (Hollywood Principle) : 고수준 구성요소에서 저수준을 다루는 원칙 (추상화에 의존)      단점  알고리즘의 제공된 골격에 의해 유연성이 제한될 수 있다.  알고리즘 구조가 복잡할수록 템플릿 로직 형태를 유지하기 어려워진다.  추상 메소드가 많아지면서 클래스의 생성, 관리가 어려워질 수 있다.  상위 클래스에서 선언된 추상 메소드를 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는지 클래스 로직을 이해해야 할 필요가 있다.  로직에 변화가 생겨 상위 클래스를 수정할 때, 모든 서브 클래스의 수정이 필요 할수도 있다.  하위 클래스를 통해 기본 단계 구현을 억제하여 리스코프 치환 법칙을 위반할 여지가 있다.  할리우드 원칙 준수  헐리우드 원칙(Hollywood Principle) 이란 고수준 모듈(추상클래스, 인터페이스)에 의존하고 고수준 모듈에서 연락(메소드 실행) 하라는 원칙이다.객체 끼리 이상하게 얼키고 설켜, 의존성이 복잡하게 꼬여있는 것을 ‘의존성 부패(dependency rot)’ 라고 부르는데, 헐리우드 원칙을 활용하면 의존성 부패를 방지할 수 있게 된다.자바 프로그래밍으로 간단히 말하자면, 다형성을 이용해 고수준의 객체 타입에서만 왠만하면 메서드 실행을 하라는 말이다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-14-TemplateMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-13-state-html": {
        "title": "[deisgn Pattern Series] 13 State",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StateState상태 패턴(State Pattern)은 객체가 특정 상태에 따라 행위를 달리하는 상황에서, 상태를 조건문으로 검사해서 행위를 달리하는 것이 아닌, 상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴을 말한다.객체 지향 프로그래밍에서의 클래스는 꼭 사물 / 생물만을 표현하는 고체 형태의 데이터만 표현 할 수 있는게 아니다.경우에 따라서 무형태의 행위 / 동작도 클래스로 묶어 표현할 수 있다.그래서 상태를 클래스로 표현하면 클래스를 교체해서 ‘상태의 변화’를 표현할 수 있고, 객체 내부 상태 변경에 따라 객체의 행동을 상태에 특화된 행동들로 분리해 낼 수 있으며,새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.  전략 패턴(Strategy Pattern)이 ‘전략 알고리즘’을 클래스로 표현한 패턴이라면, 상태 패턴(State Pattern)은 ‘객체 상태’를 클래스로 표현한 패턴이라고 보면 된다.구조  State 인터페이스 : 상태를 추상화한 고수준 모듈.  ConcreteState : 구체적인 각각의 상태를 클래스로 표현. State 역할로 결정되는 인터페이스(API)를 구체적으로 구현한다. 다음 상태가 결정되면 Context에 상태 변경을 요청하는 역할도 한다.  Context : State를 이용하는 시스템. 시스템 상태를 나타내는 State 객체를 합성(composition)하여 가지고 있다. 클라이언트로부터 요청받으면 State 객체에 행위 실행을 위임한다  상태 클래스는 싱글톤 클래스로 구성한다.전략 패턴의 전략 객체 같은 경우 매개 값에 따라 알고리즘 수행 형태가 달라질수 있지만, 상태는 그 객체의 현 폼을 나타내는 것이기 때문에 대부분의 상황에서 유일하게 있어야 한다.특징사용 시기  객체의 행동(메서드)가 상태(state)에 따라 각기 다른 동작을 할때.  상태 및 전환에 걸쳐 대규모 조건 분기 코드와 중복 코드가 많을 경우  조건문의 각 분기를 별도의 클래스에 넣는것이 상태 패턴의 핵심  런타임단에서 객체의 상태를 유동적으로 변경해야 할 때장점  상태(State)에 따른 동작을 개별 클래스로 옮겨서 관리 할 수 있다.  상태(State)와 관련된 모든 동작을 각각의 상태 클래스에 분산시킴으로써, 코드 복잡도를 줄일 수 있다.  단일 책임 원칙을 준수할 수 있다. (특정 상태와 관련된 코드를 별도의 클래스로 구성)  개방 폐쇄 원칙을 준수할 수 있다. (기존 State 클래스나 컨텍스트를 변경하지 않고 새 State를 도입할 수 있다)  하나의 상태 객체만 사용하여 상태 변경을 하므로 일관성 없는 상태 주입을 방지하는데 도움이 된다.단점  상태 별로 클래스를 생성하므로, 관리해야할 클래스 수 증가  상태 클래스 갯수가 많고 상태 규칙이 자주 변경된다면, Context의 상태 변경 코드가 복잡해지게 될 수 있다.  객체에 적용할 상태가 몇가지 밖에 없거나 거의 상태 변경이 이루어지지 않는 경우 패턴을 적용하는 것이 과도할 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-13-State.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-series-12-factorymethod-html": {
        "title": "[deisgn Pattern Series] 12 Factorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "layout: postcategories: [DESIGN_PATTERN]—from Dictionary - FactoryMethodFactoryMethod팩토리 메소드 패턴은 객체 생성을 공장(Factory) 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴이다.즉, 클라이언트에서 직접 new 연산자를 통해 제품 객체를 생성하는 것이 아닌, 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것이다.또한 객체 생성에 필요한 과정을 템플릿 처럼 미리 구성해놓고, 객체 생성에 관한 전처리나 후처리를 통해 생성 과정을 다양하게 처리하여 객체를 유연하게 정할 수 있는 특징도 있다.  Creator : 최상위 공장 클래스로서, 팩토리 메서드를 추상화하여 서브 클래스로 하여금 구현하도로 함          객체 생성 처리 메서드(someOperartion) : 객체 생성에 관한 전처리, 후처리를 템플릿화한 메소드      팩토리 메서드(createProduct) : 서브 공장 클래스에서 재정의할 객체 생성 추상 메서드        ConcreteCreator : 각 서브 공장 클래스들은 이에 맞는 제품 객체를 반환하도록 생성 추상 메소드를 재정의한다. 즉, 제품 객체 하나당 그에 걸맞는 생산 공장 객체가 위치된다.  Product : 제품 구현체를 추상화  ConcreteProduct : 제품 구현체정리하자면, 팩토리 메소드 패턴은 객체를 만들어내는 공장(Factory 객체)을 만드는 패턴이라고 보면 된다. 그리고 어떤 클래스의 인스턴스를 만들지는 미리 정의한 공장 서브 클래스에서 결정한다.이렇게하면 객체 간 결합도가 낮아진다.  [ Template Method 패턴과 Factory Method 패턴과의 관계 ]  뭔가 이름 구성이 비슷해서 둘이 어떠한 관계가 있어 보이는데, 템플릿 메서드는 행동 패턴이고 팩토리 메서드는 생성 패턴이라 둘은 전혀 다른 패턴이다.다만 클래스 구조의 결은 둘이 같다고 보면 되는데, 인스턴스를 생성하는 공장을 Template Method 패턴으로 구성한 것이 Factory Method 패턴이 되기 때문이다.Template Method 패턴에서는 하위 클래스에서 구체적인 처리 알고리즘의 내용을 만들도록 추상 메소드를 상속 시켰었다. 이 로직을 알고리즘 내용이 아닌 인스턴스 생성에 적용한 것이 Factory Method 패턴 인 것이다.// 제품 객체 추상화 (인터페이스)interface IProduct {    void setting();}// 제품 구현체class ConcreteProductA implements IProduct {    public void setting() {    }}class ConcreteProductB implements IProduct {    public void setting() {    }}// 공장 객체 추상화 (추상 클래스)abstract class AbstractFactory {    // 객체 생성 전처리 후처리 메소드 (final로 오버라이딩 방지, 템플릿화)    final IProduct createOperation() {        IProduct product = createProduct(); // 서브 클래스에서 구체화한 팩토리 메서드 실행        product.setting(); // .. 이밖의 객체 생성에 가미할 로직 실행        return product; // 제품 객체를 생성하고 추가 설정하고 완성된 제품을 반환    }    // 팩토리 메소드 : 구체적인 객체 생성 종류는 각 서브 클래스에 위임    // protected 이기 때문에 외부에 노출이 안됨    abstract protected IProduct createProduct();}// 공장 객체 A (ProductA를 생성하여 반환)class ConcreteFactoryA extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductA();    }}// 공장 객체 B (ProductB를 생성하여 반환)class ConcreteFactoryB extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductB();    }}특징사용 시기  클래스 생성과 사용의 처리 로직을 분리하여 결합도를 낮추고자 할 때  코드가 동작해야 하는 객체의 유형과 종속성을 캡슐화를 통해 정보 은닉 처리 할 경우  라이브러리 혹은 프레임워크 사용자에게 구성 요소를 확장하는 방법을 제공하려는 경우  기존 객체를 재구성하는 대신 기존 객체를 재사용하여 리소스를 절약하고자 하는 경우          상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다. 그리고 객체 생성 방식의 변화는 해당되는 모든 코드 부분을 변경해야 하는 문제가 발생한다.      따라서 객체의 생성 코드를 별도의 클래스 / 메서드로 분리 함으로써 객체 생성의 변화에 대해 대비를 하기 위해 팩토리 메서드 패턴을 이용한다고 보면 된다.      특정 기능의 구현은 별개의 클래스로 제공되는 것이 바람직한 설계이기 때문이다      장점  생성자(Creator)와 구현 객체(concrete product)의 강한 결합을 피할 수 있다.  팩토리 메서드를 통해 객체의 생성 후 공통으로 할 일을 수행하도록 지정해줄 수 있다.  캡슐화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.  단일 책임 원칙 준수 : 객체 생성 코드를 한 곳 (패키지, 클래스 등)으로 이동하여 코드를 유지보수하기 쉽게 할수 있으므로 원칙을 만족  개방/폐쇄 원칙 준수 : 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있어 원칙을 만족 (확장성 있는 전체 프로젝트 구성이 가능)  생성에 대한 인터페이스 부분과 생성에 대한 구현 부분을 따로 나뉘었기 때문에 패키지 분리하여 개별로 여러 개발자가 협업을 통해 개발단점  각 제품 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에, 구현체가 늘어날때 마다 팩토리 클래스가 증가하여 서브 클래스 수가 폭발한다.  코드의 복잡성이 증가한다.실사용 예시  java.util.Calendar 의 getInstance()  java.util.ResourceBundle 의 getBundle()  java.text.NumberFormat 의 getInstance()  java.nio.charset.Charset 의 forName()  java.net.URLStreamHandlerFactory 의 createURLStreamHandler(String)  java.util.EnumSet 의 of()  jakarta.xml.bind.JAXBContext 의 createMarshaller() and other similar methods",
        "url": "//2024/05/19/deisgn-pattern-series-12-FactoryMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-11-abstractfactory-html": {
        "title": "[deisgn Pattern Series] 11 Abstractfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AbstractFactoryAbstractFactory추상 팩토리 패턴은 연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다.클라이언트에서 특정 객체을 사용할때 팩토리 클래스만을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리시킬 수 있다.즉, 추상 팩토리의 핵심은 제품 ‘군’ 집합을 타입 별로 찍어낼수 있다는 점이 포인트 이다.  AbstractFactory : 최상위 공장 클래스. 여러개의 제품들을 생성하는 여러 메소드들을 추상화 한다.  ConcreteFactory : 서브 공장 클래스들은 타입에 맞는 제품 객체를 반환하도록 메소드들을 재정의한다.  AbstractProduct : 각 타입의 제품들을 추상화한 인터페이스  ConcreteProduct (ProductA ~ ProductB) : 각 타입의 제품 구현체들. 이들은 팩토리 객체로부터 생성된다.  Client : Client는 추상화된 인터페이스만을 이용하여 제품을 받기 때문에, 구체적인 제품, 공장에 대해서는 모른다.Abstract Factory vs. Factory Method둘다 팩토리 객체를 통해 구체적인 타입을 감추고 객체 생성에 관여하는 패턴 임에는 동일하다. 또한 공장 클래스가 제품 클래스를 각각 나뉘어 느슨한 결합 구조를 구성하는 모습 역시 둘이 유사하다.그러나 주의할 것은 추상 팩토리 패턴이 팩토리 메서드 패턴의 상위 호환이 아니라는 점이다. 두 패턴의 차이는 명확하기 때문에 상황에 따라 적절한 선택을 해야 한다.예를 들어 팩토리 메서드 패턴은 객체 생성 이후 해야 할 일의 공통점을 정의하는데 초점을 맞추는 반면, 추상 팩토리 패턴은 생성해야 할 객체 집합 군의 공통점에 초점을 맞춘다.단, 이 둘을 유사점과 차이점을 조합해서 복합 패턴을 구성하는 것도 가능하다.FactoryMethodAbstractFactory공통점객체 생성 과정을 추상화한 인터페이스를 제공  객체 생성을 캡슐화함으로써 구체적인 타입을 감추고 느슨한 결합 구조를 표방차이점구체적인 객체 생성과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적관련 있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적한 Factory당 한 종류의 객체 생성 지원한 Factory에서 서로 연관된 여러 종류의 객체 생성을 지원. (제품군 생성 지원)메소드 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스의 생성 및 구성에 대한 의존을 감소클래스(Factory) 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스 군의 생성 및 구성에 대한 의존을 감소흐름// Product A 제품군interface AbstractProductA {}// Product A - 1class ConcreteProductA1 implements AbstractProductA {}// Product A - 2class ConcreteProductA2 implements AbstractProductA {}// Product B 제품군interface AbstractProductB {}// Product B - 1class ConcreteProductB1 implements AbstractProductB {}// Product B - 2class ConcreteProductB2 implements AbstractProductB {}interface AbstractFactory {    AbstractProductA createProductA();    AbstractProductB createProductB();}// Product A1와 B1 제품군을 생산하는 공장군 1 class ConcreteFactory1 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA1();    }    public AbstractProductB createProductB() {        return new ConcreteProductB1();    }}// Product A2와 B2 제품군을 생산하는 공장군 2class ConcreteFactory2 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA2();    }    public AbstractProductB createProductB() {        return new ConcreteProductB2();    }}특징사용 시기  관련 제품의 다양한 제품 군과 함께 작동해야 할때, 해당 제품의 구체적인 클래스에 의존하고 싶지 않은 경우  여러 제품군 중 하나를 선택해서 시스템을 설정해야하고 한 번 구성한 제품을 다른 것으로 대체할 수도 있을 때  제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때장점  객체를 생성하는 코드를 분리하여 클라이언트 코드와 결합도를 낮출 수 있다.  제품 군을 쉽게 대체 할 수 있다.  단일 책임 원칙 준수  개방 / 폐쇄 원칙 준수단점  각 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에 객체가 늘어날때 마다 클래스가 증가하여 코드의 복잡성이 증가한다. (팩토리 패턴의 공통적인 문제점)  기존 추상 팩토리의 세부사항이 변경되면 모든 팩토리에 대한 수정이 필요해진다. 이는 추상 팩토리와 모든 서브클래스의 수정을 가져온다.  새로운 종류의 제품을 지원하는 것이 어렵다. 새로운 제품이 추가되면 팩토리 구현 로직 자체를 변경해야한다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-11-AbstractFactory.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-10-proxy-html": {
        "title": "[deisgn Pattern Series] 10 Proxy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ProxyProxy프록시 패턴(Proxy Pattern)은 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 행동 패턴이다.프록시(Proxy)의 사전적인 의미는 ‘대리인’이라는 뜻이다. 즉, 누군가에게 어떤 일을 대신 시키는 것을 의미하는데, 이를 객체 지향 프로그래밍에 접목해보면 클라이언트가 대상 객체를 직접 쓰는게 아니라 중간에 프록시(대리인)을 거쳐서 쓰는 코드 패턴이라고 보면 된다. 따라서 대상 객체(Subject)의 메소드를 직접 실행하는 것이 아닌, 대상 객체에 접근하기 전에 프록시(Proxy) 객체의 메서드를 접근한 후 추가적인 로직을 처리한뒤 접근하게 된다.이런 방법을 사용하는 이유는 대상 클래스가 민감한 정보를 가지고 있거나 인스턴스화 하기에 무겁거나 추가 기능을 가미하고 싶은데, 원본 객체를 수정할 수 없는 상황일 때를 극복하기 위해서다.  안(Security) : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달한다.  캐싱(Caching) : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.  데이터 유효성 검사(Data validation) : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.  지연 초기화(Lazy initialization) : 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할때까지 연기할 수 있다.  로깅(Logging) : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.  원격 객체(Remote objects) : 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 할 수 있다.패턴 구조  Subject : Proxy와 RealSubject를 하나로 묶는 인터페이스 (다형성)          대상 객체와 프록시 역할을 동일하게 하는 추상 메소드 operation() 를 정의한다.      인터페이스가 있기 때문에 클라이언트는 Proxy 역할과 RealSubject 역할의 차이를 의식할 필요가 없다.        RealSubject : 원본 대상 객체  Proxy : 대상 객체(RealSubject)를 중계할 대리자 역할          프록시는 대상 객체를 합성(composition)한다.      프록시는 대상 객체와 같은 이름의 메서드를 호출하며, 별도의 로직을 수행 할수 있다 (인터페이스 구현 메소드)      프록시는 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안 된다.        Client : Subject 인터페이스를 이용하여 프록시 객체를 생성해 이용.          클라이언트는 프록시를 중간에 두고 프록시를 통해서 RealSubject와 데이터를 주고 받는다.      종류일반 프록시interface ISubject {    void action();}class RealSubject implements ISubject {    public void action() {        System.out.println(\"원본 객체 액션 !!\");    }}class Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {        this.subject = subject;    }    public void action() {        subject.action(); // 위임        /* do something */        System.out.println(\"프록시 객체 액션 !!\");    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}가상 프록시  지연 초기화 방식  가끔 필요하지만 항상 메모리에 적재되어 있는 무거운 서비스 객체가 있는 경우  이 구현은 실제 객체의 생성에 많은 자원이 소모 되지만 사용 빈도는 낮을 때 쓰는 방식이다.      서비스가 시작될 때 객체를 생성하는 대신에 객체 초기화가 실제로 필요한 시점에 초기화될수 있도록 지연할 수 있다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy() {  }    public void action() {  \t// 프록시 객체는 실제 요청(action(메소드 호출)이 들어 왔을 때 실제 객체를 생성한다.      if(subject == null){          subject = new RealSubject();      }      subject.action(); // 위임      /* do something */      System.out.println(“프록시 객체 액션 !!”);  }}  class Client {    public static void main(String[] args) {        ISubject sub = new Proxy();        sub.action();    }}## 보호 프록시- 프록시가 대상 객체에 대한 자원으로의 엑세스 제어(접근 권한)- 특정 클라이언트만 서비스 객체를 사용할 수 있도록 하는 경우- 프록시 객체를 통해 클라이언트의 자격 증명이 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있게 한다.```javaclass Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    boolean access; // 접근 권한    Proxy(RealSubject subject, boolean access) {        this.subject = subject;        this.access = access;    }    public void action() {        if(access) {            subject.action(); // 위임            /* do something */            System.out.println(\"프록시 객체 액션 !!\");        }    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject(), false);        sub.action();    }}로깅 프록시  대상 객체에 대한 로깅을 추가하려는 경우      프록시는 서비스 메서드를 실행하기 전달하기 전에 로깅을 하는 기능을 추가하여 재정의한다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {      this.subject = subject;  }    public void action() {      System.out.println(“로깅………………”);      subject.action(); // 위임  /* do something */  System.out.println(\"프록시 객체 액션 !!\");  System.out.println(\"로깅..................\");   } }      class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}```원격 프록시  프록시 클래스는 로컬에 있고, 대상 객체는 원격 서버에 존재하는 경우  프록시 객체는 네트워크를 통해 클라이언트의 요청을 전달하여 네트워크와 관련된 불필요한 작업들을 처리하고 결과값만 반환  클라이언트 입장에선 프록시를 통해 객체를 이용하는 것이니 원격이든 로컬이든 신경 쓸 필요가 없으며, 프록시는 진짜 객체와 통신을 대리하게 된다캐싱 프록시  데이터가 큰 경우 캐싱하여 재사용을 유도  클라이언트 요청의 결과를 캐시하고 이 캐시의 수명 주기를 관리특징사용 시기  접근을 제어하거가 기능을 추가하고 싶은데, 기존의 특정 객체를 수정할 수 없는 상황일때  초기화 지연, 접근 제어, 로깅, 캐싱 등, 기존 객체 동작에 수정 없이 가미하고 싶을 때장점  개방 폐쇄 원칙(OCP) 준수          기존 대상 객체의 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.        단일 책임 원칙(SRP) 준수          대상 객체는 자신의 기능에만 집중 하고, 그 이외 부가 기능을 제공하는 역할을 프록시 객체에 위임하여 다중 책임을 회피 할 수 있다.        원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행하는데 유용하다  클라이언트는 객체를 신경쓰지 않고, 서비스 객체를 제어하거나 생명 주기를 관리할 수 있다.  사용자 입장에서는 프록시 객체나 실제 객체나 사용법은 유사하므로 사용성에 문제 되지 않는다.단점  많은 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가한다.          예를들어 여러 클래스에 로깅 기능을 가미 시키고 싶다면, 동일한 코드를 적용함에도 각각의 클래스에 해당되는 프록시 클래스를 만들어서 적용해야 되기 때문에 코드량이 많아지고 중복이 발생 된다.      자바에서는 리플렉션에서 제공하는 동적 프록시(Dynamic Proxy) 기법을 이용해서 해결할 수 있다. (후술)        프록시 클래스 자체에 들어가는 자원이 많다면 서비스로부터의 응답이 늦어질 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-10-Proxy.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-09-adaptor-html": {
        "title": "[deisgn Pattern Series] 09 Adaptor",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AdaptorAdaptor어댑터 패턴(Adaptor Pattern) 이란 이름 그대로 클래스를 어댑터로서 사용되는 구조 패턴이다.이를 객체 지향 프로그래밍에 접목해보면, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해주도록 변환 역할을 해주는 행동 패턴이라고 보면 된다. 예를들어 기존에 있는 시스템에 새로운 써드파티 라이브러리를 추가하고 싶거나, Legacy 인터페이스를 새로운 인터페이스로 교체하는 경우에 어댑터 패턴을 사용하면 코드의 재사용성을 높일 수 있다.즉, 어댑터란 이미 구축되어 있는 것을 새로운 어떤것에 사용할때 양 쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로서, 기존 시스템에서 새로운 기능을 사용하려고 할때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할수 있다고 보면 된다.구조Adapter 패턴에는 기존 시스템의 클래스를 상속(Inheritance) 해서 호환 작업을 해주냐, 합성(Composition)해서 호환 작업을 해주냐에 따라, 두 가지 패턴 방법으로 나뉘게 된다.객체 어댑터(Object Adaptor)  합성(Composition)된 맴버에게 위임을 이용한 어댑터 패턴 (추천 🌟)  자기가 해야 할 일을 클래스 맴버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다.  합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다.  Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Client Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Object Adaptor 방식에선 합성을 이용해 구성한다.      Adaptee(Service)를 따로 클래스 멤버로 설정하고 위임을 통해 동작을 매치시킨다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter implements Target {    Service adaptee; // composition으로 Service 객체를 클래스 필드로// 어댑터가 인스턴스화되면 호환시킬 기존 서비스를 설정Adapter(Service adaptee) {    this.adaptee = adaptee;}// 어댑터의 메소드가 호출되면, Adaptee의 메소드를 호출하도록public void method(int data) {    adaptee.specificMethod(data); // 위임} } ```클래스 어댑터(Class Adaptor)  클래스 상속을 이용한 어댑터 패턴  Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.  상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 전반적으로 권장하지는 않는 방법이다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Cient Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Class Adaptor 방식에선 상속을 이용해 구성한다.      Existing Class와 Adaptee(Service) 를 동시에 implements, extends 하여 구현한다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter extends Service implements Target {// 어댑터의 메소드가 호출되면, 부모 클래스 Adaptee의 메소드를 호출public void method(int data) {    specificMethod(data);} } ```특징사용 시기  레거시 코드를 사용하고 싶지만 새로운 인터페이스가 레거시 코드와 호환되지 않을 때  이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때  이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조할때  소프트웨어의 구 버전과 신 버전을 공존시키고 싶을때장점  프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있기 때문에 단일 책임 원칙(SRP)을 만족한다.  기존 클래스 코드를 건들지 않고 클라이언트 인터페이스를 통해 어댑터와 작동하기 때문에 개방 폐쇄 원칙(OCP)을 만족한다.  만일 추가로 필요한 메소드가 있다면 어댑터에 빠르게 만들 수 있다. 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 쉬워진다.단점  새로운 인터페이스와 어댑터 클래스 세트를 도입해야 하기 때문에 코드의 복잡성이 증가한다.  때로는 직접 서비스(Adaptee) 클래스를 변경하는것이 간단할수 있는 경우가 있기 때문에 신중히 선택하여야 한다.실제 사용 예시  java.util.Arrays 의 asList()  java.util.Collections 의 list()  java.util.Collections 의 enumeration()  java.io.InputStreamReader(InputStream) (returns a Reader)  java.io.OutputStreamWriter(OutputStream) (returns a Writer)  jakarta.xml.bind.annotation.adapters.XmlAdapter 의 marshal() and unmarshal()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-09-Adaptor.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-08-decorator-html": {
        "title": "[deisgn Pattern Series] 08 Decorator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DecoratorDecorator데코레이터 패턴(Decorator Pattern)은 대상 객체에 대한 기능 확장이나 변경이 필요할때 객체의 결합을 통해 서브클래싱 대신 쓸수 있는 유연한 대안 구조 패턴이다.Decorator을 해석하자면 ‘장식자’ 라는 의미를 가지고 있는데,  마치 기본 제품에 포장지나 외부 디자인을 살짝 변경해 줌으로써 새로운 기능을 부여하는 것과 같이,객체 지향 프로그래밍에서 원본 객체에 대해서 무언가를 장식하여 더 멋진 기능을 가지게 만드는 것이기 때문에 이 명칭이 붙었다고 보면 된다.데코레이터 패턴을 이용하면 필요한 추가 기능의 조합을 런타임에서 동적으로 생성할 수 있다. 데코레이터할 대상 객체를 새로운 행동들을 포함한 특수 장식자 객체에 넣어서 행동들을 해당 장식자 객체마다 연결시켜, 서브클래스로 구성할때 보다 훨씬 유연하게 기능을 확장 할 수 있다. 그리고 기능을 구현하는 클래스들을 분리함으로써 수정이 용이해진다  Component (Interface) : 원본 객체와 장식된 객체 모두를 묶는 역할  ConcreteComponent : 원본 객체 (데코레이팅 할 객체)  Decorator : 추상화된 장식자 클래스          원본 객체를 합성(composition)한 wrappee 필드와 인터페이스의 구현 메소드를 가지고 있다        ConcreteDecorator : 구체적인 장식자 클래스          부모 클래스가 감싸고 있는 하나의 Component를 호출하면서 호출 전/후로 부가적인 로직을 추가할 수 있다.      흐름// 원본 객체와 장식된 객체 모두를 묶는 인터페이스interface IComponent {    void operation();}// 장식될 원본 객체class ConcreteComponent implements IComponent {    public void operation() {    }}// 장식자 추상 클래스abstract class Decorator implements IComponent {    IComponent wrappee; // 원본 객체를 composition    Decorator(IComponent component) {        this.wrappee = component;    }    public void operation() {        wrappee.operation(); // 위임    }}// 장식자 클래스class ComponentDecorator1 extends Decorator {    ComponentDecorator1(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}class ComponentDecorator2 extends Decorator {    ComponentDecorator2(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}패턴사용 시기  객체 책임과 행동이 동적으로 상황에 따라 다양한 기능이 빈번하게 추가/삭제되는 경우  객체의 결합을 통해 기능이 생성될 수 있는 경우  객체를 사용하는 코드를 손상시키지 않고 런타임에 객체에 추가 동작을 할당할 수 있어야 하는 경우  상속을 통해 서브클래싱으로 객체의 동작을 확장하는 것이 어색하거나 불가능 할 때장점  데코레이터를 사용하면 서브클래스를 만들때보다 훨씬 더 유연하게 기능을 확장할 수 있다.  객체를 여러 데코레이터로 래핑하여 여러 동작을 결합할 수 있다.  컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.  각 장식자 클래스마다 고유의 책임을 가져 단일 책임 원칙(SRP)을 준수  클라이언트 코드 수정없이 기능 확장이 필요하면 장식자 클래스를 추가하면 되니 개방 폐쇄 원칙(OCP)을 준수  구현체가 아닌 인터페이스를 바라봄으로써 의존 역전 원칙(DIP) 준수단점  만일 장식자 일부를 제거하고 싶다면, Wrapper 스택에서 특정 wrapper를 제거하는 것은 어렵다.  데코레이터를 조합하는 초기 생성코드가 보기 안좋을 수 있다. new A(new B(new C(new D())))  어느 장식자를 먼저 데코레이팅 하느냐에 따라 데코레이터 스택 순서가 결정지게 되는데, 만일 순서에 의존하지 않는 방식으로 데코레이터를 구현하기는 어렵다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-08-Decorator.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-07-observer-html": {
        "title": "[deisgn Pattern Series] 07 Observer",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ObserverObserver옵저버 패턴(Observer Pattern)은 옵저버(관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 패턴이다.옵저버 패턴은 여타 다른 디자인 패턴들과 다르게 일대다(one-to-many) 의존성을 가지는데, 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. Pub/Sub(발행/구독) 모델로도 알려져 있다.  ISubject : 관찰 대상자를 정의하는 인터페이스  ConcreteSubject : 관찰 당하는 대상자 / 발행자 / 게시자          Observer들을 리스트(List, Map, Set ..등)로 모아 합성(compositoin)하여 가지고 있음      Subject의 역할은 관찰자인 Observer들을 내부 리스트에 등록/삭제 하는 인프라를 갖고 있다. (register, remove)      Subject가 상태를 변경하거나 어떤 동작을 실행할때, Observer 들에게 이벤트 알림(notify)을 발행한다.        IObserver : 구독자들을 묶는 인터페이스 (다형성)  Observer : 관찰자 / 구독자 / 알림 수신자.          Observer들은 Subject가 발행한 알림에 대해 현재 상태를 취득한다.      Subject의 업데이트에 대해 전후 정보를 처리한다.      흐름// 관찰 대상자 / 발행자interface ISubject {    void registerObserver(IObserver o);    void removeObserver(IObserver o);    void notifyObserver();}class ConcreteSubject implements ISubject {    // 관찰자들을 등록하여 담는 리스트    List&lt;IObserver&gt; observers = new ArrayList&lt;&gt;();    // 관찰자를 리스트에 등록    @Override    public void registerObserver(IObserver o) {        observers.add(o);        System.out.println(o + \" 구독 완료\");    }    // 관찰자를 리스트에 제거    @Override    public void removeObserver(IObserver o) {        observers.remove(o);        System.out.println(o + \" 구독 취소\");    }    // 관찰자에게 이벤트 송신    @Override    public void notifyObserver() {        for(IObserver o : observers) { // 관찰자 리스트를 순회하며            o.update(); // 위임        }    }}// 관찰자 / 구독자interface IObserver {  void update();}class ObserverA implements IObserver {  public void update() {    System.out.println(\"ObserverA 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverA\"; }}class ObserverB implements IObserver {  public void update() {    System.out.println(\"ObserverB 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverB\"; }}특징사용 시기  앱이 한정된 시간, 특정한 케이스에만 다른 객체를 관찰해야 하는 경우  대상 객체의 상태가 변경될 때마다 다른 객체의 동작을 트리거해야 할때  한 객체의 상태가 변경되면 다른 객체도 변경해야 할때. 그런데 어떤 객체들이 변경되어야 하는지 몰라도 될 때  MVC 패턴에서도 사용됨 (Model, View, Controller)          MVC의 Model과 View의 관계는 Observer 패턴의 Subject 역할과 Observer 역할의 관계에 대응된다.      하나의 Model에 복수의 View가 대응한다.      장점  Subject의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지할 수 있다.  발행자의 코드를 변경하지 않고도 새 구독자 클래스를 도입할 수 있어 개방 폐쇄 원칙(OCP)Visit Website 준수한다  런타임 시점에서에 발행자와 구독 알림 관계를 맺을 수 있다.  상태를 변경하는 객체(Subject)와 변경을 감지하는 객체(Observer)의 관계를 느슨하게 유지할 수 있다. (느슨한 결합)단점  구독자는 알림 순서를 제어할수 없고, 무작위 순서로 알림을 받음          하드 코딩으로 구현할수는 있겠지만, 복잡성과 결합성만 높아지기 때문에 추천되지는 않는 방법이다.        옵저버 패턴을 자주 구성하면 구조와 동작을 알아보기 힘들어져 코드 복잡도가 증가한다.  다수의 옵저버 객체를 등록 이후 해지하지 않는다면 메모리 누수가 발생할 수도 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-07-Observer.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-06-iterator-html": {
        "title": "[deisgn Pattern Series] 06 Iterator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - IteratorIterator반복자(Iterator) 패턴은 일련의 데이터 집합에 대하여 순차적인 접근(순회)을 지원하는 패턴이다.데이터 집합이란 객체들을 그룹으로 묶어 자료의 구조를 취하는 컬렉션을 말한다. 대표적인 컬렉션으로 한번쯤은 들어본 리스트나 트리, 그래프, 테이블 등이 있다.  Aggregate (인터페이스) : ConcreateIterator 객체를 반환하는 인터페이스를 제공한다.          iterator() : ConcreateIterator 객체를 만드는 팩토리 메서드        ConcreateAggregate (클래스) : 여러 요소들이 이루어져 있는 데이터 집합체  Iterator (인터페이스) : 집합체 내의 요소들을 순서대로 검색하기 위한 인터페이스를 제공한다.          hasNext() : 순회할 다음 요소가 있는지 확인 (true / false)      next() : 요소를 반환하고 다음 요소를 반환할 준비를 하기 위해 커서를 이동시킴        ConcreateIterator (클래스) : 반복자 객체          ConcreateAggregate가 구현한 메서드로부터 생성되며, ConcreateAggregate 의 컬렉션을 참조하여 순회한다.      어떤 전략으로 순회할지에 대한 로직을 구체화 한다      흐름// 집합체 객체 (컬렉션)interface Aggregate {    Iterator iterator();}class ConcreteAggregate implements Aggregate {    Object[] arr; // 데이터 집합 (컬렉션)    int index = 0;    public ConcreteAggregate(int size) {        this.arr = new Object[size];    }    public void add(Object o) {        if(index &lt; arr.length) {            arr[index] = o;            index++;        }    }    // 내부 컬렉션을 인자로 넣어 이터레이터 구현체를 클라이언트에 반환    @Override    public Iterator iterator() {        return new ConcreteIterator(arr);    }}// 반복체 객체interface Iterator {    boolean hasNext();    Object next();}class ConcreteIterator implements Iterator {    Object[] arr;    private int nextIndex = 0; // 커서 (for문의 i 변수 역할)    // 생성자로 순회할 컬렉션을 받아 필드에 참조 시킴    public ConcreteIterator(Object[] arr) {        this.arr = arr;    }    // 순회할 다음 요소가 있는지 true / false    @Override    public boolean hasNext() {        return nextIndex &lt; arr.length;    }    // 다음 요소를 반환하고 커서를 증가시켜 다음 요소를 바라보도록 한다.    @Override    public Object next() {        return arr[nextIndex++];    }}특징사용 시기  컬렉션에 상관없이 객체 접근 순회 방식을 통일하고자 할 때  컬렉션을 순회하는 다양한 방법을 지원하고 싶을 때  컬렉션의 복잡한 내부 구조를 클라이언트로 부터 숨기고 싶은 경우 (편의 + 보안)  데이터 저장 컬렉션 종류가 변경 가능성이 있을 때          클라이언트가 집합 객체 내부 표현 방식을 알고 있다면, 표현 방식이 달라지면 클라이언트 코드도 변경되어야 하는 문제가 생긴다.      장점  일관된 이터레이터 인터페이스를 사용해 여러 형태의 컬렉션에 대해 동일한 순회 방법을 제공한다.  컬렉션의 내부 구조 및 순회 방식을 알지 않아도 된다.  집합체의 구현과 접근하는 처리 부분을 반복자 객체로 분리해 결합도를 줄 일 수 있다.          Client에서 iterator로 접근하기 때문에 ConcreteAggregate 내에 수정 사항이 생겨도 iterator에 문제가 없다면 문제가 발생하지 않는다.        순회 알고리즘을 별도의 반복자 객체에 추출하여 각 클래스의 책임을 분리하여 단일 책임 원칙(SRP)를 준수한다.  데이터 저장 컬렉션 종류가 변경되어도 클라이언트 구현 코드는 손상되지 않아 수정에는 닫혀 있어 개방 폐쇄 원칙(OCP)를 준수한다단점  클래스가 늘어나고 복잡도가 증가한다.          만일 앱이 간단한 컬렉션에서만 작동하는 경우 패턴을 적용하는 것은 복잡도만 증가할 수 있다.      이터레이터 객체를 만드는 것이 유용한 상황인지 판단할 필요가 있다.        구현 방법에 따라 캡슐화를 위배할 수 있다.실제 예제  java.util.Enumeration 과 java.util.Iterator  Java StAX (Streaming API for XML)의 Iterator 기반 API          XmlEventReader, XmlEventWriter      ",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-06-Iterator.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-05-facade-html": {
        "title": "[deisgn Pattern Series] 05 Facade",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FacadeFacade퍼사드 패턴(Facade Pattern)은 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스(API)를 구성하기 위한 구조 패턴이다.이처럼 파사드는 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 제공하려는 목적이라고 생각하면 된다.  Facade라는 단어의 뜻은 건축물의 정면을 의미한다.건축물의 정면은 보통 건축물의 이미지와 건축 의도를 나타내기 때문에 오래 전부터 특별한 디자인을 적용하여 의미를 부여했다.이처럼 건축물 정면만 봐도 이 건물이 어떤 목적을 하는지 단번에 알수 있다는 특징을 차용하여 명명 지은 것이다.  Facade : 서브시스템 기능을 편리하게 사용할 수 있도록 하기 위해 여러 시스템과 상호 작용하는 복잡한 로직을 재정리해서 높은 레벨의 인터페이스를 구성한다. Facade 역할은 서브 시스템의 많은 역할에 대해 ‘단순한 창구’가 된다. 클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않도록 한다.  Additional Facade : 퍼사드 클래스는 반드시 한개만 존재해야 한다는 규칙같은 건 없다. 연관 되지 않은 기능이 있다면 얼마든지 퍼사드 2세로 분리한다. 이 퍼사드 2세는 다른 퍼사드에서 사용할 수도 있고 클라이언트에서 직접 접근할 수도 있다.  SubSystem(하위 시스템) : 수십 가지 라이브러리 혹은 클래스들  Client : 서브 시스템에 직접 접근하는 대신 Facade를 사용한다.퍼사드 패턴은 전략 패턴이나 팩토리 패턴과 같은 여타 다른 디자인 패턴과는 다르게 클래스 구조가 정형화 되지 않은 패턴이다.반드시 클래스 위치는 어떻고 어떤 형식으로 위임을 해야되고 이런것이 없다. 그냥 퍼사드 클래스를 만들어 적절히 기능 집약해주는 논리라고 생각하면 된다.재귀적 Facade 패턴의 적용재귀적 퍼사드란 Additional Facade 를 말하는 것이다. 예를 들어 다수의 클래스, 다수의 패키지를 포함하고 있는 큰 시스템에 요소 마다 Facade 패턴을 여기 저기 적용하고 다시 그 Facade를 합친 Facade를 만드는 식으로,퍼사드를 재귀적으로 구성하면 시스템은 보다 편리하게 된다. 이처럼 퍼사드는 한 개만 있으라는 법은 없으며 필요에 의하면 얼마든지 늘려서 의존할 수 있다.특징사용 시기  시스템이 너무 복잡할때  그래서 간단한 인터페이스를 통해 복잡한 시스템을 접근하도록 하고 싶을때  시스템을 사용하고 있는 외부와 결합도가 너무 높을 때 의존성 낮추기 위할때장점  하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템을 사용하기 쉬워진다.  하위 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있다.  복잡한 코드를 감춤으로써, 클라이언트가 시스템의 코드를 모르더라도 Facade 클래스만 이해하고 사용 가능하다  외부에서 내부 로직을 직접 사용하기 때문에 내부 로직의 구조를 변경한다고 하거나 파라미터나 리턴값 등을 변경할 경우 직접적으로 영향을 받아 수정이 힘들거나불가능한 경우가 종종 있다. 하지만 중간에 매개체 역할을 해주는 퍼사드 객체가 있기 때문에 실제 내부 로직이 어떻게 변경이 되더라도 상관이 없어지므로 의존성이 감소된다.단점  퍼사드가 앱의 모든 클래스에 결합된 최상위 객체가 될 수 있다  퍼사드 클래스 자체가 서브시스템에 대한 의존성을 가지게 되어 의존성을 완전히는 피할 수는 없다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-05-Facade.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-04-builder-html": {
        "title": "[deisgn Pattern Series] 04 Builder",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BuilderBuilder빌더 패턴(Builder Pattern)은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성하는 방식이다.1. 점층적 생성자 패턴우리가 다양한 매개변수를 입력받아 인스턴스를 생성하고 싶을때 사용하던 생성자를 오버로딩 하는 방식이다.문제는 타입이 다양할수록 생성자 메서드 수가 기하급수적으로 늘어나 가독성이나 유지보수 측면에서 좋지 않다.2. 자바 빈(Java Beans) 패턴이러한 단점을 보완하기 위해 Setter 메소드를 사용한 자바 빈(Bean) 패턴이 고안 되었다.매개변수가 없는 생성자로 객체 생성후 Setter 메소드를 이용해 클래스 필드의 초깃값을 설정하는 방식이다기존 생성자 오버로딩에서 나타났던 가독성 문제점이 사라지고 선택적인 파라미터에 대해 해당되는 Setter 메서드를 호출함으로써 유연적으로 객체 생성이 가능해졌다.하지만 이러한 방식은 객체 생성 시점에 모든 값들을 주입 하지 않아 일관성(consistency) 문제와 불변성(immutable) 문제가 나타나게 된다.1) 일관성 문제필수 매개변수란 객체가 초기화될때 반드시 설정되어야 하는 값이다. 하지만 개발자가 깜빡하고 set~() 메서드를 호출하지 않았다면 이 객체는 일관성이 무너진 상태가 된다. 즉, 객체가 유효하지 않은 것이다. 만일 다른곳에서 햄버거 인스턴스를 사용하게 된다면 런타임 예외가 발생할 수도 있다.이는 객체를 생성하는 부분과 값을 설정하는 부분이 물리적으로 떨어져 있어서 발생하는 문제점이다.물론 이는 어느정도 생성자(Constructor)와 결합하여 극복은 할 수 있다.하지만 다음에 소개할 불변성의 문제 때문에 자바 빈즈 패턴은 지양해야 한다.2) 불변성 문제자바 빈즈 패턴의 Setter 메서드는 객체를 처음 생성할때 필드값을 설정하기 위해 존재하는 메서드이다.하지만 객체를 생성했음에도 여전히 외부적으로 Setter 메소드를 노출하고 있으므로, 협업 과정에서 언제 어디서 누군가 Setter 메서드를 호출해 함부로 객체를 조작할수 있게 된다. 이것을 불변함을 보장할 수 없다고 얘기한다.Builder 패턴빌더 패턴은 이러한 문제들을 해결하기 위해 별도의 Builder 클래스를 만들어 메소드를 통해 step-by-step 으로 값을 입력받은 후에 최종적으로 build() 메소드로 하나의 인스턴스를 생성하여 리턴하는 패턴이다.빌더 패턴 사용법을 잠시 살펴보면, StudentBuilder 빌더 클래스의 메서드를 체이닝(Chaining) 형태로 호출함으로써 자연스럽게 인스턴스를 구성하고 마지막에 build() 메서드를 통해 최종적으로 객체를 생성하도록 되어있음을 볼 수 있다.패턴 구조class Student {    private int id;    private String name = \"아무개\";    private String grade = \"freshman\";    private String phoneNumber = \"010-0000-0000\";    public Student(int id, String name, String grade, String phoneNumber) {        this.id = id;        this.name = name;        this.grade = grade;        this.phoneNumber = phoneNumber;    }        @Override    public String toString() {        return \"Student { \" +                \"id='\" + id + '\\'' +                \", name=\" + name +                \", grade=\" + grade +                \", phoneNumber=\" + phoneNumber +                \" }\";    }    public static class StudentBuilder {        private int id;        private String name;        private String grade;        private String phoneNumber;        public StudentBuilder id(int id) {            this.id = id;            return this;        }        public StudentBuilder name(String name) {            this.name = name;            return this;        }        public StudentBuilder grade(String grade) {            this.grade = grade;            return this;        }        public StudentBuilder phoneNumber(String phoneNumber) {            this.phoneNumber = phoneNumber;            return this;        }             public Student build() {            return new Student(id, name, grade, phoneNumber); // Student 생성자 호출        }    }}빌더 네이밍  멤버이름()  set멤버이름()  with멤버이름()장점  객체 생성 과정을 일관된 프로세스로 표현  디폴트 매개변수 생략을 간접적으로 지원  필수 멤버와 선택적 멤버를 분리 가능  객체 생성 단계를 지연할 수 있다.  초기화 검증을 멤버별로 분리할 수 있다.  멤버에 대한 변경 가능성 최소화를 추구한다.단점  코드 복잡성 증가  생성자보다 성능이 떨어짐Simple Builderclass Person {    // final 키워드로 필드들을 불변 객체로 만든다.    private final String name;    private final String age;    private final String gender;    private final String job;    private final String birthday;    private final String address;    // 정적 내부 빌더 클래스    public static class Builder {        // 필수 파라미터        private final String name;        private final String age;        // 선택 파라미터        private String gender;        private String job;        private String birthday;        private String address;        // 필수 파라미터는 빌더 생성자로 받게 한다        public Builder(String name, String age) {            this.name = name;            this.age = age;        }        // 선택 파라미터는 각 메서드를 통해 정의한다        public Builder gender(String gender) {            this.gender = gender;            return this;        }        public Builder job(String job) {            this.job = job;            return this;        }        public Builder birthday(String birthday) {            this.birthday = birthday;            return this;        }        public Builder address(String address) {            this.address = address;            return this;        }        // 대상 객체의 private 생성자를 호출하여 최종 인스턴스화 한다        public Person build() {            return new Person(this); // 빌더 객체 자신을 넘긴다.        }    }    // private 생성자 - 생성자는 외부에서 호출되는것이 아닌 빌더 클래스에서만 호출되기 때문에    private Person(Builder builder) {        this.name = builder.name;        this.age = builder.age;        this.gender = builder.gender;        this.job = builder.gender;        this.birthday = builder.birthday;        this.address = builder.address;    }    @Override    public String toString() {        return \"Person{\" +                \"name='\" + name + '\\'' +                \", age='\" + age + '\\'' +                \", gender='\" + gender + '\\'' +                \", job='\" + job + '\\'' +                \", birthday='\" + birthday + '\\'' +                \", address='\" + address + '\\'' +                '}';    }}Director BuilderGOF에서 정의하고 있는 디자인 패턴은 복잡한 객체의 생성 알고리즘과 조립 방법을 분리하여 빌드 공정을 구축하는것이 목적이다. 빌더를 받아 조립 방법을 정의한 클래스를 Director라고 부른다.class Data {    private String name;    private int age;    public Data(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}abstract class Builder {    // 상속한 자식 클래스에서 사용하도록 protected 접근제어자 지정    protected Data data;    public Builder(Data data) {        this.data = data;    }    // Data 객체의 데이터들을 원하는 형태의 문자열 포맷을 해주는 메서드들 (머리 - 중간 - 끝 형식)    public abstract String head();    public abstract String body();    public abstract String foot();}// Data 데이터들을 평범한 문자열로 변환해주는 빌더class PlainTextBuilder extends Builder {    public PlainTextBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"Name: \");        sb.append(data.getName());        sb.append(\", Age: \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\";    }}// Data 데이터들을 JSON 형태의 문자열로 변환해주는 빌더class JSONBuilder extends Builder {    public JSONBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"{\\n\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t\\\"Name\\\" : \");        sb.append(\"\\\"\" + data.getName() + \"\\\",\\n\");        sb.append(\"\\t\\\"Age\\\" : \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\\n}\";    }}// Data 데이터들을 XML 형태의 문자열로 변환해주는 빌더class XMLBuilder extends Builder {    public XMLBuilder(Data data) {        super(data);    }    @Override    public String head() {        StringBuilder sb = new StringBuilder();        sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?&gt;\\n\");        sb.append(\"&lt;DATA&gt;\\n\");        return sb.toString();    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t&lt;NAME&gt;\");        sb.append(data.getName());        sb.append(\"&lt;NAME&gt;\");        sb.append(\"\\n\\t&lt;AGE&gt;\");        sb.append(data.getAge());        sb.append(\"&lt;AGE&gt;\");        return sb.toString();    }    @Override    public String foot() {        return \"\\n&lt;/DATA&gt;\";    }}// 각 문자열 포맷 빌드 과정을 템플릿화 시킨 디렉터class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    // 일종의 빌드 템플릿 메서드라 보면 된다    public String build() {        StringBuilder sb = new StringBuilder();        // 빌더 구현체에서 정의한 생성 알고리즘이 실행됨        sb.append(builder.head());        sb.append(builder.body());        sb.append(builder.foot());        return sb.toString();    }}Lombok의 @Builder/ @SuperBuilder클래스에 @Builder 어노테이션만 붙여주면 클래스를 컴파일 할 때 자동으로 클래스 내부에 빌더 API가 만들어진다. 롬복의 @Builder는 GOF의 디렉터 빌더가 아닌 심플 빌더 패턴을 다룬다실무 예제  java.lang.StringBuilder의 append()  java.lang.StringBuffer의 append()  java.nio.ByteBuffer의 put() - CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer 도 마찬가지  javax.swing.GroupLayout.Group의 addComponent()  java.lang.Appendable의 구현체  java.util.stream.Stream.Builder",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-04-Builder.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-03-flyweight-html": {
        "title": "[deisgn Pattern Series] 03 Flyweight",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FlyWeightFlyWeight플라이웨이트 패턴(Flyweight Pattern)은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴이다.간단히 말하면 캐시(Cache) 개념을 코드로 패턴화 한것으로 보면 되는데, 자주 변화는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식이다. 그래서 동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 최적화를 노리는 경량 패턴이라고도 불린다.  Flyweight : 경량 객체를 묶는 인터페이스.  ConcreteFlyweight : 공유 가능하여 재사용되는 객체 (intrinsic state)  UnsahredConcreteFlyweight : 공유 불가능한 객체 (extrinsic state)  FlyweightFactory : 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스          GetFlyweight() 메서드는 팩토리 메서드 역할을 한다고 보면 된다.      만일 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다        Client : 클라이언트는 FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다.intrinsic 와 extrinsic 상태플라이웨이트 패턴에서 가장 주의 깊게 보아야 할 점이 바로 Intrinsic와 Extrinsic의 상태를 구분하는 것이다.intrinsic란 ‘고유한, 본질적인’ 이라는 의미를 가진다. 본질적인 상태란 인스턴스가 어떠한 상황에서도 변하지 않는 정보를 말한다. 그래서 값이 고정되어 있기에 충분히 언제 어디서 공유해도 문제가 없게 된다.extrinsic이란 ‘외적인, 비본질적인’ 이라는 의미를 가진다. 인스턴스를 두는 장소나 상황에 따라서 변화하는 정보를 말한다. 그래서 값이 언제 어디서 변화할지 모르기 때문에 이를 캐시해서 공유할수 는 없다.  intrinsic한 객체 : 장소나 상황에 의존하지 않기 때문에 값이 고정되어 공유할 수 있는 객체  extrinsic한 객체 : 장소나 상황에 의존하기 때문에 매번 값이 바뀌어 공유할 수 없는 객체flyWeight 패턴 특징사용 시기  어플리케이션에 의해 생성되는 객체의 수가 많아 저장 비용이 높아질 때  생성된 객체가 오래도록 메모리에 상주하며 사용되는 횟수가 많을때  공통적인 인스턴스를 많이 생성하는 로직이 포함된 경우  임베디드와 같이 메모리를 최소한으로 사용해야하는 경우에 활용장점  애플리케이션에서 사용하는 메모리를 줄일 수 있다.  프로그램 속도를 개선 할수 있다.          new로 인스턴스화를 하면 데이터가 생성되고 메모리에 적재 되는 미량의 시간이 걸리게 된다.      객체를 공유하면 인스턴스를 가져오기만 하면 되기 때문에 메모리 뿐만 아니라 속도도 향상시킬 수 있게 되는 것이다.        단점              코드 복잡도 증가예시class Memory {    public static long size = 0; // 메모리 사용량    public static void print() {        System.out.println(\"총 메모리 사용량 : \" + Memory.size + \"MB\");    }}// ConcreteFlyweight(intrinsic) - 플라이웨이트 객체는 불변성을 가져야한다. 변경되면 모든 것에 영향을 주기 때문이다.final class TreeModel {    // 메시, 텍스쳐 총 사이즈    long objSize = 90; // 90MB    String type; // 나무 종류    Object mesh; // 메쉬    Object texture; // 나무 껍질 + 잎사귀 텍스쳐    public TreeModel(String type, Object mesh, Object texture) {        this.type = type;        this.mesh = mesh;        this.texture = texture;        // 나무 객체를 생성하여 메모리에 적재했으니 메모리 사용 크기 증가        Memory.size += this.objSize;    }}// UnsahredConcreteFlyweight(extrinsic)class Tree {    // 죄표값과 나무 모델 참조 객체 크기를 합친 사이즈    long objSize = 10; // 10MB    // 위치 변수    double position_x;    double position_y;    // 나무 모델    TreeModel model;    public Tree(TreeModel model, double position_x, double position_y) {        this.model = model;        this.position_x = position_x;        this.position_y = position_y;        // 나무 객체를 생성하였으니 메모리 사용 크기 증가        Memory.size +=  this.objSize;    }}// Clientclass Terrain {    // 지형 타일 크기    static final int CANVAS_SIZE = 10000;    // 나무를 렌더릴    public void render(String type, Object mesh, Object texture, double position_x, double position_y) {        // 나무를 지형에 생성//        Tree tree = new Tree(//                type, // 나무 종류//                mesh, // mesh//                texture, // texture//                Math.random() * CANVAS_SIZE, // position_x//                Math.random() * CANVAS_SIZE // position_y//        );        // 1. 캐시 되어 있는 나무 모델 객체 가져오기        TreeModel model = TreeModelFactory.getInstance(type);        // 2. 재사용한 나무 모델 객체와 변화하는 속성인 좌표값으로 나무 생성        Tree tree = new Tree(model, position_x, position_y);        출처: https://inpa.tistory.com/entry/GOF-💠-Flyweight-패턴-제대로-배워보자 [Inpa Dev 👨‍💻:티스토리]        System.out.println(\"x:\" + tree.position_x + \" y:\" + tree.position_y + \" 위치에 \" + type + \" 나무 생성 완료\");    }}public static void main(String[] args) {        // 지형 생성        Terrain terrain = new Terrain();        // 지형에 Oak 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Oak\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Acacia 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Acacia\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Jungle 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Jungle\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 총 메모리 사용률 출력        Memory.print();    }/** * 1. intrinsic 객체와 extrinsic 객체 쪼개기 * -&gt; 같은 객체를 여러 번 올릴 필요가 없기 때문에 공유되는 객체는 따로 빼둔다. *  * 2. Flyweight 팩토리 만들기 * -&gt; Flyweight Pool : HashMap 컬렉션을 통해 키와 나무 모델 객체를 저장하는 캐시 저장소 역할 * -&gt; getInstance : Pool에서 가져오고자 하는 객체가 있는지 검사하고 있으면 가져오고 없으면 생성 */// FlyweightFactoryclass TreeModelFactory {    // Flyweight Pool - TreeModel 객체들을 Map으로 등록하여 캐싱    private static final Map&lt;String, TreeModel&gt; cache = new HashMap&lt;&gt;(); // static final 이라 Thread-Safe 함    // static factory method    public static TreeModel getInstance(String key) {        // 만약 캐시 되어 있다면        if(cache.containsKey(key)) {            return cache.get(key); // 그대로 가져와 반환        } else {            // 캐시 되어있지 않으면 나무 모델 객체를 새로 생성하고 반환            TreeModel model = new TreeModel(                    key,                    new Object(),                    new Object()            );            System.out.println(\"-- 나무 모델 객체 새로 생성 완료 --\");            // 캐시에 적재            cache.put(key, model);            return model;        }    }}/** * 3. Client 최적화  * -&gt; TreeModel에서 공유되고 있는 나무 모델을 가져온다. * -&gt; 가져온 나무 모델과 좌표값으로 나무 객체를 생성 */Garbage Collection 처리 주의사항‘인스턴스를 관리’ 하는 기능을 자바 프로그래밍에서 구현하여 사용할 때에는 반드시 ‘관리되고 있는 인스턴스는 GC(Garbage Collection) 처리되지 않는다’ 라는 점을 주의해야 한다.즉, 나무를 모두 렌더링을 완료하여 더이상 나무를 생성할 일이 없다라면, 반드시 TreeModelFactory에 잔존해있는 Flyweight Pool 을 비워줄 필요가 있는 것이다. 그래야 인스턴스에 대한 참조를 잃은 TreeModel 인스턴스들이 GC에 의해 메모리 청소가 되게 된다. 그렇지 않으면 더이상 나무를 생성할 일이 없는데도 TreeModel 데이터가 메모리에 쓸데없이 잔존하게 된다.실제 예시String Constant Pool  String Constant Pool 개념이 바로 Flyweight Pool 개념이다.  자바는 String 데이터에 대해 별도로 string constant pool 영역에 적재한다.  같은 문자열 데이터 다시 사용될때 pool을 검사해 있다면 이를 공유한다.  만일 pool에 없다면 새로 메모리를 할당하여 pool에 등록한 후 재사용한다.  String 클래스는 Flyweight 패턴을 통해 리터럴 문자열 데이터에 대한 캐싱을 하고 있는 것이다.  String 클래스는 불변(immutable) 객체 특성을 가지고 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-03-FlyWeight.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-02-composite-html": {
        "title": "[deisgn Pattern Series] 02 Composite",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CompositeComposite합체 패턴(Composite Pattern)은 복합 객체(Composite) 와 단일 객체(Leaf)를 동일한 컴포넌트로 취급하여, 클라이언트에게 이 둘을 구분하지 않고 동일한 인터페이스를 사용하도록 하는 구조 패턴이다.복합체 패턴은 전체-부분의 관계를 갖는 객체들 사이의 관계를 트리 계층 구조로 정의해야 할때 유용하다.윈도우나 리눅스의 파일 시스템 구조를 떠올려보면 쉽게 이해할 수 있다.폴더(디렉토리) 안에는 파일이 들어 있을수도 있고 파일을 담은 또 다른 폴더도 들어있을 수 있다.이를 복합적으로 담을수 있다 해서 Composite 객체라고 불리운다. 반면 파일은 단일 객체 이기 때문에 이를 Leaf 객체라고 불리운다. 즉 Leaf는 자식이 없다.복합체 패턴은 바로 이 폴더와 파일을 동일한 타입으로 취급하여 구현을 단순화 시키는 것이 목적이다.폴더 안에는 파일 뿐만 아니라 서브 폴더가 올수 있고 또 서브 폴더안에 서브 폴더가 오고.. 이런식으로 계층 구조를 구현하다 보면, 자칫 복잡해 질 수 도 있는 복합 객체를 재귀 동작을 통해 하위 객체들에게 작업을 위임한다. 그러면 복합 객체와 단일 객체를 대상으로 똑같은 작업을 적용할 수 있어 단일 / 복합 객체를 구분할 필요가 거의 없어진다.패턴  Component : Leaf와 Compsite 를 묶는 공통적인 상위 인터페이스  Composite : 복합 객체로서, Leaf 역할이나 Composite 역할을 넣어 관리하는 역할을 한다.          Component 구현체들을 내부 리스트로 관리한다      add 와 remove 메소드는 내부 리스트에 단일 / 복합 객체를 저장      Component 인터페이스의 구현 메서드인 operation은 복합 객체에서 호출되면 재귀 하여, 추가 단일 객체를 저장한 하위 복합 객체를 순회하게 된다.        Leaf: 단일 객체로서, 단순하게 내용물을 표시하는 역할을 한다.  Component 인터페이스의 구현 메서드인 operation은 단일 객체에서 호출되면 적절한 값만 반환한다  Client : 클라이언트는 Component를 참조하여 단일 / 복합 객체를 하나의 객체로서 다룬다.패턴 흐름// Component 인터페이스interface ItemComponent {    int getPrice();    String getName();}// Composite 객체class Bag implements ItemComponent {    // 아이템들과 서브 가방 모두를 저장하기 위해 인터페이스 타입 리스트로 관리    List&lt;ItemComponent&gt; components = new ArrayList&lt;&gt;();    String name; // 가방 이름    public Bag(String name) {        this.name = name;    }    // 리스트에 아이템 &amp; 가방 추가    public void add(ItemComponent item) {        components.add(item);    }    // 현재 가방의 내용물을 반환    public List&lt;ItemComponent&gt; getComponents() {        return components;    }    @Override    public int getPrice() {        int sum = 0;        for (ItemComponent component : components) {            // 만일 리스트에서 가져온 요소가 Item이면 정수값을 받을 것이고, Bag이면 '재귀 함수' 동작이 되게 된다 ☆            sum += component.getPrice(); // 자기 자신 호출(재귀)        }        return sum; // 그렇게 재귀적으로 돌아 하위 아이템들의 값을 더하고 반환하게 된다.    }    @Override    public String getName() {        return name;    }}// Leaf 객체class Item implements ItemComponent {    String name; // 아이템 이름    int price; // 아이템 가격    public Item(String name, int price) {        this.name = name;        this.price = price;    }    @Override    public int getPrice() {        return price;    }    @Override    public String getName() {        return name;    }}class Client {    public static void main(String[] args) {        // 1. 메인 가방 인스턴스 생성        Bag bag_main = new Bag(\"메인 가방\");        // 2. 아이템 인스턴스 생성        Item armor = new Item(\"갑옷\", 250);        Item sword = new Item(\"장검\", 500);        // 3. 메인 가방에는 모험에 필요한 무구 아이템만을 추가        bag_main.add(armor);        bag_main.add(sword);        // 4. 서브 가방 인스턴스 생성        Bag bag_food = new Bag(\"음식 가방\");        // 5. 아이템 인스턴스 생성        Item apple = new Item(\"사과\", 400);        Item banana = new Item(\"바나나\", 130);        // 6. 서브 가방에는 음식 아이템만을 추가        bag_food.add(apple);        bag_food.add(banana);        // 7. 서브 가방을 메인 가방에 넣음        bag_main.add(bag_food);        // ----------------------------------------------------- //        Client client = new Client();        // 가방 안에 있는 모든 아이템의 총 값어치를 출력 (가방안에 아이템 뿐만 아니라 서브 가방도 들어있음)        client.printPrice(bag_main);        // 서브 가방 안에 있는 모든 아이템의 총 값어치를 출력        client.printPrice(bag_food);    }    public void printPrice(ItemComponent bag) {        int result = bag.getPrice();        System.out.println(bag.getName() + \"의 아이템 총합 : \" + result + \" 골드\");    }}패턴 특징사용 시기  데이터를 다룰때 계층적 트리 표현을 다루어야 할때  복잡하고 난해한 단일 / 복합 객체 관계를 간편히 단순화하여 균일하게 처리하고 싶을때장점  단일체와 복합체를 동일하게 여기기 때문에 묶어서 연산하거나 관리할 때 편리하다.  다형성 재귀를 통해 복잡한 트리 구조를 보다 편리하게 구성 할 수 있다.  수평적, 수직적 모든 방향으로 객체를 확장할 수 있다.  새로운 Leaf 클래스를 추가하더라도 클라이언트는 추상화된 인터페이스 만을 바라보기 때문에 개방 폐쇄 원칙(OCP)Visit Website을 준수 한다. (단일 부분의 확장이 용이)단점  재귀 호출 특징 상 트리의 깊이(depth)가 깊어질 수록 디버깅에 어려움이 생긴다.  설계가 지나치게 범용성을 갖기 때문에 새로운 요소를 추가할 때 복합 객체에서 구성 요소에 제약을 갖기 힘들다.  계층형 구조에서 leaf 객체와 composite 객체들을 모두 동일한 인터페이스로 다루어야하는데, 이 공통 인터페이스 설계가 까다로울 수 있다.          복합 객체가 가지는 부분 객체의 종류를 제한할 필요가 있을 때      수평적 방향으로만 확장이 가능하도록 Leaf를 제한하는 Composite를 만들때      ",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-02-Composite.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-01-chainofresponsibility-html": {
        "title": "[deisgn Pattern Series] 01 Chainofresponsibility",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Chain Of ResponsibilityChain Of Responsibility책임 연쇄 패턴(Chain Of Responsibility Pattern, COR)은 클라이어트의 요청에 대한 세세한 처리를 하나의 객체가 몽땅 하는 것이 아닌,여러개의 처리 객체들로 나누고, 이들을 사슬(chain) 처럼 연결해 집합 안에서 연쇄적으로 처리하는 행동 패턴이다.이러한 처리 객체들을 핸들러(handler)라고 부르는데, 요청을 받으면 각 핸들러는 요청을 처리할 수 있는지, 없으면 체인의 다음 핸들러로 처리에 대한 책임을 전가한다.한마디로 책임 연쇄라는 말은 요청에 대한 책임을 다른 객체에 떠넘긴다는 소리이다. 떠넘긴다고 하니까 부정적인 의미로 들릴수도 있겠지만, 이러한 체인 구성은 하나의 객체에 처리에 대한 책임을 요청을 보내는 쪽(sender)과 요청을 처리하는(receiver) 쪽을 분리하여 각 객체를 부품으로 독립시키고 결합도를 느슨하게 만들며,상황에 따라서 요청을 처리할 객체가 변하는 프로그램에도 유연하게 대응할 수 있다는 장점을 가지고 있다. 특히나 중첩 if-else 들을 최적화하는데 있어 실무에서도 많이 애용되는 패턴중 하나이기도 하다.특징패턴 사용 시기  특정 요청을 2개 이상의 여러 객체에서 판별하고 처리해야 할때  특정 순서로 여러 핸들러를 실행해야 하는 경우  프로그램이 다양한 방식과 종류의 요청을 처리할 것으로 예상되지만 정확한 요청 유형과 순서를 미리 알 수 없는 경우  요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때 (체인 연결을 런타임에서 동적으로 설정)패턴 장점  클라이언트는 처리 객체의 체인 집합 내부의 구조를 알 필요가 없다.  각각의 체인은 자신이 해야하는 일만 하기 때문에 새로운 요청에 대한 처리객체 생성이 편리해진다.  클라이언트 코드를 변경하지 않고 핸들러를 체인에 동적으로 추가하거나 처리 순서를 변경하거나 삭제할 수 있어 유연해진다  요청의 호출자(invoker)와 수신자(receiver)  분리시킬 수 있다.          요청을 하는 쪽과 요청을 처리하는 쪽을 디커플링 시켜 결합도를 낮춘다      요청을 처리하는 방법이 바뀌더라도 호출자 코드는 변경되지 않는다.      패턴 단점  실행 시에 코드의 흐름이 많아져서 과정을 살펴보거나 디버깅 및 테스트가 쉽지 않다.  충분한 디버깅을 거치지 않았을 경우 집합 내부에서 무한 사이클이 발생할 수 있다.  요청이 반드시 수행된다는 보장이 없다. (체인 끝까지 갔는데도 처리되지 않을 수 있다)  책임 연쇄로 인한 처리 지연 문제가 발생할 수 있다. 다만 이는 트레이드 오프로서 요청과 처리에 대한 관계가 고정적이고 속도가 중요하면 책임 연쇄 패턴 사용을 유의하여야 한다.ex)// 구체적인 핸들러를 묶는 인터페이스 (추상 클래스)abstract class Handler {    // 다음 체인으로 연결될 핸들러    protected Handler nextHandler = null;    // 생성자를 통해 연결시킬 핸들러를 등록    public Handler setNext(Handler handler) {        this.nextHandler = handler;        return handler; // 메서드 체이닝 구성을 위해 인자를 그대로 반환함    }    // 자식 핸들러에서 구체화 하는 추상 메서드    protected abstract void process(String url);    // 핸들러가 요청에 대해 처리하는 메서드     public void run(String url) {        process(url);        // 만일 핸들러가 연결된게 있다면 다음 핸들러로 책임을 떠넘긴다        if (nextHandler != null)            nextHandler.run(url);    }}class ProtocolHandler extends Handler {    @Override    protected void process(String url) {        int index = url.indexOf(\"://\");        if (index != -1) {            System.out.println(\"PROTOCOL : \" + url.substring(0, index));        } else {            System.out.println(\"NO PROTOCOL\");        }    }}class DomianHandler extends Handler {    @Override    protected void process(String url) {        int startIndex = url.indexOf(\"://\");        int lastIndex = url.lastIndexOf(\":\");        System.out.print(\"DOMAIN : \");        if (startIndex == -1) {            if (lastIndex == -1) {                System.out.println(url);            } else {                System.out.println(url.substring(0, lastIndex));            }        } else if (startIndex != lastIndex) {            System.out.println(url.substring(startIndex + 3, lastIndex));        } else {            System.out.println(url.substring(startIndex + 3));        }    }}class PortHandler extends Handler {    @Override    protected void process(String url) {        int index = url.lastIndexOf(\":\");        if (index != -1) {            String strPort = url.substring(index + 1);            try {                int port = Integer.parseInt((strPort));                System.out.println(\"PORT : \" + port);            } catch (NumberFormatException e) {                e.printStackTrace();            }        }    }}class Client {    public static void main(String[] args) {        // 1. 핸들러 생성        Handler handler1 = new ProtocolHandler();        Handler handler2 = new DomianHandler();        Handler handler3 = new PortHandler();        // 2. 핸들러 연결 설정 (handler1 → handler2 → handler3)        handler1.setNext(handler2).setNext(handler3);        // 3. 요청에 대한 처리 연쇄 실행        String url1 = \"http://www.youtube.com:80\";        System.out.println(\"INPUT: \" + url1);        handler1.run(url1);        System.out.println();        String url2 = \"https://www.inpa.tistory.com:443\";        System.out.println(\"INPUT: \" + url2);        handler1.run(url2);        System.out.println();        String url3 = \"http://localhost:8080\";        System.out.println(\"INPUT: \" + url3);        handler1.run(url3);    }}실수에서 예시  java.util.logging.Logger의 log()  javax.servlet.Filter의 doFilter()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-01-ChainOfResponsibility.html"
      }
      ,
    
      "java-2024-05-18-java-series-29-virtualthread-html": {
        "title": "[java Series] 29 Virtualthread",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VirtualThreadVirtualThread! 간단 정리 버전 !기본 구성Project Loom에서 시작되었으며, Java19에는 Preview로 지원되었고 21에서 정식으로 추가됐다.기본 발상은 Java의 쓰레드는 Kernal Thread를 할당 받아서 사용했었는데 이는  할당까지 OS의 영향하에 있다.  할당까지 비용이 너무 많이 든다.  1 ~ 2MB가 최대flowchart TDsubgraph PlatformThread    subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        subgraph JVM        PlatformThread1        PlatformThread2    end        KernalThread1 --&gt; PlatformThread1    KernalThread2 --&gt; PlatformThread2end라는 문제가 근본적으로 있었다. 그래서 이를 극복하기 위해서 ThreadPool를 할당하여 쓰고 버리는 것이 아닌 반납 하는 시스템으로 자주 사용했다.VirtualThread는 기존 쓰레드(PlatformThread)와 달리 JVM 단에서 쓰레드를 만들어서 실행하는 방향으로 발상을 바꾸게 되어 생겼다. 이를 통해서  JVM의 영향력 아래 있다.  할당에 비용이 적게 들어서 쓰고 버리는 형태로 패러다임이 변경됐다.  ~ KB 단위 사이즈는 식의 변화가 생겼다. 이러면서 기존 쓰레드는 PlatformThread로 개명했다.flowchart TDsubgraph VirtualThread     subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        KernalThread1 --&gt; ForkJoinPool    KernalThread2 --&gt; ForkJoinPool        subgraph JVM        ForkJoinPool                ForkJoinPool --&gt; CarrierThread1        ForkJoinPool --&gt; CarrierThread2                CarrierThread1 --&gt; Queue1        CarrierThread2 --&gt; Queue2                Queue1 --&gt; VirtualThread1        Queue1 --&gt; VirtualThread2        Queue2 --&gt; VirtualThread3        Queue2 --&gt; VirtualThread4    endend  캐리어 쓰레드란?  Proeject Loom의 일부로 도입된 개념으로 VirtualThread를 실행하기 위한 운반체 역할을 한다. PlatformThread를 기반으로 합니다. CarrierThread는 ForkJoinPool 안에 workerThread로 생성이 되어 스케쥴링 된다.VirtualThreadVirtualThread Thread(Runnable을 구현한)를 상속 받았다. 따라서 상호 변용이 가능하다.package java.lang;sealed abstract class BaseVirtualThread extends Thread        permits VirtualThread, ThreadBuilders.BoundVirtualThread {    BaseVirtualThread(String name, int characteristics, boolean bound) {        super(name, characteristics, bound);    }    abstract void park();    abstract void parkNanos(long nanos);    abstract void unpark();}package java.lang;/** * A thread that is scheduled by the Java virtual machine rather than the operating * system. */final class VirtualThread extends BaseVirtualThread {//... 중략private static final long CARRIER_THREAD = U.objectFieldOffset(VirtualThread.class, \"carrierThread\");    // carrier thread when mounted, accessed by VM    private volatile Thread carrierThread;}주의점  쓰고 버리는게 오히려 이득이다.  커넥션 풀을 사용하는 경우(MySQL 같이)나 IO 최대 개수 제한이 있는 경우(OS 파일) 문제가 될 수 있으니 Bound를 두고 사용하는게 맞을 수 있다.",
        "url": "//java/2024/05/18/java-series-29-VirtualThread.html"
      }
      ,
    
      "java-2024-05-18-java-series-28-reactive-html": {
        "title": "[java Series] 28 Reactive",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReactiveReactive데이터 흐름과 전달에 대한 프로그래밍 패러다임이다.기존 명령형 패러다임은 콜을 받아서 당겨오는(Pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(Push) 방식이다.즉, 주변 환경과 상호작용을 하는 것을 주도하는게 아니라 일정 값이 변하면 이벤트를 받아서 동작한다. 일종의 옵저버(Observer) 패턴이다.  대략적으로 보면?      기본 골자는 Stream API와 비슷하다.    Stream API와 같이 끝 맺는 메소드 (subscribe)가 있어야 한다.    퍼블리셔가 이벤트를 발행하면 stream을 타고 subscrbie 소비가 되는 패턴이다.  Flow APIJava 9에는  java.util.concurrent.Flow를 추가했다.리액티브 표준에 따라 발행(Pub)/ 구독(Sub)을 할 수 있도록 되어 있다.  Publisher : 데이터를 발행하는 주체이다.    @FunctionalInterfacepublic static interface Publisher&lt;T&gt; {  public void subscribe(Subscriber&lt;? super T&gt; subscriber);}        Subscriber : 데이터를 소비하는 주체이다.    public static interface Subscriber&lt;T&gt; {  public void onSubscribe(Subscription subscription);  public void onNext(T item);  public void onError(Throwable throwable);  public void onComplete();}        Subscription : 구독 그 자체다. Publisher - Subscriber를 연결한다.    public static interface Subscription {  public void request(long n);  public void cancel();}        Processor : 리액티스 스트림에서 처리하는 단계이다.    public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}      ",
        "url": "//java/2024/05/18/java-series-28-Reactive.html"
      }
      ,
    
      "java-2024-05-18-java-series-27-little-html": {
        "title": "[java Series] 27 Little",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자잘한 기록물charType -&gt; integer numberclass Example {    public static void main(String[] args) {         char charNine = '9';         int nine = charNine - '0';         // -&gt; nine;    }}String -&gt; splice?class Example {    public static void main(String[] args) {         String exam = \"adcd\";         StringBuilder builder = new StringBuilder(exam);         builder.deleteCharAt(1); //like Splice    }}",
        "url": "//java/2024/05/18/java-series-27-Little.html"
      }
      ,
    
      "java-2024-05-18-java-series-26-set-html": {
        "title": "[java Series] 26 Set",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SetintersectList의 retainAll은 교집합 구현에 완벽히 사용 불가import java.util.ArrayList;class RetainTest {    @Test    public void case1() {        String first = \"aaabb\";        String second = \"aabbb\";        List&lt;String&gt; firstList = new ArrayList(); // [aa, aa, ab, bb]        List&lt;String&gt; secondList = new ArrayList(); //[aa, ab, bb, bb]        char[] firstChar = first.toCharArray();        for( int i = 1; i &lt; firstChar.length; i ++ )  firstList.add(firstChar[i - 1]+\"\"+firstChar[i]);        char[] secondChar = second.toCharArray();        for( int i = 1; i &lt; secondChar.length; i ++ )  secondList.add(secondChar[i - 1]+\"\"+secondChar[i]);                                firstList.retainAll(secondList);        System.out.println(firstChar); //[aa, aa, ab, bb]                //firstList에 영향이 없다 치고        secondList.remove(firstList);        System.out.println(secondList); //[aa, ab, bb, bb]        /**         * - 결론         * 알던 것과 결과가 굉장히 다르다.          */    }}",
        "url": "//java/2024/05/18/java-series-26-Set.html"
      }
      ,
    
      "java-2024-05-18-java-series-24-junit-html": {
        "title": "[java Series] 24 Junit",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JUnitJunitAnnotation            Annotation      Description                                @Test      메소드가 테스트 메소드임을 나타낸다.                            @ParameterizedTest      매개변수가 있는 테스트임을 나타낸다.                            @ValueSource      반복 테스트에서 지정한 배열을 파라미터 값으로 순서대로 넘겨준다. (하나의 인수일 경우)                            @NullSource      Null로 값을 전달할 떄  사용한다.                            @EmptySource      빈 값을 인수로 전달할 때 사용한다.                            @NullAndEmptySource      Null, Empty 모두 전달할 때 사용      @CsvSource      테스트 입력값을 Csv로 구성하여 던질 떄 사용한다.              @EnumSource      열거형의 배열을 테스트 메소드에 전달                            @MethodSource      Arguments로 파라미터를 여러 개 전달할 떄 사용한다. (Arguments.of(value, value….))                            @RepeatedTest      메소드가 반복 테스트 메소드임을 나타낸다.                            @DisplayName      테스트 클래스 또는 메소드에 대한 사용자 지정 표시 이름                            @DisplayNameGeneration      테스트 클래스 이름 생성기를 선언한다. *                            @BeforeEach      @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 전에 실행되는 것을 나타낸다. 테스트 마다 실행 전에 실행된다.  매 테스트마다 초기화해야 하는 경우 사용된다.                            @AfterEach      @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 후에 실행되는 것을 나타낸다.  테스트 마다 실행 후에 실행된다.      매 테스트 후 정리해야 하는 경우 사용된다.                            @BeforeAll      @BeforeEach 와 유사하지만 static 메소드여야만 하며  테스트 전에 한 번만 실행된다.                            @AfterAll      @AfterEach 와 유사하지만 static 메소드여야만 하며  테스트 후에 한 번만 실행된다.                            @Nested      주석이 달린 클래스가 중첩 테스트 클래스임을 나타낸다.                            @Tag      클래스, 메소드 수준 테스트 필터링을 위해서 사용한다.                            @Disabled      테스트 클래스, 메소드를 비활성화할 때 사용한다.                            @Timeout      테스트 타임아웃을 지정한다.                            @ExtendWith      확장을 선언적으로 등록할 때 사용한다.                            @RegisterExtension      필드를 통해 프로그래밍 방식으로 확장을 등록할 떄 사용한다.                            @TempDir      테스트 메소드에서 필드 주입 또는 매개변수 주입을 통해 임시 디렉토리를 제공                            @TestFactory      동적 테스트를 위한 테스트 팩토리임을 나타낸다.                            @TestTemplate                                   @TestClassOrder      @Nested 간 실행 순서를 구성하는 데 사용한다.                            @TestMethodOrder      테스트 메소드간 순서를 구성하는 데 사용한다.                                               @                            @TestInstance      주석이 달린 테스트 클래스의 인스턴스 수명 주기를 구성하는데 사용한다.                            @Sql      sql 파일을 지정하여 Dao 단위 테스트에 미리 구성된 쿼리를 실행한다.                    class Junit {    @TestFactory    Stream&lt;DynamicTest&gt; testFactory () {        List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        return numbers.stream()                      .forEach( num -&gt; dynamicTest(                              num,                              () -&gt; assertThat(number &lt; 10).isTrue()                      ));    }    @ParameterizedTest    @ValueSource(ints = {1,2,3,4,5,6,7,8,9,10})    public isUnderThen(int number){        assertThat(number &lt; 10).isTrue();    }}Spring Test AnnotationsController Test| Annotation                                                                                                                                                    |                                      Description                                      ||:————————————————————————————————————————————————————–|:————————————————————————————-:|| @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, properties = “spring.profiles.active=[profile]”)                  | SpringBootTest임을 알린다. 이 어노테이션이 붙으면 SpringContext를 실행하고 Component 스캔 등을 한다. (스프링을 켠다.) || @AutoConfigureMockMvc                                                                                                                                         |                                    서블릿 컨테이너를 모킹한다.                                    || @TestPropertySource                                                                                                                                           |     테스트 환경의 Property를 지정할 수 있다. (classpath:로 resource 내부에서 찾는건 덤 -&gt; build에서 찾는다.)     || @ActiveProfiles                                                                                                                                               |                               Active로 둘 Profile를 지정한다.                                |            Object      Description                  @AutowiredMockMvc      테스트용 MVC환경을 만들어 요청, 전송, 응답을 제공하는 클래스              @LocalServerPortint port      현재 mocking 혹은 지정된 포트를 반환한다. (RandomPort의 경우)      //ex)@Test@DisplayName(value = \"ContextLoadTest\")void contextLoads() throws Exception {        System.out.println(\"ContextLoaded\");        //given        String expect = \"junitTest\";        //when        mockMvc.perform(        get(\"/v1/user/test\")        .contentType(MediaType.APPLICATION_JSON)        .accept(MediaType.APPLICATION_JSON)        )        //that        .andExpect(MockMvcResultMatchers.status().isOk())        .andExpect(jsonPath(\"$\",expect).exists());        }ServiceTest| Annotation  |                 Description                  ||:————|:——————————————–:|| @ExtendWith |        단위 테스트에 공통적으로 사용할 확장 기능을 선언한다.        || @Mock       |       Mock 객체를 생성 메소드는 있지만 내부 구현이 없다.        || @Spy        | 모든 기능을 가지고 있다. 다만 Stub을 하면 해당 부분만 Mocking된다. || @InjectMock |  @Mock, @Spy로 생산한 객체를 주입한다.(생성자 주입으로 추정된다.)  |RepositoryTest| Annotation                                                                                                                                          |                         Descpription                         ||:—————————————————————————————————————————————————-|:————————————————————:|| @DataJpaTest(  showSql = true,  properties = {“classpath:application.yml”},  includeFilters = {}) | SpringContext 중 Repository에 관련된 요소들만 테스트하기 위해서 사용하는 어노테이션이다. || @AutoConfigureTestDatabase(connection=””, replace=””)                                                                                               |    TestDB를 구성할 때 유용한 어노테이션이다. 테스트 시 DB를 테스트 DB로 대체할 수 있다.    |",
        "url": "//java/2024/05/18/java-series-24-Junit.html"
      }
      ,
    
      "java-2024-05-18-java-series-23-shellcommand-html": {
        "title": "[java Series] 23  shellcommand",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - shellCommand당시 OOM이 나서 여러 옵션을 건들였었는데 이에 대해서 찾아보고 이를 기록한 문서입니다.#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jstat -gcutil -h 20 $pid 2000 10000#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jhsdb jmap --binaryheap --dumpfile /home/chat/dump.hprof --pid $pid#!/bin/bash#projectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jcmd $pid GC.class_histogram &gt; histogram.logif [ -z $pid ] then        echo \"No server is running.\" else        kill -9 \"$pid\"        echo \"Shut down the running server.\"fi/home/jdk-11/bin/java \\-XX:+UseParallelOldGC \\-Xms1024m \\-Xmx4096m \\-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=/home/chat/dump/heapdump.hprof \\-verbose:gc \\-jar \\-Dspring.profiles.active=prod \\$projectPath/$projectName-*.war \\&gt; $projectPath/out.log  \\2&gt; $projectPath/exception.log &amp;echo \"The server was successfully run.\"",
        "url": "//java/2024/05/18/java-series-23-ShellCommand.html"
      }
      ,
    
      "java-2024-05-18-java-series-22-floatingpoint-html": {
        "title": "[java Series] 22 Floatingpoint",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Floating point issue부동 소수점 관련 문제class FloatingPoint {    @Test    public void fpFailure() {        Assertions.assertEquals(1.2 , 1.1 + 0.1);        //결과는? false        //부동소수점 문제 때문에 그렇다. (특히 이 주변은 다 괜찮은데 얘만 그렇다.)        /**         * Expected :1.2         * Actual   :1.2000000000000002         */        //위와 같은 결과로 나온다.    }        @Test    public void fpSuccess() {        Assertions.assertEquals(BigDecimal.valueOf(1.2), BigDecimal.valueOf(1.1).add(BigDecimal.valueOf(0.1)));        //이러면 성공한다.    }}Java _ BigDecimal 관련 사용 시 유의점연산  ’+’ : BigDecimal.valueOf(x).add(BigDecimal.valueOf(y));  ’-‘ : BigDecimal.valueOf(x).substract(BigDecimal.valueOf(y));  ‘*’ : BigDecimal.valueOf(x).multiply(BigDecimal.valueOf(y));  ’/’ : BigDecimal.valueOf(x).divide(BigDecimal.valueOf(y));  ’%’ : BigDecimal.valueOf(x).remainder(BigDecimal.valueOf(y));  절대값 : BigDecimal.valueOf(x).abs();소수점RoundingMode  UP(BigDecimal.ROUND_UP), : 양수일 때 올림, 음수일 때 내림  DOWN(BigDecimal.ROUND_DOWN), : ROUND_UP과 반대  CEILING(BigDecimal.ROUND_CEILING), : 올림  FLOOR(BigDecimal.ROUND_FLOOR), : 내림  HALF_UP(BigDecimal.ROUND_HALF_UP), : 반올림 (5이상 올림 5미만 버림)  HALF_DOWN(BigDecimal.ROUND_HALF_DOWN), : 반올림 ( 6이상 올림, 6미만 버림)  HALF_EVEN(BigDecimal.ROUND_HALF_EVEN), : 반올림 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP  UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);: 딱 떨어지는 값이 아니면 ArithmeticException사용법BigDecimal(\"0.9999\").setScale(0, RoundingMode.CEILING);MathContext  UNLIMITED = new MathContext(0, RoundingMode.HALF_UP); : unlimit (무제한 정밀 산술)  DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal32 format, 7 digits ( 7자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal64 format, 16 digits  ( 16자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);: matching the precision of the IEEE 754-2019 decimal128 format, 34 digits ( 32자리 정밀도 및 HALF_EVENT의 반올림 모드)MethodsBigIntegerclass IntroduceBigInteger {    public void bit () {        BigInteger i = new BigInteger(\"1018\"); // 2진수로 표현하면 : 1111111010(2)        int bitCount = i.bitCount(); // 1의 갯수 : 8        int bitLength = i.bitLength(); // 비트 수 : 10        int getLowestSetBit = i.getLowestSetBit(); // 1        boolean testBit3 = i.testBit(3); // true        BigInteger setBit12 = i.setBit(12); // 우측에서 13번째 비트를 1로 변경 → 1001111111010(2) → 5114        BigInteger flipBit0 = i.flipBit(0); // 1111111011(2) → 1019        BigInteger clearBit3 = i.clearBit(3); // 1111110010(2) → 1010        }           public void bitOperate () {        BigInteger i = new BigInteger(\"17\"); // 2진수 : 10001(2)        BigInteger j = new BigInteger(\"7\"); // 2진수 : 111(2)        BigInteger and = i.and(j); // 10001(2) &amp; 111(2) = 00001(2) → 1(10)        BigInteger or = i.or(j); // 23        BigInteger not = j.not(); // -8        BigInteger xor = i.xor(j); // 22        BigInteger andNot = i.andNot(j); // 16        BigInteger shiftLeft = i.shiftLeft(1); // 34        BigInteger shiftRight = i.shiftRight(1); // 8    }}JsonSerializerBigDecimal to JsonValueclass BigDecimalScale6WithBankersRoundingSerializer  implements JsonSerializer&lt;BigDecimal&gt; {    public static Integer SCALE_SIX = 6;    public static RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;        @Override    public Object serialize( BigDecimal value, JsonGenerator gen,   SerializerProvider serializers ) {        return gen.writeString(value.setScale(SCALE_SIX, BANKERS_ROUNDING_MODE).toString());    }}",
        "url": "//java/2024/05/18/java-series-22-FloatingPoint.html"
      }
      ,
    
      "java-2024-05-18-java-series-21-yaml-html": {
        "title": "[java Series] 21 Yaml",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - YAMLYAML(Yet Another Markup Language)기존에 주로 사용되던 포맷인 JSON의 불편함을 해소하기 위해 만들어진 superset이다. (확장자만 바꿔도 JSON -&gt; YAML로 변환된다. )데이터 정의  Key:Value 표기  콤마 표기하지 않음  indent로 계층 구조를 표현  따옴표 (굳이 쓰지 않아도 된다.)  작은 따옴표, 큰 따옴표 -&gt; 이스케이필 문자를 구분해야하면, 큰 따옴표는 escapeSequence, 작은 따옴표는 그대로 문자열로 처리한다.배열 &amp; 리스트  -으로 하위 엘리먼트 표현  객체 배열이 필요하다면 객체 시작에만 -를 사용한다.    students:  - name: Mark major: Math age: 20  - name: Julie major: Arts age: 23  - name: Tommy major: Music age: 25        Boolean : yes/no, true/false를 boolean으로 구문한다. case insensitive다.  변수 선언 : &amp;으로 변수 선언하고 *으로 참조한다.default: &amp;default_school # default_school 라는 변수를 선언하고, 그 내용은 group 과 description 데이터를 지니고 있다   group: '서울대학교'   description: |      서울에 위치하는 대한민국 대학교!student:   - name: '홍길동'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다   - name: '임꺽정'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다",
        "url": "//java/2024/05/18/java-series-21-YAML.html"
      }
      ,
    
      "java-2024-05-18-java-series-20-stringandtokenizer-html": {
        "title": "[java Series] 20 Stringandtokenizer",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Split vs StringTokenizerSplit vs. StringTokenizer1. Split정규식을 받는 메소드와, 정규식 + 인덱스를 받는 메소드 두 개가 오버로딩되어 있다.class String {    public String[] split(String regex);// 반환을 String 배열로 받는다.// 구분 기호를 문자열이 아닌 정규표현식으로 받는다. (중요)    public String[] split(String regex, int limit);// 문자열을 정규식에 맞춰서 분리하는데 limit만큼 문자열을 자른다.}2. StringTokenizer구분자를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는데 사용한다.// 문자열을 공백 문자를 구분자로 자르기new StringTokenizer(String str)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// 이때 구분자는 토큰으로 간주되지 않음new StringTokenizer(String st, String delim)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// returnDelims 의 값을 true로하면 구분자도 토큰으로 간주new StringTokenizer(String str, String delim, boolean returnDelims)결론적으로 split vs. StringTokenizer  split 메소드는 String클래스에 속해있는 메소드이고, StringTokenizer는 java.util에 포함되어 있는 클래스이다.  구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.  split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.  split는 빈문자열을 토큰으로 인식하는 반면, StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다.  성능은 split 보다 StringTokenizer 가 좋다.  split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.  그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.",
        "url": "//java/2024/05/18/java-series-20-StringAndTokenizer.html"
      }
      ,
    
      "java-2024-05-18-java-series-19-clone-html": {
        "title": "[java Series] 19 Clone",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CloneCloneObject.clone()인스턴스 객체 복제를 위한 메소드, 해당 인스턴스를 복제해서 새로운 인스턴스를 생성해서 그 참조 값을 반환한다. clone() 사용을 위해서 Cloneable을 구현해야한다.Deep vs. ShallowDeep은 값 타입이든, 참조 타입이든 복사하여 원본과 구분되는 결과물을 생성해 내는 것을 의미하며, 얕은 복사는 값이든 참조든 복사하여 원본과 같은 결과물을 만들어내는 것을 의미한다.Deep의 주의사항만일 필드에 참조형이 있다면 아무리 대상을 깊은 복사했어도 필드는 참조를 복사한다. 따라서 필드의 클래스도 따로 처리를 해야한다.",
        "url": "//java/2024/05/18/java-series-19-Clone.html"
      }
      ,
    
      "java-2024-05-18-java-series-18-variableargument-html": {
        "title": "[java Series] 18 Variableargument",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 가변인자Variable Argument가변 인수 사용법메서드 파라미터 부분에 타입… 매개변수명 으로 처리하면 사용이 가능하다.가변 인수는 전달 인자를 0개부터 n개까지 넣을수 있다. 그리고 파라미터로 넘겨지는 값들을 모아서 컴파일시 배열로 처리된다. 주의할점은 인자들의 갯수에는 제한이 없지만, 배열 자료형은 매개변수 타입으로 명시된 것에 따라간다는 점이다.만일 매개변수가 가변 인자 외에 다른 매개 변수들도 받는다면, 반드시 가변 인자를 메서드 파라미터 가장 마지막에 위치하도록 정의해야 한다.그리고 매개변수가 넘겨지는 순서는, 인자들이 앞에 있는 파라미터 부터 차례대로 넘겨지고 남은 나머지 인자들이 가변 인자로 넘겨지게 된다.주의점  가변 인자 자체가 성능에 좋지않다. (배열 선언)  가변 인수 자체를 오버로딩하면 컴파일러가 어떤 메소드를 사용해야할지 구분하지 못한다.  배열 타입 매개변수와 혼용하지 않기    public void print( String ... str ) {}public void print( String[] str) {}        제네릭과 혼합하면 신중하게 -&gt; 제네릭은 배열로 실체화 불가하다.  ",
        "url": "//java/2024/05/18/java-series-18-VariableArgument.html"
      }
      ,
    
      "java-2024-05-18-java-series-17-generic-html": {
        "title": "[java Series] 17 Generic",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GenericGeneric클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 법을 의미한다.ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();제네릭 타입 매개변수위에서 보다시피, 제네릭은 &lt;&gt; 꺾쇠 괄호 키워드를 사용하는데 이를 다이아몬드 연산자라고 한다. 그리고 이 꺾쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할 수 있다. 이것을 마치 메소드가 매개변수를 받아 사용하는 것과 비슷하여 제네릭의 타입 매개변수(parameter) / 타입 변수 라고 부른다.타입 파라미터 정의이 타입 매개변수는 제네릭을 이용한 클래스나 메소드를 설계할 때 사용된다.예를들어 다음 코드는 제네릭을 감미한 클래스를 정의한 코드이다. 클래스명 옆에  기호로 제네릭을 붙여준 걸 볼 수 있다.그리고 클래스 내부에서 식별자 기호 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정되어 있다.class FruitBox&lt;T&gt; {    List&lt;T&gt; fruits = new ArrayList&lt;&gt;();    public void add(T fruit) {        fruits.add(fruit);    }}제네릭 클래스를 만들었으면 이를 인스턴스화 해보자. 마치 파라미터를 지정해서 보내는 것 처럼 생성 코드에서 꺾쇠 괄호 안에 지정해주고 싶은 타입명을 할당해주면,제네릭 클래스 선언문 부분으로 가서 타입 파라미터 T 가 지정된 타입으로 모두 변환되어 클래스의 타입이 지정되게 되는 것이다.타입 파라미터 생략제네릭 객체를 사용하는 문법 형태를 보면 양쪽 두 군데에 꺾쇠 괄호 제네릭 타입을 지정함을 볼 수 있다. 하지만 맨 앞에서 클래스명과 함께 타입을 지정해 주었는데 굳이 생성자까지 제네릭을 지정해 줄 필요가 없다.따라서 jdk 1.7 버전 이후부터,  new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다. 제네릭 나름대로 타입 추론을 해서 생략 된 곳을 넣어주기 때문에 문제가 없는 것이다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;Apple&gt;();// 다음과 같이 new 생성자 부분의 제네릭의 타입 매개변수는 생략할 수 있다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;&gt;();복수 타입 파라미터제네릭은 반드시 한개만 사용하라는 법은 없다. 만일 타입 지정이 여러개가 필요할 경우 2개, 3개 얼마든지 만들 수 있다.제네릭 타입의 구분은 꺽쇠 괄호 안에서 쉽표(,)로 하며 &lt;T, U&gt; 와 같은 형식을 통해 복수 타입 파라미터를 지정할 수 있다. 그리고 당연히 클래스 초기화할때 제네릭 타입을 두개를 넘겨주어야 한다.import java.util.ArrayList;import java.util.List;class Apple {}class Banana {}class FruitBox&lt;T, U&gt; {    List&lt;T&gt; apples = new ArrayList&lt;&gt;();    List&lt;U&gt; bananas = new ArrayList&lt;&gt;();    public void add(T apple, U banana) {        apples.add(apple);        bananas.add(banana);    }}public class Main {    public static void main(String[] args) {    \t// 복수 제네릭 타입        FruitBox&lt;Apple, Banana&gt; box = new FruitBox&lt;&gt;();        box.add(new Apple(), new Banana());        box.add(new Apple(), new Banana());    }}중첩 타입 파라미터제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.public static void main(String[] args) {    // LinkedList&lt;String&gt;을 원소로서 저장하는 ArrayList    ArrayList&lt;LinkedList&lt;String&gt;&gt; list = new ArrayList&lt;LinkedList&lt;String&gt;&gt;();    LinkedList&lt;String&gt; node1 = new LinkedList&lt;&gt;();    node1.add(\"aa\");    node1.add(\"bb\");    LinkedList&lt;String&gt; node2 = new LinkedList&lt;&gt;();    node2.add(\"11\");    node2.add(\"22\");    list.add(node1);    list.add(node2);    System.out.println(list);}타입 파라미터 기호 네이밍| 타입  |\t설명||:—:|:—–:||  |타입(Type)|||요소(Element), 예를 들어 List|||키(Key), 예를 들어 Map&lt;k, v&gt;|||리턴 값 또는 매핑된 값(Variable)|||숫자(Number)||&lt;S, U, V&gt;|2번째, 3번째, 4번째에 선언된 타입|제네릭 사용 이유, 장점  컴파일 타임에 타입 검사  불필요한 캐스팅을 없앨 수 있음주의 사항  제네릭 타입의 객체는 생성이 불가  static 멤버에 제네릭 타입이 올 수 없음 ( 제네릭 객체 생성 전에 자료 타입이 정해져 있어야 해서 )  제네릭으로 배열을 만들 수 없다.제네릭 범위 한정제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에서 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.예를들어 다음 계산기 클래스가 있다고 하자. 정수, 실수 구분없이 모두 받을 수 있게 하기위해 제네릭으로 클래스를 만들어주었다.하지만 단순히  로 지정하게 되면 숫자에 관련된 래퍼 클래스 뿐만 아니라 String이나 다른 클래스들도 대입이 가능하다는 점이 문제이다.// 숫자만 받아 계산하는 계산기 클래스 모듈class Calculator&lt;T&gt; {    void add(T a, T b) {}    void min(T a, T b) {}    void mul(T a, T b) {}    void div(T a, T b) {}}public class Main {    public static void main(String[] args) {        // 제네릭에 아무 타입이나 모두 할당이 가능        Calculator&lt;Number&gt; cal1 = new Calculator&lt;&gt;();        Calculator&lt;Object&gt; cal2 = new Calculator&lt;&gt;();        Calculator&lt;String&gt; cal3 = new Calculator&lt;&gt;();        Calculator&lt;Main&gt; cal4 = new Calculator&lt;&gt;();    }}개발자의 의도로는 계산기 클래스의 제네릭 타입 파라미터로 Number 자료형만 들어오도록 하고 문자열이나 또 다른 클래스 자료형이 들어오면 안되게 하고 싶다고 한다.그래서 나온 것이 제한된 타입 매개변수 (Bounded Type Parameter) 이다.타입 한정 키워드 extends&lt;T extends [ 제한 타입 ]&gt;인터페이스 타입 한정extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있다.interface Readable {}// 인터페이스를 구현하는 클래스public class Student implements Readable {} // 인터페이스를 Readable를 구현한 클래스만 제네릭 가능public class School &lt;T extends Readable&gt; {}다중 타입 한정만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한하고 싶다면,  &amp; 연산자를 이용하면 된다. 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 된다.단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.interface Readable {}interface Closeable {}class BoxType implements Readable, Closeable {}class Box&lt;T extends Readable &amp; Closeable&gt; {    List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T item) {        list.add(item);    }}재귀적 타입 한정재귀적 타입 한정이란 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 시키는 것을 말한다.실무에선 주로 Comparable 인터페이스와 함께 쓰인다.예를들어 다음과 같이 &lt;E extends Comparable&gt; 제네릭 E의 타입 범위를 Comparable 로 한정한다는 E를 중첩시킨 표현식을 사용할수 있는데, 이 말은 '타입 E는 자기 자신을 서브 타입으로 구현한 Comparable 구현체로 한정' 한다는 뜻이다.class Compare {\t// 외부로 들어온 타입 E는 Comparable&lt;E&gt;를 구현한 E 객체 이어야 한다.    public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; collection) {        if(collection.isEmpty()) throw new IllegalArgumentException(\"컬렉션이 비어 있습니다.\");        E result = null;        for(E e: collection) {            if(result == null) {                result = e;                continue;            }            if(e.compareTo(result) &gt; 0) {                result = e;            }        }        return result;    }}제네릭 형변환캐스팅배열과 같은 일반적인 변수 타입과 달리 지네릭 서브 타입간에는 형변환이 불가능하다. 심지어 대입된 타입이 Object라도 말이다. 자연스럽게 다형성이 적용될 것이라 생각하였지만, 실상 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능한 것이다.와일드 카드      &lt;?&gt; : Unbounded Wildcards (제한 없음)타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다        &lt;? extends 상위타입&gt; : Upper Bounded Wildcards (상위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있다        &lt;? super 하위타입&gt; : Lower Bounded Wildcards (하위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다  자바의 공변성/ 반공변성제네릭의 와일드카드를 배우기 앞서 선수 지식으로 알고 넘어가야할 개념이 있다.조금 난이도 있는 프로그래밍 부분을 학습 하다보면 한번쯤은 들어볼수 있는 공변성(Covariance) / 반공변성(Contravariance) 합쳐서 ‘변성(Variance)’ 이라하는 개념이다.변성은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타태는 지표이다. 그리고 공변성은 서로 다른 타입간에 함께 변할수 있다는 특징을 말한다.이를 객체 지향 개념으로 표현하자면 Liskov 치환 원칙[1]Visit Website에 해당된다.  공변 : S 가 T 의 하위 타입이면,          S[] 는 T[] 의 하위 타입이다.List&lt;S&gt; 는 List&lt;T&gt; 의 하위 타입이다.        반공변 : S 가 T의 하위 타입이면,  T[] 는 S[] 의 하위 타입이다. (공변의 반대)List&lt;T&gt; 는 List&lt;S&gt; 의 하위 타입이다. (공변의 반대)  무공변 / 불공변 : S 와 T 는 서로 관계가 없다.          List&lt;S&gt; 와 List&lt;T&gt; 는 서로 다른 타입이다      제네릭은 공변성이 없다객체 타입은 상하 관계가 있다 그러나 제네릭 타입은 상하관계가 없다. 즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이 불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.제네릭 와일드 카드자바 제네릭을 이용해 프로그래밍 할때 간혹 클래스 정의문을 보다보면 꺾쇠 괄호 ? 물음표 기호가 있는 것을 한번쯤 본 적이 있을 것이다. 이 물음표가 와일드카드이며, 물음표의 의미 답게 어떤 타입이든 될 수 있다는 뜻을 지니고 있다.            와일드카드      네이밍      설명                  &lt;?&gt;      Unbounded wildcards  비한정적 와일드 카드      제한 없음 (모든 타입이 가능)              &lt;? extends U&gt;      Upper Bounded Wildcards 상한 경계 와일드카드      상위 클래스 제한 (U와 그 자손들만 가능)상한이 U라 상한 경계라고 한다.              &lt;? super U&gt;      Lower Bounded Wildcards  하한 경계 와일드카드      하위 클래스 제한 (U와 그 조상들만 가능)  하한이 U라 하한 경계라고 한다.      제네릭의 공변, 반공변자바의 제네릭은 기본적으로 공변, 반공변을 지원하지 않지만, &lt;? extends T&gt; , &lt;? super T&gt; 와일드카드를 이용하면 컴파일러 트릭을 통해 공변, 반공변이 적용되도록 설정 할 수 있다. 둘을 정리하자면 다음과 같다.  상한 경계 와일드카드 &lt;? extends U&gt; : 공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U를 상속받은 하위 클래스 (U와 U의 자손 타입만 가능)상한의 뜻 : 타입의 최고 한도는 U 라는 의미. (최대 U 이하)        하한 경계 와일드카드 &lt;? super U&gt; : 반공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U가 상속한 상위 클래스 (U와 U의 조상 타입만 가능)하한의 뜻 : 타입의 최저 한도는 U 라는 의미. (최소 U 이상)        비경계          타입 매개변수의 범위는 제한이 없다. (모두 가능) &lt; ? extends Object &gt;의 줄임 표현      PECS (Producer-Extends / Consumer-Super)  외부에서 온 데이터를 생산(Producer) 한다면 &lt;? extends T&gt; 를 사용 (하위타입으로 제한)  외부에서 온 데이터를 소비(Consumer) 한다면 &lt;? super T&gt; 를 사용 (상위타입으로 제한). [1] : 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다.",
        "url": "//java/2024/05/18/java-series-17-Generic.html"
      }
      ,
    
      "java-2024-05-18-java-series-16-enum-html": {
        "title": "[java Series] 16 Enum",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnumerationEnumerationJAVA에서 enum은 interface와 같이 독립된 특수한 클래스로 구분된다. 즉, 일종의 객체이기 때문에 heap에 저장되며,각 enum 상수들은 별개의 메모리 주소 값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.장점  코드가 단순해지며 가독성이 좋아진다  허용 가능한 값들을 제한하여 유형 안전(type safe)을 제공한다.  키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 나타낼 수 있다.  자체 클래스 상수와 달리 switch문에서도 사용할 수 있다  단순 상수와 비교해 IDE의 적극적인 지원을 받을 수 있다 (자동완성, 오타검증, 텍스트 리팩토링 등등)  리팩토링시 변경 범위가 최소화 된다 (enum에서 한번에 관리하기 때문에 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다)  enum은 본질적으로 Thread safe인 싱글톤 객체 이므로 싱글톤 클래스를 생성하는데에도 사용된다메소드|메소드|\t설명\t|리턴 타입||:—–:|:——–:|:———–:||name()|열거 객체의 문자열을 리턴|String||ordinal()|열거 객체의 순번(0부터 시작)을 리턴|int||compareTo()|열거 객체를 비교해서 순번 차이를 리턴|int||valueOf(String name)|문자열을 입력받아서 일치하는 열거 객체를 리턴|enum||values()|모든 열거 객체들을 배열로 리턴|enum[]|java.lang.Enum모든 클래스가 Object 클래스를 자동 상속하는 것 처럼, Enum 클래스도 무조건 java.lang.Enum 이라는 클래스의 상속을 받는다. 그리고 java.lang.Enum 클래스에 정의되어 있는 메소드를 가져와 사용하는 것이다            메소드      내용                  clone()      객체를 복제하기 위한 메소드하지만, 이 메소드는 enum 클래스에서 사용하면 안된다.만약 호출될 경우엔 CloneNotSupportedException 이라는 예외를 발생시키도록 되어있다              finalize()      GC가 발생할 때 처리하기 위한 메소드              hashCode()      int 타입의 해시 코드 값을 리턴하는 메소드              equals()      두 개의 객체가 동일한지를 확인하는 메소드      Enum, Singleton자바에서의 enum 열거 타입은 일종의 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개하게 된다. 하지만 enum은 클래스처럼 이용할수는 있지만 인스턴스화는 할수는 없는데, 실제로 new 키워드로 인스턴스 생성을 하려고 하면 에러가 난다.이러한 제약적인 특징을 가지고 있는 이유는 enum 타입은 고정된 상수들의 집합으로써, 런타임(run-time)이 아닌 컴파일타임(compile-time)에 모든 값을 알고 있어야 하는 규칙이 있기 때문이다. 즉, 다른 패키지나 클래스에서 enum 타입에 접근해서 변수 처럼 동적으로 어떠한 값들을 할당해 주는 행위는 금지된 것이다.이 때문에 enum 객체의 생성자의 접근제어자를 private으로 설정해야 한다. 이렇게 되면 외부에서 접근 가능한 생성자가 없으므로 enum타입은 실제적으로 final 클래스와 다름이 없게 된다.이러한 특성 때문에, enum타입은 싱글톤을 구현하는 하나의 방법으로 사용되기도 한다.",
        "url": "//java/2024/05/18/java-series-16-Enum.html"
      }
      ,
    
      "java-2024-05-18-java-series-15-reflection-html": {
        "title": "[java Series] 15. Reflection",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReflectionReflectionjava.lang.Class자바 프로그래밍을 할때 우리는 보통 변수나 클래스를 직접 선언하고 만들어 사용하여 왔다. 그런데 어떤 경우에는 애플리케이션 실행 중에서 클래스를 동적으로 불러와 다루어야 할 경우가 생긴다. 즉, 코드를 실행하기전 컴파일 단에서 개발자가 직접 폴더를 뒤져가며 클래스 정의문을 찾아 클래스 정보를 얻는 것이 아닌, 코드 상에서 호출 로직을 통해 클래스 정보를 얻어와 다룸으로써 런타임 단에서 다이나믹하게 클래스를 핸들링 하는 것이다.이때 사용되는 것이 바로 Class 클래스 객체이다.Class 클래스는 java.lang.Class 패키지에 별도로 존재하는 독립형 클래스로서, 자신이 속한 클래스의 모든 멤버 정보를 담고 있기 때문에 런타임 환경에서 동적으로 저장된 클래스나 인터페이스 정보를 가져오는데 사용된다. 여기서 오해하지 말아야 할 것이 클래스 자료형을 말하는게 아니라 클래스 이름이 “Class” 인 클래스를 말하는 것이다.  JVM의 클래스 로더(class loader)는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.먼저 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환하고, 없으면 classpath에 지정된 경로를 따라서 클래스 파일을 찾아 해당 클래스 파일을 읽어서 Class 객체로 변환한다.만일 못 찾으면 우리가 익히아는 ClassNotFoundException 예외를 띄우게 된다.Class 객체 얻기Object.getClass()  모든 클래스의 최상위 클래스인 Object 클래스에서 제공하는 getClass() 메서드를 통해 가져온다.  해당 클래스가 인스턴스화 된 상태 이어야 한다는 제약이 있다.java Class&lt;? extends String&gt; cls = str.getClass();.class 리터럴로 얻기  인스턴스가 존재하지 않고, 컴파일된 클래스 파일만 있다면 리터럴로 Class 객체를 곧바로 얻을 수 있다.  가장 심플하게 Class 객체를 가져오는 방법이다.java  Class&lt;? extends String&gt; cls2 = String.class;Class.forName() 으로 얻기  위의 리터럴 방식과 같이 컴파일된 클래스 파일이 있다면 클래스 이름만으로 Class 객체를 반환 받을 수 있다.  클래스의 도메인을 상세히 적어주어야 한다. 그래서 클래스 파일 경로에 오타가 있으면 에러가 발생할 수 있기 때문에 주의해야한다. (대소문자 실수 등)  만일 Class 객체를 찾지 못한다면 ClassNotFoundException를 발생 시키기 때문에 예외처리가 강제된다.  그러나 다른 두가지 방법보다 forName을 통해 얻게 되면 메모리를 절약하며 동적 로딩 할 수 있기 때문에 가장 성능이 좋다.java Class&lt;?&gt; cls3 = Class.forName(\"java.lang.String\");  Class 클래스 객체를 forName() 메서드를 통해 가져오는 방법을 ‘동적 로딩’이라고 부른다. 보통 다른 클래스 파일을 불러올때는 컴파일 시 JVM의 Method Area에 클래스 파일이 같이 바인딩(binding)이 되지만, forName()으로 .class파일을 불러올 때는 컴파일에 바인딩이 되지않고 런타임때 불러오게 되기 때문에 동적 로딩이라고 부른다.그래서 컴파일 타입에 체크 할 수 없기 때문에 클래스 유무가 확인되지 않아 예외 처리를 해주어야 하는 이유이기도 하다.Class 메소드 종류  String getName(): 클래스의 이름을 리턴한다.  Package getPackage(): 클래스의 패키지 정보를 패키지 클래스 타입으로 리턴한다.  Field[] getFields(): public으로 선언된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.  Field getField(String name): public으로 선언된 변수를 Field 클래스 타입으로 리턴한다.  Field[] getDeclaredFields(): 해당 클래스에서 정의된 변수 목록을 field 클래스 배열 타입으로 리턴한다.  Field getDeclaredField(String name): name과 동일한 이름으로 정의된 변수를 Field 클래스 타입으로 리턴한다.  Method[] getMethods(): public으로 선언된 모든 메소드 목록을 Method 클래스 배열 타입으로 리턴한다. 해당 클래스에서 사용 가능한 상속받은 메소드도 포함된다.  Method getMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 메소드를 Method 클래스 타입으로 리턴한다.  Method[] getDeclaredMethods(): 해당 클래스에서 선언된 모든 메소드 정보를 리턴한다.  Method getDeclaredMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 해당 클래스에서 선언된 메소드를 Method 클래스 타입으로 리턴한다.  Constructor[] getConstructors(): 해당 클래스에 선언된 모든 public 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  Constructor[] getDeclaredConstructors(): 해당 클래스에서 선언된 모든 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  int getModifiers(): 해당 클래스의 접근자(modifier) 정보를 int 타입으로 리턴한다.  String toString(): 해당 클래스 객체를 문자열로 리턴한다.Reflection APIClass 객체를 이용하면 클래스에 대한 모든 정보(클래스의 정의된 멤버의 이름이나 개수 등)를 런타임 단에서 코드 로직으로 얻을 수 있다는 것을 알았다.클래스 정보들을 실행부에서 얻을 수 있는 점은 꽤나 매력적인데, 이러한 정보들을 이용하여 오로지 Class 객체만으로 본 클래스를 인스턴스화 할 수 있고,메서드를 호출 할 수 있는 ..등 보다 동적인 코드를 작성할 수 있게 된다. 이처럼 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메소드, 타입, 변수, …)에 접근할 수 있게 해주는 자바 기법을 Reflection API 라고 부른다.자바 리플렉션(Reflection - 사전적 의미 : 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그램 기법이다.클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍을 가능케 해준다.사용법동적으로 생성자 가져와서 초기화public static void main(String[] args) throws Exception {    // 클래스 객체 가져오기 (forName 메소드 방식)    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 생성자 가져오기 - Person(String name, int age)    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); // getConstructor 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.    // 가져온 생성자로 인스턴스 만들기    Person person1 = constructor.newInstance(\"홍길동\", 55);    person1.getField(); // 이름 : 홍길동, 나이 : 55}  getConstructor() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만일 어떠한 매개변수 타입을 지정해주지 않으면 기본 생성자가 호출되게 된다.  만약 해당하는 생성자를 찾지 못하면 NoSuchMethodException이 발생된다메소드 가져와서 실행하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 특정 public 메서드 가져와 실행    // getMethod(\"메서드명\", 매개변수타입들)    Method sum = personClass.getMethod(\"sum\", int.class, int.class);    int result = (int) sum.invoke(new Person(), 10, 20);    System.out.println(\"result = \" + result); // 30    // 특정 static 메서드 가져와 실행    Method staticSum = personClass.getMethod(\"staticSum\", int.class, int.class);    int staticResult = (int) staticSum.invoke(null, 100, 200);    System.out.println(\"staticResult = \" + staticResult); // 300    // 특정 private 메서드 가져와 실행    Method privateSum = personClass.getDeclaredMethod(\"privateSum\", int.class, int.class);    privateSum.setAccessible(true); // private 이기 때문에 외부에서 access 할 수 있도록 설정    int privateResult = (int) privateSum.invoke(new Person(), 1000, 2000);    System.out.println(\"privateResult = \" + privateResult); // 3000}  getMethod() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만약 매개변수가 없는 메소드라면 메소드 명만 입력해주면 된다.  실행은 Method 타입에서 제공하는 invoke()를 호출하여 실행하면 된다.          instance 메소드 - 매개변수로 인스턴스 필요      static 메소드 - 매개변수 필요 없음      private 메소드 - invoke 하기전에 공개화 할 필요있음      동적으로 필드 가져와 조작하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // static 필드를 가져와 조작하고 출력하기    Field height_field = personClass.getField(\"height\");    height_field.set(null, 200);    System.out.println(height_field.get(null)); // 200}  getField() 를 통해 클래스의 필드를 얻을 수 있다.  필드 값 변경은 set() 메서드를 호출하면 된다.  필드는 클래스가 인스턴스가 되어야 Heap 메모리에 적재됨으로 인스턴스가 필요하다.  다만, static 필드라면 Method Area에 이미 적재되어 있으므로 인스턴스가 필요없다.",
        "url": "//java/2024/05/18/java-series-15.-Reflection.html"
      }
      ,
    
      "java-2024-05-18-java-series-14-dynamicproxy-html": {
        "title": "[java Series] 14 Dynamicproxy",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 다이나믹 프록시Dynamic Proxy자바 프로그래밍의 디자인 패터중 하나인 프록시 패턴Visit Website은 초기화 지연, 접근 제어, 로깅, 캐싱 등,기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴이다.이 디자인 패턴을 적용하면 개방 폐쇄 원칙(OCP)Visit Website의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 플러스 효과를 얻을 수 있다는 장점이 있다.하지만 프록시 디자인 패턴은 대상 원본 클래스 수만큼 일일히 프록시 클래스를 하나하나 만들어 줘야하는 치명적인 단점이 존재한다. 즉, 프록시 적용 대상 객체가 100개면 프록시 객체도 100개 만들어줘야 한다는 말이다. 따라서 코드량이 많아지게 되고 중복이 발생하여 코드의 복잡도가 증가한다는 한계점이 존재한다.바로 이러한 단점들을 보완하여 컴파일 시점이 아닌 런타임 시점에 프록시 클래스를 만들어주는 방식이 자바 가상 머신(JVM)에서 공식적으로 지원하는 동적 프록시(Dynamic Proxy) 기능이다.동적 프록시는 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의 Reflection APIVisit Website 기법을 응용한 연장선의 개념이다. 프록시 패턴의 기본 흐름은 거의 같고, 프록시를 클래스로 직접만들어서 등록하냐 이미 지원하는 api를 이용하여 동적으로 등록하느냐에 따른 차이만 있을 뿐이다.Dynamic Proxy 구성 요소newProxyInstance() Methodpublic class Proxy implements java.io.Serializable {\t// ...        public static Object newProxyInstance(        ClassLoader loader,  //클래스 로더         Class&lt;?&gt;[] interfaces,  // 타깃의 인터페이스        InvocationHandler h  // 타깃 정보가 포함된 Handler    ) throws IllegalArgumentException {        // ...    }}      ClassLoader loader프록시 클래스를 만들 클래스 로더(Class Loader)Proxy 객체가 구현할 Interface에 Class Loader를 얻어오는 것이 일반적        Class&lt;?&gt;[] interfaces프록시 클래스가 구현하고자 하는 인터페이스 목록 (배열)메서드를 통해 생성 될 Proxy 객체가 구현할 Interface를 정의한다.        InvocationHandler h프록시의 메서드(invoke)가 호출되었을때 실행되는 핸들러 메서드  InvocationHandlerInvocationHandler 인터페이스는 위에서 본 newProxyInstance() 메서드의 3번째 매개변수에 들어갈 핸들러 메서드를 정의하는 함수형 인터페이스이다.이 인터페이스 코드 구성을 보면 내부에 invoke() 라는 추상메서드 하나만 정의되어있는 걸 볼 수 있다.invoke() 메서드는 동적 프록시의 메서드가 호출되었을때, 이를 낚아채어 대신 실행되는 메서드이다. 메서드의 파라미터를 통해 어떤 메서드가 실행되었는지 메서드 정보와 메서드에 전달된 인자까지 알수있다.디자인 패턴으로 프록시를 구성하면 단점이 중복된 메서드 코드 로직이 발생한다는 점인데, 이 invoke() 메서드에 동적으로 등록함으로써 반복된 코드를 줄이게 되는 것이다.public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}  Object proxy : 프록시 객체  Method method : 호출한 메서드 정보  Object[] args : 메서드에 전달된 매개변수 (배열)예시interface AInterface {    String call();    void print();    void run();}class AImpl implements AInterface {    @Override    public String call() {        System.out.println(\"A 호출\");        return \"a\";    }    @Override    public void print() {        System.out.println(\"A print @@@@@@@\");    }    @Override    public void run() {        System.out.println(\"A Running !!!!!!!!!\");    }}public class Client {    public static void main(String[] arguments) {        AInterface proxyA = (AInterface) Proxy.newProxyInstance(                AInterface.class.getClassLoader(),                new Class[]{AInterface.class},                (proxy, method, args) -&gt; { // 람다 함수                    Object target = new AImpl();                    System.out.println(\"TimeProxy 실행\");                    long startTime = System.nanoTime();                    Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행                    long endTime = System.nanoTime();                    long resultTime = endTime - startTime;                    System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);                    return result;                }        );        proxyA.call();        proxyA.print();        proxyA.run();    }}Dynamic Proxy 제약 사항지금까지 동적 프록시 구현 및 응용을 다뤄보았다. 아주 약간의 퍼포먼스를 희생하고 자유롭게 프록시를 다이나믹하게 등록할 수 있지만,여기에 추가로 한가지 제약사항이 존재한다. 동적 프록시에 타켓을 등록할때 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 된다는 점이다.인터페이스를 기반으로 프록시를 동적으로 만들어주기 때문에, 인터페이스가 필수이기 때문이다.즉, 자바에서 newProxyInstance()를 이용해 동적 프록시 객체를 만들때 Class 기반으로는 Proxy 객체를 생성할 수 없다는 말이다. 하지만 클래스의 확장성을 고려할 필요가 없거나 한가지 책임만 분명하게 하는 경우 굳이 인터페이스를 등록해 사용하지 않는 겨우도 있다. 프록시 때문에 굳이 일일히 인터페이스를 구현해야 하는 것도 결국은 디자인 패턴의 한계점의 회귀이다.CGLIB(Code Generator Library)인터페이스가 아닌 클래스를 대상으로 바이트 코드를 조작해서 프록시 생성할 수 있는 라이브러리다.효용성을 입증 받아 스프링에 기본으로 내장돼있다.  스프링 프레임워크에서 Bean을 등록할 때 Spring AOP를 이용하여 등록을 하는데, Bean으로 등록하려는 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 Interface를 구현하고 있지 않으면 CGLIB 라이브러리를 이용한다.CGLIB 프록시CGLIB 에서는 Enhancer 객체로 프록시 객체를 만들며 MethodInterceptor 인터페이스로 프록시 핸들러를 등록한다.// 프록시 핸들러class MyProxyInterceptor implements MethodInterceptor {    private final Object target;    MyProxyInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(            Object o,            Method method,            Object[] args,            MethodProxy methodProxy    ) throws Throwable {        System.out.println(\"TimeProxy 실행\");        long startTime = System.nanoTime();        Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행        long endTime = System.nanoTime();        long resultTime = endTime - startTime;        System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);        return result;    }}// 프록시를 적용할 대상 타켓class Subject {    public void call() {        System.out.println(\"서비스 호출\");    }}public class Client {    public static void main(String[] arguments) {        // 1. 프록시 등록 (CGLIB는 Enhancer를 사용해서 프록시를 등록한다)        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Subject.class); // CGLIB는 구체 클래스를 상속 받아서 프록시를 생성하기 때문에 상혹할 구체 클래스를 지정        enhancer.setCallback(new MyProxyInterceptor(new Subject())); // 프록시 핸들러 할당        // 2. 프록시 생성        Subject proxy = (Subject) enhancer.create(); // setSuperclass() 에서 지정한 클래스를 상속 받아서 프록시가 만들어진다.        // 3. 프록시 호출        proxy.call();    }}람다로?public class Client {    public static void main(String[] arguments) {                Subject proxy = (Subject) Enhancer.create(Subject.class, (MethodInterceptor) (o, method, args, methodProxy) -&gt; {            Subject target = new Subject();            System.out.println(\"TimeProxy 실행\");            long startTime = System.nanoTime();            Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행            long endTime = System.nanoTime();            long resultTime = endTime - startTime;            System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);            return result;        });                proxy.call();    }}주의사항이렇게 보면 인터페이스 기반일 때는 Dynamic Proxy를 사용하고, 클래스 기반일 때는 CGLIB를 사용하면 되겠지만, 이 라이브러리도 제약사항이 존재한다.우선 CGLIB는 기본적으로 클래스 상속(extends)을 통해 프록시 구현이 되기 때문에, 타겟 클래스가 상속이 불가능할때는 당연히 프록시 등록이 불가능하다. 또한 메서드에 final 키워드가 붙게되면 그 메서드를 오버라이딩하여 사용 할수 없게되어 결과적으로 프록시 메서드 로직이 작동되지 않는다.정리하자면 프록시 대상 객체는 상속에 있어 제한이 있으면 안된다는 것이다.  클래스와 메소드에 final 키워드 적용  추상 클래스(abstract class)  클래스의 생성자를 private화 하여 생성자를 제한할 경우",
        "url": "//java/2024/05/18/java-series-14-DynamicProxy.html"
      }
      ,
    
      "java-2024-05-18-java-series-13-serialize-deserialize-html": {
        "title": "[java Series] 13 Serialize_deserialize",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 직렬화 역직렬화Serialize &amp; Deserialize직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes)형태로 연속적인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다. 그 반대 개념인 역직렬화는(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다.이를 시스템적으로 살펴보면, JVM의 힙(heap) 혹은 스택(stack) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여데이터베이스나 파일과 같은 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역질렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.직렬화 사용처  서블릿 세션          단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 만일 세션 데이터를 저장 &amp; 공유가 필요할때 직렬화를 이용한다.      세션 데이터를 데이터베이스에 저장할때      톰캣의 세션 클러스터링Visit Website을 통해 각 서버간에 데이터 공유가 필요할때        캐시          데이터베이스로부터 조회한 객체 데이터를 다른 모듈에서도 필요할때 재차 DB를 조회하는 것이 아닌, 객체를 직렬화하여 메모리나 외부 파일에 저장해 두었다가 역직렬화하여 사용하는 캐시 데이터로서 이용이 가능하다.      물론 자바 직렬화를 이용해서만 캐시를 저장할 수 있는 것은 아니지만 자바 시스템에서 만큼은 구현이 가장 간편하기 때문에 많이 사용된다고 보면 된다.      단, 요즘은 Redis, Memcached 와 같은 캐시 DBVisit Website를 많이 사용하는 편이다.        Remote Method Invocation          자바 RMI는 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.      이 메세지에 객체 데이터를 직렬화하여 송신하는 것이다.      최근에는 소켓을 이용하기 때문에 안쓰이는 기술이다.      직렬화 vs. JSON자바 직렬화의 장점  직렬화는 자바의 고유 기술인 만큼 당연히 자바 시스템에서 개발에 최적화되어 있다.  자바의 광활한 레퍼런스 타입에 대해 제약 없이 외부에 내보낼 수 있다는 것이다.사실 그 외에는 JSON이 훨씬 낫다.직렬화 방법  Serialize 구현Serializable 인터페이스는 아무런 내용도 없는 마커 인터페이스Visit Website 로서, 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준으로 사용된다.  ObjectOutputStream 객체 직렬화직렬화(스트림에 객체를 출력) 에는 ObjectOutputStream을 사용한다.객체가 직렬화될때 오직 객체의 인스턴스 필드값 만을 저장한다. static 필드나 메서드는 직렬화하여 저장하지 않는다직렬화 요소의 제외  transient 키워드    class Customer implements Serializable { int id;  String name;  transient String password; // 직렬화 대상에서 제외 int age;  public Customer(int id, String name, String password, int age) {     this.id = id;     this.name = name;     this.password = password;     this.age = age; }     ...}        readObject / writeObject 재정의직렬화 &amp; 역직렬화할때 호출되는 readObject() 와 writeObject() 는 기본적으로 모든 요소에 대해 자동 직렬화 한다. 그런데 이 메서드들을 직렬화할 클래스에 별도로 재정의 해주면 직렬화를 선택적으로 조작할 수 있게 된다. 이를 커스텀 직렬화 라고도 불리운다.class Customer implements Serializable {    int id; // 고객 아이디    String name; // 고객 닉네임    String password; // 고객 비밀번호    int age; // 고객 나이    public Customer(int id, String name, String password, int age) {        this.id = id;        this.name = name;        this.password = password;        this.age = age;    }    // 직렬화 동작 재정의    private void writeObject(ObjectOutputStream out) throws IOException{        out.writeInt(id);        out.writeObject(name);        out.writeInt(age);    }    // 역직렬화 동작 재정의    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{        this.id = in.readInt();        this.name = (String) in.readObject();        this.age = in.readInt();    }    @Override    public String toString() {        return \"Customer{\" +                \"id=\" + id +                \", password='\" + password + '\\'' +                \", name='\" + name + '\\'' +                \", age=\" + age +                '}';    }}  상속 관계에서 직렬화만약 부모-자식 상속 관계에서 부모 클래스가 Serializable을 구현했다면 자식 클래스는 Serializable을 구현하지 않아도 직렬화가 가능하다. 그러면 반대로 부모 클래스는 Serializable을 구현하지 않고 자식 클래스만 구현했다면 어떤 방식으로 직렬화될까?직렬화할때 부모 클래스의 인스턴스 필드는 무시되고 자식 필드만 직렬화가 된다. 따라서 상위 클래스의 필드까지 직렬화하려면 부모 클래스가 Serializable을 구현하도록 설정하던지,위에서 다뤄본 writeObject / readObject 메서드를 재정의하여 직접 직렬화 코드를 추가 하면 된다.직렬화 버전 관리      SerialVersionUIDSerializable 인터페이스를 구현하는 모든 직렬화된 클래스는 serialVersionUID(이하 SUID) 이라는 고유 식별번호를 부여 받는다. 이 식별 ID는 클래스를 직렬화, 역직렬화 과정에서 동일한 특성을 갖는지 확인하는데 사용된다. 그래서 클래스 내부 구성이 수정될 경우, 기존에 직렬화한 SUID와 현재 클래스의 SUID 버전이 다르기 때문에 이를 인지하고 InvalidClassException 예외가 발생시켜 값 불일치 되는 현상을 미연에 방지한다.단, 직렬화 스펙 상 serialVersionUID 값 명시는 필수가 아니며, 만일 클래스에 SUID 필드를 명시하지 않는다면, 시스템이 런타임에 클래스의 이름, 생성자 등과 같이 클래스의 구조를 이용해 암호 해시함수를 적용해 자동으로 클래스 안에 생성하게 된다.        수동 버전 관리만일 네트워크로 객체를 직렬화하여 전송하거나 협업을 하는 경우 수신자와 송신자 모두 같은 버전의 클래스를 가지고 있어야 할텐데, 만일 클래스가 조금만 변경사항이 있으면 모든 사용자에게 재배포해야 하는 애로사항이 생겨 프로그램을 관리하기 어렵게 만든다.  따라서 직렬화 클래스는 왠만한 상황에선 serialVersionUID 를 직접 명시해주어 클래스 버전을 수동으로 관리하는 것을 권장하는 편이다.SUID를 직접 명시해주면 클래스의 내용이 변경되어도, 클래스의 버전이 시스템이 자동 생성된 값으로 변경되지 않기 때문이다. 이외에도 런타임에 SUID를 생성하는 시간도 많이 잡아먹기 때문에 미리 명시를 강력히 권장되는 바이다.  SerialVersionUID 수동 관리 유의사항  클래스 serialVersionUID를 명시하더라도 절대 만능이 아니다. 위와 같이 단순히 필드 변수 하나 추가하는 정도는 문제가 없겠지만 필드 타입을 변경하는 상황에서는 버전 수동 관리를 하여도 예외를 막을순 없다.직렬화 예외  InvalidClassException  NotSerializableException직렬화의 단점  용량이 크다. (메타 정보를 모두 가지고 있다.)  역직렬화 과정에서 공격당할 위험이 있다.  릴리즈 후 수정이 어렵다.  클래스 캡슐화가 깨진다.  버그와 보안에 취약하다.",
        "url": "//java/2024/05/18/java-series-13-Serialize_Deserialize.html"
      }
      ,
    
      "java-2024-05-18-java-series-12-brokensingleton-html": {
        "title": "[java Series] 12 Brokensingleton",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Singleton과 훼손Singleton싱글톤은 기본적으로 단 하나의 유일한 객체를 의미한다.역직렬화에 의한 싱글톤 훼손자바의 직렬화(Serialize)는 JVM의 힙 메모리에 있는 객체 데이터를 바이트 스트림(byte stream) 형태로 바꿔 외부 파일로 내보낼수 있게 하는 기술을 말한다. 반대로 외부로 내보낸 직렬화 데이터를 다시 읽어들여 자바 객체로 재변환하는 것을 역직렬화(Deserialize) 라 한다.직렬화하여 내보낸 외부 파일은 데이터베이스에 저장되기도 하며 네트워크를 통해 전송되기도 한다. 이 직렬화를 적용하기 위해선 클래스에 Serializable 인터페이스를 implements 하면 된다.그런데 만일 어떤 클래스를 직렬화하여 다른 컴퓨터에 전송하려는데, 이 클래스를 싱글톤으로 구성하려고 한다. 하지만 이 싱글톤 클래스는 송신자가 파일을 받고 역직렬화시 깨지게 되어 더이상 싱글톤이 아니게 된다.이러한 현상이 생기는 이유는 역직렬화 자체가 보이지 않은 생성자로서 역할을 수행하기 때문에 인스턴스를 또다시 만들어, 직렬화에 사용한 인스턴스와는 전혀 다른 인스턴스가 되기 때문에 일어나는 것이다. 따라서 클래스에 Serializable을 구현하면 더 이상 이 클래스는 싱글톤이 아니게 되어 메모리 이점을 더이상 얻을수 없게 된다.훼손 대응 방안이러한 싱글톤의 역직렬화의 대응 방안으로 직렬화 관련 메서드인 readResolve() 를 정의하면 된다.readResolve 메서드를 정의하게 되면, 역직렬화 과정에서 readObject를 통해 만들어진 인스턴스 대신 readResolve에서 반환되는 인스턴스를 내가 원하는 것으로 바꿀 수 있기 때문이다. 그리고 기존에 역직렬화를 통해 새로 생성된 객체는 알아서 Garbage CollectorVisit Website의 대상이 된다.class Singleton implements Serializable {    private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    // 역직렬화한 객체는 무시하고 클래스 초기화 때 만들어진 인스턴스를 반환    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}이때 싱글턴 인스턴스의 직렬화 결과에는 아무런 실 데이터를 가질 이유가 없기 때문에, 싱글톤 클래스에 필드 변수들이 있을 경우 모든 인스턴스 필드를 transient로 선언한다. 아무리 readResolve 메서드라도 역직렬화 과정 중간에 역직렬화된 인스턴스의 참조를 훔쳐오는 공격을 행할경우 다른 객체로 바뀔 위험이 있기 때문이다.class Singleton implements Serializable {    // 싱글톤 객체의 필드들을 transient 설정하여 직렬화 제외    transient String str = \"\";    transient ArrayList lists = new ArrayList();    transient Integer[] integers;        private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}리플렉션에 의한 싱글톤 훼손자바 리플렉션(Reflection - 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 조작하는 프로그램 기법이다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고 객체를 생성하는 것 또한 가능하게 해준다.이러한 리플렉션 기법은 프레임워크, 라이브러리에서 많이 사용된다. 왜냐하면 프레임워크, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버들을 구성할지 모르는데, 이러한 사용자 클래스들을 기존의 기능과 동적으로 연결 시키기 위하서 이다. 이미 Spring, Lombok 등 많은 프레임워크에서 리플렉션 기능을 사용하고 있다.그런데 문제는 리플렉션을 통해 싱글톤 객체를 생성하게 되면 다른 객체를 반환해 싱글톤이 다시 한번 깨지는 것이다. 클래스 객체를 통해 해당 객체의 생성자를 받아와 newInstance() 메서드를 실행하면 인스턴스를 생성할 수 있게 되는데, 여기서 생성된 인스턴스는 Holder가 가지고 있는 인스턴스와는 전혀 다른 새로운 인스턴스이기 때문이다.",
        "url": "//java/2024/05/18/java-series-12-BrokenSingleton.html"
      }
      ,
    
      "java-2024-05-18-java-series-11-heappollution-html": {
        "title": "[java Series] 11 Heappollution",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 힙 오염Heap Pollution힙 오염은 JVM의 Heap 메모리 영역에 저장되어 있는 특정 변수가 불량 데이터를 참조함으로써, 만일 힙에서 데이터를가져오려고 할 때 얘기치 못한 런타임 에러가 발생할 수 있는 오염 상태를 의미한다.힙 오염의 대표 이유는 Generic이다.Generic collection은 이전 버전과의 호환성을 위해서 Compile 때 Generic을 Object으로 변환하거나 제거함으로써 하위 호환을 했다.  제네릭 타입 소거(Erasure)  제네릭은 type-safe하며 실행 시간 오버헤드를 줄이기 위해서 도입된 문법으로, 이전 자바에서 제네릭 타입 파라미터가 없던 탓에 호환성을 위해서제네릭은 컴파일되면 제네릭 타입은 사라졌다. 즉, .class에는 제네릭 정보가 존재하지 않았다.  컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거하기 때문에 잠재적 힙 오염 문제에 빠질 수 있게 됐다.  Reifiable, Non-Reifiable  실체화 타입(Reifiable Type)이란 컴파일 단계에서 타입 소거에 의해 지워지지 않는 타입 정보를 말한다.      int, double, float, byte 등 원시 타입    Number, Integer 등 일반 클래스와 인터페이스 타입    List, ArrayList, Map 등 자체(Raw Type)    List&lt;?&gt;, ArrayList&lt;?&gt; 등 비한정 와일드 카드가 포함된 매개변수화 타입 (와일드 카드 &lt;?&gt; 는 애초에 타입 정보가 명시되지 않았으므로 타입 소거를 해도 별 문제가 없다. 컴파일 타임에 Object로 변환 됨)    비실체화 타입(Non-Reifiable Type) 컴파일 단계에서 타입 소거에 의해서 타입 정보가 제거된 타입을 의미한다. 제네릭 타입 파라미터는 모두 제거된다.      List, List    List, ArrayList    List&lt;? extends Number&gt;, List&lt;? super String&gt;    제네릭 소거 과정  컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 필요한 곳에 형 변환을 넣고 최종적으로 컴파일 코드에 Type Erasure로 제네릭 타입을 제거하게 된다.      제네릭 타입의 경계(bound)를 제거              제네릭  -&gt; T는 Number로 치환                  는 Object로 치환```java// T extends Type -&gt; Type /* 치환 전 */class Box {List list = new ArrayList&lt;&gt;();                    void add(T item) {    list.add(item); }      T getValue(int i) {     return list.get(i); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);} } ```              제네릭 타입을 제거한 후 타입이 일치하지 않는 곳은 형 변환을 추가한다.```java/* 치환 전 */class Box { List list = new ArrayList(); // Object      void add(Number item) {     list.add(item); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);}Number getValue(int i) {    return (Number) list.get(i); // 캐스팅 연산자 추가} } ``` 3. 소거는 똑같이 진행 ```java // T -&gt; Object /* 치환 전 */ public static &lt;T&gt; int count(T[] anArray, T elem) {int cnt = 0;for (T e : anArray)    if (e.equals(elem))        ++cnt;    return cnt; }    /* 치환 후 */public static int count(Object[] anArray, Object elem) {    int cnt = 0;    for (Object e : anArray)        if (e.equals(elem))            ++cnt;        return cnt;}```  Bridge 메소드  컴파일러는 확장된 제네릭 타입에 대해서 타입 소거를 해도 다형성 보존을 위해서 별도의 bridge method를 생성한다.제네릭 힙 오염  원시 타입과 매개변수 타입을 동시에 사용하는 경우  확인되지 않은 형 변환을 수행하는 경우//ClassCastException 발생 예정ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"A\");list1.add(\"B\");Object obj = list1; //상위 타입 Object로 변경ArrayList&lt;Double&gt; list2 = (ArrayList&lt;Double&gt;) obj; //DownCastlist2.add(1.0);list2.add(2.0);System.out.println(list2); // [홍길동, 임꺾정, 1.0, 2.0]for(double n : list2) {    System.out.println(n);}컴파일러는 위의 코드에 대해서 컴파일 에러를 내지 않는다. 이는 제네릭 타입 소거에 의해서 나타나는 문제다.1. 컴파일러는 타입 캐스팅을 검사하지 않는다.-&gt; 컴파일러는 형변환 대상 객체에 대해서 검사하지 않는다. 정확히 말하면 캐스팅 했을 때 대입되는 변수에 저장할 수 있느냐만 검사한다.2. 제네릭 타입이 소거되면 결국 Object-&gt; 컴파일되면서 결국 제네릭은 Object가 된다. 결국 위 예시는 RawType이 되면서 어떤 정보든 저장할 수 있게 되면서 컴파일 에러가 나지 않는다.제네릭 힙 오염 방지책자바에서 Collections 클래스의 checkList() 메소드를 지원한다 해당 객체에 대해서 의도치 않은 타입의 데이터가 들어갔을 때 이를 감지하여 예외를 발생시킨다. https://inpa.tistory.com/entry/JAVA-☕-제네릭-타입-소거-컴파일-과정-알아보기 ",
        "url": "//java/2024/05/18/java-series-11-HeapPollution.html"
      }
      ,
    
      "java-2024-05-18-java-series-10-equalsandhashcode-html": {
        "title": "[java Series] 10 Equalsandhashcode",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Equals And Hash CodeEqualsAndHashCodeEquals어떤 참조 변수의 값이 같은지 다른지 동등 비교를 할 때 사용비교할 대상이 객체면 주소 값을 비교한다.override Equals기본적으로 참조형은 주소 값을 비교한다. 아무래 내부 필드가 같아도 엄연히 다른 주소 값이다. 그래서 Java에서는 필드 값을 비교하도록 오버라이드 해서 주소 값 비교를 우회한다.HashCode객체 주소 값을 해싱해서 해시코드를 만든 후 반환한다.(객체의 지문과 같다.)엄밀히 말하면 주소 값으로 만든 고유한 숫자 값이다.override Hashcode만약 Equals만 오버라이드하면 에러를 낸다. java는 equals를 오버라이드하면 당연히 hashcode도 객체의 필드를 다루도록 오버라이드 하도록 한다.왜냐하면 equals()의 결과가 true면 두 객체의 해시코드는 반드시 같아야 한다는 자바의 규칙때문이다.이렇게 강요하는 이유는 hash 값을 사용하는 CollectionFrameWork 사용에 문제가 발생하기 때문이다.ex) setEquals and Hashcode 동작 순서?https://inpa.tistory.com/entry/JAVA-☕-equals-hashCode-메서드-개념-활용-파헤치기1. HashCode는 고유하지 않다.보통 해싱 알고리즘은 서로 다른 주소를 가진 경우 같은 해시코드를 가질 여지가 없다. 64bit(8바이트) 주소값을 hashCode로 이용해서 반환하면4바이트(32bit)로 강제 캐스팅 되기 때문에 값이 겹칠 수도 있다. 즉 서로 다른 객체라도 같은 해시코드를 반환할 수 있다. 2. 해결책@EqualsAndHashCode에서 볼 수 있듯 equals로 두 객체의 진짜 주소를 직접 비교하는 식으로 극복한다.진짜 주소 값이 필요할때?hashcode() 오버라이드 시 비교 대상 객체가 같은지 아닌지를 판별할 수 있다. 그런데, 오버라이드 해버리면 객체 자체의 주소 값(해시코드)가 필요할 때 난감해진다.그래서 identityHashCode()라는 메소드를 제공한다.",
        "url": "//java/2024/05/18/java-series-10-EqualsAndHashCode.html"
      }
      ,
    
      "java-2024-05-18-java-series-09-innerclassproblem-html": {
        "title": "[java Series] 09 Innerclassproblem",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Inner class에서의 문제점Inner Class ProblemInner Class를 선언하면 Inner Class를 static으로 설정하라고 경고한다.이는 Inner Class가 Inner static 보다 메모리를 더 많이 쓰고, 느리고, 바깥 클래스가 GC 대상에서 빠져 메모리 관리에 문제가 될 수 있다.Inner class는 외부 참조를 한다.일반적으로 내부 클래스를 만들기 위해서는 외부 클래스를 초기화 해야한다. 이러한 문제 때문에 inner 클래스는 외부 참조를 갖게 된다. 심지어 내부 클래스가 외부 멤버를사용하지 않아도 숨겨진 외부 참조가 생성된다.public class Outer_Class {    int field = 10;    class Inner_Class {        int inner_field = 20;    }}// Outer_class$Inner_class.class// Outer_class.class// 바이트 코드를 디컴파일하면class Outer_Class$Inner_Class {    int inner_field;        Outer_Class$Inner_Class(Outer_Class this$0) { //생성자로 외부 클래스를 매개 변수로 받아서 초기화        this.this$0 = this$0;        this.inner_field = 20;    }}// 즉 바깥 클래스의 인스턴스와 암묵적으로 연결Inner 클래스의 메모리 누수Inner 클래스가 바깥 클래스를 외부 참조하므로 외부 클래스는 필요가 없고 내부 클래스만 남아있을 경우, 외부 참조로 내부 클래스와연결되어 있기 때문에 메모리에 잔존하고 누수로 이어진다.해결법은 static  static inner는 외부 참조가 없다.  static inner는 메모리 누수가 없다.",
        "url": "//java/2024/05/18/java-series-09-InnerClassProblem.html"
      }
      ,
    
      "java-2024-05-18-java-series-08-callby-html": {
        "title": "[java Series] 08 Callby",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CallByCall By Value vs. Call By Reference프로그래밍을 하다보면 반드시 마주치는 것이 바로 call by value / call by reference 개념이다.함수의 매개변수에서 값을 복사하느냐 주소값을 참조하느냐에 따라 반환 결과가 달라지기 때문에 대부분의 프로그래밍 교육과정에선 중요시 하게 여긴다.자바에서도 역시 call by value 와 call by reference 동작 차이가 존재한다.자바의 데이터형을 알아보면 크게 두가지로 나뉘게 된다.  기본형(primitive type) - Boolean Type(boolean), Numeric Type(short, int, long, float, double, char)  참조형(reference type) - Class Type, Interface Type, Array Type, Enum Type, 기본형을 제외한 모든 것들",
        "url": "//java/2024/05/18/java-series-08-CallBy.html"
      }
      ,
    
      "java-2024-05-18-java-series-07-tuning-html": {
        "title": "[java Series] 07 Tuning",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TuningGC Tuning주의점  GC 옵션은 서비스 특징마다 적정 값이 다르다.  GC 튜닝은 최후의 수단이다. (코드 최적화가 우선이다.)목표  Old로 넘어가는 객체의 수 최소화 하기Old는 Young에서 GC보다 시간이 오래 소요된다. 따라서 Old로 넘어가는 수를 줄이면 Full GC가 줄어든다.이는 Young size를 잘 조절하는 것만으로 Old로 넘어가는 것을 줄이고 이 자체로 튜닝이 된다는 것이다.  Full GC 시간 줄이기Full GC 실행 시간은 Minor GC에 비해 길다. 그러므로 Old 사이즈를 조정하는 것도 방법이다. 그렇다고 너무 줄이면 OutOfMemoryError가 발생하거나 FUll GC가 자주 발생할 수 있다. 반대로 너무 Old를 늘리면 FullGC는 줄지만 실행 시간이 늘어날 수 있다.튜닝 진행1. GC 상황 모니터링# jstat gcutil  명령어로 현재 실행중인 8884번 프로세스에 대해 1초에 한번 씩 총 10번 GC와 관련된 정보를 출력하도록 모니터링jstat -gcutil -t 8844 1000 0            컬럼      설명                  S0      Survivor 영역 0의 사용율(현재 용량에 대한 비율)              S1      Survivor 영역 1의 사용율(현재 용량에 대한 비율)              E      Eden 영역의 사용율 (현재 용량에 대한 비율)              O      Old 영역의 사용율 (현재 용량에 대한 비율)              P      Permanent 영역의 사용율 (현재 용량에 대한 비율)              YGC      Young 세대의 GC 이벤트 수              YGCT      Young 세대의 GC 시간              FGC      Full GC 이벤트 수              FGCT      Full GC 시간              GCT      GC 총 시간      2. 모니터링 결과 분석 후 GC 튜닝 여부 결정  Minor GC 수행시간: YGCT / YGC (0.314 / 19) = 0.016초  Major GC 수행 시간: FGCT / FGC (0.291 / 3) = 0.097초# Minor GC의 처리 시간이 빠르다 (50ms 내외)# Minor GC의 주기가 빈번하지 않다 (10초 내외)# Full GC의 처리 시간이 빠르다 (1초 내외)# Full GC의 주기가 빈번하지 않다 (10분에 1회)3. GC 알고리즘 방식 지정            GC 알고리즘      내용                  Parallel GC      - ‘처리량’이 중요한 시스템에서 주로 사용 - Full GC 수행 시 compaction 작업이 수행되기 때문에 GC 시간 자체는 많이 소요되나 일정한 멈춤 시간을 제공함              CMS GC      - 응답시간이 중용한 시스템에사 주로 사용  - compaction 미수행으로 Stop-The-World 시간은 짧으나 자주 Compaction이 발생하는 시스템의 경우 오히려 Full GC 보다 Compation 시간이 오래 걸릴 수 있음  - 자원 사용량이 증가하는 점도 고려해야 함              G1 GC      - 성능적으로 가장 우수한 GC 방식이나, JDK 7 버전부터 정식 제공되었으며, Java 9 에서 Default GC 방식으로 채택      4. Heap 크기 지정JVM의 힙 크기는 GC 발생 횟수와 수행 시간에 영향을 끼치기 떄문에 옵션을 통해 조절하면 애플리케이션의 성능 향상을 가져올 수 있다. 메모리 크기는 JVM의 시작 크기 -Xms 최대 크기 -Xmx를 말한다.메모리 크기와 GC 발생 횟수, GC 수행 시간 관계는 아래와 같다.  메모리 크기가 크면          GC 발생 횟수가 감소      GC 수행 시간은 길어진다.        메모리 크기가 작으면          GC 발생 횟수는 증가한다.      GC 수행 시간은 짧아진다.                  구분      옵션      설명                  힙(heap) 영역 크기      -Xms      JVM 시작 시 힙 영역 크기              힙(heap) 영역 크기      -Xmx      최대 힙 영역 크기              New 영역의 크기      -XX:NewRatio      New 영역과 Old 영역의 비율              New 영역의 크기      -XX:NewSize      New 영역의 크기              New 영역의 크기      -XX:SurvivorRatio      Eden 영역과 Survivor 영역의 비율      # 이 중에서 중요한 옵션은 -Xms 옵션, -Xmx 옵션, -XX:NewRatio 옵션이다.# 특히 -Xms 옵션과 -Xmx 옵션은 왠만하면 필수로 지정하길 권장되며, 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.# # NewRatio는 New 영역과 Old 영역의 비율이다. # -XX:+NewRatio=1로 지정하면 (New 영역):(Old 영역)의 비율은 1:1이 된다. # 만약 1GB라면 (New 영역):(Old 영역)은 500MB:500MB가 된다. # NewRatio가 2이면 (New 영역):(Old 영역)이 1:2가 된다. # 즉, 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.# 힙 시작 크기 256mb, 힙 최대 크기 2gb# young 영역과 old 영역 비율 1:2 로 설정 (New 영역:Old 영역 = 1:2)# Parallel GC 로 실행java -Xms256m -Xmx2048m -XX:+NewRatio=2 -XX:+UseParallelGC5. 결과 분석분석할 때는 다음의 사항을 중심으로 살펴보는 것이 좋다. 이는 우선 순위 별로 나열되어 있다.  FullGC 수행 시간  MinorGC 수행 시간  Full GC 수행 간격  MinorGC 수행 간격  전체 Full GC 수행 시간  전체 Minor GC 수행 시간  전체 GC 수행 시간  Full GC 수행 횟수  Minor GC 수행 횟수",
        "url": "//java/2024/05/18/java-series-07-Tuning.html"
      }
      ,
    
      "java-2024-05-18-java-series-06-gc-algorithm-html": {
        "title": "[java Series] 06 Gc_algorithm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GC Algorithm가비지 컬렉션 알고리즘1. Serial GC  서버의 CPU 코어가 1개일 때 사용하기 위해서 개발된 GC  GC 처리하는 쓰레드가 1개라서 STW가 길다.  MinorGC에서는 Mark-Sweep, MajorGC에서는 Mark-Sweep-Compactjava -XX:+UseSerialGC -jar Application.java2. Parallel GC  Java 8의 Default  Serial GC와 기본 알고리즈은 같지만 Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old는 Single)  Serial GC에 비해서 STW가 줄어java -XX:+UseParallelGC -jar Application.java # -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수3. Parallel Old GC(Parallel Compacting Collector)  Parallel GC를 개선한 버전  Young, Old도 멀티 GC  새로운 GC 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old도 Multi)java -XX:+UseParallelOldGC -jar Application.java# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수4. CMS GC (Concurrent Mark Sweep)  어플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되어 STW를 최대한 줄이기 위래서 고안된 GC  GC 과정이 매우 복잡  GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다.  메모리 파편화 문제  CMS GC는 Java9부터 deprecated, Java14에는 중지됨# deprecated in java9 and finally dropped in java14java -XX:+UseConcMarkSweepGC -jar Application.java5. G1 GC (Garbage First)  GMC GC를 대체하기 위해서 Java 7에서 최초로 release  Java 9+의 디폴트 GC  4GB 이상의 Heap, STW이 0.5 이상이될 때 사용 (Heap이 너무 작으면 미사용 권장)  기존의 GC에서는 HEAP 영역을 물리적으로 고정된 Young/ Old로 나눴지만 G1은 Region을 도입. Eden, Survivor, Old를 고정이 아닌 동적으로 부여  Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 식java -XX:+UseG1GC -jar Application.java6. Shenandoah GC  Java 12에 release  RedHat에서 개발  기존 GMS가 가진 단편과, G1이 가진 pause 이슈를 해결  강력한 Concurrency와 가벼운 GC 로직으로 Heap 사이즈에 영향을 받지 않고 일정한 Pause 시간 소요가 특징java -XX:+UseShenandoahGC -jar Application.java7. ZGC( Z Garbage Collector )  Java 15에 release  대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해서 디자인된 GC  G1의 Region처럼 ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정이지만 ZPage는 2mb 배수로 운영됨  ZGC가 내세우는 최대 장점은 힙 크기가 증가해도 STW가 절대로 10ms를 넘지 않는다.java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java",
        "url": "//java/2024/05/18/java-series-06-GC_Algorithm.html"
      }
      ,
    
      "java-2024-05-18-java-series-05-gc-html": {
        "title": "[java Series] 05 Gc",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GCGC자바의 메모리 관리 방법 중 하나로 JVM의 HEAP 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스(C/C++ 은 수동으로 메모리 할당, 해제를 해야했다.)1. 대상판단 근거로 도달성, 도달능력(Reachability)라는 개념을 적용한다. 객체에 레퍼런스가 있다면 Reachable[1], 객체에 유효한 레퍼런스가 없으면 UnReachable[2]로 구분한다.주로 Heap Area에서 참조하고 있지 않은 객체가 GC 대상이 된다.청소 방식Mark And SweepGC가 동작하는 가장 기초적인 청소 과정.GC 대상이 될 객체를 식별(Mark), 제거(Sweep)하며 객체가 제거되며 파편화된 메모리를 영역 앞에서부터 채워나가는 작업을 수행한다.  Mark : Root Space부터 그래프 순회를 통해서 연결되나 객체를 찾아서 각각 어떤 객체를 참조하고 있는지 마킹  Sweep : Unreachable를 Heap에서 제거한다.  Compact : Heap의 시작 주소를 모아 메모리가 할당된 부분과 아닌 부분으로 압축한다. (GC 종류에 따라 하지 않는 경우도 있음 )GC 동작 과정Heap은 동적으로 레퍼런스 데이터가 저장되는 공간으로 GC 대상이 되는 공간이다. Heap은 아래 2가지를 전제(Weak Generational Hypothesis)로 설계됐다.  대부분 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.  오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.즉, 객체는 대부분 일회성, 메모리에 오랫동안 남을 경우는 드물다는 것이다.   Young          새롭게 객체가 할당되는 영역      대부분 객체가 금방 Unreachalbe이 되므로 Young에 생성됐다 사라짐      Young에 대한 GC를 Minor GC라고 부름        Old          Young에서 Reachable을 유지하면 복사되는 영역      Young보다 크게 할당됨. 크기가 큰 만큼 가비지는 적게 발생      Old에 대한 GC를 Full GC라고 부름        Eden          new를 통해 생성된 위치      정기적 쓰레기 수집 후 살아남으면 Survivor로 보냄        Survivor 0/ 1          최소 1 번 이상의 GC에서 살아남은 객체가 존재하는 영역      Survivor 0, 1 중 하나는 꼭 비어 있다.      MinorGCYoung은 Old에 비해서 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다.  처음 생성된 객체는 Young 영역의 Eden에 위치  Eden이 꽉차면 MinorGC 발생          Obj MarK로 Reachable 탐색      살아 남은 Obj Survivor로 이동      Eden의 unreachable gowp      살아남은 모든 객체 age[3] += 1      Eden이 가득 차면 비어있는 Survivor로 Eden, 기존 Survivor 내용들 이동      옮긴 Survivor 내역들 age += 1      MajorGCOld는 길게 살아남은 메모리들이 존재하는 공간. age 임계 값을 초과해서 이동되는 녀석 가끔 Young에 담을 수 없을 정도로 크면 Old로 보내기도 함그리고 MajorGC는 객체들이 계속 Promotion되어 Old가 부족해지면 발생MinorGC vs. MajorGC            GC Type      MinorGC      MajorGC                  대상      Young      Old              실행 시점      Eden이 꽉 차면      Old가 꽉차면              실행 속도      빠르다      느리다      MajorGC는 old가 꽉 차면 Unreachable을 한꺼번에 삭제하는 MajorGC가 실행된다. Young은 크기가 작기에 빠르지만 Old는 크기에 보통 10배 이상의 시간을 사용한다.또한  STOP-THE-WORLD 가 발생한다. 이 때 Thread가 멈추고 Mark and Sweep을 하므로 일시적으로 멈추기 때문[1] : 객체가 참조되고 있는 상태[2] : 객체가 참조되고 있지 않은 상태 (GC 대상)[3] : Survivor 영역에서 객체가 살아남은 횟수. Object Header에 기록 age가 임계 값에 다다르면 Promotion( Old로 이동 여부를 결정. 기본 임계값은 31)",
        "url": "//java/2024/05/18/java-series-05-GC.html"
      }
      ,
    
      "java-2024-05-18-java-series-04-jni-html": {
        "title": "[java Series] 04 Jni",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JNIJNI(Java Native Interface)자바 네이티브 인터페이스는 JVM위에서 실행되고 있는 자바 코드가 네이티브 응용 프로그램(하드웨어, 운영체제 플랫폼에 종속된 프로그램들), C, C++, 어셈블리 같은 다른 언어들로작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크1. 네이티브 메소드Java는 메소드 구현이 네이티브 코드에서 제공될 것임을 나타내는 데 사용되는 네이티브 키워드를 제공한다. 일반적으로 네이티브 실행 프로그램을 만들 때 정적 또는 공유 라이브러리를 사용할 수 있다.2. 예약어  native: 다른 언어에서 사요할 수 있게 해주는 키워드  volatile: Thread safe를 하게 해주는 키워드  strictfp: 자바와 타 플랫폼 간 부동소수점 정밀도를 맞추기 위한 키워드  assert: 인자로 주어진 값이 참인지 거짓인지 판별하는 메소드",
        "url": "//java/2024/05/18/java-series-04-JNI.html"
      }
      ,
    
      "java-2024-05-18-java-series-03-memory-html": {
        "title": "[java Series] 03 Memory",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - memoryMemory (Runtime Data Area)  Method(static) 영역  Stack 영역  Heap 영역1. 자바 변수 종류  클래스 변수: 클래스 영역에서 static이 붙는 변수 - 클래스가 메모리에 올라갈 떄  인스턴스 변수: static이 나닌 변수 (참조 없을 경우 gc 대상) - 인스턴스가 생성될 때  지역 변수: 메소드 내에서 선언, 메소드가 끝나면 소멸 - 해당 메소드가 실행될 때  매개 변수: 메소드 호출 시 전달하는 값 - 해당 메소드가 실행될 때2. Method(Static) 영역 ( == Class area, Static area)  JVM이 동작해서 클래스가 로딩될 때 생성      JVM이 읽어들인 클래스와 인터페이스에 대한 정보(멤버 변수, 런타임 상수 풀, 생성자, 메소드 등)와 함께 클래스 변수(static variable)가 저장되는 영역    ↳ Field Information: 멤버 변수의 이름, 데이터 타입, 접근 제어자에 대한 정보    ↳ Method Information: 메소드 이름, 리턴 타입, 매개변수, 접근제어자에 대한 정보    ↳ Type Information: class인지 interface인지 여부 저장, 전체 이름, super의 이름(interface, object인 경우 Heap에서 관리)    Method(Static) 영역에 있는 것은 어느 곳에서나 접근 가능  Method(Static) 영역에 있는 데이터는 프로그램 시작 ~ 종료까지 메모리에 남아 있다.2.1 Runtime Constant Poolstatic 영역에 존재하는 별도 관리 영역 상수 자료형을 저장하여 참조하고 중복을 막는다.3. Stack 영역  메소드 내에서 정의하는 기본 자료형에 해당되는 지역 변수의 데이터 값이 저장되는 공간  메소드가 호출될 때 스택 영역에 스택 프레임[1]이 생기고 그 안에서 메소드를 호출  primitive 타입에 해당되는 지역변수, 매개 변수 데이터 값이 저장됨  메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 사라짐  Stack은 LIFO이며, 스코프 범위를 벗어나면 스택 메모리에서 사라진다.4. Heap[2]  JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 여역  new 연산자로 생성되는 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간  Heap에 있는 오브젝트들을 가리키는 레퍼런스 변수는 stack에 적재  Heap는 Stack과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지. 그러나 Heap에 인스턴스를 참조하지 않는 상황이 되면 GC 대상이 된다.  stack은 쓰레드 개수마다 생성되지만 Heap은 몇 개의 쓰레드가 존재하든 상관 없이 하나의 Heap만 존재한다. https://inpa.tistory.com/entry/JAVA-☕-그림으로-보는-자바-코드의-메모리-영역스택-힙#  https://1-7171771.tistory.com/140  method(static) area? permenent generation?1. Permanent Generation : 생성된 객체들의 정보의 주소 값이 저장된 공간이다. 클래스 로더에 의해 load되는 Class, Method 드엥 대한 Meta 정보가 저장되는 영역 (Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용)  MetaSpace[3]: class의 메타 정보, 메소드의 메타 정보, static object 변수, 상수, JVM, JIT 관련 데이터 등  New/Young          메모리에 객체가 생성되면 Eden에 생성된다.      Eden에 메모리가 가득차면 Eden 데이터가 Survivor1 혹은 Survivor2로 옮겨진다. 1,2 우선 순위는 없다.      Survivor에 있으면 어디에서인가 참조되고 있는 객체들이다. 둘 중 하나가 가득차면 공간이 남아 있는 Survivor로 옮겨진다.      이러한 매커니즘으로 Survivor1 혹은 Survivor2 둘 중 하나는 항상 비워져 있다.      이 과정에서 Minor GC가 발생한다. New/Young에서 발생하는 CG로 Eden 또는 Survior1, Survior2에서 사용되지 않는 객체들을 삭제한다.  Old          Survivor 1, 2를 왔다 갔다하는 동안 살아남은 객체들은 Old로 간다. Old는 Young 보다 크게 할당한다. 이러한 이유로 Old의 GC는 Young보다 드물다.      간혹 Eden -&gt; Old로 넘어가는 경우가 있는데 Survivor에 담을 수 없을 만큼 큰 경우 발생한다.      오랫동안 살아남은 객체?  Minor GC가 발생하면 ageBit를 1씩 늘린다. ageBit이 MaxTenuringThreshold[4]를 초과하면Old로 이동한다. (너무 커서 Eden에서 Old로 바로 이동하기도 한다.)  Old에서는 Major GC(Full Gc)가 일어나며, GC를 진행하는 Thread를 제외하고 이외의 모든 Thread를 멈춘 상태로 GC가 진행된다.이 상태를 stop-the-world라고 한다.  JVM에서 GC를 튜닝하는 이유가 stop-the-world 시간을 단축시키 위함이다.GC 알고리즘 종류  Serial GC : JDK 5,6에서 사용 Minor, Major 모두 싱글 스레드로 실행 -&gt; Stop-The-World가 김.          Mark-Sweep-Compact 알고리즘 사용 (식별하고 지우고 빈공간 정리, 압축)  Parallel GC : Young에서 Minor GC 수행 시 멀티쓰레드 사용(SingleCore CPU라면 Serial로 동작)  Parallel old GC : Old에서 Full GC도 병렬로 처리. Old에서 GC를 처리할 때 Mark-Summary(살아 있는 객체를 식별)-Compaction 사용  CMS(Concurrent Mark &amp; Sweep) GC : Major GC를 최소한으로 하려는데 초점을 둠. MajorGC 수행 시간을 줄기이 위해서 GC의 대상 객체를 최대한 정밀하게 파          Initial Mark : 현재 살아남은 객체를 탐색, GC ROOT에서 참조하는 객체들만 우선적으로 탐색(STW 매우 적음)      Concurrent Mark : Initial Mark에서 탐색한 객체들이 참조하고 있는 객체를 찾아가면 GC 대상인지 판별 (STW 없음)      ReMark : Concurrent Mark 실행 중 새로 생성된 객체나, 참조가 끊어지는 등 변경된 사항이 있는지 다시 한 번 확인 (STW 발생 -&gt; 멀티쓰레딩으로 시간 단축)      Concurrent Sweep : ReMark까지 검증 완료된 GC 대상을 삭제 (STW 없이 진행)        CMS GC는 Compact를 하지 않기 때문에 메모리 단편화를 신경써야 한다. 연속적으로 메모리 할당이 불가능할 정도까지 도달했으면  Compaction을 해야하는데, 이때 다른 GC의 Compaction보다Stop-The-World가 길다.  G1 GC (Garbage First GC)기존 CG 알고리즘으로 큰 메모리에서 효율이 좋지 못해서 개선하기 위해서 등장했다. 기존의 Heap과는 다르게 Region으로 나눠서 관리한다. https://1-7171771.tistory.com/140 Region이라는 논리적인 단위로 메모리를 관히하며, CMS와ㅏ 달리 Compaction을 진행하고 메모리 단편화 문제를 없앰. STW 시간을 예측할 수 있다.  Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간. 이 공간에서 GC가 효율적으로 일어나지 않는다.  Available/Unused : 아직 사용하지 않은, 비어있는 공간Young GC를 수행할 때 STW가 발생, 멀티쓰레드로 극복한다. Young GC는 Regionwnd GC 대상 객체가 가장 많은 Region에서 진행(Eden / Survivor).이 Region에서 살아남은 객체를 다른 Region(Survivor)로 옮기고 빈 Region을 Available/Unused로 돌린다.[1] : 하나의 메소드에 필요한 메모리 덩어리를 묶어서 스택 프레임이라고 한다. 하나의 메소드당 하나의 스택 프레임이 필요하며, 메소드를 호출하기 직전 스택 프레임을 자바 Stack에 생성한 후 메소드를 호출한다.[2] : 자바 코드를 실행할때 따로 -Xms과 -Xmx 옵션을 사용하면 힙 메모리의 초기 사이즈와 최대 사이즈를 조절할 수 있다.[3] : 자바 8부터 변경되었다. 이 영역은 Native 메모리 영역으로 JVM이 아닌 OS에서 관리되도록 변경됐다.[4] :  기본 값 15",
        "url": "//java/2024/05/18/java-series-03-Memory.html"
      }
      ,
    
      "java-2024-05-18-java-series-02-jvm-html": {
        "title": "[java Series] 02 Jvm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JVMJVMJava Virtual Machine의 줄임말이다.Java는 JVM이라는 가상머신을 거쳐서 OS에 도달한다. 이때 인식하는 것이 자바 바이트코드(Java Bytecode)이다. Java Compiler는 .java를 .class로 변환해준다. 여기서 자바 바이트 코드는 명령어의 크기가 1바이트이다.바이트 코드는 다시 실시간 번역기 또는 JIT(Just-In-Time)[1] 컴파일러에 의해서 바이너리 코드로 변환된다. 이때 변환은 모든 바이트 코드를 변환하는 것이 아니라 실행하기 전에 필요한 부분을 즉석으로 컴파일 하는 방식을 말한다.또한, 자주 쓰이는 코드는 캐싱해서 같은 부분을 반복적으로 번역(interpret)하지 않도록 한다.JVM은 크게 아래와 같이 이뤄져 있다.  클래스 로더(Class Loader)  실행 엔진(Execution Engine)          인터프리터(Interpreter)      JIT 컴파일러(Just-In-Time)      가비지 콜렉터(Garbage collector)        런타임 데이터 영역(Runtime Data Area)1. 클래스 로더JVM 내로 클래스 파일(*.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.2. 실행 엔진클래스를 실행시키는 엔진, 클래스로더가 JVM 내 런타임 데이터 영역에 바이트 코드를 배치시키고 이것은 실행 엔진에 의해서 실행된다. 바이트 코드는 바이너리 코드가 아니다. 그래서 실행 엔진은 바이트 코드를 JVM 내부에서 바이너리 코드로 변환한다.2.1.1. 인터프리터바이트 코드를 명령 단위로 읽어서 실행한다.2.1.2. JIT(HotSpot)인터프리터 방식으로 사용하기 직전 기계어로 변역하고 캐싱하여 이후에는 번역하지 않는 방식으로 동작한다.2.2 가비지 콜렉터[2]더 이상 사용하지 않는 인스턴스를 찾아 메모리에서 삭제한다.2.3 Runtime Data Area3. JDK? JRE?  JDK : Java Development Kit ( JRE + (javac, jdb, javadoc…))  JRE : Java Runtime Environment ( JVM + 자바 클래스 라이브러리)[1] : 크게 나눠서 HotSpot Vm과 같이 메소드(함수) 단위로 JIT하는 방식과 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하여 컴파일할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 추가적으로, 미리 컴파일된 코드를 실행하는게 아니라 런타임에 동적으로 코드를 생성하여 실행하므로 잠재적 보안 문제가 있다. 예를 들어 인텔 스펙터가 JIT에 의존하는 JS 엔진을 가진 브라우저에서만 발생했다.",
        "url": "//java/2024/05/18/java-series-02-jvm.html"
      }
      ,
    
      "java-2024-05-18-java-series-01-version-html": {
        "title": "[java Series] 01 Version",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자바 버전별 정보JDK 1.0  안정화 작업JDK 1.1  이너 클래스, JavaBeans, RMI, Reflection, Calendar 유니코드 지원Javabeans : 자바로 작성된 소프트웨어 컴포넌트\t&gt; 1. 기본 생성자가 반드시 존재해야한다. \t&gt; 2. 모든 속성은 비공개\t&gt; 3. 속성에 접근하고 꺼내올 수 있는 getter, setter 구성\t&gt; 4. Serializable 구현RMI : Remote Method Invocation의 약자로 분산 애플리케이션을 구축하는 데 사용, 한 시스템(JVM)에 상주하는 객체가 다른 JVM에서 실행 중인 객체에 액세스, 호출할 수 있도록 도와주는 메커니즘JDK 1.2  JIT(HotSpot), Collection Framework 등 추가J2SE 1.3  HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가J2SE 1.4assert, 정규표현식, IPv6, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가J2SE 5  Generics 추가  Annotation 추가  동시성 제어 API (Concurrency API) 추가  Enumeration 추가  Auto Boxing/ Unboxing 추가Java SE 7  Diamond Operator ( ‘&lt;&gt;’ ) 추가Java SE 8 (오라클 인수 이후)  Lambda Expression 지원  Method Reference 지원  인터페이스에 default method가 추가  Optional 추가  날짜와 시간 API 추가       //javax.time.Clock   Clock.systemUTC();                    //current time of your system in UTC.    Clock.millis();                        //time in milliseconds from 1/1/1970.        //javax.tme.ZoneId   ZoneId zone = ZoneId.of(“Europe/London”);        //zoneId from a timezone.    Clock clock = Clock.system(zone);            //set the zone of a Clock.        //javax.time.LocalDate   LocalDate date = LocalDate.now();            //current date    String day = date.getDayOfMonth();            //day of the month    String month = date.getMonthValue();            //month    String year = date.getYear();                //year        Stream API 추가  PermGenArea 제거 : java8이전에는 초기 설정시 PermSize, MaxPerSize를 성정해야 했는데 이후 MetaSpace로 변경됐다. MetaSpace는 런타임 시 메모리 요규 사항에 따라 자체 크기를 조정하며, 필요하다면 MaxMetaspaceSize 매개변수를 조정하여 양을 조정할 수 있다.## Permanent Generation- Permanent Generation은 Class 혹은 Method Code가 저장되는 영역- PermGen은 Heap에 속함- Default로 제한된 크기를 가짐## Metaspace- Metaspace는 Java 클래스 로더가 현재까지 로드한 class들의 메타 데이터가 저장되는 공간- JVM에 의해 관리되는 Heap이 아닌 OS 레벨에서 관리되는 Native 메모리 영역에 위치- Default로 제한된 크기를 가지고 있지 않고, 필요한 만큼 늘어남Java SE 9  모듈 시스템 jigsaw 등장 (https://www.baeldung.com/project-jigsaw-java-modularity)  A New HTTP Client : 8까지 사용하던 HttpURLConnection을 대체할 새로운 java.net.http 패키지 추가  JsShell : main 메소드 없이 코드를 테스트할 수 있는 대화식 REPL(Read-Eval-Print-Loop) 도구를 제공  Process API 개선 : OS 프로세스 관리 및 컨트롤을 위해 (java.lang.ProcessHandle, java.lang.ProcessHandle.Info)가 추가 됐다.  Try-With-Resource 개선  다이아몬트 연산자를 익명클래스에서도 사용할 수 있도록 개선됨  Interface Private Method 인터페이스 내에서 private 메소드 사용이 가능해짐  Optional To Stream :  Optional로 Stream을 생성할 수 있게 됐다.       &gt; Stream steram = Optional.of(1).stream();Java SE 10  Local-Variable Type Interface : 로컬 변수 타입 추론 기능이다. 로컬 변수 타입을 var로 선언할 수 있다.```javavar list - new ArrayList();\t//ArrayList 으로 추론var stream = list.stream();\t\t//Stream 으로 추론var numbers = List.of(1, 2, 3, 4, 5);\t//List 으로 추론for (var number : numbers){\t\t//Integer 추론\tSystem.out.println(number);}- Garbage Collector Interface : 다양한 GC의 코드 고립도를 향상하는 인터페이스 도입- Thread-Local Handshakes : VM safepoint를 수행할 필요 없이 개별 쓰레드를 stop하고 콜백을 수행할 수 있도록 추가VM safePoint :: “Stop The World”로 모든 쓰레드를 일시 정지시키는 작업    safepoint를 발생시키는 경우    - Garbage collection pauses    - Code deoptimization    - Flusing code cache    - Class redefinition    - Biased lock revocation    - Various debug operation- Root Certificates : HTTPS 통신에 쓰이는 root CA 목록을 OracleJdk에서도 가지게 됐다.# Java SE 11- HTTP 클라이언트(JEP 321) : java 9에 포함됐던 HTTP 클라이언트 API를 정식 채택, URLConnection 기반의 HTTP 개발보다 개선된 기능, 명명 규칙을 제공한다. 특히 HTTP 2.0을 지원하여 웹소켓도 포함되어있다.- 새로운 String 메소드 추가|     Method      |                          Description                           ||:---------------:|:--------------------------------------------------------------:||     strip()     |                         문자열 앞, 뒤 공백 제거                         || stripLeading()  |                          문자열 앞의 공백 제거                          || stripTrailing() |                          문자열 뒤의 공백 제거                          ||    isBlank()    | 문자열이 비어있거나 공백만 포함되어있을 경우 true (String.trim().isEmpty()와 결과 같음) ||     lines()     |                     문자열을 라인 단위로 쪼개는 스트림 반환                     ||    repeat(n)    |                   지정된 수 만큼 문자열을 반복하여 붙여서 반환                    |```java trim()은 U+0020이하의 값만 공백으로 인식(tab, CR, LF, 공백) 하지만 유니코드에는 외에 다른 공백을 제공하는데 이를 제거하려면 Character.isWhitespace(int)를 사용해야만 했다.Java SE 11 부터는 strip()을 사용하면 된다.  Lambda 파라미터로 var 사용    (var x, var y) -&gt; x.process(y) =&gt; (x, y) -&gt; x.process(y)      Java SE 12  문법적으로 Switch 문을 확장```java//기존 방식switch (day) {    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;}//Java SE 12 부터의 방식switch (day) {    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);}- 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선# Java SE 13- Switch 문 개선을 위한 'yield' 예약어 추가```javavar a = switch (day) {    case MONDAY, FRIDAY, SUNDAY:        yield 6;    case TUESDAY:        yield 7;    case THURSDAY, SATURDAY:        yield 8;    case WEDNESDAY:        yield 9;};  textBlock 추가    String str = \"\"\" This is text block\"\"\";      Java SE 14  12, 13에서의 Switch 문이 표준화되었다.      record( preview ) : java로 많은 상용구를 작성하는 수고를 덜어주는 record 클래스 도입```javafinal class Point {  public final int x;  public final int y;    public Point(int x, int y) {      this.x = x;      this.y = y;  }}// state-based implementations of equals, hashCode, toString// nothing else  //레코드 사용record Point(int x, int y) { }```  NullPointerException track: 어떤 부분에서 NPE가 발생헀는지 설명해준다.Java SE 15  textBlock / Multiline Strings가 공식 채택 준비됐습니다.  Sealed Classes ( preview ) 상속 가능한 클래스를 지정할 수 있는 봉인 클래스가 추가된다. 상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해있어야 한다.  EdDSA 암호화 알고리즘 추가  스케일링 가능한 낮은 지연의 가비지 컬렉터 추가(ZGC)[1]Java SE 16  jdk1.8부터 시작된 PermGen 대신 Metaspace를 지원하기 시작  OpenJdk의 버전관리가 git으로 변경되었습니다.  Unix-Domain Socket Channels : Unix 도메인 소켓에 연결할 수 있다.Java SE 17  RandomGenerator : 의사 난수 생성기를 통해서 예측하기 어려운 난수를 생성하는 API가 출시됐다.  M1 정식 지원Java SE 18  UTF-8이 기본 인코딩셋이 되었다.  Simple Web Server: 간편설정, 최소한의 기능으로 바로 사용 가능한 HTTP 파일 서버를 제공한다.  Relection 기능 리팩토링( 메소드 핸들을 이용해서 다시 구현 )  switch-case 패턴 매칭 preview  try-catch-finally deprecated  ( try-with-resources 권장)Java SE 19  VirtualThread, Foreign Function &amp; Memory API, Structured Concurrency, Vector API 등이 preview로 추가Java SE 20  VirtualThread(second preview), ScopedValue(incubated), StructuredConcurrency(SecondIncubate)Java SE 21  StringTemplate(preview)  Sequenced Collections  Generational ZGC  Switch Pattern Matching 정식 출시  Unnamed Patterns and Variables (Preview)  Virtual Thread 정식 출시  Windows 32-bit x86 제거 예정Java SE 22  G1 GC에 Region Pinning 기술을 구현해 지연 시간(latency) 단축  super() 호출 전에 다른 statement 실행을 가능하게함 (프리뷰 기능).  이름없는 변수 및 패턴. 안쓰는 변수 이름을 언더스코어(_)로 표기하는 것을 허용  StructuredConcurrency(secondPreview) : 쓰레드 캔슬, 셧다운에 의한 리스크를 줄이고 Observability 향상, 여러 쓰레드에서 실행되는 관련있는 작업들을 그룹핑하는 기능  ScopedValues(secondPreview) : 같은 쓰레드 내에서의 공유 데이터를 관리하기 위한 컨테이너 오브젝트. ThreadLocal과 비슷하지만 ThreadLocal의 단점을 보완해 더 적은 리소스를 사용하고 더 안전하다고 한다. (특히 VirtualThreads, StructuredConcurrency랑 같이 활용될 때)Java SE 23  2024/06/08 Preview  2024/09 GA[1] ZGC 메소드 핸들 ",
        "url": "//java/2024/05/18/java-series-01-Version.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
