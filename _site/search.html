<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | newkayak12.github.io</title>
	<meta name="description"
		content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>

  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2024-06-13-effective-java-series-53-optional-html": {
        "title": "[effective Java Series] 53.optional",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "옵셔널 반환은 신중히옵셔널이 나오기 전, 예외를 던지거나 null을 반환하거나 했다. 그러나 이는 에외를 예외답게 사용하지 않는다는 점과 stackTrace 캡쳐에 리소스가 크게 든다는 점NPE에 시달려야 한다는 점 불편한 점이 많았다.Optional은 자바 8에 추가 됐다. Optional은 원소 1개를 최대로 가지는 불변 컬렉션이다. Optional에서는 null이면 에러를 던질 수도, 기본 값을 할당할 수도 있다.NPE에서 비교적 자유로워진다. 예외검사와 NullCheck를 모두 겸할 수 있다. 굉장히 편리하지만 무조건 좋은건 아니다.Collection, Stream, Array 같은 컨테이너 타입은 Optional로 감싸면 원타입도 무거운데 optional로 감싸서 리소스가 너무 많이 든다. 박싱 타입도 같은 이유로지양하면 좋다. 그래서 OptionalInt, OptionalLong, OptionalDouble을 제공한다. 기본 타입으로 말이다. 또한 Optional를 컬렉션 키로 하는 것도 지양하자.",
        "url": "//2024/06/13/Effective-java-series-53.Optional.html"
      }
      ,
    
      "2024-06-13-effective-java-series-52-ifnullreturnarray-html": {
        "title": "[effective Java Series] 52.ifnullreturnarray",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "null 대신 빈 컬렉션이나 배열을 반환하자컨테이너(배열, 컬렉션)이 비었을 때 선택지는 null, 빈 컨테이너 둘 중 하나다. null을 값으로 생각하면 null을 리턴할 수도 있다. 그러나 NPE 등 고려할 것들이많아진다. 혹자는 빈 컨테이너 생성도 리소스라고 할지 모른다. 그러나 오히려 방어 로직이 훨씬 골치아픈 일이 될 수도 있다. 결론적으로 말하면 그렇고 하나씩 따져보자.  빈 컨테이너 생성? 성능에 큰 영향이 가지 않는다. : 이 정도 리소스 할당은 전혀 문제가 되지 않는 정도의 컴퓨팅 성능을 보인다.  빈 컨테이너를 그냥 반환하면 된다. : 빈 컨테이너를 확인하고 null을 반환하는 것보다 훨씬 간편하고 의미적으로도 맞다.  정말로 신경쓰이면 : Collection.emptyList(), Collection.emptyMap(), Collection.emptySet()을 반환하는 방법이 있다. 배열도 new int[0]을 반환하면 된다.",
        "url": "//2024/06/13/Effective-java-series-52.IfNullReturnArray.html"
      }
      ,
    
      "2024-06-13-effective-java-series-51-reallyusevarargs-html": {
        "title": "[effective Java Series] 51.reallyusevarargs",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "가변인수는 신중히가변 인수를 호출하면 인수 개수와 길이가 같은 배열을 만들도 배열에 저장해서 가변인수 메소드에 건낸다. 인수 개수는 런타임에 알 수 있다. 이런 불확실성은 왠지 모르게불편해지는 부분이다. 더군다나 인수가 1개 이상 필요한데, 가변 인수를 안 넘기면? 원소가 0인 배열이 만들어지고 이를 위한 방어 로직을 짜야한다.이 경우 꼭 필요한 원소는 파라미터로 선언하고 그 다음부터 가변인수로 만들면?int avg( int... values) {}//이거 대신int avg( int first, int... values) {}//이렇게 바꾸면?성능적으로 보면? 권장하지 않는다. 이 비용은 감당하기 싫으면서 유연성이 필요하다면?public void Record(){}public void Record(int var1){}public void Record(int var1, int var2){}public void Record(int var1, int var2, int var3){}public void Record(int var1, int var2, int var3, int var4){}public void Record(int var1, int var2, int var3, int var4, int... var5){}스프링에 있는 Jooq가 이런식으로 구현해놓은 경우가 있다. 이러면 마지막 케이스는 정말 극소수가 될거다. 자연스레 비용이 준다.",
        "url": "//2024/06/13/Effective-java-series-51.ReallyUseVarArgs.html"
      }
      ,
    
      "2024-06-13-effective-java-series-50-consideroverload-html": {
        "title": "[effective Java Series] 50.consideroverload",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "다중 정의는 신중히다중 정의된 메소드는 컴파일 타임에 정해진다. 그런데! 매개변수가 일전의 다중 정의 매개변수들을 모두 포함할 수 있는 다중정의라면? 해당 메소드 외는 호출될 가능성이 없다.import java.util.Collections;public String overloading(Set&lt;?&gt; set) {}public String overloading(List&lt;?&gt; set) {}public String overloading(Collection&lt;?&gt; set) {}위의 파라미터가 Collection&lt;?&gt;인 메소드만 열심히 호출된다. 다중정의한 메소드는 객체 런타임 타입은 중요하지 않다. 오로지 컴파일 타임에,오직 매개변수의 컴파일 타입에 의해 결정된다. 다중 정의는 혼동을 일으킬 여지가 있는 방식이다. 안전하게 하려면 매개변수 수가 같은 다중정의는 지양하는 것이 좋다.더구나 가변인수를 사용하는 메소드는 아예 꿈도 꾸지 않는게 좋다. 차라리 이름을 다르게 짓는게 낫다.가장 좋은 방법은 위의 여지가 없는 아예 명확히 구분되는 형식으로 다중정의하는 것이 최고다. 다중 정의의 실효성이야 확실하니 말이다.예를 들어import java.util.ArrayList;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.remove();의 경우에서 remove는 (Object o), (int index)가 있다. 여기서list.remove(1)을 던지면 둘 중 어떤걸 실행할까? Boxing된 (Object o)? (int index)?다중 정의의 최상의 결과는 언제 어떤 메소드가 불리는지는 모르는데 아주 명확히 잘 작동하는 경우다. 신경 쓸 게 없는 경우말이다.",
        "url": "//2024/06/13/Effective-java-series-50.ConsiderOverload.html"
      }
      ,
    
      "2024-06-13-effective-java-series-49-methodsignature-html": {
        "title": "[effective Java Series] 49.methodsignature",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "메소드 시그니처를 신중히 설계하자.고민할 점  메소드 이름을 신중히 짓자.  편의 메소드를 너무 많이 만들지 말자.  매개변수는 구성을 고민하자. 매개변수는 최대 4개 정도가 좋다. 특히 같은 타입이 연달아 나오면 문제가 된다.3번은 아래와 같은 기술로 헤쳐나갈 수 있다.  메소드를 쪼개거나  매개변수를 묶는 컨테이너 클래스를 만들거나  1 + 2의 빌더 패턴을 사용한다.여담으로 매개변수 타입은 클래스보다 인터페이스가 나을 수 있다. 그러면 유연성이 올라간다. 또한 단순 boolean 보다는 직관성을 위해서 Enum 두 개가 나을 수도 있다.",
        "url": "//2024/06/13/Effective-java-series-49.MethodSignature.html"
      }
      ,
    
      "2024-06-13-effective-java-series-48-depensiveclone-html": {
        "title": "[effective Java Series] 48.depensiveclone",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "방어적 복사본을 고려하자.자바는 시스템의 다른 부분과는 별개다. 그래서 불변식이 자연스레 지켜진다. 그럼에도 불변식을 지키기 위한 노력은 계속된다. 우리는 개발할 때 누군가는 이를 무너뜨리려한다고가정하고 방어적으로 프로그램을 작성해야 한다. 예를 들어 java.util.Date getter로 리턴해도 setYear같은 메소드를 콜하면 원본이 변경되므로불변식을 지킬 수 없다. 이런 경우 아예 복사본을 던질 수도 있다.매개변수 유효성 검사에서도 그 전에 방어적 복사본을 두고 복사본으로 검사하면 특히 멀티쓰레딩 환경에서 원본을 지킬 수 있다는 장점이 있다.public Period( Date start, Date end ) {    this.start = new Date(start.getTime());    this.end = new Date(end.getTime());        if( this.start.compareTo(this.end) &gt; 0 ) throw new IllegalArgumentException();}위 코드를 보면 이상하다 정상일지 아닐지 모르는 객체를 복사한다? 그러나 위에 기술한 바와 같이 멀티 쓰레딩 환경에서는 찰나에 어떤 문제가 생길지 모른다.검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격을 받을 경우 위 코드는 방어할 수 있다. 또한 clone을 사용하지 않았는데,clone 재정의로 어떻게 될지 모른다.public getDate() {    return this.date;}//...Period period = new Period();period.getDate().setYear(1);방어적 복사본을 반환해서 위의 불변식을 해치는 상황을 막을 수 있다. 방어적 복사가 불변 객체만을 위한건 아니다. 메소드든 생성자든 클라이언트가 제공한 객체의 참조를내부의 자료구조에 보관해야 한다면 그 객체가 잠재적으로 변경될 수 있는지 확인해야 한다. 확실할 수 없다면 복사본을 만들자.방어적 복사가 항상 옳은건 아니다. 성능 저하가 수반되고 항상 사용할 수 있는 건 아니다. 또한, 호출자가 컴포넌트 내부를 수정하지 않을거라는 확신이 있다면 방어적 복사를생략할 수도 있다. 또한 생략으로 영향이 클라이언트에게만 간다고 확신한다면 생략할 수도 있다.",
        "url": "//2024/06/13/Effective-java-series-48.DepensiveClone.html"
      }
      ,
    
      "2024-06-13-effective-java-series-47-chechparameter-html": {
        "title": "[effective Java Series] 47.chechparameter",
        "tags": "",
        "date": "June 13, 2024",
        "author": "",
        "category": "",
        "content": "매개변수가 유효한지 검사하라인덱스 값은 음수이면 안되며, 객체 참조는 null이 아니어야 한다. 뭐 이런 제약은 문서화 해서 남겨야 한다. 또한 메소드 시작점에 검사해서 오류를 미리 방지해야 한다.이 검사를 소홀이 하면 메소드 수행 중간 에러를 던지거나, 잘 실행됐는데 잘못된 결과를 반환하거나, 메소드 결과는 정상이지만 나중에 보면 객체가 오염되어 있다던가결론적으로 실패 원자성을 어기는 결과를 낳을 수 있다.이런 검사를 위해서 자바7에서 추가된 java.util.Objects.requireNonNull 등의 유틸 메소드로 검사를 하는 방법이 있다. 자바9에서는 checkFromIndexSize,checkFromToIndex, checkIndex 등의 메소드가 추가됐다. 혹은 assert로 유효성 검증을 할 수도 있다.또한 생성자 매개변수 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않도록 하기 위해서 필요하다. 몸체 실행 전, 그러니까 시작하자마자 검사해야한다는규칙에도 예외는 있다. 유효성 검사 비용이 너무 높거나 실용적이지 않으면 혹은 계산 중 암묵적으로 검사가 수행될 때말이다. 그러나 암묵적 유효성 검사는 어디까지나암묵적이다. 실패 원자성을 해칠 여지가 여전히 존재한다.",
        "url": "//2024/06/13/Effective-java-series-47.ChechParameter.html"
      }
      ,
    
      "2024-06-12-effective-java-series-46-parallelstream-html": {
        "title": "[effective Java Series] 46.parallelstream",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "병렬 스트림?자바 7부터 고성능 병렬 분해(Parallel decom-position) 프레임워크인 포크-조인을 추가했다. 자바 8부터는 병렬 파이프라인을 병렬 실행할 수 있는 스트림을 지원한다.이를 통해 동시성 프로그램을 작성하기 쉬워지고 있다. 그러나 남용하면 안된다.보통 병렬 스트림을 사용하면 무조건 더 빨라질거라고 생각하지만 그렇지 않다. 예를 들어 스트림을 병렬으로 나누느라 리소스를 더 가져간다거나 혹은 실패할 수도 있다.또한 중간 연산으로 limit을 사용하면 병렬 연산의 의미가 퇴색된다. limit을 사용하면 CPU 코어가 남으면 원소를 더 처리하고 제한 개수 이후 결과는 버려도 된다고가정한다. 이는 계산 하나하나 연산이 오래걸리는 작업이라면 버릴 결과를 위해서 연산을 하는 것과 같다.따라서 리소스, 병렬로 나눴을 때 효용성을 고려해야 한다. 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열int 범위, long 범위일 경우 효과가 좋다. 이들의 공통점은 순차적으로 실행할 때 참조 지역성이 뛰어다는 것이다.또한 종단 연산 중 reduction에 적합하다. min, max, count, sum, anyMatch, allMatch, noneMatch 같은 연산 말이다. 가변 축소하는collect는 그다지 병렬에 적합하지 않다.정리하면 스트림 병렬에는 주의해야 한다. 항상 행복한 결과가 있지는 않다. 성능이 나빠지거나 예상치 못한 동작을 발생할 수 있다. 또한 병렬화에 드는 추가 비용을 상쇄할 정도의결과가 나오지 않으면 단일 스트림이 낫다.",
        "url": "//2024/06/12/Effective-java-series-46.ParallelStream.html"
      }
      ,
    
      "2024-06-12-effective-java-series-45-usepurefunction-html": {
        "title": "[effective Java Series] 45.usepurefunction",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "스트림에서는 부작용 없는 함수를 사용하라스트림은 단순 API를 넘어 함수형 패러다임에 기초한 패러다임이다. 스트림 패러다임의 핵심은 일련의 변환으로 재구성하는 부분이다. 이때 각 변환 단계는 한 단계이전 결과를 받아 처리하는 순수 함수여야 한다. 순수 함수는 다른 가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다. 모두 sideEffect가 없다.",
        "url": "//2024/06/12/Effective-java-series-45.UsePureFunction.html"
      }
      ,
    
      "2024-06-12-effective-java-series-44-becarefulusestream-html": {
        "title": "[effective Java Series] 44.becarefulusestream",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "스트림을 주의해서 사용하자스트림은 유한/ 무한 시퀀스를 의미하거나, 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.스트림 파이프라인은 소스 스트림에서 시작해서 종단 연산으로 끝나며 그 사이에 하나 이상의 중간 연산이 있을 수 있다. 각 중간 연산은 스트림을 어떠한 방식으로변환한다.스트림 API는 메소드 연쇄를 지원하는 Fluent API다. 즉, 파이프 라인 하나를 구성하는 모든 호출을 연결해서 단 하나의 표현식으로 완성할 수 있다.스트림 API는 람다가 필수다. 람다의 부작용처럼 오히려 가독성이 떨어지기 시작한다. for로 되어 있는 기존 코드를 스트림을 사용하도록 리팩토링하는 건 좋다. 그러나 스트림으로 작성하는게 나아 보일 때만 반영하자. 또한 함수 객체로는 할 수 없지만 블록으로 할 수 있는 일들이 있다.  코드 블록에서는 지역변수를 읽고 수정할 수 있다. 그러나 람다는 final로 지역변수를 취급하기에 수정할 수 없다.  코드 블록에서는 return으로 흐름 제어할 수 있지만 람다, 스트림 중에는 불가능하다.그러나  시퀀스를 일관되게 변환  시퀀스를 필터링  시퀀스를 하나의 연산을 사용해서 결합한다.  시퀀스를 컬렉션에 모은다.  시퀀스에서 특정 조건을 만족하는 원소를 찾는다.라고 하면 스트림으로 리팩토링을 할 만하다.",
        "url": "//2024/06/12/Effective-java-series-44.BecarefulUseStream.html"
      }
      ,
    
      "2024-06-12-effective-java-series-43-usestandardfuntionalinterface-html": {
        "title": "[effective Java Series] 43.usestandardfuntionalinterface",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "표준 함수형 인터페이스 사용자바 8부터 함수형 인터페이스 지원으로 다양한 일을 할 수 있게 됐다. 그 쓰임새가 늘어남에 따라 java.util.function에는 다양한 용도의 표준 함수형 인터페이스가담겨 있다. 필요한 용도에 맞는게 있다면, 직접 구현하지 말고 이를 사용하는 것이 좋다. 보통 이름만으로 동작을 어느 정도 예측할 수 있기 때문이다. 만약 직접 구현해야한다면언제 구현하는게 좋을까?  자주 쓰이며, 이름 자체가 용도를 명확히 전달한다.  반드시 따라야할 규약이 있다.  유용한 디폴트 메소드를 제공할 수 있다.만일 직접 만들어 써야 한다면 네이밍 컨벤션을 잘 지키자. 그리고 표준 함수형 인터페이스에는 기본 타입만 지원하는 것을 볼 수 있는데, 직접 만들어 사용할 때도최대한 기본형을 사용하는 것을 추천한다. 동작은 가능하지만 박싱, 언박싱 과정이 리소스를 낭비한다. 또한 함수형 인터페이스도 인터페이스다. 배포하면 돌이킬 수 없다. 따라서 신중히 작성하자. 마지막으로 @FunctionalInterface를 사용하자 이 어노테이션을 붙이면 해당 인터페이스가 함수형 인터페이스 조건을 만족하는지 컴파일 타임에체크할 수 있다.",
        "url": "//2024/06/12/Effective-java-series-43.UseStandardFuntionalInterface.html"
      }
      ,
    
      "2024-06-12-effective-java-series-42-usemethodreference-html": {
        "title": "[effective Java Series] 42.usemethodreference",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "람다보다는 메소드 참조를 사용하라람다보다 더 간결하게 사용할 수 있다. 메소드 참조(Method reference)로 말이다. 매개변수 구성(수, 타입, 순서)이 같다면 람다 대신 메소드 참조를 전달하면같은 결과를 더 보기 좋게 얻을 수 있다. 메소드 참조가 람다를 대체하는 건 아니다. 람다로 할 수 없는 일은 메소드 참조로도 할 수 없다.단순히 메소드 참조는 람다로 구현했을 경우 길고 복잡해질 때 좋은 대안이 되어준다. 메소드 참조는 기능을 잘 드러내는 이름을 지어줄 수도 있다. 메소드 참조의 유형은아래의 다섯 가지다.  정적 메소드를 가리키는 메소드 참조  한정적 참조 - 수신 객체(receiving object)를 특정하는 한정적 인스턴스 메소드 참조 (함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 같다.)  비한정적 참조 - 수신 객체를 특정하지 않는 비한정적 인스턴스 메소드 참조 (함수 객체를 적용하는 시점에 수신 객체를 알려준다.)  클래스 생성자  배열 생성자            유형      예시      람다                  정적      Integer::parseInt      str -&gt; Integer.parseInt(str);              한정적(인스턴스)      Instant.now()::isAfter      t -&gt;  Instant.now.isAfter(t)              비한정적      String::toLowerCase      str -&gt; str.toLowerCase()              클래스 생성자      Object::new      () -&gt;     new Object();              배열 생성자      Object[]::new      () -&gt; new Object[0];      ",
        "url": "//2024/06/12/Effective-java-series-42.UseMethodReference.html"
      }
      ,
    
      "2024-06-12-effective-java-series-41-uselambda-html": {
        "title": "[effective Java Series] 41.uselambda",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "익명 클래스보단 람다.자바 8에 와서 추상 메소드 하나짜리 인터페이스는 특별한 의미를 인정 받게 됐다. 함수형 인터페이스로 말이다. 이 함수형 인터페이스는 자바 8에서 람다를 지원하는초석이 됐다.Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()))람다는 기존 익명 구현 객체보다 훨씬 간결하고 가독성도 월등히 높다. 또한 람다를 사용하면 컴파일러가 문맥을 보고 타입을 추론해준다.따라서 타입을 명시해야만 되는 경우가 아니고서야 굳이 매개변수 타입을 명시할 필요는 없다.그러나 람다는 이름도 없고 문서화도 하지 못한다. 따라서 코드 자체로 동작이 명확하지 않거나 너무 길어진다면 람다를 포기하는 게 좋다. 또한 람다는 자신을 참조할 수 없다. 람다 내부에서 this는 바깥 인스턴스를 가리킨다. 반대로 익명 구현 객체는 자신을 가리킨다. 상황에 따라 취사 선택하는 현명함을 보이자.",
        "url": "//2024/06/12/Effective-java-series-41.UseLambda.html"
      }
      ,
    
      "2024-06-12-effective-java-series-40-usemarkerinterface-html": {
        "title": "[effective Java Series] 40.usemarkerinterface",
        "tags": "",
        "date": "June 12, 2024",
        "author": "",
        "category": "",
        "content": "정의하는게 타입이라면 마커 인터페이스를 사용하자.아무 메소드 없이 단지 자신을 구현하는 클래스가 특정 속성을 가진다고 표시하는 인터페이스를 마커 인터페이스(marker interface)라고 한다. Serializable이 예다.마커 인터페이스는 타입으로써 역할을 하지만 마커 어노테이션은 그렇지 않다. 두 번쨰로 마커 인터페이스는 적용 대상을 더 정밀하게 지정할 수 있다.반대로 마커 어노테이션이 마커 인터페이스보다 나은 점은 어노테이션 시스템의 지원을 받는다는 점을 들 수 있다. 그러면 어노테이션, 인터페이스 언제 써야할까?클래스와 인터페이스 외 프로그램 요소에 마킹해야 할 때 어노테이션을 써야한다. 마킹이 된 객체를 매개변수로 받는다면 인터페이스를 쓰는 것이 좋다. 그러면컴파일 타임에 오류를 잡아낼 수 있다. 특히 어노테이션 적용 대상(Target)이 ElementType.TYPE이면 다시 한 번 생각해보는게 좋다.",
        "url": "//2024/06/12/Effective-java-series-40.UseMarkerInterface.html"
      }
      ,
    
      "programmers-2024-06-11-programmers-series-lv-01-failurerate-html": {
        "title": "[programmers Series] Lv. 01 Failurerate",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "카카오 - 실패율Programmers  슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.실패율은 다음과 같이 정의한다.스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.제한사항스테이지의 개수 N은 1 이상 500 이하의 자연수이다.stages의 길이는 1 이상 200,000 이하이다.stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.알고리즘  int, double을 잘 다루는가  자바 Comparator를 구현  자바에서 tuple 표현풀이class FailureRate {    @Nested    class TestCases {        @Test        public void case1 () {            int N = 5;            int[] stages = {2, 1, 2, 6, 2, 4, 3, 3};            int[] result = {3, 4, 2, 1, 5};            Assertions.assertArrayEquals(result, solution(N, stages));        }        @Test        public void case2 () {            int N = 4;            int[] stages = {4, 4, 4, 4, 4};            int[] result = {4, 1, 2, 3};            Assertions.assertArrayEquals(result, solution(N, stages));        }    }    public  int[] solution(int N, int[] stages) {        double[][] container = new double[N][2];        int[] answer = new int[N];        int size = stages.length;        for ( int i = 1; i &lt;= N; i ++ ) {            int count = 0;            for (int j = 0; j &lt; stages.length; j ++ ) {                if( i == stages[j] ) count++;            }            double[] element = new double[2];            element[0] = i;            if( size != 0 ) {                element[1] = count / (size * 1.0);            }            else if( size == 0 ) element[1] = 0.0;            container[i - 1] = element;            size -= count;        }        Arrays.sort(container, (o1, o2) -&gt; {            double result =  (o1[1] - o2[1]);            if (result != 0.0) return result &gt; 0 ? -1 : 1;            else {                return (int)(o1[0] - o2[0]);            }        });        for( int i = container.length - 1; i &gt;= 0; i --) answer[i] = (int) container[i][0];        return answer;    }}",
        "url": "//programmers/2024/06/11/Programmers-series-LV.-01-FailureRate.html"
      }
      ,
    
      "2024-06-11-effective-java-series-38-useroverrideannotation-html": {
        "title": "[effective Java Series] 38.useroverrideannotation",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "어노테이션을 일관되게 사용하라@Override 어노테이션은 해당 메소드가 재정의했음을 알리는 수단으로, 재정의한 대상이 올바른지, 정말로 재정의 했는지 컴파일러에서 체크하는 용도로 사용된다.어노테이션을 일관되게 사용하면 다양한 버그를 예방할 수 있다.예를 들어 재정의라고 생각하고 다중정의를 하고 @Override를 안 붙였다고 해보자. 오동작할지도 모른다. 코드 자체는 컴파일에 문제가 없으므로 이상함을 못느낄지도 모른다.@Override를 붙였다면 알 수 있는 ‘버그’다. 이와 같이 대부분의 경우 어노테이션을 일관되게 사용하는 것은 굉장히 중요하다.",
        "url": "//2024/06/11/Effective-java-series-38.UserOverrideAnnotation.html"
      }
      ,
    
      "2024-06-11-effective-java-series-37-userannotation-html": {
        "title": "[effective Java Series] 37.userannotation",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "명명 패턴보다 어노테이션명명패턴은 시그니쳐 네이밍 패턴으로 구분되어야하는 부분, 아닌 부분을 나누는 패턴을 의미한다. 좋은 시도지만 몇 가지 단점이 있다.  오타가 나면 안된다.  개발자가 의도한대로 실패없이 작동할거라는 보장이 없다.어노테이션, 위 문제를 해결해주는 강력한 도구다. Annotation을 선언하고 이후 AnnotationProcessor(javax.annotation.processing)로 이를 처리한다.Junit의 @Test가 적절한 예시이다. 단순히 마커 어노테이션으로써 마킹하고 이후 프로세싱하도록 한다. 이러면 비즈니스 로직은 그대로 두고 어노테이션의 관심사면처리할 수 있다. 보통 이 처리는 리플렉션으로 진행한다.어노테이션에도 매개변수를 선언해서 이를 처리에 활용할 수도 있다.  이와같이 생각보다 어노테이션으로 할 수 있는 일들은 많다. 굳이 명명 패턴으로 처리할 명분이 없다.",
        "url": "//2024/06/11/Effective-java-series-37.UserAnnotation.html"
      }
      ,
    
      "2024-06-11-effective-java-series-36-ifyouwanttoextanableenumthenuseinterface-html": {
        "title": "[effective Java Series] 36.ifyouwanttoextanableenumthenuseinterface",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "확장 할수 있는 열거 타입이 필요하면 인터페이스를 사용해라열거는 타입 안전 열거 패턴(type safe enum pattern)보다 우수하다. 타입 안전 열거 패턴은 클래스를 이용하고, 생성자를 private로 만들어 최초 정의된 객체만 참조할 수 있게 했다.하는 것을 의미한다. 열거가 타입 안전 열거보다 뒤지는건 확장성 하나다.보통 열거를 확장할 일은 거의 없다. 사용해야 한다면 열거 타입에 임의의 인터페이스를 구현하는 아이디어다.public enum BasicOperation implements Operation {    }과 같이 말이다. implements 한 타입을 연산의 타입으로 가져가면 된다. 이렇게 인터페이스로 확장 가능한 열거를 흉내내는데도 한계가 있다. 열거끼리 상속이 불가하다는 것이다. 아무 상태에도 의존하지 않는다면 디폴트 구현을 이용해서 인터페이스에 추가할 수 있다.",
        "url": "//2024/06/11/Effective-java-series-36.IfYouWantToExtanableEnumThenUseInterface.html"
      }
      ,
    
      "2024-06-11-effective-java-series-35-useenummapratherthanordinalindexing-html": {
        "title": "[effective Java Series] 35.useenummapratherthanordinalindexing",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "ordinal 인덱싱 대신 EnumMap을 사용하자배열이나 리스트에서 원소를 꺼낼 때 ordinal로 인덱로 사용한다고 해보자. 그러면 이전부터 있던 문제점이 노출된다. ordinal을 사용해서 정확한 정수 값을 사용한다는 보장이 없다.이 경우 EnumMap을 사용하는게 나을 수도 있다. EnumMap도 내부에 배열을 사용하기 때문에 성능적으로 전혀 밀리지 않는다. 내부 구현을 숨겨서 Map의 타입 안정성,배열의 성능을 모두 얻어냈다.",
        "url": "//2024/06/11/Effective-java-series-35.UseEnumMapRatherThanOrdinalIndexing.html"
      }
      ,
    
      "2024-06-11-effective-java-series-34-useenumsetratherthanbitfield-html": {
        "title": "[effective Java Series] 34.useenumsetratherthanbitfield",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "비트 필드 대신 EnumSetpublic class Text { public static final int STYLE_BOLD = 1 &lt;&lt; 0; public static final int STYLE_ITALIC = 1 &lt;&lt; 1; public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; public static final int STYLE_STRIKE_THROUGH= 1 &lt;&lt; 3; }이러고 Text.STYLE_BOLD | Text.STYLE_ITALIC 같이 하면 집합 연산을 수행할 수 있다.  그러나 비트 필드는 정수 열거 상수의 단점을 가지고 있으며 추가로  비트 필드(합, 교집합)에 맞춰서 모든 필드를 순회하는데 까다롭다.  최대 몇 비트가 필요할지 미리 예측해서 적절한 타입을 선언해야한다.등의 이슈가 있다. 차라리 java.util.EnumSet을 사용하는 방법이 있다. 내부는 비트 벡터로 이뤄져 있다.EnumSet.of(Text.STYLE_BOLD, Text.STYLE_ITALIC) 같이 사용하면 된다.",
        "url": "//2024/06/11/Effective-java-series-34.UseEnumSetRatherThanBitField.html"
      }
      ,
    
      "2024-06-11-effective-java-series-33-donotuseordinal-html": {
        "title": "[effective Java Series] 33.donotuseordinal",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "ordinal 대신 인스턴스 필드를 사용하자일전에 enum에 인스턴스 필드를 선언할 수 있다는 걸 알았다.public enum Planet {    MERCURY(1),    VENUS(2),    EARTH(3),    MARS(4),    JUPITER(5),    SATURN(6),    URANUS(7),    NEPTUNE(8);        private final int order;    Planet(int order) {        this.order = order;    }}같이 말이다. 자바에서는 열거에 ordinal을 제공한다. 열거 순서에 대한 값이다. 열거를 정수로 변환할 필요가 있을 떄 ordinal을 쓰고 싶어지지만 참자.상수 선언을 바꾸면 오동작할 가능성이 높으며, 이미 사용 중인 정수와 같이 같은 상수는 추가할 방법이 없다. 차라리 인스턴스에 정수를 저장하는게 좋다.사실 ordinal은 Enum의 API 문서를 보면 EnumSet, EnumMap 같이 열거 타입 기반의 범용 자료 구조에 쓸 목적으로 설계됐다고 한다. 따라서 이런 용도가 아니면절대로 사용하지 말자.",
        "url": "//2024/06/11/Effective-java-series-33.DoNotUseOrdinal.html"
      }
      ,
    
      "2024-06-11-effective-java-series-32-useenumeration-html": {
        "title": "[effective Java Series] 32.useenumeration",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "int 상수 대신 열거 타입을 사용하기정수 열거 패턴(int enum pattern)은 type-safe하지도 않고 표현력도 별로고 궁극적으로 프로그램이 깨지기 쉽다. 문자열 열거 패턴(String enum pattern)은 좋을까?더 나쁘다. 문자열 상수의 이름 대신 문자열 값을 하드코딩하게 만들기 때문이다.차라리 열거를 쓰는게 낫다. 열거는 밖에서 접근할 수 있는 생성자를 제공하지 않으니 사실상 final이다. 열거로 만들어진 인스턴스는 딱 하나씩만 존재함이 보장된다.싱글톤이다. 또한 열거 타입은 각자 네임스페이스가 있어서 열거 원소 간 이름이 겹쳐도 상관 없다. 또한 필드를 선언하고 생성자를 추가하여 열거에 특정 속성들을매핑할 수도 있다.public enum Planet {    MERCURY(1),    VENUS(2),    EARTH(3),    MARS(4),    JUPITER(5),    SATURN(6),    URANUS(7),    NEPTUNE(8);        private final int order;    Planet(int order) {        this.order = order;    }}enum Operator {    ADD {public double apply(double x, double y) {return x + y;}},    SUBTRACT {public double apply(double x, double y) {return x - y;}},    MULTIPLE {public double apply(double x, double y) {return x * y;}},    DIVIDE {public double apply(double x, double y) {return x / y;}};        public abstract double apply(double x , double y);}열거를 언제 사용하면 좋을까? 필요한 원소를 컴파일 타임에 다 알 수 있는 상수 집합이라면 열거가 좋다. 열거로 정의된 상수가 영원히 고정될 필요는 없다.",
        "url": "//2024/06/11/Effective-java-series-32.UseEnumeration.html"
      }
      ,
    
      "2024-06-11-effective-java-series-31-typesafecontainer-html": {
        "title": "[effective Java Series] 31.typesafecontainer",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "타입 안전 이종 컨테이너컨테이너 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 기를 함께 제공하는 설계 방식을 타입 안전 이종 컨테이너 패턴(type safe heterogeneous container pattern)이라고 한다.각 타입의 Class 객체를 매개변수화 할 수 있는데 Class&lt;T&gt;와 같은 형태가 된다. 이런 class 리터럴을 타입 토큰이라고 한다.컨테이너에 데이터를 넣을 때 데이터, 타입을 함께 넣고, 뺄 때 (Class&lt;T&gt;) type.cast()로 타입 캐스팅하고 리턴하면 된다. cast는 형변환 연산자의 동적 버전이다.여기서 주의할 것이 있다. 악의적인 클라이언트가 Class 객체를 raw 타입으로 넘기면 type-safe하지 않아질 수 있다. 두 번째로 class 리터럴에는 실체화 불가 타입을 사용할 수 없다. 즉, List&lt;String&gt;.class같은게 불가하단 소리다. 물론 슈퍼 타입 토큰 같은 것으로 해결하려는 노력은 있다. Class.getGenericSuperclass()와 ParameterizedType.getActualTypeArguments()를 사용해서 실제 타입을 가져올 수 있다.spring에서는 ParameterziedTypeReference라는 이름으로 슈퍼 타입 토큰을 지원한다.",
        "url": "//2024/06/11/Effective-java-series-31.TypeSafeContainer.html"
      }
      ,
    
      "2024-06-11-effective-java-series-30-becarefulusevarargswithgeneric-html": {
        "title": "[effective Java Series] 30.becarefulusevarargswithgeneric",
        "tags": "",
        "date": "June 11, 2024",
        "author": "",
        "category": "",
        "content": "제네릭과 가변인수를 함께 쓸 때는 신중하자가변 인수 메소드를 호출하면 가변인수를 담기 위한 배열이 자동으로 만들어진다. 메소드 선언히 실체화 불가 타입(제네릭)으로 매개 변수를 선언하면 컴파일러가 경고를보낸다. 힙 오염의 여지가 있기 때문이다. 매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생한다. 이는 컴파일러의 자동 형변환 실패할 수 있으니제네릭 의 근간이 무너진다.그런데, 왜 가변 인자를 메소드 시그니처에 선언할 수 있게 했을까? 편하니까다. 놀랍게도 말이다. 자바 7 이전까지는 호출자쪽에서 발생하는 경고를 무시할 수 없었다.@SafeVarargs이 자바7에서 추가되면서 경고를 숨길 수 있게 됐다. 당연히 @SafeVarargs를 쓸 때는 정당한 사유가 있어야 하며 어노테이션 만으로 메소드가 type-safe 함을 보장한다는 의미를 가지고 있으므로 주의해야한다. 추가로 당연히 주석도 달아야 한다.다시 돌아가서 제네릭 varargs를 안전하게 쓰려면 어떻게 하면 좋을까? readOnly로 인덱스에 접근하여 수정하지만 않으면 된다. 혹은 배열을 방어적 복사를 해서 뱉으면 된다.",
        "url": "//2024/06/11/Effective-java-series-30.BecarefulUseVarargsWithGeneric.html"
      }
      ,
    
      "effective-java-2024-06-10-effective-java-series-29-usegeneric-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 10, 2024",
        "author": "",
        "category": "",
        "content": "Object보다는 제네릭을 쓰자.Object를 사용하여 메소드, 클래스를 작성하면 필연적으로 형변환을 마주치게 된다. 이는 당연히 런타임 에러의 위험을 안고 있다. 그렇다면 굳이 Object로 선언하고형변환하는 불필요한 코드를 작성할 필요가 있을까?이 경우 제네릭을 사용하여, 컴파일 타임에 타입 체크를 받을 수 있으며, 형변환 하는 불필요한 코드를 줄일 수 있다. 그리고 이 편이 훨씬 type-safe하다.또한 &lt;E super Fruit&gt;나 &lt;E extends Fruit&gt; 등과 같이 범위 한정도 가능하며 &lt;E extends Comparable&lt;E&gt;&gt;와 같이 재귀적으로 타입한정도 가능하다.",
        "url": "//effective_java/2024/06/10/Effective-java-series-29.UseGeneric.html"
      }
      ,
    
      "effective-java-2024-06-10-effective-java-series-28-userlistratherthanarray-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 10, 2024",
        "author": "",
        "category": "",
        "content": "배열보다 리스트Sub가 Super의 하위 타입이면 Sub[]는 Super[]의 하위 타입이 된다. 배열은 공변(covariant)이기 떄문이다. 그러나 제네릭은 불공변(invariant)다.보통 제네릭이 문제가 있다고 생각할 수 있다.Object[] arr = new Long[3]은 컴파일은 된다. 런타임에 ArrayStoreException을 낸다.  그러나 List&lt;Object&gt; list = new ArrayList&lt;Long&gt;()은컴파일조차 되지 않는다. 즉, 제네릭이 정상이고 배열쪽이 비정상이라는 소리다.그럼 제네릭으로 배열을 만들면 되지 않을까? 일단 정상적인 방법으로는 허용하지는 않는다.배열은 컴파일에 체크 되지만 실질적으로 런타임에 저장 가능한지를 체크한다. 그래서 위와 같은 경우가 허용되지 않는다.즉, 실체화가 된다. 그러나 제네릭은 런타임에 타입이 소거된다. 즉 컴파일 타임에만 강하게 검사한다. 이는 런타임에는 타입을 알 수 없음을 의미한다. 즉, type-safe하지 않기에 허용하지 않는다. 제네릭은 실체화 불가 타입이라고 한다.  실체화되지 않아서 오히려 런타임에는 컴파일보다 타입 정보를 적게 가진다.위에서 제네릭 배열은 ‘정상적인 방법’에서는 컴파일 타임에 에러를 낸다고 했다. 가능은 하다. 가변인자로 제네릭을 받을 수 있다. 그러나 난해한 경고 메시지를 뱉는다.물론 @SafeVarargs로 대처할 수 있다. 이는 해당 어노테이션과 함께 ‘왜 무시할 수 있는지?’ 이유를 주석으로 남겨야함을 의미한다.또한 Object[]을 만들고 제네릭으로 형변환을 할 수도 있다. 이래도 경고를 뱉는다.차라리 List&lt;E&gt;를 사용하는 편이 낫다.",
        "url": "//effective_java/2024/06/10/Effective-java-series-28.UserListRatherThanArray.html"
      }
      ,
    
      "effective-java-2024-06-10-effective-java-series-27-suppressuncheckedexception-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 10, 2024",
        "author": "",
        "category": "",
        "content": "비검사 경고 지워나가가기Set&lt;String&gt; test = new HashSet();이런 코드를 작성하면 Set와 로타입인 HashSet 간의 타입 차이로 에러가 발생한다. 자바 7부터 다이아몬드 연산자 (&lt;&gt;)로 타입 추론이 되긴 하지만이를 작성하지 않으면 컴파일러는 경고한다.경고 자체를 제거할 수는 없지만 타입이 안전한게 확실하다면 @SuppressWarning(\"unchecked\")로 경고를 숨길 수 있다. 이 어노테이션은 너무 남발하면 좋지 않다.예상치 못한 곳에서 런타임에 에러가 발생할 수도 있기 때문이다. 때문에 최대한 좁은 범위에 적용해야한다. 또한 위 어노테이션을 사용했다면 경고를 무시해도 된다고 선언하는 것과 같으므로 꼭 주석으로 왜 무시해도 되는지?를 남기는 것이 좋다.",
        "url": "//effective_java/2024/06/10/Effective-java-series-27.SuppressUncheckedException.html"
      }
      ,
    
      "effective-java-2024-06-10-effective-java-series-26-donotuserawtype-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 10, 2024",
        "author": "",
        "category": "",
        "content": "로 타입은 사용하지 말라로 타입이란 제네릭이 들어갈 자리에 아무 것도 지정하지 않은 타입을 일컫는다. 각가의 제네릭 타입은 일련의 매개변수화 타입(Parameterized type)을 정의한다.List&lt;String&gt;을 정의하면 String이 매개변수화 타입이 된다. 로 타입은 타입선언에서 제네릭 타입 정보가 모두 지워진 것처럼 동작하는데, 제네릭이 출시되기전 코드와 호환선을 위해서 제공되는 타입이다.제네릭을 사용하면 컴파일러는 해당 요소를 다루는 곳에서 묵시적으로 형변환을 하여 절대 실패하지 않음을 보장한다. 그러나 로 타입을 쓰면 제네릭이 주는 안정성과 표현력 둘 다잃게 된다.로 타입을 사용할 수는 있다. 동작은 한다. 그러나 type-safe 하지 않다. 따라서 비한정 와일드 카드 타입(unbounded wildcard type)을 대신 사용하는 것이 좋다.List&lt;?&gt;와 같이 물음표가 붙을 것을 왕왕 볼 수 있다. 이러면 범용적인 타입이 된다.예외적으로 로타입을 사용하는 경우가 있는데 class 리터럴이다. 예를 들어 List.cass, Map.class다. List&lt;String&gt;.class는 불가능하다.",
        "url": "//effective_java/2024/06/10/Effective-java-series-26.DoNotUseRawType.html"
      }
      ,
    
      "effective-java-2024-06-10-effective-java-series-25-keyword-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 10, 2024",
        "author": "",
        "category": "",
        "content": "용어 정리            한      영      예시                  매개변수화 타입      parameterized type      List              실제 타입 매개변수      actual type parameter      String              제네릭 타입      generic type      List              정규 타입 매개변수      formal type parameter      E              비한정적 와일드카드 타입      unbounded wildcard type      List&lt;?&gt;              로 타입      raw type      List              한정적 타입 매개변수      bounded type parameter                    재귀적 타입 한정      recursive type bound      &lt;T extends Comparable&gt;              한정적 와일드 카드 타입      bounded wildcard type      List&lt;? extends Number&gt;              제네릭 메소드      generic method      static List asList( E [] a ) { ... }              타입 토큰      type token      String.class      ",
        "url": "//effective_java/2024/06/10/Effective-java-series-25.Keyword.html"
      }
      ,
    
      "effective-java-2024-06-09-effective-java-series-24-donotdefinemultipleclassinafile-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 9, 2024",
        "author": "",
        "category": "",
        "content": "톱레벨 클래스는 한 파일에 하나만한 파일에 여러 개의 클래스를 담을 수 있다. ( swift가 한 파일에 여러 struct를 선언하곤 한다. ) 그러나, 이렇게 되면 컴파일 순서에 따라 동작이 달라질 수도 있다.Mango.javaclass Mango {    static final String NAME = \"mango\";}class Apple {    static final String NAME = \"apple\";}Apple.javaclass Mango {    static final String NAME = \"mango juice\";}class Apple {    static final String NAME = \"apple juice\";}Main.javaclass Main {    public static void main(String[] args) {        System.out.println(Apple.NAME + \" - \" + Mango.NAME);    }}이러면 컴파일 순서에 따라서 다르게 출력된다.",
        "url": "//effective_java/2024/06/09/Effective-java-series-24.DoNotDefineMultipleClassInAFile.html"
      }
      ,
    
      "effective-java-2024-06-09-effective-java-series-23-usememberclassasstatic-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 9, 2024",
        "author": "",
        "category": "",
        "content": "중첩 클래스는 static으로 만들길 추천한다.중첩 클래스는 다른 클래스 안에 정의된 클래스를 의미한다 종류는 ‘정적 멤버 클래스, ‘비정적 멤버 클래스’, ‘익명 클래스’, ‘지역 클래스’ 네 가지로 나뉜다.이 중 첫 번째 빼고는 모두 내부 클래스(inner class)에 속한다.정적 멤버 클래스는 보통 바깥에 노출하고 쓸 때 유용한 도우미 클래스로 쓰인다.비정적 멤버 클래스는 암묵적으로 바깥 클래스의 인스턴스와 암묵적으로 연결된다( 메모리 누수의 원인이 되기도 한다. ). 왜냐하면 비정적 멤버 클래스는 바깥 인스턴스 없이 생성할 수 없기 때문이다. 이런 비정적 멤버 클래스는 어댑터 정의, 다른 클래스의 인스턴스처럼 보이게하는 뷰로 주로 사용한다. 그러나 보통 위의 원인으로 바깥 인스턴스에서 접근할 일이 없다면 static을 붙이는게 메모리 누수 문제 해결에 좋다.익명 클래스는 익명 구현 객체라고 보면 된다. 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다. 익면 클래스는 instanceof, 클래스 이름이 필요한 작업 등을 수행할 수 없다.지역 클래스는 지역 변수 선언하는 곳에 클래스를 선언하는 것으로 거의 쓸 일이 없다.",
        "url": "//effective_java/2024/06/09/Effective-java-series-23.UseMemberClassAsStatic.html"
      }
      ,
    
      "effective-java-2024-06-09-effective-java-series-22-usehierarchicalstructure-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 9, 2024",
        "author": "",
        "category": "",
        "content": "태그 달린 클래스보다는 계층 구조 활용하기태그 값으로 두 가지 역할을 하는 클래스를 본 적 있을 것이다. 이런 클래스는 여러 구현이 혼합되어 가독성이 떨어진다. 또한 final을 필드에 선언했다면 쓰지 않더라도생성자 초기화를 진행해야 한다. 거기다 새로운 구현을 추가한다면? switch-case도 늘려야한다. 이와 같이 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.이는 계층 구조를 어설프게 흉내낸 것이다.차라리 abstract class를 두고 태그 마다 새로운 클래스를 확장하는게 더 나은 선택지가 될 수 있다. 그러면 case도 추가하지 않아도 되고, 루트 클래스를직접 건들 필요도 없으며, 확장의 유연성 또한 증가한다.",
        "url": "//effective_java/2024/06/09/Effective-java-series-22.UseHierarchicalStructure.html"
      }
      ,
    
      "effective-java-2024-06-09-effective-java-series-21-useinterfaceastypesetter-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 9, 2024",
        "author": "",
        "category": "",
        "content": "인터페이스는 타입 정의 용도로 사용하자인터페이스를 구현한다는 것은 ‘자신의 인스턴스로 무엇을 할 수 있는지’를 클라이언트에게 알리는 역할을 한다. 이런 인터페이스에public interface Fruits {    static final String STRAWBERRY = \"Strawberry\";    static final String PINE_APPLE = \"Pineapple\";}와 같은 상수 인터페이스를 구현하는 것은 내부 구현을 외부에 노출하는 것과 같다. 차라리 위와 같이 사용할 거라면public class Fruits {        private Fruits(){};        public static final String STRAWBERRY = \"Strawberry\";    public static final String PINE_APPLE = \"Pineapple\";}와 같은 상수 유틸 클래스나.public enum Fruits{    STRAWBERRY(\"Strawberry\"), PINE_APPLE(\"Pineapple\");        private String name;    public Fruits (String name) {        this.name = name;    }        public String getName() { return this.name; }}와 같은 enum을 쓰는게 낫다.",
        "url": "//effective_java/2024/06/09/Effective-java-series-21.UseInterfaceAsTypeSetter.html"
      }
      ,
    
      "programmers-2024-06-08-programmers-series-lv-01-dart-html": {
        "title": "[programmers Series] Lv. 01 Dart",
        "tags": "",
        "date": "June 8, 2024",
        "author": "",
        "category": "",
        "content": "카카오 - 다트 게임Programmers  카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.다트 게임은 총 3번의 기회로 구성된다.각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고)스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고)스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.입력 형식\"점수|보너스|[옵션]\"으로 이루어진 문자열 3세트.예) 1S2D*3T점수는 0에서 10 사이의 정수이다.보너스는 S, D, T 중 하나이다.옵선은 *이나 # 중 하나이며, 없을 수도 있다.알고리즘단순 배열 사용과 char에 대한 사용풀이class Dart {    @Nested    public class TestCases {        @Test        @DisplayName(\"1S2D*3T - 37\")        void case1 () {            String dartResult = \"1S2D*3T\";            int result = 37;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1D2S#10S - 9\")        void case2 () {            String dartResult = \"1D2S#10S\";            int result = 9;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1D2S0T - 3\")        void case3 () {            String dartResult = \"1D2S0T\";            int result = 3;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1S*2T*3S - 23\")        void case4 () {            String dartResult = \"1S*2T*3S\";            int result = 23;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1D#2S*3S - 5\")        void case5 () {            String dartResult = \"1D#2S*3S\";            int result = 5;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1T2D3D# - -4\")        void case6 () {            String dartResult = \"1T2D3D#\";            int result = -4;            Assertions.assertEquals(result, solution(dartResult));        }        @Test        @DisplayName(\"1D2S3T* - 59\")        void case7 () {            String dartResult = \"1D2S3T*\";            int result = 59;            Assertions.assertEquals(result, solution(dartResult));        }    }    public  int solution(String dartResult) {        int[] numbers = new int[3];        int idx = 0;        for ( int i = 0; i &lt; dartResult.length(); i ++ ) {            char now = dartResult.charAt(i);            if( Character.isDigit(now) ) {                if( now == '1' &amp;&amp; dartResult.charAt(i + 1) == '0') {                    i += 1;                    numbers[idx] = 10;                } else {                    numbers[idx] = now - 48;                }                idx += 1;            }            if( Character.isAlphabetic(now)) {                switch (now) {                    case 'S':                        numbers[idx - 1] = (int) Math.pow(numbers[idx - 1], 1);                        break;                    case 'D':                        numbers[idx - 1] = (int) Math.pow(numbers[idx - 1], 2);                        break;                    case 'T':                        numbers[idx - 1] = (int) Math.pow(numbers[idx - 1], 3);                        break;                }            }            if( now == '#' || now == '*') {                switch (now) {                    case '#':                        numbers[idx - 1] = numbers[idx - 1] * -1;                        break;                    case '*':{                        if( idx - 1 &gt; 0 ) numbers[idx - 2] = numbers[idx - 2] * 2;                        numbers[idx - 1] = numbers[idx - 1] * 2;                    }                }            }        }        int answer = 0;        for( int number : numbers ) answer += number;        return answer;    }}",
        "url": "//programmers/2024/06/08/Programmers-series-LV.-01-Dart.html"
      }
      ,
    
      "effective-java-2024-06-07-effective-java-series-20-considerimplementtarget-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 7, 2024",
        "author": "",
        "category": "",
        "content": "인터페이스 작성 시 구현을 염두하고 설계하자인터페이스에도 디폴트 메소드가 추가됐다. 하지만 모든 상황을 고려하여 불변식을 해치지 않는 디폴트 메소드를 작성하는 것은 어렵다. 예를 들어 디폴트 메소드를 추후 추가하여 기존 구현에서 구현을 수정하지 않게 되면 기존 구현에 문제가 생긱는 경우들이 있다.(책에서는 이 예시로 apache.commons.collections4.collection.SynchronizedCollection를 들었다. )컴파일에 성공하더라도 디폴트 메소드는 기존 구현체에 런타임 오류를 일으킬 수도 있다. 따라서 꼭 필요한 경우가 아니면 기존 인터페이스에 디폴트 메소드를 추가하는 것은지양하는게 좋다. 해야만 한다면 기존 구현체와 충돌할지도 고려하는게 좋다( 물론 어려워 보인다. )결론적으로 인터페이스는 릴리즈 후 수정할 수 있다는 가능성을 염두하지 않는 것이 좋아 보인다.",
        "url": "//effective_java/2024/06/07/Effective-java-series-20.ConsiderImplementTarget.html"
      }
      ,
    
      "effective-java-2024-06-07-effective-java-series-19-useinterfaceratherthanabstractclass-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 7, 2024",
        "author": "",
        "category": "",
        "content": "추상 클래스보다는 인터페이스를 우선하라자바에서 다중 상속이 불가능하다는 한계점이 있다. 반면 인터페이스는 구현한 클래스가 규약만 잘 지킨다면 어떤 클래스를 상속했든 같은 타입으로 취급한다.기존 클래스에도 손쉽게 인터페이스를 구현할 수 있다.이런 인터페이스는 믹스인(mixin) 정의에 안성 맞춤이다. 믹스인을 구현한 클래스에 원래 원 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.(swift의 protocol과 유사한 것 같다.) 이처럼 대상 타입의 주된 기능에 선택적 기능을 혼합 한다고 해서 믹스인이라고 부른다.인터페이스로는 계층 구조가 없는 타입 프레임 워크를 만들 수 있다. 만일 상속을 이용했다면 소위 말하는 조합 폭발이 벌어졌을 수도 있는 상황에도 인터페이스는 유연하게대응할 수 있다.한 편 인터페이스와 abstract class를 함께 사용하는 추상 골격 구현(skeletal implementation)을 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취한느 방법 도 있다.import java.util.Map;public abstract class AbstractMapEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {    }",
        "url": "//effective_java/2024/06/07/Effective-java-series-19.UseInterfaceRatherThanAbstractClass.html"
      }
      ,
    
      "effective-java-2024-06-07-effective-java-series-18-considerinheritance-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 7, 2024",
        "author": "",
        "category": "",
        "content": "상속을 고려하거나 아니면 아예 금지하라상속용 클래서는 override 할 수 있는  메소드들은 어떻게 내부적으로 사용하는지 문서로 남겨야 한다. 그렇지 않으면 재정의로 예기치 못한 상황이 벌어질 수도 있다.특히 ‘Implementation Requirements’로 시작하는 절은 그 메소드의 내부 동작 방식을 설명하는 곳이다. @ImplSpec을 붙이면 자바독 도구가 생성한다.이는 API 문서가 ‘어떻게’가 아니라 ‘무엇’을 하는지 설명해야 한다는 지향점과 대치된다. 그렇지만 클래스를 안전하게 상속할 수 있도록 하기 위해서는 위와 같은내부 구현 방식을 설명해야 한다.물론 상속에 의한 영향도룰 줄이려면 외부 노출을 줄이는게 맞지만 너무 적게 노출하면 상속으로 얻는 이점마자 없앨 수 있다. 그러니 주의해야 한다. 필요하다면 직접 구현해서 영향도를 평가해보는 방법도 좋다.또한, 상속용 클래스 생성자는 직/간접적으로 재정의 가능 메소드를 생성자에서 호출하면 안 된다. 추가적으로 clone, readObject도 생성자와 비슷한 효과를 내므로이들 또한 재정의 가능 메소드를 호출해서는 안 된다.아예 상속을 금지하는 것도 좋은 방법이다. 1) final로 선언하거나 2) 모든 생성자를 private, package-private로 선언하고 public 정적 팩토리를 만드는 방법도 있다. (물론 이런 문제들 때문에 상속을 허용할 클래스만을 지정하는 permit이 생겼다.)public sealed class GameCharacter permits Kirby, Mario {}public class Kirby extends GameCharacter { } //Opublic class Mario extends GameCharacter { } //Opublic class Sonic extends GameCharacter { } //X",
        "url": "//effective_java/2024/06/07/Effective-java-series-18.ConsiderInheritance.html"
      }
      ,
    
      "programmers-2024-06-06-programmers-series-lv-01-crane-html": {
        "title": "[programmers Series] Lv. 01 Crane",
        "tags": "",
        "date": "June 6, 2024",
        "author": "",
        "category": "",
        "content": "카카오 - 크레인 게임Programmers알고리즘단순 순회와 단순 스택 이용풀이public class Crane {    @Nested    public  class TestCases {            @Test        public void case1 () {            int[][] board = {                    {0, 0, 0, 0, 0},                    {0, 0, 1, 0, 3},                    {0, 2, 5, 0, 1},                    {4, 2, 4, 4, 2},                    {3, 5, 1, 3, 1}            };            int[] moves = {1,5,3,5,1,2,1,4};            int result = 4;                Assertions.assertEquals(solution(board, moves), result);            }    }    public  int solution( int [][] board, int[] moves) {        int answer = 0;        Stack&lt;Integer&gt; bucket = new Stack&lt;&gt;();        for( int move : moves ) {            for( int i = 0; i  &lt; board.length; i ++ ) {                int number = board[i][move - 1];                if( number != 0 ) {                    board[i][move - 1] = 0;                    if(!bucket.isEmpty() &amp;&amp;number ==  bucket.peek()) {                        bucket.pop();                        answer += 2;                    } else bucket.add(number);                                             break;                }            }        }        return answer;    }}",
        "url": "//programmers/2024/06/06/Programmers-series-LV.-01-Crane.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-17-usecomposition-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "상속보다는 컴포지션상속은 코드 재사용의 기초지만 항상 최선은 아니다. 상위 - 하위 클래스를 모두 같은 프로그래머가 개발하면 안전하지만 다른 패키지의 구체 클래스를 상속하는 것은 위험하다. 이는 캡슐화를 무력화하는 방법 중 하나다. 또, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스에 이상 동작을 일으킬 수 있다.  예시로 상위 클래스가 자기 사용을 할 경우내부 구현이 언제 바뀔지 몰라서를 들 수 있다.아니면 아예 재정의를 해서 상위 메소드 내용을 배제하는 방법도 있다. 이러면 상위 구현을 완전 다시 구현해야 해서 난이도가 급격하게 올라간다. 또한, 상위 메소드가상위 private 필드를 사용하면 하위에서 접근할 방법이 없다는 것도 문제다. 결국 이러면 아예 새로 만드는 게 나을 수 있다.우회로 비슷한 기능을 다른 이름 메소드로 만들었다고 쳐도 운 없에 상위에서 같은 시그니쳐로 메소드를 만들면 결국 override가 되어버린다.결국 어떻게 해도 상위 클래스를 상속 받는 것은 문제의 소지가 있다. 추가적으로 상속은 하위에서도 그 결함을 승계하는 문제도 있다.차라리 새로운 클래스를 만들고 상위 클래스를 새로 만든 클래스의 private 필드로 두는게 나을 수도 있다. 이런 클래스를 래퍼 클래스, 기능을 덧씌운다고 해서 데코레이터 패턴(DecoratorPattern), 넓게는 위임(Delegate)패턴이라고 부른다. (참고로 내부 객체에 자신의 참조를 넘기는 경우 위임에 해당한다.)래퍼클래스라고 아예 단점이 없는건 아니다 콜백 처리를 할 수 없다는 것이 문제다. 상위는 래퍼 객체의 this를 알 수 없다.",
        "url": "//effective_java/2024/06/05/Effective-java-series-17.useComposition.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-16-minimizethepossibilityofchange-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "변경 가능성을 최소화하자불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.  객체의 상태를 변경하는 메소드를 제공하지 않는다.  클래스를 확장할 수 없도록 한다. (클래스에 final 선언 혹은 public 생성자에 exception 던지도록)  모든 필드를 final로 선언  모든 필드를 private로 선언  자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.불변 객체는 근본적으로 ThreadSafe 처리할 필요는 없다. 또한 불변 클래스는 인스턴스 캐싱을 해서 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리를 제공할 수 있다.이렇게 하면 메모리 사용량과 GC 비용이 줄어든다. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다. 예를 들어 BigInteger의 negate 메소드는 크기가 같고 부호만 반대라면 새로운 BingInteger를 생성하는데 원본 인스턴스를 공유한 다른 인스턴스를 (리소스를 최소한으로 하는 방향으로)만들 수 있다. 또한 불변 객체는 그 자체로 실패 원자성을 제공한다. (불변이기에 실패해도 내부 값은 유효하다.)단점 역시 존재한다. 값이 다르면 반드시 다른 독립된 객체로 만들어야 한다. 이를 해소하는 방법은 미리 연산을 예측해서 기본 기능을 만들거나 예측할 수 없다면 가변 동반 클래스로 제공하는 것이다. 예를 들어 StringBuilder가 있다.  여튼 정리하면 public class - private field를 기본으로 하자.  가능하면 불변 클래스를 만들기 위해서 필드에 final을 붙이자. 그게 아니더라도 최대한 붙이자  그리고 getter/ setter를 쓰자! 무조건은 아니다.  생성자는 불변성을 띨 수 있는 초기화가 모두 완료된 완벽한 상태의 객체를 생성해야 한다.",
        "url": "//effective_java/2024/06/05/Effective-java-series-16.MinimizeThePossibilityOfChange.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-15-donotusepublicfield-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "public 클래스에서는 public 필드가 아닌 getter/setter를 쓰자class Point {    private double x;    private double y;        public double getX () {        return this.x;    }        public double getY() {        return this.y;    }        public void setX( double x ) {        this.x = x;    }    public void setY( double y ) {        this.y = y;    }}데이터 필드에 직접 접근을 막되 정해진 루트로만 접근할 수 있게 해서 캡슐화 이점을 제공하는 예시이다.물론 모든 클래스에 저런 처리가 필요한건 아니다. package-private 클래스 혹은 private 클래스라면 데이터 필드를 노출해도 전혀 문제가 없다.",
        "url": "//effective_java/2024/06/05/Effective-java-series-15.DoNotUsePublicField.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-14-minimizeaccessrights-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "클래스, 멤버의 접근 권한 최소화캡슐화, 내부 데이터, 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는가에 대한 내용이다.  여러 컴포넌트를 병렬로 개발할 수 있다.  시스템 관리 포인트를 줄일 수 있다. 다른 컴포넌트로 교체하는 부담도 적다.  정보 은닉 자체가 성능을 높이지는 않지만, 성능 최적화에 도움을 준다. ( 서로 간섭이 적기에 디버깅이 편하다. )  외부 의존도가 떨어지므로 라이브러리의 경우 유지보수가 용이해준다.기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다. 그렇지 않으면 open 되므로 하위 호환을 위해서 영원히 기존 구현을 바꿀 수 없게 된다.그런데 멤버 접근성을 좁히지 방해하는 제약이 있다. 상위 클래스 메소드 보다 접근 수준을 좁게 설정할 수 없다. 이 제약은 리스코프 치환 원칙을 지키기 위해 필요하다.public 클래스 멤버를 private로 하는 것이 기본이다. package-private까지 낮추는 건 괜찮지만 pulblic은 정말 아니어야만 한다. public 가변 필드를두면 ThreadSafe하지 않다. final을 붙이면 내부 구현을 바꿀 수 없어서 리팩토링에 제약이 생긴다. 특히 배열은 public static final로 두거나 이 필드를 반환하는 접근자 메소드를 두면 배열이 변경 가능성이 있으므로 제공하지 않는 것이 좋다.추가로 두 가지 암묵적 접근 수준이 있다. 모듈은 자신에 속하는 패키지 중 공개(export)할 것들을 선언할 수 있다. 모듈 시스템을 활용하면 클래스를 외부에 공개하지않으면서도 같은 모듈을 이루는 패키지 사이에는 자유롭게 공유할 수 있다.",
        "url": "//effective_java/2024/06/05/Effective-java-series-14.MinimizeAccessRights.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-13-comparable-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "Comparable 구현 고려하기Comparable 역시 믹스인 인터페이스다. compareTo는 단순 동치성 비교에 더해서 순서까지 비교할 수 있으며, 제네릭하다.compareTo의 규격은 equals와 비슷하다.  객체 간 순서를 비교한다. 작으면 음수, 같으면 0 크면 양수  Comparable을 구현한 클래스는 모든 x, y에 대해서  Math.abs(x.compareTo(y)) == Math.abs(y.compareTo(x))  Comparable을 구현한 클래스는 추이성을 보장해야 한다. (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 이면 x.comapreTo(z) &gt; 0  Comparable을 구현한 클래스는 x.compareTo(y) == 0 이면 Math.abs(x.compareTo(z)) == Math.abs(y.compareTo(z))  (x.compareTo(y) == 0) == (x.equals(y))이어야 한다. 이는 필수는 아니다.문제는 equals랑 같다. 상속 받아서 확장하면 compareTo 규약을 지키기 어렵다. 우회법도 같다. 상속 확장 대신 컴포지션으로 확장하면 된다.",
        "url": "//effective_java/2024/06/05/Effective-java-series-13.Comparable.html"
      }
      ,
    
      "effective-java-2024-06-05-effective-java-series-12-cloneable-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 5, 2024",
        "author": "",
        "category": "",
        "content": "Clone 재정의는 주의하자Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 큰 문제는 clone()이 선언된 곳이 Object에 있다는 것이다. 이는 단순Cloneable 구현만으로 clone을 호출할수 없다는 뜻이 된다.Cloneable은 clone의 동작 방식을 결정한다. 여기서 단순 clone 은 문제가 있다. 예를 들어 내부에 Array[]가 있다고 해보자. 이를 clone하면복사를 했더라도 같은 배열을 참조하도록 된다. 이는 곧 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변성을 해친다는 뜻이다.clone은 사실상 생성자와 같이 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야만 한다. 따라서 올바르게 clone 하려면 내부 정보를복사해야 한다. 가장 쉬운 방법은 참조형 필드는 직접 clone하는 방법 뿐이다.여기서 Cloneable 아키텍처는 ‘가변 객체를 참조하는 필드는 final로 선언’하라는 일반 용법과 충돌한다. 또, Cloneable을 구현한 클래스를 clone 할 때는 ThreadSafe를 보장해야한다.살짝 두서가 없었지만 정리하면  super.clone()을 호출하고 필드를 적절히 수정한다. 필요하면 DeepCopy를 수행한다.  접근제한자는 public으로  반환 타입은 클래스 자신으로만약 이게 녹록지 않다면 복사 생성자/복사 팩토리를 제공할 수 있다.  복사 생성자public class CloneObject {    public CloneObject(CloneObject co) {                return ....;    }}  복사 팩토리public class CloneFactory {    public static CloneFactory newInstance(CloneFactory cloneFactory) {                return .... ;    }}",
        "url": "//effective_java/2024/06/05/Effective-java-series-12.Cloneable.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-11-hashcode-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "HashCode 재정의규약equals를 재정의하면 hashCode도 재정의해야 한다. Object 명세에서 발췌한 규약을 보자.  equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메소드는 몇 번을 호출해도 일관되게 같은 값을 반환해야 한다.  equals가 두 객체가 같다고 판단한다면 hashCode도 같은 값을 반환해야 한다.  equals가 두 객체가 다르다고 판단했더라도 hashCode가 무조건 다를 필요는 없다.주의점  equals에서 사용하지 않은 필드는 ‘반드시’ hashCode에서 제외해야만 한다. 성능 높인답시고 제외시키면 안된다.  hashCode를 lazy로 설정하려면 threadSafe까지 고려해야 한다.  hashCode 대상을 공개하지 않는 것이 좋다. 그래야 추후 계산 방식을 바꿀 수도 있다.정의 방법  int 필드(result)를 하나 생성한다.  1에서 만든 필드에          Type.hashCode()를 할당한다.      참조 타입이면 표준형(canonical representation)을 만들어 호출한다.      필드가 배열이면 핵심 원소를 각각 필드처럼 다룬다. 혹은 Arrays.hashCode를 사용한다.      result = 31 * result + Type.hashCode()를 필드마다 반복한다.      31인 이유는 홀수이면서 소수이기 때문에 전통적으로 썻다고 한다. 위 예시를 풀어보면 아래와 같다.@Overridepublic int hashCode () {    int result = Short.hashCode(a);    result = 31 * result + Integer.hashCode(b);    result = 31 * result + Double.hashCode(c);        return result;}",
        "url": "//effective_java/2024/06/04/Effective-java-series-11.HashCode.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-10-equals-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "Equals는 일반 규약을 지켜서 재정의하라정의가 필요/불필요한 경우  equal 재정의를 추천하지 않는 경우          인스턴스가 고유하다면 ( 값이 아닌 동작하는 클래스 -&gt; ex) Thread)      인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없다면      상위에서 정의한 equals만으로 충분하다면      클래스가 private 혹은 package-private이고 equals를 호출할 일이 없다면        equals 재정의를 추천하는 경우          논리적 동치성 확인할 필요가 있을 경우      상위 클래스의 equals로는 부족할 경우      일반 규약그러면 equals는 어떤 규약을 따라야할까? 아래가 일반 규약이다.  반사성(reflexivity) : null이 아닌 모든 값 x에 대해서 x.equals(x) == true;          자기 자신은 같아야 한다.        대칭성(symmetry) : null이 아닌 모든 참조 값 x,y에 대해서 x.equals(y) == true 이면 y.equals(x) == true          두 객체 비교 순서를 바꿔도 결과는 같아야 한다.        추이성(transitivity) : null이 아닌 x, y, z의 경우 x.equals(y) == true 이고 y.equals(z) == true이면 x.equals(z) == true          삼단 논법과 유사하다.        일관성(consistency) : null이 아닌 x,y를 x.equals(y)를 여러 번 실행해도 늘 같은 값이 나온다.          반복해도 같은 결과 ( 비교 요소가 불변이든 가변이든 판단에 별 중요하지 않는 요소까지 비교하면 문제가 생길 수 있다.)        nonNull : null이닌 값에 x.equals(null) == false          null이 아닌 녀석은 null과 다르다.      이 규약을 어기면 예상하기 어려운 결과를 초래할 수도 있다.이 규약은 equals를 override한 서브클래싱한 객체와 부모 객체를 비교했을 때 equals 비교 요소에 따라 결과가 다르게 나타날 수 있다. 그런데 이 둘은같으면 같은 타입이 아니어서 문제고 달라도 원하는 모습이 나오지 않아서 문제다. 이처럼 구체 클래스를 확장해서 새로운 값을 추가하면서 'equals'를 만족시킬 방법은 없다.그래서 상속 대신 has-a 관계로 갖는 composition으로 확장하면 해소할 수 있다.equals 구현 단계  == 로 자기 자신 참조인지 확인  instanceof로 입력 타입을 확인  입력을 올바른 타임으로 형변환(공변성을 이용한다.)  입력한 객체와 자기 자신을 핵심 필드들이 모두 일치하는지 비교          null이 정상 값이라면 Objects.equals(obj1, obj2)로 비교해서 NPE를 피하자.      비교하기 너무 복잡하면 필드의 표준형(canonical form)을 저장하고 표준형끼리 비교해보자      필드 비교 순서가 equals의 성능을 좌우하기도 한다. (확률적으로 다를 가능성이 높은 것 -&gt; 낮은 것으로 비교하자.)        equals를 재정의하면 hashcode로 같이 재정의하자",
        "url": "//effective_java/2024/06/04/Effective-java-series-10.Equals.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-09-usetrywithresourcethantryfinally-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "try-finally 보다는 try-with-resourceimport java.io.*;class Example {    public void tryFinally() {        InputStream in = new FileInputStream(new File(\"/\"));        try {            OutputStream out = new FileOutputStream(new File(\"/\"));                        try {                byte[] buf = new byte[1024];                int n;                while ( (n = in.read(buf)) &gt;= 0 )  out.write(buf, 0, n);            } finally {                out.close();            }        } finally {            in.close();        }                //try-finally 중첩으로 hell이 시작된다.    }        public void tryWithResource() {        //AutoCloseable  구현이 전제 조건이다.        try (                InputStream in = new FileInputStream(new File(\"/\"));                OutputStream out = new FileOutputStream(new File(\"/\"));        ){            byte[] buf = new byte[1024];            int n;            while ( (n = in.read(buf)) &gt;= 0 )  out.write(buf, 0, n);                    } catch (Exception e) {        }    }}는",
        "url": "//effective_java/2024/06/04/Effective-java-series-09.useTryWithResourceThanTryFinally.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-08-avoidusefinalizerandcleaner-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "finalizer, cleaner 사용하지 않기  finalizer는 실행 타이밍을 예측하기 어렵다. finalizer 실행 도중 에러가 생겨도 trace를 알 수 없다.  cleaner는 finalizer보다 덜하긴 하지만 여전히 예측 불가에 느리다.C++ 과 다르게 자바는  finalizer로 리소스 정리를 해줄 필요가 없다. 대신 try-with-resource 등으로 회수한다. 이는 java에서 finalizer, cleaner를 사용할 이유를 퇴색시킨다. 더 나아가 이 둘은 실행 될지 아닐지도 예측하기 어렵다.문제는 이 둘에 FileStream을 회수하는 등의 동작을 넣으면 언제 회수할지 모르기 때문에 한정된 자원에 누수가 생긴다. 특히 상태를 수정하는 경우는 절대로 이 둘에 의존하면 안된다. 언제 실행될지도 모르기 때문이다. 그래도, FileStream을 닫는 코드가 없을 때 언제 실행할지 모르지만 실행을 할 수도 있는 안전망 정도로 구현해 놓는 식으로 쓸 수도 있긴하다.두 번째 문제는 finalizer 공격에 노출될 수도 있다는 것이다. 객체를 서브클래싱하고, initialize를 의도적으로 실패해서 finalizer를 유도하고 거기에 문제가 될 만한 코드를 심는다.class IgnoreFinalizer {        //Overrides method that is deprecated and marked for removal in 'java.lang.Object'     @Override    @SuppressWarnings    protected final void finalize() throws Throwable {        AssertionError();    }}",
        "url": "//effective_java/2024/06/04/Effective-java-series-08.avoidUseFinalizerAndCleaner.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-07-clearobsoletereference-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "다쓴 객체의 참조 해제import java.util.Arrays;import java.util.EmptyStackException;public class Stack&lt;T&gt; {    private T[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new T[DEFAULT_INITIAL_CAPACITY];    }    public void push(T e) {        ensureCapacity();        elements[size++] = e;    }    public T pop() {        if (size == 0) throw new EmptyStackException();//        return elements[--size]; //이러기만 하면 OOM 발생할 수도 있다.        T element = elements[--size];        element[size] = null; //이 코드가 필요하다.        return element;    }    private void ensureCapacity() {        if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1);    }}위의 포인트와 같이 오래 사용하면 OutOfMemoryError를 피할 수 없는 경우들이 왕왕있다. 그래서 다 쓴 객체(Obsolete reference)를 참조 해제하는 것이필요할 떄가 있다. 물론 Java는 C++ 같이 일일이 해제할 필요는 없다만위의 경우와 같이 스택이 본인의 메모리를 직접 관리하는 경우 ( elements 배열로 풀을 만들어 관리 ) elements를 쓰는지 아닌지 GC는 알 길이 없다. 이와 같이 본인 메모리를 직접 관리하는 클래스라면 항상 MemoryLeak을 염두해야만 한다.두 번째로 캐시 메모리도 누수 주범이다. 보통 그래서 TTL을 두거나 하는 식으로 관리한다. 혹은 WeakHashMap 등으로 방지할 수 있다.  WeakHashMappublic class Fruit{    String name;    public Fruit(String name) {        this.name = name;    }    @Override    public String toString() {        return \"Fruit{\" +                \"name='\" + name + '\\'' +                '}';    }}public class WeakHashMapExample {    public static void main(String[] args) {        WeakHashMap&lt;Fruit, String&gt; map = new WeakHashMap&lt;&gt;();        Fruit apple = new Fruit(\"apple\");        Fruit orange = new Fruit(\"orange\");        map.put(apple, \"test a\");        map.put(orange, \"test b\");        apple = null;        System.gc();        map.entrySet().forEach(System.out::println );                //Fruit{name='orange'}=test b    }}  WeakReferenceclass WeakReferenceExample {    static class TestObject {        String exam;        public TestObject(String exam) {            this.exam = exam;        }        @Override        public String toString() {            return \"TestObject{\" +                    \"exam='\" + exam + '\\'' +                    '}';        }    }    public static void main(String[] args) {        TestObject strong = new TestObject(\"Strong\");        TestObject weak = new TestObject(\"Weak\");                        TestObject bindStrong = strong;        WeakReference&lt;TestObject&gt; bindWeak = new WeakReference&lt;TestObject&gt;(weak);        System.out.println(bindStrong); //Strong        System.out.println(bindWeak.get());//Weak        strong = null;        weak = null;        System.gc();        //bindStrong null을 넣어도 객체 해제 X        //bindWeak null을 넣으면 객체 해제        System.out.println(bindStrong); //Strong        System.out.println(bindWeak.get());//null    }}마지막으로 리스너, 콜백 등이 달려 있는 경우다. (EventSource 같은)",
        "url": "//effective_java/2024/06/04/Effective-java-series-07.ClearObsoleteReference.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-06-avoidinitializeunnecessaryinstance-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "불필요한 객체 생성 피하기똑같은 기능의 객체를 매번 생성하는 건 굉장히 비효율이다. 예를 들어서 String s = new String(\"HELLO\");와 같은 경우는 String s = \"HELLO\";와사실 똑같다. 차이점이라면 전자는 매 번 객체를 만들고 후자는 가상 머신 안에서 같은 문자열 리터럴을 사용할 경우 모든 코드가 같은 객체를 사용할 것을 보장한다.다른 예로 정규표현식으로 검색하는 경우를 들 수 있는데 Pattern.compile()로 매 번 만들어 쓰는건 문제가 있다. 이 경우 패턴을 static으로 두고 사용하거나 하는방법이 있다. 여기에 머리를 더 쓰면 lazy init을 할 수도 있긴 하지만 대부분의 경우 lazy initialization은 성능상 크게 개선되지 않고 코드는 복잡하게할 가능성이 농후하므로 지양하는 것이 좋다.알게 모르게 객체를 재생성할 수도 있다.private static long sum () {    Long sum = 0L;        for ( long i = 0; i &lt;= Integer.MAX_VALUE; i ++ ) sum += i;    //이러면 += 1; 마다 인스턴스를 계속 생성한다.        return sum;}이런 어이 없는 경우가 발생할 수도 있으니 주의하자.불필요하게 객체를 낭비하는 것은 좋지 않다. 그렇다고 객체 생성을 지양하는 것이 좋다는 것이 아니다. JVM 발전으로 작은 객체 생성은 크게 부담되는 작업이 아니다.따라서 코드 퀄리티를 높이기 위해서 하는 trade-off는 가치 있는 일이다.반대로 너무 오버해서 Pool 등을 구성하는 극단적인 일도 지양하자. DB 커넥션의 경우 풀로 유지하는 것이 좋은게 맞다. 생성에 리소스가 어마무시하게 드니까. 그러나 비용이 작은 경우는 오히려 독이 된다.",
        "url": "//effective_java/2024/06/04/Effective-java-series-06.AvoidInitializeUnnecessaryInstance.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-05-useinjection-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "의존 관계 주입을 사용하자.사용하는 자원에 따라 달라지는 클래스의 경우에는 정적 유틸(이니셜라이즈 불가하며 static 메소드로 구성된) 클래스나 싱글턴은 그리 적합하지 않다.대신 인스턴스를 생성할 때 생성자로 필요한 자원을 넘겨줘서 유연하게 대처하는 방식을 채택할 수 있다.이에 대한 쓸만한 변형으로 생성자에 factory를 넘기는 방법이 있다. java 1.8 부터는 Supplier를 던져서 해결할 수도 있다.",
        "url": "//effective_java/2024/06/04/Effective-java-series-05.UseInjection.html"
      }
      ,
    
      "effective-java-2024-06-04-effective-java-series-04-useprivateconstructor-html": {
        "title": "Effective java",
        "tags": "",
        "date": "June 4, 2024",
        "author": "",
        "category": "",
        "content": "인스턴스화를 막기 위해서 private 생성자를 사용한다.생성화를 명시하지 않으면 기본 생성자를 만든다. 따라서 이를 막으려면 private로 생성자를 만들어줘야 한다. 혹은 정말로 생성자를 사용하지 못하게 하려면 AssertionError를 던지는 것도 방법이다.",
        "url": "//effective_java/2024/06/04/Effective-java-series-04.UsePrivateConstructor.html"
      }
      ,
    
      "programmers-2024-06-03-programmers-series-lv-01-ourpassword-html": {
        "title": "[programmers Series] Lv. 01 Ourpassword",
        "tags": "",
        "date": "June 3, 2024",
        "author": "",
        "category": "",
        "content": "둘만의 암호  문제 설명두 문자열 s와 skip, 그리고 자연수 index가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다.- 문자열 s의 각 알파벳을 index만큼 뒤의 알파벳으로 바꿔줍니다.- index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아갑니다.- skip에 있는 알파벳은 제외하고 건너뜁니다.예를 들어 s = \"aukks\", skip = \"wbqd\", index = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 skip에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 \"ukks\" 또한 위 규칙대로 바꾸면 \"appy\"가 되며 결과는 \"happy\"가 됩니다.두 문자열 s와 skip, 그리고 자연수 index가 매개변수로 주어질 때 위 규칙대로 s를 변환한 결과를 return하도록 solution 함수를 완성해주세요.제한사항- 5 ≤ s의 길이 ≤ 50- 1 ≤ skip의 길이 ≤ 10- s와 skip은 알파벳 소문자로만 이루어져 있습니다.    -  skip에 포함되는 알파벳은 s에 포함되지 않습니다.- 1 ≤ index ≤ 20알고리즘  char로 처리풀이class OurPassword {    @Nested    class TestCases {        @Test        public void case1 () {            String s = \"aukks\";            String skip = \"wbqd\";            int index = 5;            String result = \"happy\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case2 () {            String s = \"abcde\";            String skip = \"\";            int index = 0;            String result = \"abcde\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case3 () {            String s = \"abcde\";            String skip = \"\";            int index = 1;            String result = \"bcdef\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case4 () {            String s = \"abcde\";            String skip = \"fghij\";            int index = 5;            String result = \"klmno\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case5 () {            String s = \"ybc\";            String skip = \"az\";            int index = 1;            String result = \"bcd\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case6 () {            String s = \"abd\";            String skip = \"\";            int index = 2;            String result = \"cdf\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case7 () {            String s = \"xyz\";            String skip = \"\";            int index = 2;            String result = \"zab\";//            Assertions.assertEquals(result, solutionBack(s, skip, index));            Assertions.assertEquals(result, solution(s, skip, index));        }        @Test        public void case8 () {            String s = \"ace\";            String skip = \"d\";            int index = 4;            String result = \"fhi\";            Assertions.assertEquals(result, solutionBack(s, skip, index));//            Assertions.assertEquals(result, solution(s, skip, index));        }    }    public String solution( String s, String skip, int index ){        StringBuilder builder = new StringBuilder();        for( int i = 0; i &lt; s.length(); i ++) {            int charAt = s.charAt(i);            for (int j = 0; j &lt; index; j ++) {                charAt ++;                if( charAt  &gt; 'z' )  charAt -= ('z'-'a'+1);                if( skip.contains(String.valueOf((char) charAt)) ) j --;            }            builder.append((char) charAt);        }        return builder.toString();    }}",
        "url": "//programmers/2024/06/03/Programmers-series-LV.-01-OurPassword.html"
      }
      ,
    
      "programmers-2024-06-02-programmers-series-lv-01-smallestchar-html": {
        "title": "[programmers Series] Lv. 01 Smallestchar",
        "tags": "",
        "date": "June 2, 2024",
        "author": "",
        "category": "",
        "content": "크기가 작은 부분 문자열  문제 설명숫자로 이루어진 문자열 t와 p가 주어질 때,t에서 p와 길이가 같은 부분문자열 중에서,이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return 하는 함수 solution을 완성하세요.예를 들어, t=\"3141592\"이고 p=\"271\" 인 경우,t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다.이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.제한사항1 ≤ p의 길이 ≤ 18p의 길이 ≤ t의 길이 ≤ 10,000t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.알고리즘주의점t의 길이가 10,000 이므로 자료형을 Long으로 선택풀이class SmallestChar {    @Nested    class TestCases {        @Test        public void case1 () {            String t = \"3141592\";            String p = \"271\";            int result = 2;            Assertions.assertEquals(result, solution(t, p));        }            @Test        public void case2 () {            String t = \"500220839878\";            String p = \"7\";            int result = 8;            Assertions.assertEquals(result, solution(t, p));        }            @Test        public void case3 () {            String t = \"10203\";            String p = \"15\";            int result = 3;            Assertions.assertEquals(result, solution(t, p));        }    }        public int solution (String t, String p) {        long length = p.length();        long pNumber = Long.parseLong(p);            List&lt;Long&gt; list = new ArrayList&lt;&gt;();            for( int i = 0; i &lt;= t.length() - length; i ++ ) {            list.add(Long.parseLong(t.substring(i, i + (int)length)));        }            return (int) list.stream().filter(elem -&gt; elem &lt;= pNumber).count();    }}",
        "url": "//programmers/2024/06/02/Programmers-series-LV.-01-SmallestChar.html"
      }
      ,
    
      "programmers-2024-06-02-programmers-series-lv-01-rollcake-html": {
        "title": "[programmers Series] Lv. 01 Rollcake",
        "tags": "",
        "date": "June 2, 2024",
        "author": "",
        "category": "",
        "content": "롤케이크 자르기       철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다.     이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다.     철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데,     그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다.     그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이     각 조각에 동일한 가짓수의 토핑이 올라가면     공평하게 롤케이크가 나누어진 것으로 생각합니다.     예를 들어,     롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다.     토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때,     케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다.     만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면     롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다.     철수가 [1, 2, 1]이 놓인 조각을,     동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면     철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만,     동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로,     이는 공평하게 나누어진 것이 아닙니다.     만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1)     사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다.     이 경우 철수는 세 가지 토핑(1, 2, 3)을,     동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로,     이는 공평하게 나누어진 것입니다.     공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다.     위의 롤케이크를 [1, 2, 1, 3, 1],     [4, 1, 2]으로 잘라도 공평하게 나뉩니다.     어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.     롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 topping이 매개변수로 주어질 때,     롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요.  제한사항 -  1 ≤ topping의 길이 ≤ 1,000,000 -  1 ≤ topping의 원소 ≤ 10,000 알고리즘X아이디어  Map으로 미리 카운트 해서 그 결과를 정리하면서 keySet이 같아질 경우를 세면 되지 않을까?  배열 두 개를 두고, 각 요소까지 잘라졌을 때 원소의 개수를 기록한다. 이후 두 배열을 비교한다.풀이class RollCakeCutting {    @Nested    public class TestCases {        @Test        public void case1 () {            int[] topping = new int[]{1, 2, 1, 3, 1, 4, 1, 2};            int result = 2;            Assertions.assertEquals(result, solution(topping));        }        @Test        public void case2 () {            int[] topping = new int[]{1, 2, 3, 1, 4};            int result = 0;            Assertions.assertEquals(result, solution1(topping));            Assertions.assertEquals(result, solution2(topping));        }        @Test        public void case3 () {            int[] topping = new int[]{1, 2, 3, 4};            int result = 1;            Assertions.assertEquals(result, solution1(topping));            Assertions.assertEquals(result, solution2(topping));        }        @Test        public void case4 () {            int[] topping = new int[]{2, 1,  1, 1, 3};            int result = 2;            Assertions.assertEquals(result, solution1(topping));            Assertions.assertEquals(result, solution2(topping));        }    }    //1. useMap    public int solution1(int[] topping) {        Map&lt;Integer, Integer&gt; leftSide = new HashMap&lt;&gt;();        Map&lt;Integer, Integer&gt; rightSide = Arrays.stream(topping).boxed()                .collect(Collectors.toMap(Function.identity(), integer -&gt; 1, (integer, integer2) -&gt; integer + integer2));        int count = 0;        for( int i = 0; i &lt; topping.length; i ++ ) {            Integer number = topping[i];            leftSide.putIfAbsent(number, 1);            leftSide.computeIfPresent(number, (k, v) -&gt; leftSide.get(k) + 1);            Integer right = rightSide.get(number);            if(right &lt;= 1) rightSide.remove(number);            else rightSide.put(number, right - 1);            if( leftSide.keySet().size() == rightSide.keySet().size()) count ++ ;        }        return count;    }    //2. useSet    public int solution2(int[] topping) {        int answer = 0;        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        int[] partA = new int[topping.length];        int[] partB = new int[topping.length];        for ( int i = 0; i &lt; topping.length; i ++ ) {            set.add(topping[i]);            partA[i] = set.size();        }        set.clear();        for ( int i = topping.length - 1; i &gt;= 0 ; i -- ) {            set.add(topping[i]);            partB[i] = set.size();        }        for ( int i = 0; i &lt; partA.length - 1; i ++ ) {            if( partA[i] == partB[i + 1] ) answer += 1;        }        return answer;    }}",
        "url": "//programmers/2024/06/02/Programmers-series-LV.-01-RollCake.html"
      }
      ,
    
      "programmers-2024-06-01-programmers-series-lv-01-repaint-html": {
        "title": "[programmers Series] Lv. 01 Repaint",
        "tags": "",
        "date": "June 1, 2024",
        "author": "",
        "category": "",
        "content": "덧칠하기알고리즘풀이  어느 학교에 페인트가 칠해진 길이가 n미터인 벽이 있습니다. 벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프로 붙였다가 철거할 때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다. 페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다.넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다. 이를 위해 벽을 1미터 길이의 구역 n개로 나누고, 각 구역에 왼쪽부터 순서대로 1번부터 n번까지 번호를 붙였습니다. 그리고 페인트를 다시 칠해야 할 구역들을 정했습니다.벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다.롤러가 벽에서 벗어나면 안 됩니다.구역의 일부분만 포함되도록 칠하면 안 됩니다.즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다.한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다. 예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다.정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 section이 매개변수로 주어질 때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요.제한사항1 ≤ m ≤ n ≤ 100,0001 ≤ section의 길이 ≤ n1 ≤ section의 원소 ≤ nsection의 원소는 페인트를 다시 칠해야 하는 구역의 번호입니다.section에서 같은 원소가 두 번 이상 나타나지 않습니다.section의 원소는 오름차순으로 정렬되어 있습니다.class Repaint {    @Nested    class TestCases {        @Test        public void case1 () {            int n = 8; //totalLength            int m = 4; //maxPaintLength            int[] section = {2,3,6}; //repaintTargets            int expected = 2;            Assertions.assertEquals(expected, solution(n, m, section));        }        @Test        public void case2 () {            int n = 5;            int m = 4;            int[] section = {1,3};            int expected = 1;            Assertions.assertEquals(expected, solution(n, m, section));        }        @Test        public void case3 () {            int n = 4;            int m = 1;            int[] section = {1,2,3,4};            int expected = 4;            Assertions.assertEquals(expected, solution(n, m, section));        }    }    public int solution( int n , int m, int[] section ) {        int start = section[0];        int end = section[0] + m - 1;        int count = 1;        for ( int sec : section ) {            if( sec &gt;= start &amp;&amp; sec &lt;= end) continue;            start = sec;            end = start + m - 1;            count += 1;        }        return count;    }}",
        "url": "//programmers/2024/06/01/Programmers-series-LV.-01-Repaint.html"
      }
      ,
    
      "programmers-2024-06-01-programmers-series-lv-01-numberbuddy-html": {
        "title": "[programmers Series] Lv. 01 Numberbuddy",
        "tags": "",
        "date": "June 1, 2024",
        "author": "",
        "category": "",
        "content": "숫자 짝꿍Programmers  두 정수 X, Y의 임의의 자리에서 공통으로 나타나는 정수 k(0 ≤ k ≤ 9)들을 이용하여 만들 수 있는 가장 큰 정수를 두 수의 짝꿍이라 합니다(단, 공통으로 나타나는 정수 중 서로 짝지을 수 있는 숫자만 사용합니다).X, Y의 짝꿍이 존재하지 않으면, 짝꿍은 -1입니다. X, Y의 짝꿍이 0으로만 구성되어 있다면, 짝꿍은 0입니다.예를 들어, X = 3403이고 Y = 13203이라면, X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 3, 0, 3으로 만들 수 있는 가장 큰 정수인 330입니다.다른 예시로 X = 5525이고 Y = 1255이면 X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 2, 5, 5로 만들 수 있는 가장 큰 정수인 552입니다(X에는 5가 3개, Y에는 5가 2개 나타나므로 남는 5 한 개는 짝 지을 수 없습니다.)두 정수 X, Y가 주어졌을 때, X, Y의 짝꿍을 return하는 solution 함수를 완성해주세요.제한사항3 ≤ X, Y의 길이(자릿수) ≤ 3,000,000입니다.X, Y는 0으로 시작하지 않습니다.X, Y의 짝꿍은 상당히 큰 정수일 수 있으므로, 문자열로 반환합니다.알고리즘자료구조 PriorityQueue? Map?풀이  @Nested    class TestCases {        @Test        public void case1 () {            String x = \"100\";            String y = \"2345\";            String expected = \"-1\";            Assertions.assertEquals(expected, solution(x, y));        }        @Test        public void case2 () {            String x = \"100\";            String y = \"203045\";            String expected = \"0\";            Assertions.assertEquals(expected, solution(x, y));        }        @Test        public void case3 () {            String x = \"100\";            String y = \"123450\";            String expected = \"10\";            Assertions.assertEquals(expected, solution(x, y));        }        @Test        public void case4 () {            String x = \"12321\";            String y = \"42531\";            String expected = \"321\";            Assertions.assertEquals(expected, solution(x, y));        }        @Test        public void case5 () {            String x = \"5525\";            String y = \"1255\";            String expected = \"552\";            Assertions.assertEquals(expected, solution(x, y));        }    }    //PriorityQueue에 넣어서 하나를 기준으로 숫자가 맞으면 빼내는 방식    public static String solution(String x, String y) {        PriorityQueue&lt;Character&gt; xQueue = new PriorityQueue&lt;&gt;(Collections.reverseOrder());        PriorityQueue&lt;Character&gt; yQueue = new PriorityQueue&lt;&gt;(Collections.reverseOrder());        for(Character xChar: x.toCharArray() ) xQueue.add(xChar);        for(Character yChar: y.toCharArray() ) yQueue.add(yChar);        PriorityQueue&lt;Character&gt; shortQueue = xQueue;        PriorityQueue&lt;Character&gt; longQueue = yQueue;        if(shortQueue.size() &gt; longQueue.size()) {            shortQueue = yQueue;            longQueue =  xQueue;        }        List&lt;Character&gt; result = new ArrayList&lt;&gt;();        while( !shortQueue.isEmpty() ) {            char element = shortQueue.poll();            if( longQueue.contains(element) ){                while(!longQueue.isEmpty()) {                    char longelem = longQueue.poll();                    if(longelem == element) {                        result.add(element);                        break;                    }                }            }        }        if( result.isEmpty() ) return \"-1\";        else if ( result.stream().filter(e -&gt; e == '0').count() == result.size()) {            return  \"0\";        }        else {           StringBuilder builder = new StringBuilder();           for( char ch : result ) builder.append(ch);           return builder.toString();        }    }    // 미리 정리해서 Map으로 원소 개수를 파악해서 정렬하는 방식    public static String solution2(String x, String y) {        Map&lt;Integer, Long&gt; xMap = Arrays.stream(x.split(\"\")).collect(Collectors.groupingBy(str -&gt; Integer.parseInt(str), Collectors.counting()));        Map&lt;Integer, Long&gt; yMap = Arrays.stream(y.split(\"\")).collect(Collectors.groupingBy(str -&gt; Integer.parseInt(str), Collectors.counting()));        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();            IntStream.rangeClosed(0, 9)                .forEach(refValue -&gt; {                    long xValue = xMap.getOrDefault(refValue, 0L);                    long yValue = yMap.getOrDefault(refValue, 0L);                        Integer[] tmpArray;                    int count = 0;                        if (xValue &gt; yValue) count = (int) yValue;                    else if (xValue &lt; yValue) count = (int) xValue;                    else count = (int) xValue;                        tmpArray = new Integer[count];                    Arrays.fill(tmpArray, refValue);                        result.addAll(Arrays.stream(tmpArray).collect(Collectors.toList()));                });            result.sort((p, n) -&gt; n - p);            if (result.isEmpty()) return \"-1\";        String answer = result.stream().map(String::valueOf).collect(Collectors.joining());            if (answer.startsWith(\"0\")) return \"0\";        else return answer;    }",
        "url": "//programmers/2024/06/01/Programmers-series-LV.-01-NumberBuddy.html"
      }
      ,
    
      "effective-java-2024-05-31-effective-java-series-03-makesuresingtonasenumtypeorprivateconstructor-html": {
        "title": "Effective java",
        "tags": "",
        "date": "May 31, 2024",
        "author": "",
        "category": "",
        "content": "private 생성자나 열거 타입으로 싱글톤임을 보증하기싱글톤은 인스턴스를 오직 하나만 만들 수 있는 클래스를 말한다. 싱글톤이 무조건 좋은건 아니다. 예를 들어 mocking을 하기 어려워 진다는 단점이 생긴다.그러나 싱글턴을 무력화 할 수도 있다. ReflectionAPI를 사용하면 가능하다. AcessibleObject.setAccessible을 사용하면 된다.물론 생성자를 수정하여 두 번째 인스턴스가 생성되면 예외를 던져서 막을 수는 있다. 혹은 필드에 본인을 new로 생성하고 정적 팩토리 메소드로 그 인스턴스를 던지면 된다.(여기에서도 동시성 문제가 있을 수 있지만 일단 넘어가자)싱글톤에서 Serialize를 하려면 Serializable을 구현하는 것 뿐만 아니라 인스턴스 필드를 @Transient로 두고 readResolve, WriteReplace를 구현해야 한다.이런 작업들이 복잡하다면 Enum으로 싱글톤을 만들 수도 있다.public enum Singleton {    INSTANCE;        public void bark() {        System.out.println(\"BARK\");    }}물론! Enum 외의 클래스를 상속해야한다면 이 방법도 문제가 있다.",
        "url": "//effective_java/2024/05/31/Effective-java-series-03.MakeSureSingtonAsEnumTypeOrPrivateConstructor.html"
      }
      ,
    
      "effective-java-2024-05-31-effective-java-series-02-considerbuilderpattern-html": {
        "title": "Effective java",
        "tags": "",
        "date": "May 31, 2024",
        "author": "",
        "category": "",
        "content": "생성자에 매개변수가 많다면 빌더 패턴을 고려하자.정적 팩토리, 생성자 모두 매개변수가 많을 때 모든 경우의 수를 고려하여 overload를 해야한다는 단점이 있다. 이때 Builder 를 사용하면 적절히 대응할 수 있다.class Pizza {            private final List&lt;String&gt; topping;    private final String cheese;        private Pizza(List&lt;String&gt; topping, String cheese) {        this.topping = topping;        this.cheese = cheese;    }         public Builder builder() {        return new Builder();    }        public static class Builder {        private List&lt;String&gt; topping;        private String cheese;                public Builder topping (List&lt;String&gt; topping) {            this.topping = topping;            return this;        }        public  Builder cheese (String cheese) {            this.cheese = cheese;            return this;        }                public Pizza build() {            return new  Pizza(this.topping, this.cheese);        }    } }또한 이런 식으로 사용하면 객체의 불변성도 지킬 수 있다. 이러면  점층적 생성자 패턴의 매개변수 문제를 해결할 수 있다.  자바빈즈 패턴의 불변성을 해치는 점도 해결할 수 있다.이러한 빌더 패턴은 (파이썬, 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.또한 빌더는 계층적으로 설계된 클래스와 쓰기 좋다.import java.util.EnumSet;import java.util.Objects;public abstract class Pizza {    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self;        }        abstract Pizza build();        protected abstract T self;    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone();    }}public class JacksonPizza extends Pizza {    public enum Size {SMALL, MEDIUM, LARGE}    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override        public JacksonPizza build() {             return new JacksonPizza(this);        }        //공변 반환 타입 : 재정의한 메소드의 반환 타입이 상위에서 정한 타입의 하위가 될 수 있다.                 @Override        protected Builder self(){ return this; }    }        private JacksonPizza(Builder builder) {        super(builder);        size = builder.size;    }}",
        "url": "//effective_java/2024/05/31/Effective-java-series-02.ConsiderBuilderPattern.html"
      }
      ,
    
      "effective-java-2024-05-31-effective-java-series-01-usefactorymethod-html": {
        "title": "Effective java",
        "tags": "",
        "date": "May 31, 2024",
        "author": "",
        "category": "",
        "content": "생성자 대신 정적 팩토리 메소드정적 팩토리 메소드해당 클래스의 인스턴스를 반환하는 정적 메소드를 의미한다. (GOF에서 의미하는 팩토리 메소드와는 다르다.)ex)public static Boolean valueOf(boolean b) {    return b ? Boolean.TRUE : Boolean.FALSE;}장점  이름을 가질 수 있다. : 생성자로는 반환될 객체 특성을 제대로 설명하지 못할 수 있다.  호출될 때마다 인스턴스를 새로 생성할 필요는 없다. : 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 것을 캐싱하여 재활용 할 여지가 생겼다. 이는 생성 비용 절감과 직결된다. FlyWeight와도 비슷하다. 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스 생명을 통제할 수 있다. (Instance-controlled) 이는 singleton이나 noninstantiable로도 만들 수도 있다.  반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. : 반환 타입의 하위 타입이기만 하면 상관이 없다.  정적 팩토리 메소드를 작성하는 시점에는 반환된 객체의 클래스가 존재하지 않아도 된다. : 이런 부분이 프레임워크를 만드는 근간이 된다고 한다. 구현과 - 제공을 분리할 수 있게 해준다.단점  상속을 위해서 public, protected가 필요한데 정적 팩토리 메소드만 제공하면 하위 클래스를 만들 수 없다. : 이는 결론적으로 컴포지션을 사용하도록 종용한다.  정적 팩토리 메소드는 프로그래머가 찾기 어렵다. : 구현이 드러나 있지 않으므로 인스턴스화할 방법을 알아내야 한다.  이런 문제를 해결 하기 위해서 아래와 같은 규약을 따르는 것이 좋다.          from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드이다. -&gt; Date d = Date.from(instance);      of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드 -&gt; Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);      valueOf: from, of의 더 자세한 버전 -&gt; BigInteger prime = BigInteger.valueof(Integer.MAX_VALUE);      instance/getInstance : 명시한 인스턴스 반환하지만 같은 인스턴스인지는 알 수 없음 -&gt; Example.getInstance()      create/newInstance : 항상 새로운 인스턴스 반환 보장 -&gt;  Array.newInstance(classObject,arrayLength)      getType : 생성할 클래스가 아닌 다른 클래스를 반환하는 팩토리 메소드를 정의한다. -&gt; Files.getFileStore(path)      newType : newInstance와 같으니 생성할 클래스가 아닌 다른 클래스를 반환하는 팩토리 메소드를 정의한다. -&gt; Files.newBufferedReader(path)      type : getType, newType의 짧은 버전 -&gt; Collections.list(legacyLitany)      ",
        "url": "//effective_java/2024/05/31/Effective-java-series-01.UseFactoryMethod.html"
      }
      ,
    
      "programmers-2024-05-29-programmers-series-lv-01-knight-html": {
        "title": "[programmers Series] Lv. 01 Knight",
        "tags": "",
        "date": "May 29, 2024",
        "author": "",
        "category": "",
        "content": "숫자나라 기사단Programmers  숫자나라 기사단의 각 기사에게는 1번부터 number까지 번호가 지정되어 있습니다.기사들은 무기점에서 무기를 구매하려고 합니다.각 기사는 자신의 기사 번호의 약수 개수에 해당하는 공격력을 가진 무기를 구매하려 합니다.단, 이웃나라와의 협약에 의해 공격력의 제한수치를 정하고,제한수치보다 큰 공격력을 가진 무기를 구매해야 하는 기사는협약기관에서 정한 공격력을 가지는 무기를 구매해야 합니다.예를 들어, 15번으로 지정된 기사단원은15의 약수가 1, 3, 5, 15로 4개 이므로,공격력이 4인 무기를 구매합니다.만약, 이웃나라와의 협약으로 정해진 공격력의 제한수치가 3이고제한수치를 초과한 기사가 사용할 무기의 공격력이 2라면,15번으로 지정된 기사단원은 무기점에서 공격력이 2인 무기를 구매합니다.무기를 만들 때, 무기의 공격력 1당 1kg의 철이 필요합니다.그래서 무기점에서 무기를 모두 만들기 위해 필요한 철의 무게를 미리 계산하려 합니다.기사단원의 수를 나타내는 정수 number와 이웃나라와협약으로 정해진 공격력의 제한수치를 나타내는 정수 limit와제한수치를 초과한 기사가 사용할 무기의 공격력을 나타내는 정수 power가 주어졌을 때,무기점의 주인이 무기를 모두 만들기 위해 필요한철의 무게를 return 하는 solution 함수를 완성하시오.알고리즘  단순 순회 및 약수 구하기(O₍n₎)    int number = 1000000000;    int count = 0;    for(int i = 1; i &lt;= number; i++) {        if (number % i == 0) count++;    }목표 숫자까지 나머지 연산(modulo) 연산을 해서 나머지가 0이면 약수로 판별한다.  순회 수 줄이기 (O₍√n₎)대상 숫자( ex) 100 )의 제곱근인 10까지 순회를 하며, 순회 중인 숫자(i)의 제곱이 대상 숫자( ex) 100) 이면 개수가 하나나머지 연산을 해서 나머지가 0이면 약수가 2개 임에서 착한해서 확인한다.    int number = 1000000000;    int count = 0;    for(int i = 1; i * i &lt;= number; i++) {        if ( i * i == number ) count += 1;         else if (number % i == 0) count += 2;    }풀이class Knights {    @Nested    class TestCases {        @Test        public void case1 () {            int number = 5;            int limit = 3;            int power = 2;            int result = 10;            Assertions.assertEquals(result, solution(number, limit, power));        }        @Test        public void case2 () {            int number = 10;            int limit = 3;            int power = 2;            int result = 21;            Assertions.assertEquals(result, solution(number, limit, power));        }    }    public int solution ( int number, int limit, int power ) {        int answer = 0;        for (int num = 1; num &lt;= number; num ++ ) {            int count = 0;            for( int i = 1; i * i &lt;= num; i ++) {                if( i * i == num ) count += 1;                else if ( num % i == 0 ) count += 2;            }            if( count &gt; limit ) answer += power;            else answer += count;        }        return answer;    }}",
        "url": "//programmers/2024/05/29/Programmers-series-LV.-01-Knight.html"
      }
      ,
    
      "programmers-2024-05-28-programmers-series-lv-01-walking-in-the-park-html": {
        "title": "[programmers Series] Lv. 01 Walking In The Park",
        "tags": "",
        "date": "May 28, 2024",
        "author": "",
        "category": "",
        "content": "공원 산책Programmers  지나다니는 길을 ‘O’, 장애물을 ‘X’로 나타낸 직사각형 격자 모양의 공원에서로봇 강아지가 산책을 하려합니다.  산책은 로봇 강아지에 미리 입력된 명령에 따라 진행하며,명령은 다음과 같은 형식으로 주어집니다.  - [\"방향 거리\", \"방향 거리\" … ]    예를 들어 “E 5”는 로봇 강아지가 현재 위치에서 동쪽으로 5칸 이동했다는 의미입니다.로봇 강아지는 명령을 수행하기 전에 다음 두 가지를 먼저 확인합니다.  - 주어진 방향으로 이동할 때 공원을 벗어나는지 확인합니다.- 주어진 방향으로 이동 중 장애물을 만나는지 확인합니다.    위 두 가지중 어느 하나라도 해당된다면,로봇 강아지는 해당 명령을 무시하고 다음 명령을 수행합니다.  공원의 가로 길이가 W, 세로 길이가 H라고 할 때,  공원의 좌측 상단의 좌표는 (0, 0),우측 하단의 좌표는 (H - 1, W - 1) 입니다.                (0, 0)          ...                                                                                            (H -1, W - 1)         공원을 나타내는 문자열 배열 park,로봇 강아지가 수행할 명령이 담긴 문자열 배열 routes가 매개변수로 주어질 때,로봇 강아지가 모든 명령을 수행 후 놓인 위치를 [세로 방향 좌표, 가로 방향 좌표] 순으로배열에 담아 return 하도록 solution 함수를 완성해주세요.알고리즘크게 알고리즘이라고 할 부분은 없는 것으로 보이며, 단지 이차원 배열에서 이동 정도가 있을 것으로 보인다.맵 형태의 그래프 탐색 문제의 초석 정도로 보인다.풀이import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution {    public int[] solution(String[] park, String[] routes) {        int[] coordinate = {0, 0};        String[][] parkMap = new String[park.length][park[0].length()];        Map&lt;Character, Integer&gt; moveMap = Map.of(                'E', 1,                'W', -1,                'S', 1,                'N', -1        );        for (int y = 0; y &lt; park.length; y++) {            String[] row = park[y].split(\"\");            for (int x = 0; x &lt; row.length; x++) {                parkMap[y][x] = row[x];                if (row[x].equalsIgnoreCase(\"s\")) {                    coordinate[0] = y;                    coordinate[1] = x;                }            }        }        for (String route : routes) {            if (this.canIWalk(parkMap, coordinate, route)) {                Integer walk = Integer.parseInt(String.valueOf(route.charAt(2)));                Character direction = route.charAt(0);                switch (direction) {                    case 'E', 'W':                        coordinate[1] += (walk * moveMap.get(direction));                        break;                    case 'S', 'N':                        coordinate[0] += (walk * moveMap.get(direction));                        ;                        break;                }            }        }        return coordinate;    }    private boolean canIWalk(String[][] parkMap, int[] coordinate, String route) {        String obstacles = \"X\";        Character direction = route.charAt(0);        Integer walk = Integer.parseInt(String.valueOf(route.charAt(2)));        int x = coordinate[1];        int y = coordinate[0];        boolean result = Boolean.TRUE;        switch (direction) {            case 'E': {                walk *= 1;                if (parkMap[0].length &lt;= (walk + x)) {                    result = Boolean.FALSE;                    break;                }                for (int i = x; i &lt;= walk + x; i++) {                    if (parkMap[y][i].equalsIgnoreCase(obstacles)) {                        result = Boolean.FALSE;                        break;                    }                }                break;            }            case 'S': {                walk *= 1;                if (parkMap.length &lt;= (walk + y)) {                    result = Boolean.FALSE;                    break;                }                for (int i = y; i &lt;= walk + y; i++) {                    if (parkMap[i][x].equalsIgnoreCase(obstacles)) {                        result = Boolean.FALSE;                        break;                    }                }                break;            }            case 'W': {                walk *= -1;                if ((walk + x) &lt; 0) {                    result = Boolean.FALSE;                    break;                }                for (int i = x; i &gt;= walk + x; i--) {                    if (parkMap[y][i].equalsIgnoreCase(obstacles)) {                        result = Boolean.FALSE;                        break;                    }                }                break;            }            case 'N': {                walk *= -1;                if ((walk + y) &lt; 0) {                    result = Boolean.FALSE;                    break;                }                for (int i = y; i &gt;= walk + y; i--) {                    if (parkMap[i][x].equalsIgnoreCase(obstacles)) {                        result = Boolean.FALSE;                        break;                    }                }                break;            }        }        return result;    }}",
        "url": "//programmers/2024/05/28/Programmers-series-LV.-01-Walking-In-The-Park.html"
      }
      ,
    
      "programmers-2024-05-28-programmers-series-lv-01-coke-html": {
        "title": "[programmers Series] Lv. 01 Coke",
        "tags": "",
        "date": "May 28, 2024",
        "author": "",
        "category": "",
        "content": "콜라 문제programmers  정답은 아무에게도 말하지 마세요.콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다.빈 병 20개를 가져다주면 몇 병을 받을 수 있는가?단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다.  콜라 빈 병 20병을 가져가서 10병을 받습니다.받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다.5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고,또 2병을 모두 마신 뒤 가져가서 1병을 받습니다.받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다.  이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다.  콜라를 받기 위해 마트에 주어야 하는 병 수 a,빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b,상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다.상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요.알고리즘모듈러 연산풀이@Nestedclass TestCases {    @Test    public void case1 () {        int a = 2;  // 가져다 주는 빈 병 수        int b = 1;  // 빈 병을 가져다 주면 주는 콜라 수        int n = 20; // 빈 병        int expected = 19;        Assertions.assertEquals(expected, solution(a, b, n));    }    @Test    public void case2 () {        int a = 3;  // 가져다 주는 빈 병 수        int b = 1;  // 빈 병을 가져다 주면 주는 콜라 수        int n = 20; // 빈 병        int expected = 9;        Assertions.assertEquals(expected, solution(a, b, n));    }    public int solution( int a, int b, int n ) {        int answer = 0;                int coke = n;        while( true ) {            if( coke &lt; a ) break;                        int remain = coke % a;            int replace = (coke / a) * b;                        answer += replace;            coke = remain + replace;        }                return answer;    }}",
        "url": "//programmers/2024/05/28/Programmers-series-LV.-01-Coke.html"
      }
      ,
    
      "programmers-2024-05-28-programmers-series-lv-01-cardpile-html": {
        "title": "[programmers Series] Lv. 01 Cardpile",
        "tags": "",
        "date": "May 28, 2024",
        "author": "",
        "category": "",
        "content": "카드 뭉치Programmers  코니는 영어 단어가 적힌 카드 뭉치 두 개를 선물로 받았습니다. 코니는 다음과 같은 규칙으로 카드에 적힌 단어들을 사용해 원하는 순서의 단어 배열을 만들 수 있는지 알고 싶습니다.원하는 카드 뭉치에서 카드를 순서대로 한 장씩 사용합니다.한 번 사용한 카드는 다시 사용할 수 없습니다.카드를 사용하지 않고 다음 카드로 넘어갈 수 없습니다.기존에 주어진 카드 뭉치의 단어 순서는 바꿀 수 없습니다.예를 들어 첫 번째 카드 뭉치에 순서대로 [“i”, “drink”, “water”], 두 번째 카드 뭉치에 순서대로 [“want”, “to”]가 적혀있을 때 [“i”, “want”, “to”, “drink”, “water”] 순서의 단어 배열을 만들려고 한다면 첫 번째 카드 뭉치에서 “i”를 사용한 후 두 번째 카드 뭉치에서 “want”와 “to”를 사용하고 첫 번째 카드뭉치에 “drink”와 “water”를 차례대로 사용하면 원하는 순서의 단어 배열을 만들 수 있습니다.문자열로 이루어진 배열 cards1, cards2와 원하는 단어 배열 goal이 매개변수로 주어질 때, cards1과 cards2에 적힌 단어들로 goal를 만들 있다면 “Yes”를, 만들 수 없다면 “No”를 return하는 solution 함수를 완성해주세요.  제한사항1 ≤ cards1의 길이, cards2의 길이 ≤ 101 ≤ cards1[i]의 길이, cards2[i]의 길이 ≤ 10cards1과 cards2에는 서로 다른 단어만 존재합니다.2 ≤ goal의 길이 ≤ cards1의 길이 + cards2의 길이1 ≤ goal[i]의 길이 ≤ 10goal의 원소는 cards1과 cards2의 원소들로만 이루어져 있습니다.cards1, cards2, goal의 문자열들은 모두 알파벳 소문자로만 이루어져 있습니다.알고리즘굳이 따지면 Stack?풀이@Nestedclass TestCases {    @Test    public void case1 () {        String[] cards1 = {\"i\", \"drink\", \"water\"};        String[] cards2 = {\"want\", \"to\"};        String[] goal = {\"i\", \"want\", \"to\", \"drink\", \"water\"};        String expect = \"Yes\";        Assertions.assertEquals(expect, solution(cards1, cards2, goal));    }    @Test    public void case2 () {        String[] cards1 = {\"i\", \"water\", \"drink\"};        String[] cards2 = {\"want\", \"to\"};        String[] goal = {\"i\", \"want\", \"to\", \"drink\", \"water\"};        String expect = \"No\";        Assertions.assertEquals(expect, solution(cards1, cards2, goal));    }    public static String solution(String[] cards1, String[] cards2, String[] goal) {    String answer = \"Yes\";    Stack&lt;String&gt; cardPile1 = new Stack&lt;&gt;();    Stack&lt;String&gt; cardPile2 = new Stack&lt;&gt;();    Stack&lt;String&gt; goals = new Stack&lt;&gt;();    for( String card : cards1) cardPile1.add(card);    for( String card : cards2) cardPile2.add(card);    for( String word : goal) goals.add(word);    while( !goals.isEmpty() ) {        String goalWord = goals.pop();        if( goalWord.equals(cardPile1.peek()) ) {            cardPile1.pop();            continue;        }        if(goalWord.equals(cardPile2.peek())) {            cardPile2.pop();            continue;        }        answer = \"No\";        break;    }    return answer;}}    ",
        "url": "//programmers/2024/05/28/Programmers-series-LV.-01-CardPile.html"
      }
      ,
    
      "programmers-2024-05-28-programmers-series-lv-01-babbling-html": {
        "title": "[programmers Series] Lv. 01 Babbling",
        "tags": "",
        "date": "May 28, 2024",
        "author": "",
        "category": "",
        "content": "옹알이 (2)programmers  머쓱이는 태어난 지 11개월 된 조카를 돌보고 있습니다.조카는 아직 “aya”, “ye”, “woo”, “ma” 네 가지 발음과네 가지 발음을 조합해서 만들 수 있는 발음밖에 하지 못하고연속해서 같은 발음을 하는 것을 어려워합니다.  문자열 배열 babbling이 매개변수로 주어질 때,머쓱이의 조카가 발음할 수 있는 단어의 개수를 return 하도록 solution 함수를 완성해주세요.  제한사항1 ≤ babbling의 길이 ≤ 1001 ≤ babbling[i]의 길이 ≤ 30문자열은 알파벳 소문자로만 이루어져 있습니다.알고리즘없음풀이@Nestedpublic class TestCase {   @Test    public void case1 () {       String[] babbling = {\"aya\", \"yee\", \"u\", \"maa\"};       int result = 1;       Assertions.assertEquals(result, solution(babbling));   }   @Test    public void case2 () {       String[] babbling = {\"ayaye\", \"uuu\", \"yeye\", \"yemawoo\", \"ayaayaa\"};       int result = 2;       Assertions.assertEquals(result, solution(babbling));   }    @Test    public void case3 () {        String[] babbling = {\"zxv\", \"uasduu\", \"saf\", \"gas\", \"fd\"};        int result = 0;        Assertions.assertEquals(result, solution(babbling));    }    @Test    public void case4 () { //이 예시가 가장 어이없었음        String[] babbling = {\"ymae\"};        int result = 0;        Assertions.assertEquals(result, solution(babbling));    }    //각 케이스를 분해해서 확인        public static int solution( String[] babbling ) {        String[] language = {\"aya\", \"ye\", \"woo\", \"ma\"};        Pattern continuous = Pattern.compile(                \"(aya){2,}|(ye){2,}|(woo){2,}|(ma){2,}\",                Pattern.DOTALL        );        int count = Arrays.stream(babbling)                //PatternMatch로 반복되는 경우 제외                .filter(elem -&gt; {                    Matcher matcher = continuous.matcher(elem);                    return !matcher.find();                })                //단어별 Replace로 변경하되                //바로 공백으로 바꾸면 중간 단어가 없어져서                //통과될 위험이 있음                .map(elem -&gt; {                    String result = elem;                    for ( String lang : language ) {                        result = result.replaceAll(lang, \"@\");                    }                    return result.replaceAll(\"@\",\"\")                            .length() == 0 ? 1 : 0;                })                .collect(Collectors.summingInt(value -&gt; value.intValue()));        return count;    }}",
        "url": "//programmers/2024/05/28/Programmers-series-LV.-01-Babbling.html"
      }
      ,
    
      "issue-2024-05-28-issue-series-eventsourcestream-html": {
        "title": "[issue Series] Eventsourcestream",
        "tags": "",
        "date": "May 28, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EventSourceStream-ISSUEEventSourceStream and Issue  모 프로젝트에서 채팅을 구현하던 도중 Server-Sent Event으로 채팅방 정렬, 새로운 채팅방 개설 등의 작업을 진행하던 도중 겪었던 일이다.short polling/ long polling이렇게 주기적으로 서버에 질의를 던지고 바뀐 점이 있으면 가져온다.short polling은 주기가 짧게, long polling 주기 길게SSEServer@RestController  @Slf4j  public class SseController {        private final SseEmitters sseEmitters;        public SseController(SseEmitters sseEmitters) {          this.sseEmitters = sseEmitters;      }        @GetMapping(value = \"/connect\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)      public ResponseEntity&lt;SseEmitter&gt; connect() throws RuntimeException{          SseEmitter emitter = new SseEmitter(60 * 1000L);          sseEmitters.add(emitter);            emitter.send(SseEmitter.event()                      .name(\"connect\")                      .data(\"connected!\"));          return ResponseEntity.ok(emitter);      }  }Clientconst sse = new EventSource(\"http://localhost:8080/connect\");sse.addEventListener('connect', (e) =&gt; {\tconst { data: receivedConnectData } = e;\tconsole.log('connect event data: ',receivedConnectData);  // \"connected!\"});Server에서 SseEmitter 를 생성해서 Client에서 EventSource를 생성해서 그리고 eventListener를 등록해서 이벤트를 Emit 받으면 Listen해서 동작하는 식이다.이슈  503 Service Unavailable : 맨 처음 Sse를 만들고 이벤트를 emit하지 않으면 발생한다. emitter.send(SseEmitter.event().name(\"connect\").data(\"connected!\"));  그래서 위 코드와 같이 바로 send() 한다.      Jpa Connection 고갈 : open-in-view를 열어놓으면 DB 커넥션이 고갈될 수 있다.        MemoryLeak : client에서 사용하지 않을 때 heartbeat를 보내는 것으로 보인다. 그런데, 문제는 client에서 커넥션을 끊어도, 서버에서 emitter를 정리해도메모리에서 해제되지 않는 이슈가 있었다.  emitter.onCompletion(() -&gt; {      this.emitters.remove(emitter);    // 만료되면 리스트에서 삭제});  emitter.onTimeout(() -&gt; {      emitter.complete();  });  등의 훅을 설정해도 문제가 있었다.  찾아보니 이 메모리 누수 문제는 꽤나 많이 발생하던 문제로 보였다.결국 websocket으로 해결했다.결론SSE(EventSource)는 쓰기에 무리가 있는 것으로 보인다.",
        "url": "//issue/2024/05/28/ISSUE-series-EventSourceStream.html"
      }
      ,
    
      "issue-2024-05-27-issue-series-floatingpoint-html": {
        "title": "[issue Series] Floatingpoint",
        "tags": "",
        "date": "May 27, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FloatingPointIssue부동 소수점 관련 문제class FloatingPoint {    @Test    public void fpFailure() {        Assertions.assertEquals(1.2 , 1.1 + 0.1);        //결과는? false        //부동소수점 문제 때문에 그렇다. (특히 이 주변은 다 괜찮은데 얘만 그렇다.)        /**         * Expected :1.2         * Actual   :1.2000000000000002         */        //위와 같은 결과로 나온다.    }        @Test    public void fpSuccess() {        Assertions.assertEquals(BigDecimal.valueOf(1.2), BigDecimal.valueOf(1.1).add(BigDecimal.valueOf(0.1)));        //이러면 성공한다.    }}Java _ BigDecimal 관련 사용 시 유의점연산  ’+’ : BigDecimal.valueOf(x).add(BigDecimal.valueOf(y));  ’-‘ : BigDecimal.valueOf(x).substract(BigDecimal.valueOf(y));  ‘*’ : BigDecimal.valueOf(x).multiply(BigDecimal.valueOf(y));  ’/’ : BigDecimal.valueOf(x).divide(BigDecimal.valueOf(y));  ’%’ : BigDecimal.valueOf(x).remainder(BigDecimal.valueOf(y));  절대값 : BigDecimal.valueOf(x).abs();소수점RoundingMode  UP(BigDecimal.ROUND_UP), : 양수일 때 올림, 음수일 때 내림  DOWN(BigDecimal.ROUND_DOWN), : ROUND_UP과 반대  CEILING(BigDecimal.ROUND_CEILING), : 올림  FLOOR(BigDecimal.ROUND_FLOOR), : 내림  HALF_UP(BigDecimal.ROUND_HALF_UP), : 반올림 (5이상 올림 5미만 버림)  HALF_DOWN(BigDecimal.ROUND_HALF_DOWN), : 반올림 ( 6이상 올림, 6미만 버림)  HALF_EVEN(BigDecimal.ROUND_HALF_EVEN), : 반올림 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP  UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);: 딱 떨어지는 값이 아니면 ArithmeticException사용법BigDecimal(\"0.9999\").setScale(0, RoundingMode.CEILING);MathContext  UNLIMITED = new MathContext(0, RoundingMode.HALF_UP); : unlimit (무제한 정밀 산술)  DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal32 format, 7 digits ( 7자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal64 format, 16 digits  ( 16자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);: matching the precision of the IEEE 754-2019 decimal128 format, 34 digits ( 32자리 정밀도 및 HALF_EVENT의 반올림 모드)MethodsBigIntegerclass IntroduceBigInteger {    public void bit () {        BigInteger i = new BigInteger(\"1018\"); // 2진수로 표현하면 : 1111111010(2)        int bitCount = i.bitCount(); // 1의 갯수 : 8        int bitLength = i.bitLength(); // 비트 수 : 10        int getLowestSetBit = i.getLowestSetBit(); // 1        boolean testBit3 = i.testBit(3); // true        BigInteger setBit12 = i.setBit(12); // 우측에서 13번째 비트를 1로 변경 → 1001111111010(2) → 5114        BigInteger flipBit0 = i.flipBit(0); // 1111111011(2) → 1019        BigInteger clearBit3 = i.clearBit(3); // 1111110010(2) → 1010        }           public void bitOperate () {        BigInteger i = new BigInteger(\"17\"); // 2진수 : 10001(2)        BigInteger j = new BigInteger(\"7\"); // 2진수 : 111(2)        BigInteger and = i.and(j); // 10001(2) &amp; 111(2) = 00001(2) → 1(10)        BigInteger or = i.or(j); // 23        BigInteger not = j.not(); // -8        BigInteger xor = i.xor(j); // 22        BigInteger andNot = i.andNot(j); // 16        BigInteger shiftLeft = i.shiftLeft(1); // 34        BigInteger shiftRight = i.shiftRight(1); // 8    }}JsonSerializerBigDecimal to JsonValueclass BigDecimalScale6WithBankersRoundingSerializer  implements JsonSerializer&lt;BigDecimal&gt; {    public static Integer SCALE_SIX = 6;    public static RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;        @Override    public Object serialize( BigDecimal value, JsonGenerator gen,   SerializerProvider serializers ) {        return gen.writeString(value.setScale(SCALE_SIX, BANKERS_ROUNDING_MODE).toString());    }}",
        "url": "//issue/2024/05/27/ISSUE-series-FloatingPoint.html"
      }
      ,
    
      "issue-2024-05-27-issue-series-filepart-html": {
        "title": "[issue Series] Filepart",
        "tags": "",
        "date": "May 27, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FilePart-ISSUEFilePartFilePart는 MultipartRequest에서 업로드 된 파일을 표현하는데 특화된 인터페이스다.            Method      Description      Return                  filename()      클라이언트가 업로드한 파일의 원본 명을 리턴한다.      String              transferTo(File dest)      파일을 주어진 목적지로 옮기는 메소드다.      reactor.core.publisher.Mono      WebFlux에서 MultipartFile?WebFlux에서 MultipartFile Converter가 없어졌다. 그도 그럴 것이 MultipartFile은 Servlet에서 파일을 다루던 형식이기 때문이다.FilePart에 content -&gt; Flux&lt;DataBuffer&gt;로 byte[]에도 접근할 수 있다.이슈 사항dependency를 수정하던 도중  multipartFile의 transferTo를 리턴  이 값을 map,  zipWith, zipWhen으로 묶어서 로직을 수행할 수 있도록 수정  controller return 으로 이 파이프 라인을 반환하여 webflux가 subscribe 하도록 함의 순으로 했는데 문제는 로직은 정상이었는데 파일이 복사가 되지 않는 현상이 생겼다. 추정컨데, controller return 하면서 transferTo의 대상인 임시 파일이 삭제되서 생기는 현상으로 보였다.결국  flatMap으로 흐름을 정리  thenReturn으로 정리하도 다른 리턴 값을 정의  subscribe를 호출하고 그 안에서 새로운 Mono를 생성하여 반환하거나하는 방식으로 해결했다.",
        "url": "//issue/2024/05/27/ISSUE-series-FilePart.html"
      }
      ,
    
      "docker-2024-05-26-docker-series-05-docker-private-registry-html": {
        "title": "[docker Series] 05.docker Private Registry",
        "tags": "",
        "date": "May 26, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Docker Private RegistryDocker Private Registry구축보통 아래 두 개의 이미지를 사용해서 구축한다.registryhyper/docker-registry-web  registry, registry-web을 구성하고 서로 docker network로 엮어 준다.  추가로 registry-web에 env로 REGISTRY_URL, REGISTRY_NAME을 줘야 한다.  REGISTRY_URL는 예를 들어 http://localhost:port/v2, REGISTRY_NAME는 http://localhost:port  둘 다 포트를 개방한다. web은 외부에서 접속할 경우, registry는 이미지를 pull, push 할 때 주로 사용할 것이다.  curl -XGET localhost:5000/v2/_catalog로 레지스트리를 확인하고 curl -XGET localhost:5050/으로 web도 확인해 본다.이미지 태그 변경docker tag  원본:태그   도커 허브 주소:도커 허브 포트/원본:태그이미지 푸시docker push 도커 허브 주소:도커 허브 포트/원본:태그이미지 풀docker pull 도커 허브 주소:도커 허브 포트/원본:태그이슈!apache로 연결시 unknown blob 메시지 출력 시Header add X-Forwarded-Proto \"https\"RequestHeader add X-Forwarded-Proto \"https\"      X-Forwarded-Proto(XFP) 란?X-Forwarded-Proto (XFP) 헤더는 클라이언트가 프록시 또는 로드 밸런서에 접속하는데에 사용했던 프로토콜(HTTP 또는 HTTPS)이 무엇인지 확인하는 사실상의 표준 헤더 입니다.        클라이언트 -&gt; Proxy 서버 -&gt; 웹 서버  그래서 클라이언트의 HTTP/HTTPS 정보를 프록시에서 X-Forwarded-Proto 요청 헤더를 담아 웹 서버로 전달해줘야 한다. 만약 설정하지 않으면 클라이언트는 HTTPS로 접속을 하지만 웹 서버(웹 어플리케이션에서)에서는 프록시에서는 HTTP로 요청하기 때문에 클라이언트의 정보와 틀릴 수 있다.",
        "url": "//docker/2024/05/26/Docker-series-05.docker-Private-Registry.html"
      }
      ,
    
      "docker-2024-05-26-docker-series-04-dockerdaemon-html": {
        "title": "[docker Series] 04.dockerdaemon",
        "tags": "",
        "date": "May 26, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ComposeCompose사용 이유    매번 run 명령어에 옵션을 설정해 CLI로 컨테이너를 생성하기보다는 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리하면 더 편한 것이다.    이를 위해서 도커 컴포즈(Oocker Compose)는 컨테이너를 이용한 서비스의 개발과 CI를 위해 여러 개의 컨테이너를 하나의 프로젝트로서 다룰 수 있는 작업     환경을 제공한다.        도커 컴포즈는 여러 개의 컨테이너의 옵션과 환경을 정의한 파일을 읽어 컨테이너를 순차적으로 생성하는 방식으로 동작한다. 도커 컴포즈의 설정 파일은 run    명령어의 옵션을 그대로 사용할 수 있으며, 각 컨테이너의 의존성, 네트워크 볼륨 등을 함께 정의할 수 있다. 또한 스웜 모드의 서비스와 유사하게 설정     파일에 정의된 서비스의 컨테이너 수를 유동적으로 조절할수 있으며 컨테이너의 서비스 디스커버리도 자동으로 이뤄진다. 이러한 기능이 필요하지 않은 소규모    컨테이너 개발 환경에서는 도커 엔진의 run 명령어로 컨테이너를 생성하는 것이 더 편리할 수 있다. 그렇지만 컨테이너의 수가 많아지고 정의해야 할 옵션이    많아진다면 도커 컴포즈를 사용하는 것이 좋다.## 1) 버전 정의## YAML 파일 포맷에는 버전 1, 2, 2.1, 3이 있다. 버전 3은 도커 스웜모드와 호환이 되는 버전이다.## 버전 항목은 일반적으로 YAML 파일의 맨 윗부분에 명시한다.   version: '3.0'## 2) 서비스 정의 ## 서비스는 도커 컴포즈로 생성할 컨테이너 옵션을 정의한다. 이 항목에 쓰인 각 서비스는 컨테이너로 구현되며, 하나의 프로젝트로서 도커 컴포즈에 의해 관리된다. ## 서비스의 이름은 services의 하위 항목으로 정의하고, 컨테이너의 옵션은 서비스 이름의 하위 항목에 정의한다.    services:      my_container_1:        image: ...          links:            - db            - db:database            - redis          command: apachectl -DFOREGOURND      my_container_2:        image: ...        environment:          - MYSQL_ROOT_PASSWORD=mypassword          - MYSQL_DATABASE_NAME=mydb          ##또는          MYSQL_ROOT_PASSWORD: mypassword          MYSQL_DATABASE_NAME: mydb        command:[apachectl, -DFOREGROUND]        depends_on          - mysql        ports:          - \"8080\"          - \"8081-8085\"          - \"80:80\"       ## - image: 서비스의 컨테이너를 생성할 떄 쓰일 이미지의 이름을 설정한다. 이미 지름 포맷은 docker run과 같다.##  만일 이미지가 도커에 존재하지 않으면 저장소에서 자동으로 pull한다.## - links: docker run 명령어의 --link와 같으며, 다른 서비스에 서비스명만으로 접근할 수 있도록 설정한다. [SERVICE:ALIAS]의 형식을 사용하면 ##  서비스에 별칭으로도 접근할 수 있다.## - environment: docker run 명령어의 --env, -e 옵션과 동일하다. 서비스의 컨테이너 내부에서 사용할 환경변수를 지정하며, 딕셔너리(Dictionary)나##  배열 형태로 사용할 수 있다.  ## - command : 컨테이너가 실행될 때 수행할 명령어를 설정하며, docker run 명령어의 마지막에 붙는 커맨드와 같다. Dockerfile의 RUN 과 같은 배열##  형태로도 사용할 수 있다.  ## - depends_on : 특정 컨테이너에 대한 의존 관계를 나타내며, 이 항목에 명시된 컨테이너가 먼저 생성되고 실행된다. links도 depends_on과 같이##  컨테이너의 생서 ㅇ순서와 실행 순서를 정의하지만 depends_on은 서비스 이름으로만 접근할 수 있다는 점이 다르다.      ## &gt; 특정 서비스의 컨테이너만 생성하되 의존성이 없는 컨테이너를 생성하려면 --no-deps 옵션을 사용한다.     \"docker-compose up --no-deps web\"  {    links, depends_on 모두 실행 순서만 설정할 뿐 컨테이너 내부의 애플리케이션이 준비된 상태인지에 대해서는 확인하지 않는다. 예를 들어서 데이터베이스     컨테이너와 웹 서버 컨테이너가 정해진 순서대로 실행됐더라도 데이터베이스가 초기화 중이라면 웹 서버 컨테이너가 정상적으로 동작하지 않을 수 있다. 이를     해결하는 방법으로 컨테이너에 셸 스크립트를 entrypoint로 지정하는 방법이 있다. YAML 파일의 entrypoint에서 지정할 수 있다.          services:        web:          entrypont: ./sync_script.sh mysql:3306        entrypoint에 저장된 sync_script.sh는 until 구문의 조건 안에 다른 컨테이너의 애플리케이션이 준비됐는지 확인하는 명령어를 입력한다. 예를 들어    curl mysql:3306을 조건으로 넣는다면 mysql 데몬이 준비될 때까지 기다린다.                 [          until (상태를 확인할 수 있는 명령어); do              echo \"depend container is not available yet\"              sleep 1          done          echo \"depends_on container is ready\"        ]  }## - ports:  docker run 명령어의 -p와 같으며 서비스의 컨테이너를 개방할 포트를 설정한다. 그러나 단일 호스트 환경에서 80:80과 같이 호스트의 특정 ##   포트를 서비스의 컨테이너에 연결하면 docker-compose scale 명령어로 서비스의 컨테이너 수를 늘릴 수 없습니다.    services:      web:        image : alicek106/composetest:web          ports:            - \"8080\"            - \"8081-8085\"            - \"80:80\"## - build: build 항목에 정의된 Dockerfile에서 이미지를 빌드해 서비스의 컨테이너를 생성하도록 설정한다.     services:        web:          build: ./composetest          image: alicek106/composetest:web##    또는 build 항목에서는 Dockerfile 사용될 컨텍스트나 Dockerfile의 이름, Dockerfile에서 사용될 인자 값을 설정할 수 있다. image 항목을 설정하지 않으면##    이미지의 이름은 [프로젝트 이름]:[서비스 이름]이 된다.    services:      web:         build: ./composetest        context: ./composetest        dockerfile: myDockerfile        args:          HOST_NAME: web            HOST_CONFIG: self_config      {        build 항목을 YAML 파일에 정의해 프로젝트를 생성하고 난 뒤 Dokcerfile을 변경하고 다시 프로젝트를 생성해도 이미지를 새로 빌드하지 않는다.         'docker-compose up -d'에 '--build' 옵션을 추가하거나 docker-compose build 명령어를 사용해서 Dockerfile이 변경돼도 컨테이너를 생성할 때마다         빌드하도록 설정할 수 있다.                  'docker-compose up -d --build'          'docker-compose build [yml 파일에서 빌드할 서비스 이름]'      }## - extends: 다른 YAML 파일이나 현재 YAML 파일에서 서비스 속성을 상속받게 설정한다. 다음과 같이 2개의 YAML 파일이 있을 때 docker-compose.yml의 web 서비스는##    extend_compose.yml의 extend_web 서비스의 옵션을 그대로 갖게 된다. 즉, web 서비스의 컨테이너는 ubunutu:14.04 이미지의 80:80 포트로 설정된다. file##    항목을 설정하지 않으면 현재 YAML 파일에서 extends할 서비스를 찾는다 .####  설정을 상속받을 docker-compose.yml 파일      version: '3.0'    services:      web:        extends:          file: extend_compose.yml          service: extend_web          #### 설정을 상속해줄 extend_compose.yml 파일  version: '3.0'    services:      extend_web:      image: ubuntu:14.04      ports:        - \"80:80\"  #### 그러나 depends_on, links, volumes_from 항목은 각 컨테이너 사이의 의존성을 내포하므로 extends로 상속받을 수 없다.## 3) 네트워크 정의 ## - driver: 도커 컴포즈는 생성된 컨테이너를 위해 기본적으로 브릿지 타입의 네트워크를 생성한다. 그러나 YAML 파일에서 driver 항목을 정의해서 서비스의 컨테이너가 ##  브릿지 네트워크가 아닌 다른 네트워크를 사용하도록 설정할 수 있다. 특정 드라이버에 필요한 옵션은 하위 항목인 driver_opts로 전달할 수 있다.    version: '3.0'  services:    myservice:      image: nginx      networks:        - mynetwork  networks:    mynetwork:      driver: overlay      driver_opts:        subnet: \"255.255.255.0\"        IPAddress: \"10.0.0.2\"##   위의 예시는 docker-compose up -d 명령어로 컨테이너를 생성할 때 mynetwork라는 overlay 타입의 네트워크도 함께 생성하고,  myservice 서비스의 네트워크가##   mynetwork 네트워크를 사용하도록 설정한다. 단, overlay 타입의 네트워크는 스웜 모드나 주키퍼를 사용하는 환경이어야만 생성할 수 있다.## - ipam: IPAM( IP Address Manager )ㄹㅡㄹ 위해 사용할 수 있는 옵션으로 subnet, ip 범위 등을 설정할 수 있다. driver 항목에는 IPAM을 지원하는 드라이버의##  이름을 입력한다.      services:        ...        networks:        ipam:          driver: mydriver          config:            subnet: 172.20.0.0/16            ip_range: 172.20.5.0/24            gateway: 172.20.5.1## - external : YAML 파일을 통해 프로젝트를 생성할 때마다 네트워크를 생성하는 것이 아닌, 기존의 네트워크를 사용하도록 설정한다. 이를 설정하려면 사용하려는 외부##  네트워크의 이름을 하위 항목으로 입력한 뒤, external의 값을 treu로 설정한다. external 옵션은 준비된 네트워크를 사용하므로 driver, driver_opts, ipam 옵션과##  함꼐 사용할 수 없다.        services:      web:        image: alicek106/composetest:web        networks:          -alicek106_network    networks:      alicek106_network:        external: true##  위의 예제는 서비스의 컨테이너가 기존의 alicek106_network라는 이름의 네트워크를 사용하도록 설정한다.## 4) 볼륨 정의## - driver : 볼륨을 생성할 때 사용될 드라이버를 설정한다. 어떠한 설정도 하지 않으면 local로 설정되며 사용하는 드라이버에 따라 변경해야한다. 드라이버를 사용하기 위한 ## 추가 옵션은 하위 항목인 driver_opts를 통해 인자로 설정할 수 있다.  version: '3.0'  services:    ...  volumes:    driver: flocker      driver_opts:        opt: \"1\"        opt2: 2## - external : 도커 컴포즈는 YAML 파일에서 volume, volumes-from 옵션 등을 사용하면 프로젝트마다 볼륨을 생성한다. 이때 external 옵션을 설정하면 볼륨을 ##  프로젝트 생성할 때마다 생성하지 않고 기존 볼류믕ㄹ 사용하도록 설정한다.   services:    web:      image: alicek106/composetest:web      volumes:        - myvolume:/var/www/html  volumes:    myvolume:      external: true## 위의 예제에서 myvolmue이라는 이름의 외부 볼륨을 web 서비스의 컨테이너에 마운트 한다. ##  5) YAML 파일 검증하기##  YAML 파일을 작성할 때 오타 검사나 파일 포맷이 적절한지를 검사하려면 'docker-compose config' 명령어를 사용한다. 기본적으로 현재 디렉토리의 ##  docker-compose.yml 파일을 검사하지만 docker-compose -f (yml 파일 경로) config와 같이 검사할 파일의 경로를 설정할 수 있다.     'docker-compose config'",
        "url": "//docker/2024/05/26/Docker-series-04.dockerDaemon.html"
      }
      ,
    
      "docker-2024-05-26-docker-series-03-dockerfile-html": {
        "title": "[docker Series] 03.dockerfile",
        "tags": "",
        "date": "May 26, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DockerFileDockerFile    개발한 애플리케이션을 컨테이너화할 때 가장 먼저 생각하는 방법은 아래와 같다.        1. 아무것도 존재하지 않는 이미지(Ubuntu, CentOS 등)로 컨테이너 생성    2. 애플리케이션을 위한 환경을 설치하고 소스코드 등을 복사해서 잘 동작하는 것을 확인    3. 컨테이너를 이미지로 커밋        이 방법을 사용하면 애플리케이션이 동작하는 환경을 구성하기 위해 일일이 수작업으로 패키지를 설치하고 소스 코드를 GIT에 복제 하거나    호스트에서 복사해야한다. 물론 직접 컨테이너에서 애플리케이션을 구동해보고 이미지로 커밋(commit)하기 때문에 이미지의 동작을 보장할 수 있다는    점도 있다. 이 과정을 기록한 파일의 이름을 DockerFile이라고 한다. [        FROM ubuntu:14.04        MAINTAINER alicek106        LABEL \"pupose\"=\"priactice\"        RUN apt-get update        RUN apt-get install apache2 -y        ADD test.html /var/www/html        WORKDIR /var/ww/html        RUN [\"/bin/bash\", \"-c\", \"echo hello &gt;&gt; test2.html\"]        EXPOSE 80        CMD apachectl -DFOREGROUND    ]        -----------------------            {        FROM : 생성할 이미지의 베이스가 될 이미지를 뜻한다. FROM 명령어는 Dockerfile을 작성할 때 반드시 한 번 이상 입력해야        하며, 이미지 이름의 포맷은 docker run 명령어에서 이름을 사용했을 때와 같다. 사용하려는 이미지가 도커에 없다면 자동으로        pull한다.                MAINTAINER : 이미지를 생성한 개발자의 정보를 나타낸다. 단 docker 1.13.0 이후로 사용하지 않는다.         이후로는 LABEL maintainer \"~\"로 대체할 수 있다.                LABEL : 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. 예제에서는 apt-get update,         apt-get install apache2를 실행했다. 단, Dockerfile을 이미지로 빌드하는 과정에는 별도의 입력이 불가능하기 때문에         Y/N을 YES로 설정해야한다. 이미지를 빌드할 때 별도의 입력을 받아야하는 RUN이 있다면 build 명령어는 이를 오류로 간주한다.                         COPY : 호스트에 있는 파일/ 디렉토리를 이미지에 붙여 넣느다.                ADD : 파일을 이미지에 추가한다. 추가하는 파일은 Dockerfile이 위치한 디렉토리인 컨텍스트(Context)에서 가져온다.        ADD명령어는 JSON 배열의 형태로 [\"추가할 파일 이름\", ...,\"컨테이너에 추가될 위치\"]와 같이 사용할 수 있다. 추가할 파일은        여러 개를 지정할 수 있으며, 배열의 마지막 원소가 컨테이너에 추가될 위치이다.                추가적으로 URL로 파일을 붙여 넣을 수도 있다. 예를 들어 `~.tar.gz`와 같이 쓰면 자동으로 압축까지 해체한다.                         WORKDIR : 명령어를 실행할 디렉토리를 나타낸다. 배시 셸에서 cd명령어를 입력하는 것과 같은 기능을 한다.                 EXPOSE : Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정한다. 그러나 EXPOSE를 설정한 이미지로 컨테이너를         생성했다고 해서 반드시 이 포트가 바인딩되는 것은 아니며, 단지 컨테이너의 80번 포트를 사용할 것임을 나타내는 것일뿐이다.        EXPOSE는 컨테이너를 생성하는 run 명령어에서 모든 노출된 컨테이너의 포트를 호스트에 퍼블리시하는 -P 플래그와 함께 사용한다.                        RUN :  명령어에 배열로 명령어를 입력하면 순서대로 실행한다.                 CMD : CMD는 컨테이너가 시작될 때마다 실행할 명령어를 설정하며, Dockerfile에서 한 번만 사용할 수 있다.        Dockerfile에 CMD를 명시함으로써 이미지에 apachectl -DFOREGROUND라는 커맨드를 내장하면 컨테이너를 생성할 때 별도의        커맨드를 입력하지 않아도 이미지에 내장된 apachectl -DFOREGROUND 커맨드가 적용되어 컨테이너가 시작될 때 자동으로 아파치        웹 서버가 실행된다.                 ENTRYPOINT: 컨테이너가 시작될 때 항상 실행할 명령을 지정한다. `docker run`으로 실행할 때 추가 인자로 덮어 쓸 수 있다. 또한 CMD와 달리 배열형태로         지정하는게 아니면 기본 셸로 실행된다.     }RUN vs. CMD vs. ENTRYPOINT  RUN : 도커파일로 이미지를 빌드하는 순간 실행되는 명령어다. 따라서 주로 패키지 업데이트, 라이브러리 설치에 사용된다.  CMD : 이미지로 컨테이너를 생성할 때 최초록 수행된다.  ENTRYPOINT : CMD와 유사하다 그러나 생성되고 최초로 실행될 때 수행되는 명령어를 지정한다.",
        "url": "//docker/2024/05/26/Docker-series-03.dockerfile.html"
      }
      ,
    
      "docker-2024-05-26-docker-series-02-command-html": {
        "title": "[docker Series] 02.command",
        "tags": "",
        "date": "May 26, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CommandCommandcreate‘docker run -i -t –name [컨테이너 이름] -p [호스트IP]:[호스트 포트]:[컨테이너 포트] [이미지]:[버전]’list‘docker ps’ : ‘docker ps’는 정지되지 않은 컨테이너만 출력합니다.remove‘docker rm -f [컨테이너 명]’‘docker conatiner prune’ :  일괄 삭제link’–link wordpressdb:mysql’ :  IP를 몰라도 mysql이라는 호스트명으로 접근할 수 있도록 한다.권한 수정  sudo usermod -aG docker [userName]sudo service docker restart",
        "url": "//docker/2024/05/26/Docker-series-02.command.html"
      }
      ,
    
      "docker-2024-05-26-docker-series-01-options-html": {
        "title": "[docker Series] 01.options",
        "tags": "",
        "date": "May 26, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - OptionsOptions-a--attach=[]: 컨테이너에 표준 입력(stdin), 표준 출력(stdout), 표준 에러(stderr)를 연결합니다.ex) --attach=”stdin”--add-host=[]: 컨테이너의 /etc/hosts에 호스트 이름과 IP 주소를 추가합니다.ex) --add-host=hello:192.168.0.10-c--cpu-shares=0: CPU 자원 분배 설정입니다. 설정의 기본 값은 1024이며 각 값은 상대적으로 적용됩니다.ex) --cpu-shares=2048처럼 설정하면 기본 값 보다 두 배 많은 CPU 자원을 할당합니다.이 설정 값은 리눅스 커널의 cgroups에서 사용됩니다.--cap-add=[]: 컨테이너에서 cgroups의 특정 Capability를 사용합니다. ALL을 지정하면 모든 Capability를 사용합니다.ex) --cap-add=”MKNOD” --cap-add=”NET_ADMIN”처럼 설정합니다. 모든 Capability 목록은 다음 링크를 참조하기 바랍니다. (http://linux.die.net/man/7/capabilities)--cap-drop=[]: 컨테이너에서 cgroups의 특정 Capability를 제외합니다.--cidfile=””: cid 파일 경로를 설정합니다. cid 파일에는 생성된 컨테이너의 ID가 저장됩니다.--cpuset=””: 멀티코어 CPU에서 컨테이너가 실행될 코어를 설정합니다.ex) --cpuset=”0,1”처럼 설정하면 첫 번째, 두 번째 CPU 코어를 사용합니다.ex) --cpuset=”0-3”처럼 설정하면 첫 번째 CPU 코어부터 네 번째까지 사용합니다.-d--detach=false: Detached 모드입니다. 보통 데몬 모드라고 부르며 컨테이너가 백그라운드로 실행됩니다.--device=[]: 호스트의 장치를 컨테이너에서 사용할 수 있도록 연결합니다. &lt;호스트 장치&gt;:&lt;컨테이너 장치&gt; 형식입니다.ex) --device=”/dev/sda1:/dev/sda1”처럼 설정하면 호스트의 /dev/sda1 블록 장치를 컨테이너에서도 사용할 수 있습니다.--dns=[]: 컨테이너에서 사용할 DNS 서버를 설정합니다.ex) --dns=”8.8.8.8”--dns-search=[]: 컨테이너에서 사용할 DNS 검색 도메인을 설정합니다.ex) --dns-search=”example.com”처럼 설정하면 DNS 서버에 hello를 질의할 때 hello.example.com을 먼저를 찾습니다.-e--env=[]: 컨테이너에 환경 변수를 설정합니다. 보통 설정 값이나 비밀번호를 전달할 때 사용합니다.ex) -e MYSQL_ROOT_PASSWORD=examplepassword--entrypoint=””: Dockerfile의 ENTRYPOINT 설정을 무시하고 강제로 다른 값을 설정합니다.ex) --entrypoint=”/bin/bash”--env-file=[]: 컨테이너에 환경 변수가 설정된 파일을 적용합니다.ex) --env-file=”/etc/environment”--expose=[]: 컨테이너의 포트를 호스트와 연결만 하고 외부에는 노출하지 않습니다.ex) --expose=”3306”-h--hostname=””: 컨테이너의 호스트 이름을 설정합니다.-i--interactive=false: 표준 입력(stdin)을 활성화하며 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지합니다. 보통 이 옵션을 사용하여 Bash에 명령을 입력합니다.--link=[]: 컨테이너끼리 연결합니다. &lt;컨테이너 이름&gt;:&lt;별칭&gt; 형식입니다.ex) --link=”db:db”--lxc-conf=[]: LXC 드라이버를 사용한다면 LXC 옵션을 설정할 수 있습니다.ex) --lxc-conf=”lxc.cgroup.cpuset.cpus = 0,1”-m--memory=””: 메모리 한계를 설정합니다. &lt;숫자&gt;&lt;단위&gt; 형식이며 단위는 b, k, m, g를 사용할 수 있습니다.ex) --memory=”100000b”ex) --memory=”1000k”ex) --memory=”128m”ex) --memory=”1g”-n--name=””: 컨테이너에 이름을 설정합니다.ex) --net=”bridge”: 컨테이너의 네트워크 모드를 설정합니다.bridge: Docker 네트워크 브리지에 새 네트워크를 생성합니다.none: 네트워크를 사용하지 않습니다.container:&lt;컨테이너 이름, ID&gt;: 다른 컨테이너의 네트워크를 함께 사용합니다.host: 컨테이너 안에서 호스트의 네트워크를 그대로 사용합니다. 호스트 네트워크를 사용하면 D-Bus를 통하여 호스트의 모든 시스템 서비스에 접근할 수 있으므로 보안에 취약해집니다.-p--publish-all=false: 호스트에 연결된 컨테이너의 모든 포트를 외부에 노출합니다.--publish=[]: 호스트에 연결된 컨테이너의 특정 포트를 외부에 노출합니다. 보통 웹 서버의 포트를 노출할 때 주로 사용합니다.    &lt;호스트 포트&gt;:&lt;컨테이너 포트&gt; 예) -p 80:80    &lt;IP 주소&gt;:&lt;호스트 포트&gt;:&lt;컨테이너 포트&gt; 호스트에 네트워크 인터페이스가 여러 개이거나 IP 주소가 여러 개 일 때 사용합니다. 예) -p 192.168.0.10:80:80    &lt;IP 주소&gt;::&lt;컨테이너 포트&gt; 호스트 포트를 설정하지 않으면 호스트의 포트 번호가 무작위로 설정됩니다. 예) -p 192.168.0.10::80    &lt;컨테이너 포트&gt; 컨테이너 포트만 설정하면 호스트의 포트 번호가 무작위로 설정됩니다. 예) -p 80    --privileged=false: 컨테이너 안에서 호스트의 리눅스 커널 기능(Capability)을 모두 사용합니다-r--restart=””: 컨테이너 안의 프로세스 종료 시 재시작 정책을 설정합니다.    no: 프로세스가 종료되더라도 컨테이너를 재시작하지 않습니다. 예) --restart=”no”    on-failure: 프로세스의 Exit Code가 0이 아닐 때만 재시작합니다. 재시도 횟수를 지정할 수 있습니다. 횟수를 지정하지 않으면 계속 재시작합니다. 예) --restart=”on-failure:10”    always: 프로세스의 Exit Code와 상관없이 재시작합니다. 예) --restart=”always”--rm=false: 컨테이너 안의 프로세스가 종료되면 컨테이너를 자동으로 삭제합니다. -d 옵션과 함께 사용할 수 없습니다.-s--security-opt=[]: SELinux, AppArmor 옵션을 설정합니다.ex) --security-opt=”label:level:TopSecret”--sig-proxy=true: 모든 시그널을 프로세스에 전달합니다(TTY 모드가 아닐 때도). 단 SIGCHLD, SIGKILL, SIGSTOP 시그널은 전달하지 않습니다.-t--tty=false: TTY 모드(pseudo-TTY)를 사용합니다. Bash를 사용하려면 이 옵션을 설정해야 합니다. 이 옵션을 설정하지 않으면 명령을 입력할 수는 있지만 셸이 표시되지 않습니다.-u--user=””: 컨테이너가 실행될 리눅스 사용자 계정 이름 또는 UID를 설정합니다.-v--volume=[]: 데이터 볼륨을 설정입니다. 호스트와 공유할 디렉터리를 설정하여 파일을 컨테이너에 저장하지 않고 호스트에 바로 저장합니다. 호스트 디렉터리 뒤에 :ro, :rw를 붙여서 읽기 쓰기 설정을 할 수 있으며 기본 값은 :rw입니다. 자세한 내용은 ‘6.4 Docker 데이터 볼륨 사용하기’를 참조하기 바랍니다.    &lt;컨테이너 디렉터리&gt; 예) -v /data    &lt;호스트 디렉터리&gt;:&lt;컨테이너 디렉터리&gt; 예) -v /data:/data    &lt;호스트 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;:&lt;ro, rw&gt; 예) -v /data:/data:ro    &lt;호스트 파일&gt;:&lt;컨테이너 파일&gt; 예) -v /var/run/docker.sock:/var/run/docker.sock    --volumes-from=[]: 데이터 볼륨 컨테이너를 연결하며 &lt;컨테이너 이름, ID&gt;:&lt;ro, rw&gt; 형식으로 설정합니다. 기본적으로 읽기 쓰기 설정은 -v 옵션의 설정을 따릅니다. 자세한 내용은 ‘6.5 Docker 데이터 볼륨 컨테이너 사용하기’를 참조하기 바랍니다.ex) --volumes-from=”hello”ex) --volumes-from=”hello:ro”처럼 설정하면 데이터 볼륨을 읽기 전용으로 사용합니다.ex) --volumes-from=”hello:rw”처럼 설정하면 데이터 볼륨에 읽기 쓰기 모두 할 수 있습니다.-w--workdir=””: 컨테이너 안의 프로세스가 실행될 디렉터리를 설정합니다.ex) --workdir=”/var/www”",
        "url": "//docker/2024/05/26/Docker-series-01.options.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-27-afterspringready-html": {
        "title": "[spring Series] 27.afterspringready",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - WhenAfterSpringReady스프링 초기화 후 작업CommandLineRunnerCommandLineRunner는 함수형 인터페이스로 애플리케이션 구동 후 실행되어야 하는 빈을 정의하기 위해서 사용한다.@Componentclass CmdRunner implements CommandLineRunner {    @Override    public void run ( String... args ) {            }}//or@SpringApplicationpublic class TestServiceApplication {    public static void main(String[] args) {        SpringApplication.run(TestServiceApplication.class, args);    }        @Bean    public CommandLineRunner cmdRunner() {        return args -&gt; {};    }}ApplicationRunner스프링 애플리케이션이 구동된 후에 실행되어야 하는 빈을 정의하기 위한 인터페이스다.@SpringApplicationpublic class TestServiceApplication {    public static void main(String[] args) {        SpringApplication.run(TestServiceApplication.class, args);    }    @Bean    public ApplicationRunner cmdRunner() {        return args -&gt; {};    }}EventListener  ApplicationStartingEvent          애플리케이션 실행되고 가장 빠른 타이밍에 실행      Environmen, ApplicationContext는 준비가 되어 있지 않음.      source로 ApplicationContext가 넘어오는데 계속 바뀔거라는 걸 인지해야함        ApplicationContextInitializedEvent          initializer가 호출됨      ApplicationContext는 준비되어 있음      BeanDefinition 등록 전        ApplicationEnvironmentPreparedEvent          Environment 준비됨        ApplicationPreparedEvent          ApplicationContext 완전히 준비됐지만 refresh 전에 실행됨      BootstrapRegistryInitializer를 가지고 있고 곧 destroy 예정        ApplicationStartedEvent          BootstrapRegistryInitializer destroyed      ApplicationRunner, CommandLineRunner가 실행되기 전        ApplicationReadyEvent          애플리케이션이 요청을 받아서 처리할 준비가 됐을 떄 발행        ApplicationFailedEvent          애플리케이션 실패      ",
        "url": "//spring/2024/05/25/Spring-series-27.AfterSpringReady.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-26-webflux-vs-webmvc-html": {
        "title": "[spring Series] 26.webflux Vs. Webmvc",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Webflux vs. WebMVCWebflux vs. WebMVC  WebMVC  : 멀티 쓰레드 기반 웹 프레임워크  WebFlux : 리액티브 스택 기반 웹 프레임워크둘 다 있는 경우?애플리케이션 클래스 패스를 기반으로 애플리케이션 타입을 선택한다.  NONE  SERVLET  REACTIVEthis.webApplicationType = WebApplicationType.deduceFromClasspath();class WebApplicationType {    static WebApplicationType deduceFromClasspath() {        if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null)             &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)            &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {                return WebApplicationType.REACTIVE;        }        for (String className : SERVLET_INDICATOR_CLASSES) {            if (!ClassUtils.isPresent(className, null)) {                return WebApplicationType.NONE;            }        }        return WebApplicationType.SERVLET;    }}WebFluxAutoConfiguration이 활성화되는 조건  애플리케이션이 리액티브 타입인 경우  클래스패스에 웹플럭스가 존재하는 경우  WebFluxConfigurationSupport 타입의 빈이 없는 경우결론둘 다 존재하면 SERVLET이 되므로 WebFlux는 disabled 된다. @EnableWebFlux를 사용하면 강제로 활성화된다.",
        "url": "//spring/2024/05/25/Spring-series-26.Webflux-Vs.-WebMvc.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-25-httpinterface-html": {
        "title": "[spring Series] 25.httpinterface",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Http Interface ClientHttp Interface ClientRestClient동기 API가 있는 클라이언트initializeRestClient.crate()로 생성한다 혹은 builder도 제공한다.RestClient defaultClient = RestClient.create();RestClient customClient = RestClient.builder()        .requestFactory(new HttpComponentsClientHttpRequestFactory())        //Allows to use a pre-configured HttpClient        .messageConverters(converters -&gt; converters.add(new MyCustomMessageConverter()))        //메시지 컨버터 지정        .baseUrl(\"https://example.com\")        //baseUrl        .defaultUriVariables(Map.of(\"variable\", \"foo\"))        //default Uri        .defaultHeader(\"My-Header\", \"Foo\")        //defaultHeader        .requestInterceptor(myCustomInterceptor)        .requestInitializer(myCustomInitializer)        .build();Request and ResponserestClient.get().uri(\"https://example.com/orders/{id}\", 42)//Uri는 UriBuilderFactory로 만들 수 있다. // .headers()// .accept()// .acceptCharset().retrieve() //retrieve() 실행으로 body에 접근할 수 있다.  .body(String.class); //Jackson과 같은 MessageConverter로 Object로 받을 수도 있다.ResponseEntityResponseEntity&lt;String&gt; result = restClient.get()  .uri(\"https://example.com\")  .retrieve()  .toEntity(String.class); //toEntity로 ResponseEntity로 받을 수 있다.System.out.println(\"Response status: \" + result.getStatusCode());System.out.println(\"Response headers: \" + result.getHeaders());System.out.println(\"Contents: \" + result.getBody());ErrorHandlingString result = restClient.get()  .uri(\"https://example.com/this-url-does-not-exist\")  .retrieve()  .onStatus(HttpStatusCode::is4xxClientError, (request, response) -&gt; {      throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders())  })        //이와 같이  400번 대 에러를 처리할 수도 있다.  .body(String.class);Exchangeretrieve() 대신 exchange()를 사용할 수도 있다. 이를 통해서 더 디테일하게 RestClient를 사용할 수 있다.Pet result = restClient.get()  .uri(\"https://petclinic.example.com/pets/{id}\", id)  .accept(APPLICATION_JSON)  .exchange((request, response) -&gt; {    if (response.getStatusCode().is4xxClientError()) {      throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders());    }    else {      Pet pet = convertResponse(response);      return pet;    }  });MessageConverter            MessageConverter      Description                  StringHttpMessageConverter      메시지를 String으로 변환해주는 컨버터다.              FormHttpMessageConverter      FormData 를 읽고 쓸 수 있게 해주는 컨버터다. 기본적으로 application/x-www-form-urlencoded를 형태일 때 읽고 쓴다.              ByteArrayHttpMessageConverter      byte[]를 일고 쓸 수 있게 한다. application/octet-stream일 때 주로 사용한다.              MarshallingHttpMessageConverter      XML 일 때 읽고 쓸 수 있게 해주는 컨버터다.       text/xml, application/xml  일 때 주로 읽고 쓴다.              MappingJackson2HttpMessageConverter      Jackson의 ObjectMapper를 사용해서 JSON을 읽고 쓸 수 있게 해주는 컨버터다.              MappingJackson2XmlHttpMessageConverter      Jackson의 ObjectMapper를 사용해서 XML을 읽고 쓸 수 있게 해주는 컨버터다.              SourceHttpMessageConverter      javax.xml.transform.Source을 읽고 쓸 수 있게 해주는 컨버터다.  DOMSource, SAXSource, StreamSource를 읽고 쓸수 있게 해준다.      WebClient비동기 API가 있는 클아이언트특징  논 블로킹 I/O 지원  리액티브 스트림의 백프레셔 지원  고가용성  함수형 타입을 지원한다  동기, 비동기 상호 작용 지원initialize  WebClient.create()  WebClient.create(String baseUrl)WebClient.builder()는 아래 옵션을 설정할 수 있게 한다.  uriBuilderFactory: UriBuilderFactory로 URI를 커스터마이징 할 수 있다.  defaultUriVariables: UriTemplate을 확장할 때 사용한다.  defaultHeader: 매 요청 시 담기는 기본 헤더  defaultCookie: 매 요청 시 담기는 기본 쿠키  defaultRequest:매 요청 시 기본 요청으로 실행할 Consumer  filter: 매 요청 시 적용할 필터  exchangeStrategies: Http 메시지를 읽고 쓸 전략을 설정한다.  clientConnector: HTTP client library를 세팅할 수 있다.  observationRegistry: the registry to use for enabling Observability support.  observationConvention: an optional, custom convention to extract metadata for recorded observations.WebClient client1 = WebClient.builder()\t\t.filter(filterA).filter(filterB).build();WebClient client2 = client1.mutate()\t\t.filter(filterC).filter(filterD).build();// client1 has filterA, filterB// client2 has filterA, filterB, filterC, filterDRequestWebClient와 유사하다만 Reactor를 채용하고 있단 부분이 다르다.  retrieve()로 response를 추출할 수 있다.WebClient client = WebClient.create(\"https://example.org\");Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()\t\t.uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\t\t.retrieve()\t\t.toEntity(Person.class);  바디만을 직접 받을 수도 있다.WebClient client = WebClient.create(\"https://example.org\");Mono&lt;Person&gt; result = client.get()\t\t.uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\t\t.retrieve()\t\t.bodyToMono(Person.class);Flux&lt;Quote&gt; result = client.get()        .uri(\"/quotes\").accept(MediaType.TEXT_EVENT_STREAM)        .retrieve()        .bodyToFlux(Quote.class);  exchange()로 디테일하게 사용하기  exchangeToMono()  exchangeToFlux()  awaitExchange ()  exchangeToFlow()Mono&lt;Person&gt; entityMono = client.get()\t\t.uri(\"/persons/1\")\t\t.accept(MediaType.APPLICATION_JSON)\t\t.exchangeToMono(response -&gt; {\t\t\tif (response.statusCode().equals(HttpStatus.OK)) {\t\t\t\treturn response.bodyToMono(Person.class);\t\t\t}\t\t\telse {\t\t\t\t// Turn to error\t\t\t\treturn response.createError();\t\t\t}\t\t});RestTemplate템플릿 메소드 API가 있는 동기 클라이언트WebClient, RestClient에 비해 스프링에서 제공하는 오래된 템플릿 클래스다.            Method      Description                  getForObject      GET으로 요청              getForEntity      GET으로 요청 ResponseEntity로 반환              headForHeaders      HEAD 메소드로 리소스 헤더 요청              postForLocation      POST로 요청하고 Location header를 반환 받음              postForObject      POST로 요청하고  반환 받음              postForEntity      POST로 요청하고 ResponseEntity로를 반환 받음              put      PUT              patchForObject      PATCH로 요청              delete      DELETE              optionsForAllow      ALLOW로 허용된 HTTP 메소드 검색              exchange      디테일하게 요청을 설정해서 보내는 메소드              execute      콜백 인터페이스로 요청 - 응답을 하는 방식      After Spring 6spring 6 이후로 정의 된 기능이다. Java Interface로 HTTP 메소드를 정의하면프록시로 이를 정의해서 API 호출을 가능하게 해준다.자바 인터페이스 + @HttpExchange를 조합해서 HttpServiceProxyFactory에 넘기면 프록시로 생성한다.형태@HttpExchange(url = \"/repos/{owner}/{repo}\", accept = \"application/vnd.github.v3+json\")interface RepositoryService {    @GetExchange    Repository getRepository(@PathVariable String owner, @PathVariable String repo);    @PatchExchange(contentType = MediaType.APPLICATION_FORM_URLENCODED_VALUE)    void updateRepository(@PathVariable String owner, @PathVariable String repo,                          @RequestParam String name, @RequestParam String description, @RequestParam String homepage);}RestClient를 사용해서 HttpInterface 등록RestClient restClient = RestClient.builder().baseUrl(\"https://api.github.com/\").build();RestClientAdapter adapter = RestClientAdapter.create(restClient);HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();RepositoryService service = factory.createClient(RepositoryService.class);WebClient를 사용해서 HttpInterface 등록WebClient webClient = WebClient.builder().baseUrl(\"https://api.github.com/\").build();WebClientAdapter adapter = WebClientAdapter.create(webClient);HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();RepositoryService service = factory.createClient(RepositoryService.class);RestTemplate을 사용해서 HttpInterface 등록RestTemplate restTemplate = new RestTemplate();restTemplate.setUriTemplateHandler(new DefaultUriBuilderFactory(\"https://api.github.com/\"));RestTemplateAdapter adapter = RestTemplateAdapter.create(restTemplate);HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();RepositoryService service = factory.createClient(RepositoryService.class);Annotation            Annotation      Description                  @HttpExchange      HttpExchange 대상으로 선정              @RequestHeader      요청 헤더              @PathVariable      Path Variable을 설정              @RequestBody      RequestBody로 지정              @RequestParam      QueryString으로 지정              @RequestPart      PartFile로 지정              @CookieValue      쿠키 값으로 지정              @GetExchange      GET              @PostExchange      POST              @PutExchange      PUT              @PatchExchange      PATCH              @DeleteExchange      DELETE      ",
        "url": "//spring/2024/05/25/Spring-series-25.HttpInterface.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-24-springevent-html": {
        "title": "[spring Series] 24.springevent",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Spring EventSpring Event이벤트 등록ApplicationEvent를 상속해야 한다.이벤트 팔행ApplicationEventPublisher를 주입받아 사용해야 함이벤트 구독ApplicationListener를 구현하거나 @EventListener를 사용해야 한다.//Publisher@RequiredArgsConstructorpublic class EventPublisher {    private final ApplicationEventPublisher publisher;    public void publish() throws InterruptedException {        publisher.publishEvent(new CustomEvent(\"Emitted\"));    }}//Listenerpublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {    void onApplicationEvent(E event);    static &lt;T&gt; ApplicationListener&lt;PayloadApplicationEvent&lt;T&gt;&gt; forPayload(Consumer&lt;T&gt; consumer) {        return event -&gt; consumer.accept(event.getPayload());    }}//or @Componentpublic class CustomEventListener {    @EventListener    public void listen(CustomEvent event) {    }}발행/ 구독  멀티 캐스팅으로 동작 (다수의 수신자가 존재할 수 있다.)  동기 방식으로 동작 (트랜잭션이 하나의 범위로 묶일 수 있다.)  트랜잭션과 결합이 필요하다면 다른 리스너를 사용해야 한다.(@TransactionEventListener를 제공하므로 트랜잭션 단계에 관여할 수 있다.)          TransactionPhase.BEFORE_COMMIT      TransactionPhase.AFTER_COMPETION      TransactionPhase.AFTER_COMMIT      TransactionPhase.AFTER_ROLLBACK      비동기로 이벤트 처리  @Async 메소드로 비동기 구현  ApplicationEventMulticaster로 비동기 구현장/단  장점          의존성을 분리하여 두 클래스를 느슨하게 결합시킬 수 있다.      클래스가 독립적이므로 재사용성을 높일 수 있다.      추후에 별도 서비스로 분리하기 용이함      메세지 구독 모듈을 추가/ 삭제할 때, 다른 모듈에 영향을 주지 않은 채로 수정할 수 있다.      단위 테스트가 용이해짐        단점          전반적인 작업량이 많아질 수 있음      코드 흐름 파악이 어려움      메시지 구독 순서를 고려해야 하는 경우 복잡해짐      전체적인 인벤트의 구독/ 발행을 테스트하기 어려움      특정 프레임워크 API에 의존      ",
        "url": "//spring/2024/05/25/Spring-series-24.SpringEvent.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-23-transactionpropagation-html": {
        "title": "[spring Series] 23.transactionpropagation",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - PropagationPropagation시작트랜잭션은 하나의 Connection을 가져와 사용하다 닫는 사이에 일어난다. 그러므로 JDBC에서 트랜잭션을 사용하려면 auto-commit을 false로 해야한다.종료commit(), rollback()을 호출할 때까지가 하나의 트랜잭션이 된다.전파@Transactional의 장점은 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다. 이미 진행 중일 때 추가 트랜잭션을 어떻게 할지 결정하는 것이전파 속성(Propagation)이라고 한다.물리/ 논리 트랜잭션트랜잭션은 DB에서 제공하므로 커넥션 객체를 통해서 처리한다. 그래서 1개 트랜잭션 = 하나의 커넥션이라고 보며, 물리 트랜잭션이라고 부른다.다만, 스프링 내부에서 트랜잭션 개념을 두고, 이를 하나의 논리 트랜잭션으로 보며 하나의 물리 트랜잭션 안에 여러 논리 트랜잭션이 있을 수도 있다.  물리 트랜잭션 : 실제 DB에 적용되는 트랜잭션, 커넥션을 통해 커밋/롤백하는 단위  논리 트랜잭션 : 스프링이 트랜잭션 매니저를 통해서 처리하는 단위그래서  모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋됨  하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백종류  REQUIRED          의미 : 없으면 새로 만들어야 함 (기본 값)      없다면 -&gt; 새로 만듦      있으면 -&gt; 기존 트랜잭션에 참여        REQUIRED_NEW          의미 : 항상 새로운 트랜잭션이 필요함      없다면 -&gt; 새로운 트랜잭션 생성      있으면 -&gt; 기존 트랜잭션 보류하고 새로운 트랜잭션 생성        SUPPORTS          의미 : 트랜잭션이 있으면 지원      없다면 -&gt; 트랜잭션이 없이 진행함      있으면 -&gt; 기존 트랜잭션에 참여        NOT_SUPPORTED          의미 : 트랜잭션 지원하지 않음      없다면 -&gt; 트랜잭션 없이 진행      있으면 -&gt; 기존 트랜잭션 보류시키고 트랜잭션 없이 진행함        MANDATORY          의미 : 반드시 필요함      없다면 -&gt; throw IllegalTransactionStateException      있으면 -&gt; 기존 트랜잭션에 참여        NEVER          의미 : 트랜잭션 사용하지 않음(기존 트랜잭션도 사용할 생각이 없음)      없다면 -&gt; 트랜잭션 없지 진행      있으면 -&gt; IllegalTransactionStateException 발생        NESTED          의미 : 중첩 트랜잭션 생성      없다면 -&gt; 새로운 트랜잭션 생성      있으면 -&gt; 중첩 트랜잭션 생성      ",
        "url": "//spring/2024/05/25/Spring-series-23.TransactionPropagation.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-22-transactional-html": {
        "title": "[spring Series] 22.transactional",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Transactional@TransactionalAOP 기반으로 동작한다. 내부적으로 connection을 가져와서 auto-commit을 비활성하고 트랜잭션을 begin하다.그리고 커넥션을 한 쓰레드에서 공유할 수 있도록 ThreadLocal에 저장하는 트랜잭션 동기화Transaction Synchrinization를 진행한다. 이러한 이유로 parallelStream을 사용하면 문제가 생길 수 있다.parallelStream을 사용하면 ForJoinPool을 이용하기 떄문에 서로 다른 독립적인 작업이된다. 그래서 예외가 발생해도 전체 데이터가 롤백이 되지 않는다.더 심각한 부분은 각 쓰레드에서 DB 커넥션을 획득하려고 시도한다는 점이다. 이는 커넥션 풀을 빠르게 갉아 먹는다.우선순위  클래스 메소드  클래스 선언부  인터페이스 메소드  인터페이스 선언부모드  ProxyMode          반드시 public      protected, private에 선언된다고 하면 에러도 없고 실행도 없다.        AspectJMode",
        "url": "//spring/2024/05/25/Spring-series-22.Transactional.html"
      }
      ,
    
      "spring-2024-05-25-spring-series-21-filterandinterceptor-html": {
        "title": "[spring Series] 21.filterandinterceptor",
        "tags": "",
        "date": "May 25, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Filter, InterceptorFilter, InterceptorFilterDispatcher Servlet에 요청이 전달되기 전/후에 부가 작업을 할 수 있게 해주는 기능Dispatcher Servlet는 SpringContext보다 전이므로 스프링 제어 범위 밖이다.in javajavax.servlet의 Filter를 구현하면 필터를 추가할 수 있다.import java.io.IOException;public interface Filter {    public default void init(FilterConfig filterConfig) throws ServletExcpetion {}// 필터 객체 초기화        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;//  디스패쳐 서블릿 전달 전에 실행되는 메소드다.        public default void destroy() {}//  자원 반환되기 전 실행되는 메소드다.         }InterceptorSpring에서 제공하는 기술이다. 디스패쳐 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.in javapublic interface HandlerInterceptor {    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)        throws Exception {        return true;    }//  컨트롤러 호출되기 전에 실행.    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,        @Nullable ModelAndView modelAndView) throws Exception {    }//  컨트롤러 호출된 후에 실행.        default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,        @Nullable Exception ex) throws Exception {    }}정리|            대상             |                                                Filter                                                 |                                   Interceptor                                    ||:————————-:|:—————————————————————————————————–:|:——————————————————————————–:||         관리되는 컨테이너         |                                           Servlet Container                                           |                                 Spring Container                                 ||     스프링에서 예외 가능한지 여부      |                                                   X                                                   |                                        O                                         || Request/Response 조작 가능 여부 |                                                   O                                                   |                                        X                                         ||            용도             | - 공통된 보안 및 인증/ 인가 관련 작업 - 모든 요청에 대한 로깅 및 감사  - 이미지/데이터 압축 및 문자열 인코딩 - 스프링과 분리되어야 하는 기능 | - 세부적인 보안 및 인증/인가 공통 작업 - API 호출에 대한 로깅 및 감사 - Controller로 넘겨주는 정보의 가공 |이상한 점?위의 내용을 보면 스프링에 의해서 관리 받지 않기 때문에 스프링 빈으로 등록이 불가능해 보인다. 근데? 실제로 해보면 Filter 역시 스프링 빈으로 등록이 가능하며, 빈을 주입받을 수도 있다.DelegatingFilterProxy필터에서도 DI를 할 필요가 있다. 이는 DelegatingFilterProxy으로 가능해졌다.필터가 Bean으로 등록됐고, 요청이 오면 DelegatingFilterProxy으로 요청을 받아서 우리가 받은 필터(스프링 빈)에게 요청을 위임한다.  Filter 구현체가 스프링 빈으로 등록됨  ServletContext가 Filter 구현체를 갖는 DelegatingFilterProxy를 생성  ServletContext가 DelegatingFilterProxy를 서블릿 컨텍스트에 필터로 등록  요청이 오면 DelegatingFilterProxy가 구현체에게 요청을 위임하여 필터 처리를 진행",
        "url": "//spring/2024/05/25/Spring-series-21.FilterAndInterceptor.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-20-quartz-batch-html": {
        "title": "[spring Series] 20.quartz+batch",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Quartz+Batch구현Quartz -&gt; JobBeanQuartzJobBean을 상속 받도록 해서 QuartzJob을 등록할 수 있는 추상 클래스 + 템플릿 메소드로 구성package com.appg.batchService.config.scheduling.config;import com.appg.batchService.constant.Const;import com.fasterxml.uuid.Generators;import lombok.extern.slf4j.Slf4j;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.quartz.SchedulerException;import org.springframework.batch.core.Job;import org.springframework.batch.core.JobParametersBuilder;import org.springframework.batch.core.JobParametersInvalidException;import org.springframework.batch.core.launch.JobLauncher;import org.springframework.batch.core.repository.JobExecutionAlreadyRunningException;import org.springframework.batch.core.repository.JobInstanceAlreadyCompleteException;import org.springframework.batch.core.repository.JobRestartException;import org.springframework.context.ApplicationContext;import org.springframework.scheduling.quartz.QuartzJobBean;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4jpublic abstract class QuartzSchedulingFormat extends QuartzJobBean {    protected String BATCH_JOB_NAME;    private Boolean logging = Boolean.FALSE;    public QuartzSchedulingFormat(String BATCH_JOB_NAME) {        this.BATCH_JOB_NAME = BATCH_JOB_NAME;    }    protected void enableLog(boolean enable) {        this.logging = enable;    }    protected abstract void beforeExecute();    protected abstract void afterExecute();    protected abstract void whenThrowException(Exception e);    @Override    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {                this.beforeExecute();        try {            ApplicationContext applicationContext = (ApplicationContext) context.getScheduler().getContext().get(Const.APPLICATION_CONTEXT);            Job job = applicationContext.getBean(BATCH_JOB_NAME, Job.class);            JobLauncher jobLauncher = applicationContext.getBean(JobLauncher.class);            LocalDateTime now = LocalDateTime.now();            if( this.logging ) {                log.info(\"Task : {}\", job);                log.info(\"Acting time at : {}\", now.format(DateTimeFormatter.ISO_DATE_TIME));            }            jobLauncher.run(job, new JobParametersBuilder()                                                           .addString(Const.KEY, Generators.timeBasedGenerator().generate().toString())                                                           .addString(Const.JOB_NAME, BATCH_JOB_NAME)                                                           .addLocalDateTime(Const.DATE, now)                                                           .toJobParameters());        } catch (SchedulerException | JobExecutionAlreadyRunningException | JobRestartException | JobInstanceAlreadyCompleteException | JobParametersInvalidException e) {            this.whenThrowException(e);        }        this.afterExecute();    }}Quartz 등록package com.appg.batchService.config.scheduling.timetable.quatz;import com.appg.batchService.config.scheduling.config.quartz.QuartzSchedulingFormat;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class QuartzExample extends QuartzSchedulingFormat {    public static String CRON_EXPRESSION = \"*/5 * * * * ?\";    public QuartzExample() {        super(\"exampleJob\"); // JobBean 이름 넘긴다. (Spring-batch의 Job bean)    }    @Override    protected void beforeExecute() {    }    @Override    protected void afterExecute() {    }    @Override    protected void whenThrowException(Exception e) {        e.printStackTrace();    }}Spring batch Job 등록@Configuration@Slf4j@RequiredArgsConstructorpublic class BatchExample {    @Bean(name = \"exampleJob\")    public Job exampleJob(@Qualifier(value = \"exampleStep\") Step step, JobRepository jobRepository) {        return new JobBuilder(\"exampleJob\", jobRepository)                .preventRestart()                .incrementer(parameters -&gt; parameters)                .start(step).build();    }    @JobScope    @Bean(name = \"exampleStep\")    public Step exampleStep(@Qualifier(value = \"exampleTasklet\") Tasklet tasklet, JobRepository jobRepository, PlatformTransactionManager txManager) {        return new StepBuilder(\"exampleStep\", jobRepository).tasklet(tasklet, txManager).build();    }    @StepScope    @Bean(name = \"exampleTasklet\")    public Tasklet exampleTasklet (){        return (contribution, chunkContext) -&gt; {            JobParameters parameters = chunkContext.getStepContext().getStepExecution().getJobParameters();            log.info(\"ExampleTasklet {}\", parameters.getString(\"key\"));            return RepeatStatus.FINISHED;        };    }}이슈 사항  dataSource를 여러 개 사용하는 (JPA에서 스키마를 특정하지 않고 멀티로 접근할 수 있어야 하는데, Spring batch의 JobRepository가 스키마 커스텀이 불가) 것처럼 되어 버림          그리하여 DataSource를 정의하고(Bean으로 등록하면 @Primary가 되어 JPA에 영향을 미친다. -&gt; 그러면 JPA의 AutoConfigure을 포기해야한다.)```java@Configuration(value = “spring-batch-config”)@RequiredArgsConstructorpublic class SpringBatchConfig extends DefaultBatchConfiguration {  private final Environment environment;  private final PlatformTransactionManager manager;        //    private DataSource dataSource() {      HikariDataSource hikariDataSource = new HikariDataSource();      String driver =  environment.getProperty(“quartz.datasource.driver”, String.class);      String url =  environment.getProperty(“quartz.datasource.url”, String.class);      String user =  environment.getProperty(“quartz.datasource.user”, String.class);      String password =  environment.getProperty(“quartz.datasource.password”, String.class);      hikariDataSource.setDriverClassName(driver);  hikariDataSource.setJdbcUrl(url);  hikariDataSource.setUsername(user);  hikariDataSource.setPassword(password);  return hikariDataSource;   }        @Override  public JobRepository jobRepository() throws BatchConfigurationException {      JobRepositoryFactoryBean factoryBean = new JobRepositoryFactoryBean();      factoryBean.setDataSource(dataSource());  factoryBean.setTransactionManager(manager);  try {      factoryBean.afterPropertiesSet();      JobRepository jobRepository = factoryBean.getObject();      return jobRepository;  } catch (Exception e) {      return super.jobRepository();  }   }        @Bean  @Primary  public JobLauncher jobLauncher(JobRepository jobRepository) {      TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();      jobLauncher.setJobRepository(jobRepository);      jobLauncher.setTaskExecutor(new SimpleAsyncTaskExecutor()); // or use ThreadPoolTaskExecutor      return jobLauncher;  }}  - Quartz에서도 비슷한 양상의 이슈 발생```java@Configuration(value = \"spring-quartz-config\")@RequiredArgsConstructorpublic class SpringQuartzConfig {    private final Environment environment;    private DataSource dataSource() {        HikariDataSource hikariDataSource = new HikariDataSource();        String driver = environment.getProperty(\"quartz.datasource.driver\", String.class);        String url = environment.getProperty(\"quartz.datasource.url\", String.class);        String user = environment.getProperty(\"quartz.datasource.user\", String.class);        String password = environment.getProperty(\"quartz.datasource.password\", String.class);        hikariDataSource.setDriverClassName(driver);        hikariDataSource.setJdbcUrl(url);        hikariDataSource.setUsername(user);        hikariDataSource.setPassword(password);        return hikariDataSource;    }    @Bean    public SchedulerFactoryBean schedulerFactoryBean() {        SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();        schedulerFactoryBean.setSchedulerName(\"Quartz\");        schedulerFactoryBean.setApplicationContextSchedulerContextKey(Const.APPLICATION_CONTEXT);        schedulerFactoryBean.setGlobalTriggerListeners(new QuartzTriggerListener());        schedulerFactoryBean.setGlobalJobListeners(new QuartzJobListener());        schedulerFactoryBean.setDataSource(dataSource());        schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true);        return schedulerFactoryBean;    }}등록initializeTimeTable에 addJob 함수로 등록하면 된다.@Slf4j@Component@RequiredArgsConstructorpublic class QuartzScheduler {    private final Scheduler scheduler;    @PostConstruct    public void initializeTimeTable () {        try {            scheduler.standby();            this.addJob(QuartzExample.class, QuartzExample.CRON_EXPRESSION);//            scheduler.startDelayed(5000);            scheduler.start();        } catch (SchedulerException e) {            throw new RuntimeException(e);        }    }    private &lt;T extends QuartzSchedulingFormat&gt; void addJob(Class&lt;T&gt; jobClass, String cronExpression ) {        String name = jobClass.getName();        String group = jobClass.getName();        JobKey jobKey = new JobKey(name, group);        TriggerKey triggerKey = new TriggerKey(name, group);        try {            log.info(\"{} job already exists {}\", name, scheduler.checkExists(triggerKey));            log.info(\"{} trigger already exists {}\", name, scheduler.checkExists(jobKey));            if(scheduler.checkExists(jobKey) &amp;&amp; scheduler.checkExists(triggerKey)){                    scheduler.resumeAll();            }            else {                if(scheduler.checkExists(jobKey)) scheduler.deleteJob(jobKey);                if(scheduler.checkExists(triggerKey)) scheduler.unscheduleJob(triggerKey);                scheduler.scheduleJob(this.jobDetailBuilder(jobClass, jobKey), this.jobTriggerBuilder(triggerKey, cronExpression));            }        } catch (SchedulerException e) {            throw new RuntimeException(e);        }    }    private Trigger jobTriggerBuilder(TriggerKey triggerKey, String cronExpression) {        return TriggerBuilder.newTrigger()                                      .withIdentity(triggerKey)                                      .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression))                                      .build();    }    private JobDetail jobDetailBuilder(Class jobClass, JobKey jobKey) {        JobDataMap jobDataMap = new JobDataMap();        return JobBuilder.newJob(jobClass).withIdentity(jobKey)                         .storeDurably(true)                         .requestRecovery(true)                         .usingJobData(jobDataMap).build();    }}",
        "url": "//spring/2024/05/24/Spring-series-20.Quartz+Batch.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-19-springquartz-html": {
        "title": "[spring Series] 19.springquartz",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - QuartzQuartz스케쥴링 라이브러리            용어      분류      설명                  Job      인터페이스      실행할 작업을 정의하는 인터페이스              JobDetail      인터페이스      실행될 작업을 정의하고 구성하는 인터페이스              JobBuilder      클래스      JobDetail 인스턴스를 생성하는데 사용되는 유틸리티 클래스              JobListener      인터페이스      작업의 생명 주기 동안 발생하는 이벤트를 처리하는 인터페이스              JobDataMap      클래스      작업 실행시 필요한 데이터를 저장하는 맵(자료구조)                                           Trigger      인터페이스      작업의 실행 시간을 결정하는 인터페이스              CronTrigger      인터페이스      복잡한 실행 스케줄을 정의할 수 있는 Trigger 인터페이스              TriggerBuilder      클래스      Trigger 인스턴스를 생성하는데 사용되는 유틸리티 클래스              SimpleScheduleBuilder      클래스      간단한 실행 스케줄을 정의할 수 있는 클래스              CronScheduleBuilder      클래스      복잡한 실행 스케줄을 cron 표현식으로 정의할 수 있는 클래스                                           Scheduler      인터페이스      작업과 트리거를 관리하고 실행하는 인터페이스              SchedulerFactory      클래스      Scheduler 인스턴스를 생성하는 클래스      ListenerTrigger    private static class QuartzTriggerListener implements TriggerListener {        @Override        public String getName() {            return \"QuartzTriggerListener\";        }        @Override        public void triggerFired(Trigger trigger, JobExecutionContext jobExecutionContext) {            log.info(\" triggerFired [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );        }        @Override        public boolean vetoJobExecution(Trigger trigger, JobExecutionContext jobExecutionContext) {            log.info(\" vetoJobExecution [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );            return false;        }        @Override        public void triggerMisfired(Trigger trigger) {            log.info(\" triggerMisfired [{}] {}\", trigger.getJobKey().getGroup(), trigger.getJobKey().getName());        }        @Override        public void triggerComplete(Trigger trigger, JobExecutionContext jobExecutionContext, Trigger.CompletedExecutionInstruction completedExecutionInstruction) {            log.info(\" triggerComplete [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );        }    }Job    private static class QuartzJobListener implements JobListener {        @Override        public String getName() {            return \"QuartzJobListener\";        }        @Override        public void jobToBeExecuted(JobExecutionContext jobExecutionContext) {            log.info(\" jobToBeExecuted [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );        }        @Override        public void jobExecutionVetoed(JobExecutionContext jobExecutionContext) {            log.info(\" jobExecutionVetoed [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );        }        @Override        public void jobWasExecuted(JobExecutionContext jobExecutionContext, JobExecutionException e) {            log.info(\" jobWasExecuted [{}] {}\", jobExecutionContext.getJobDetail().getKey().getGroup(), jobExecutionContext.getJobDetail().getKey().getName()  );        }    }CronExpression  ＊ ＊ ＊ ＊ ＊ ?  가장 앞에 오는 단위는 초 (Seconds) 이다.  두번 째는 분 (Minutes) 을 나타낸다.  세번 째는 시 (Hours) 를 나타낸다.  네번 째는 일 (Day-of-Month, DOM) 을 나타낸다.  다섯번 째로 월 (Month) 에 대한 정보를 기술한다.  여섯번 째는 요일 (Day of Week) 을 나타낸다. 요일은 0~6 의 숫자로 쓸 수도 있지만 “MON”, “SUN” 과 같이 요일의 약자로 사용할 수도 있다.      마지막은 연도 (Year) 가 온다. 연도는 optional 이다.    와일드카드 (*) 문자는 “매 번” 을 의미한다  물음표 (?) 는 ‘설정값 없음’ 을 나타낸다. 이는 일 (DOM) 과 요일 (DOW) 에만 사용할 수 있다.  슬래쉬 (/) 는 값 증가 표현에 사용된다. 분 (Minutes) 항목에 “10/15” 라고 쓴다면, “10분 부터 시작해서 매 15분 마다” 를 의미한다.  샾 (#) 은 k#N 으로 사용되며, 이 달의 N번째 K요일을 의미한다. 요일 (DOW) 항목에 “5#2” 라고 적는다면, “이 달의 두번째 목요일” 을 뜻한다.  문자 “L” 은 마지막 (Last) 를 의미한다. L 은 일 (DOM) 과 요일 (DOW) 에만 사용할 수 있다. 예를 들어 일 (DOM) 항목에 L 이 사용된다면 단순하게 해당 월의 마지막 날을 의미한다. 조금 다른 방법으로도 사용되는데, 특정 값 뒤에 사용된다면 “이 달의 마지막 날”을 의미하게 된다. 예를 들어 요일에 “6L” 을 준다면, “이 달의 마지막 금요일” 을 의미하게 된다.  문자 “W” 는 해당 날로부터 가장 가까운 평일 (Weekday) 을 의미한다. 예를 들어 일 (DOM) 항목에 “10W” 라고 준다면, “이 달의 10째 날로부터 가장 가까운 평일” 을 의미한다.  각각의 단위는 범위나 목록으로 나타낼 수도 있다. 일 (DOM) 에 “1-15” 라고 적는다면 1일부터 15일까지를 뜻한다.  각각의 항목은 항목에 유효한 값만이 들어올 수 있다. 예를 들어 일은 1 ~ 31 사이의 숫자만 허용되고, 시간은 0 ~ 23 사이의 시간만 허용한다.ex  “0 0/5 * * * ?” : 매 시 5분마다 수행  “10 0/5 * * * ?” : 10초 뒤 5분마다 수행  “0 30 10-13 ? * WED,FRI” : 매 주 수요일과 금요일 10시 ~ 13시 30분에 수행  “0 0/30 8-9 5,20 * ?” : 매 월 5일과 20일에 8시 ~ 9시대에 30분 간격으로 수행 (ex. 8:00, 8:30, 9:00, 9:30 에 수행)",
        "url": "//spring/2024/05/24/Spring-series-19.SpringQuartz.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-18-springbatch-html": {
        "title": "[spring Series] 18.springbatch",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SpringBatchSpringBatch  JobLauncher : Job을 실행 시키는 컴포넌트  JobRepository: Job실행, Job, Step을 저장  Job : 하나의 배치 실행 단위, 1개 이상의 Step으로 구성됨  JobInstance :논리적인 Job 실행을 의미합니다. 주로 Job 에 파라미터를 부여하여 다른 JobInstance 구분할수 있습니다.  Step : 일련의 작업들  ItemReader : Step에서 데이터를 읽는 Tasklet  ItemProcessor: ItemReader에서 읽은 데이터를 처리하는 Tasklet  ItemWriter : ItemProcessor로 처리된 데이터를 쓰는 Tasklet@JobScope와 @StepScope  Scope란?      스프링 컨테이너에서 빈이 관리되는 범위    singleton, prototype, request, session, application이 있으며 기본은 singleton으로 생성된다.    Job과 Step의 빈 생성과 실행에 관여하는 스코프  프록시 모드를 기본 값으로 하는 스코프: @Scope(value = \"job\", proxyMode = ScopedProxyMode.TARGET_CLASS)  @JobScope나 @StepScope가 선언되면 빈의 생성이 애플리케이션 구동 시점이 아닌 빈의 실행 시점에 이루어진다.  @Values를 주입해서 빈의 실행 시점에 값을 참조할 수 있으며 일종의 Lazy Binding이 가능해진다.  @Value(”#{jobParameters[파라미터명]}”), @Value(”#{jobExecutionContext[파라미터명]”}), @Value(”#{stepExecutionContext[파라미터명]”})  @Value를 사용할 경우 빈 선언문에 @JobScope, @StepScope를 정의하지 않으면 오류를 발생한다. 때문에 반드시 선언해야 한다.  프록시 모드로 빈이 선언되기 때문에 애플리케이션 구동 시점에는 빈의 프록시 객체가 생성되어 실행 시점에 실제 빈을 호출 해준다.  병렬 처리 시 각 쓰레드마다 생성된 스코프 빈이 할당 되기 때문에 쓰레드에 안전하게 실행이 가능하다.@Configuration@Slf4j@RequiredArgsConstructorpublic class BatchExample {    private final PlatformTransactionManager txManager;    @Bean(name = \"exampleJob\")    public Job exampleJob(@Qualifier(value = \"exampleStep\") Step step, JobRepository jobRepository) {        return new JobBuilder(\"exampleJob\", jobRepository).start(step).build();    }    @JobScope    @Bean(name = \"exampleStep\") //작업으로 STep 명시    public Step exampleStep(@Qualifier(value = \"exampleTasklet\") Tasklet tasklet, JobRepository jobRepository) {        return new StepBuilder(\"exampleStep\", jobRepository).tasklet(tasklet, txManager).build();    }    @StepScope    @Bean(name = \"exampleTasklet\")    public Tasklet exampleTasklet (){  // 간단한 작업 명세        return (contribution, chunkContext) -&gt; {            log.info(\"ExampleTasklet\");            return RepeatStatus.CONTINUABLE;        };    }}Spring Batch 5  @EnableBatchProcessing로 Batch를 initialize 할 수 없어졌음 -&gt; 5부터 autoConfigure 날아감  JobBuilderFactory / StepBuilderFactory -&gt; JobBuilder/ StepBuilder로 변경됨참고",
        "url": "//spring/2024/05/24/Spring-series-18.SpringBatch.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-17-jdkdynamicproxy-html": {
        "title": "[spring Series] 17.jdkdynamicproxy",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JDK Dynamic ProxyJdk Dynamic Proxy인터페이스를 기반으로 프록시르 생성한다.java.lang.reflect의 InvocationHandler를 구현하면 된다. 내부에 public Object invoke(Object proxy, Method method, Object[] args)메소드가 존재한다. relfect의 invoke와 구조가 유사하다.public class Target implements TargetInterface{    @Override    public void echo(String text) {        System.out.println(text);    }}import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TargetHandler implements InvocationHandler {    private TargetInterface target;    public TargetHandler(TargetInterface target) {        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(\"before\");        Object result = method.invoke(target, args);        System.out.println(\"after\");        return result;    }}public interface TargetInterface {    public void echo(String text);}import org.junit.jupiter.api.Test;import java.lang.reflect.Proxy;public class ProxyTest {    @Test    public void test() {        TargetInterface tar = new Target();        TargetHandler handler = new TargetHandler(tar);        TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(                TargetInterface.class.getClassLoader(),                new Class[] {TargetInterface.class},                handler                );        proxy.echo(\"HI\");    }}",
        "url": "//spring/2024/05/24/Spring-series-17.JDKDynamicProxy.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-16-dynamicproxy-html": {
        "title": "[spring Series] 16.dynamicproxy",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DynamicProxyDynamicProxy분류  인터페이스가 존재하는 경우  인터페이스가 존재하지 않는 경우프록시 패턴초기화 지연, 접근 제어, 로깅 및 캐싱 등 기존 대상의 수정 없이 추가 기능을 구현하고 싶을 때 사용하는 패턴이다. 추가적으로 개방 폐쇄 원칙(Open Close Principle)에서 부합한다.기본적으로 프록시는 개발자가 직접 하나씩 만들어줘야한다.이렇게 컴파일 타임에 만드는게 아닌 런타임에 만드는 방법이 JVM에서 공식적으로 지원하는 동적 프록시(DynmicProxy)이다.굳이 따지만 ReflectionAPI의 연장선이다.",
        "url": "//spring/2024/05/24/Spring-series-16.DynamicProxy.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-15-cglib-html": {
        "title": "[spring Series] 15.cglib",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Refresh ContextCGLIB(Code Generator Library)코드 생성 라이브러리로서 런타임에 동적으로 자바 클래스의 프록시를 생성해주는 기능을 제공한다. 인터페이스가 아닌 클래스에 대해서 동적 프록시를 생성할 수 있다.인터페이스가 없어도 concrete class만 있어도 동적 프록시(DynamicProxy)를 생성할 수 있다. 원리는 타겟에 대한 정보를 직접적으로 제공 받아서 바이트 코드를 조작하여 프록시를 생성하는 것이다.리플렉션을 사용하지는 않는다.(JDK Dynamic Proxy는 리플렉션을 사용한다.)장점  인터페이스 없이 클래스만으로 프록시 객체를 동적으로 생성할 수 있다.  리플렉션이 아닌 바이트 코드 조작을 사용하며, 타겟에 대한 정보를 알고 있기에 JDK Dynamic Proxy에 비해 성능이 좋다.단점  default 생성자가 필요하다.  타겟의 생성자가 두 번 호출된다.public class Target {    public Target() {    }    public void echo (String text ) {        System.out.println(text);    }}import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class TargetMethodInterceptor implements MethodInterceptor {    private final Target target;    public TargetMethodInterceptor(Target target) {        this.target = target;    }    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(\"Before\");        method.invoke(target, args);        System.out.println(\"After\");        return null;    }}import net.sf.cglib.proxy.Enhancer;import org.junit.jupiter.api.Test;public class TestCGLIB {    @Test    public void test () {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Target.class);        enhancer.setCallback(new TargetMethodInterceptor(new Target()));;        Target target = (Target) enhancer.create();        target.echo(\"CGLIB\");    }}",
        "url": "//spring/2024/05/24/Spring-series-15.CGLIB.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-14-refresh-context-html": {
        "title": "[spring Series] 14.refresh Context",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Refresh ContextRefresh Contextclass SpringApplication {    private void refreshContext(ConfigurableApplicationContext context) {        if (this.registerShutdownHook) {            shutdownHook.registerApplicationContext(context);        }        refresh(context);    }    protected void refresh(ConfigurableApplicationContext applicationContext) {        applicationContext.refresh();    }}class SpringApplicationShutdownHook {    void registerApplicationContext(ConfigurableApplicationContext context) {        addRuntimeShutdownHookIfNecessary();        synchronized (SpringApplicationShutdownHook.class) {            assertNotInProgress();            context.addApplicationListener(this.contextCloseListener);            this.contexts.add(context);        }    }}interface ConfigurableApplicationContext {    void refresh() throws BeansException, IllegalStateException;}      Shutdown Hook 등록 -&gt; Shutdown 후 후처리 작업에 대해서 명시 (연결 종료, 자원 반납, @PreDestroy, Bean의 DestroyMethod를 실행)        refresh 실행ServletWebServerApplicationContext 기준으로    @Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) {     StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");     // 1. refresh 준비 단계      // applicationContext 상태를 active로 변경 (BeanFactory에서 bean을 꺼내기 위한 필수 작업)     prepareRefresh();     ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();     // 2. BeanFactory 준비 단계 (BeanFactory 동작 전에 필요한 작업 수행)     prepareBeanFactory(beanFactory);             // 클래스 로더를 세팅하고      // spEL Resolver     // PropertyEditory를 빈으로 추가한다.      // 의존성 주입을 무시할 인터페이스(~Aware)를 등록하고     // BeanFactory와 ApplicationContext 같은 특별한 타입들을 빈으로 등록     try {         // 3. BeanFactory의 후처리 진행         // beanFactory 후처리한다.         postProcessBeanFactory(beanFactory);         StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");                     // 4. BeanFactoryPostProcessor 실행         // BeanFactory 후처리와는 엄연히 다르다.         // 빈을 탐색하거나 빈 팩토리가 준비된 후에 해야하는 후처리기들을 실행한다.         // 예를 들어 싱글톤 객체로 인스턴스화할 빈을 탐색하는 작업         //          // 정리하면 BeanFactory를 준비하고 빈을 인스턴스화 하기 전의 중간 단계로         // 빈 목록을 불러오고, 빈의 메타 정보를 조작하기 위한         // BeanFactoryPostProcessor를 객체로 만들어 실행          invokeBeanFactoryPostProcessors(beanFactory);         // 5. BeanPostProcessor 등록         // 빈 생성되고 나서 빈의 내용이나 빈 자체를 변경하기 위한 빈 후처리기인         // BeanPostProcessor를 등록         // @Value, @PostConstruct, @Autowired 등이 BeanPostProcessor에 의해 처리되며 이를 위한 BeanPostProcessor 구현체들이 등록된다.         registerBeanPostProcessors(beanFactory);         beanPostProcess.end();         // 6. MessageSource 및 Event Multicaster 초기화         // 다국어 처리를 위한 MessageSource와 ApplicationListener에 event를 publish 하기 위한 EventMulticaster를 초기화         initMessageSource();         initApplicationEventMulticaster();         // 7. onRefresh         // TemplateMethod 패턴으로 필요한 내장 웹서버를 실행         // ApplicationConfigServletWebServerApplicationContext -&gt; Tomcat         // ApplicationConfigReactiveWebServerApplicationContext -&gt; ReactorNetty         onRefresh();         // 8. ApplicationListener 조회 및 등 록         // ApplicationListener의 구현체들을 찾아서 EventMultiCaster에 등록해주고 있다.         registerListeners();         // 9. 빈들의 인스턴스화 및 후처리         // BeanDefinition기준으로 객체 생성          // BeanPostProcessor를 적용해  @Value, @PostConstruct, @Autowired 등을 처리해주고 객체의 생성을 마무리         finishBeanFactoryInitialization(beanFactory);         // 10. refresh 마무리 단계         // 웹서버 실행         finishRefresh();     }     catch (BeansException ex) {         if (logger.isWarnEnabled()) {             logger.warn(\"Exception encountered during context initialization - \" +                 \"cancelling refresh attempt: \" + ex);         }         // Destroy already created singletons to avoid dangling resources.         destroyBeans();         // Reset 'active' flag.         cancelRefresh(ex);         // Propagate exception to caller.         throw ex;     }     finally {         // Reset common introspection caches in Spring's core, since we         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();         contextRefresh.end();     } }}      ",
        "url": "//spring/2024/05/24/Spring-series-14.Refresh-Context.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-13-configurable-application-context-html": {
        "title": "[spring Series] 13.configurable Application Context",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ConfigurableApplicationContextConfigurableApplicationContextclass SpringApplication {    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {        this.resourceLoader = resourceLoader;        Assert.notNull(primarySources, \"PrimarySources must not be null\");        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));        this.webApplicationType = WebApplicationType.deduceFromClasspath();        this.bootstrapRegistryInitializers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));        this.mainApplicationClass = deduceMainApplicationClass();    }        public ConfigurableApplicationContext run(String... args) {        long startTime = System.nanoTime();        // #1. BootStrapContext 생성        DefaultBootstrapContext bootstrapContext = createBootstrapContext();        ConfigurableApplicationContext context = null;        // #2. SYSTEM_PROPERTY_JAVA_AWT_HEADLESS 생성 {        //        //      -&gt; SpringApplication.java        //      private void configureHeadlessProperty() {        //          System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,        //                  System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));        //      }           //         // }        configureHeadlessProperty();                // #3. SpringApplicationListener 조회 및 start        SpringApplicationRunListeners listeners = getRunListeners(args);        //        // -&gt; SpringApplication.java        // private SpringApplicationRunListeners getRunListeners(String[] args) {        //     Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };        //     return new SpringApplicationRunListeners(logger,        //             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args),        //             this.applicationStartup);        // }        //        listeners.starting(bootstrapContext, this.mainApplicationClass);        //        // -&gt; SpringApplicationRunListeners.java        // void starting(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass) {        //    doWithListeners(\"spring.boot.application.starting\", (listener) -&gt; listener.starting(bootstrapContext),        //            (step) -&gt; {        //                if (mainApplicationClass != null) {        //                    step.tag(\"mainApplicationClass\", mainApplicationClass.getName());        //                }        //            });        //        // }                                try {                        // #4. Arguments 래핑 및 Environment 준비            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);            ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);                        // #5. IgnoreBeanInfo 설정 {            //            //      -&gt; SpringApplication.java            //            //      private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) {            //          if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) {            //              Boolean ignore = environment.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,            //                      Boolean.class, Boolean.TRUE);            //              System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString());            //          }            //      }            // }            configureIgnoreBeanInfo(environment);            Banner printedBanner = printBanner(environment);                        // #6. ApplicationContext 생성            context = createApplicationContext();            context.setApplicationStartup(this.applicationStartup);                        // #7. Context 준비            prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);                        // #8. Context Refresh            refreshContext(context);                        // #9. Context Refresh 후처리             afterRefresh(context, applicationArguments);                        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);            if (this.logStartupInfo) {                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);            }                        // #10. Listener 시작            listeners.started(context, timeTakenToStartup);                        // #11. Runners 실행            callRunners(context, applicationArguments);        }        catch (Throwable ex) {            handleRunFailure(context, ex, listeners);            throw new IllegalStateException(ex);        }        try {            Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);            listeners.ready(context, timeTakenToReady);        }        catch (Throwable ex) {            handleRunFailure(context, ex, null);            throw new IllegalStateException(ex);        }        return context;    }}1. BootStrapContext 생성BootStrapContext 란 애플리케이션 컨텍스트 준비 전까지 Spring의 Environment 객체를 후처리하기 위한 임시 컨텍스트 생성2. SYSTEM_PROPERTY_JAVA_AWT_HEADLESS 생성Java AWT로 UI를 생성할 경우 UI 없이도 작동할 수 있게 해주는 설정3. SpringApplicationListener 조회 및 start컨텍스트 준비 시 필요한 리스너를 찾아서 BootStrapContext를 사용해서 실행한다. 생성 시간이 길 경우 Listener로 등록해서 Notify해서 애플리케이션 컨텍스트를 준비함과 동시에 객체를 생성할 수 있게 해준다.4. Arguments 래핑 및 Environment 준비String[] 인자를 ApplicationArgument로 래핑한다. 이를 Environment를 준비하는 prepareEnvironment에 넘겨준다. 애플리케이션 타입에 따라 Environment 구현체를 생성한다.private ConfigurableEnvironment getOrCreateEnvironment() {    if (this.environment != null) {        return this.environment;    }    switch (this.webApplicationType) {    case SERVLET:        return new ApplicationServletEnvironment();    case REACTIVE:        return new ApplicationReactiveWebEnvironment();    default:        return new ApplicationEnvironment();    }}5. IgnoreBeanInfo 설정JSP의 JavaBeans를 Ingoreprivate void configureIgnoreBeanInfo(ConfigurableEnvironment environment) {    if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) {        Boolean ignore = environment.getProperty(\"spring.beaninfo.ignore\", Boolean.class, Boolean.TRUE);        System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString());    }}6. ApplicationContext 생성팩토리 클래스에 위임한다.@FunctionalInterfacepublic interface ApplicationContextFactory {    ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; {        try {            switch (webApplicationType) {            case SERVLET:                return new AnnotationConfigServletWebServerApplicationContext();            case REACTIVE:                return new AnnotationConfigReactiveWebServerApplicationContext();            default:                return new AnnotationConfigApplicationContext();            }        }        catch (Exception ex) {            throw new IllegalStateException(\"Unable create a default ApplicationContext instance, \"                + \"you may need a custom ApplicationContextFactory\", ex);        }    };    ConfigurableApplicationContext create(WebApplicationType webApplicationType);    static ApplicationContextFactory ofContextClass(Class&lt;? extends ConfigurableApplicationContext&gt; contextClass) {        return of(() -&gt; BeanUtils.instantiateClass(contextClass));    }    static ApplicationContextFactory of(Supplier&lt;ConfigurableApplicationContext&gt; supplier) {        return (webApplicationType) -&gt; supplier.get();    }}7. Context 준비Context 준비 후 하는 후처리 작업과 빈을 등록하는 Refresh 단계를 위한 전처리 작업이 수행된다.private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {    context.setEnvironment(environment);    postProcessApplicationContext(context);    applyInitializers(context);    listeners.contextPrepared(context);    bootstrapContext.close(context);    if (this.logStartupInfo) {        logStartupInfo(context.getParent() == null);        logStartupProfileInfo(context);    }    // Add boot specific singleton beans    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);    if (printedBanner != null) {        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);    }    if (beanFactory instanceof AbstractAutowireCapableBeanFactory) {        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(this.allowCircularReferences);        if (beanFactory instanceof DefaultListableBeanFactory) {            ((DefaultListableBeanFactory) beanFactory)                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);        }    }}beanNameGenerator, resourceLoader, conversionService 등이 생성됐다면 싱글톤 bean으로 등록한다. 추가로 BootStrapContext는 필요 없어지므로 종료한다.8. Context Refresh빈을 찾아서 등록하고 웹 서버를 만들어 실행하는 등의 핵심 작업들이 진행된다. refresh를 거치면 모든 객체들이 싱글톤으로 인스턴스화 되어 있다. 에러가 나면 모든 빈을 제거한다. 그래서 모 아니면 도다.9. Context Refresh 후처리protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {}이전에 callRunners()가 있어서 ApplicationRunner, CommandLineRunner가 있었다고 한다.10. Listener 시작11. Runners 실행어플리케이션이 실행된 이후에 초기화하는 작업을 필요로 하는 경우에 Runner로 등록하는데, 이들을 찾아서 실행한다.",
        "url": "//spring/2024/05/24/Spring-series-13.Configurable-Application-Context.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-12-initialize-html": {
        "title": "[spring Series] 12.initialize",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SpringBootInitializeInitialize  SpringApplication.run(~.class, args); 호출    public class SpringApplication { public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {     return run(new Class&lt;?&gt;[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {     return new SpringApplication(primarySources).run(args); } public ConfigurableApplicationContext run(String... args) { }}        ApplicationContext를 리턴 받음    class SpringApplication { public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {     this.resourceLoader = resourceLoader;     Assert.notNull(primarySources, \"PrimarySources must not be null\");     this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));     //applicationType 추론 {     //  1. 웹이 아니면 AnnotatoinConfigApplicationContext     //  2. 서블릿 기반 AnnotaionConfigServletWebServerApplicationContext -&gt; WebMvcAutoConfiguration 찾아다님     //  3. 리액티브 AnnotationConfigReactiveWebServerApplication     //     // 만약 servlet, webflux 둘 다 있으면 servlet이 기본     //}     this.webApplicationType = WebApplicationType.deduceFromClasspath();     // 26.WebfluxVs.WebMvc.md             //BootstrapRegistryInitializer를 불러오고 셋 {     // ApplicationContext 준비하고 Environment 후처리 동안 이용되는 임시 컨텍스트 객체     // 이 동안 BootstrapRegistry를 사용하는데 Initializer 들을 SpringFactory에서 가져오고 객체로 만들어 세팅함     //     //      private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {     //          ClassLoader classLoader = getClassLoader();     //          // Use names and ensure unique to protect against duplicates     //          Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));     //          List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);     //          AnnotationAwareOrderComparator.sort(instances);     //          return instances;     //      }     //     //}     this.bootstrapRegistryInitializers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));     //ApplicationInitializer 셋 {     //  Bootstrap 단계에서 캐싱한 값으로 부터 찾아서 실제로 Initialize 한다.     //}     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));     //ApplicationListener 셋 {     //   ApplicationListener들을 불러오고 listener 값을 세팅     //   ApplictionListener는 옵저버 패턴으로 애플리케이션을 구독하는 리스터     //}     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));     // Main 추론{     //     //             //         // private Class&lt;?&gt; deduceMainApplicationClass() {     //     try {     //         StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();     //         for (StackTraceElement stackTraceElement : stackTrace) {     //             if (\"main\".equals(stackTraceElement.getMethodName())) {     //                 return Class.forName(stackTraceElement.getClassName());     //             }     //         }     //     }     //     catch (ClassNotFoundException ex) {     //         // Swallow and continue     //     }     //     return null;     // }     //           //  의도적으로 RuntimeException을 내서 StackTrace를 가져온다. 그리고 Main이 붙어있는 메소드를 찾으면 Main이라고 판단하고 클래스 이름을 찾느다.     //           //     //}     this.mainApplicationClass = deduceMainApplicationClass(); }     public ConfigurableApplicationContext run(String... args) {     long startTime = System.nanoTime();     DefaultBootstrapContext bootstrapContext = createBootstrapContext();     ConfigurableApplicationContext context = null;     configureHeadlessProperty();     SpringApplicationRunListeners listeners = getRunListeners(args);     listeners.starting(bootstrapContext, this.mainApplicationClass);     try {         ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);         ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);         configureIgnoreBeanInfo(environment);         Banner printedBanner = printBanner(environment);         context = createApplicationContext();         context.setApplicationStartup(this.applicationStartup);         prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);         refreshContext(context);         afterRefresh(context, applicationArguments);         Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);         if (this.logStartupInfo) {             new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);         }         listeners.started(context, timeTakenToStartup);         callRunners(context, applicationArguments);     }     catch (Throwable ex) {         handleRunFailure(context, ex, listeners);         throw new IllegalStateException(ex);     }     try {         Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);         listeners.ready(context, timeTakenToReady);     }     catch (Throwable ex) {         handleRunFailure(context, ex, null);         throw new IllegalStateException(ex);     }     return context; }}      ConfigurableApplicationContext",
        "url": "//spring/2024/05/24/Spring-series-12.Initialize.html"
      }
      ,
    
      "spring-2024-05-24-spring-series-11-spring-boot-application-html": {
        "title": "[spring Series] 11.spring Boot Application",
        "tags": "",
        "date": "May 24, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SpringBootApplication@SpringBootApplication@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {    @AliasFor(annotation = EnableAutoConfiguration.class)    Class&lt;?&gt;[] exclude() default {};    //AutoConfigure 제외 대상    @AliasFor(annotation = EnableAutoConfiguration.class)    String[] excludeName() default {};    //AutoConfigure 제외 대상 (클래스 명)    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\")    String[] scanBasePackages() default {};    //ComponentScan Packages    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\")    Class&lt;?&gt;[] scanBasePackageClasses() default {};    //ComponentScan classes    @AliasFor(annotation = ComponentScan.class, attribute = \"nameGenerator\")    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;    //BeanNaming 담당 클래스    @AliasFor(annotation = Configuration.class)    boolean proxyBeanMethods() default true;    //@Bean을 프록시로 처리하도록 설정    //프록시가 필요한 이유는 해당 메소드를 직접 호출하는 경우에도    //항상 싱글톤 스코프를 강제해서 1개의 객체만 생성하기 위함}      @SpringBootConfiguration@Configuration을 담은 Annotation```java@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@Indexedpublic @interface SpringBootConfiguration {    @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true;  }2. @EnableAutoConfiguration필요한 Spring auto configuration을 활성화하는 어노테이션 자동 설정할 클래스 선별은 `AutoConfigurationImportSelector`가 처리한다. `@Import`를 통해서 진행한다. ```java@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {    String ENABLED_OVERRIDE_PROPERTY= \"spring.boot.enableautoconfiguration\";    Class&lt;?&gt;[] exclude() default {};    String[] excludeName() default {};}autoConfigure 가능 대상은 spring.factories에 있다.(spring-boot-autoconfigure)auto-configuration 클래스는 아래의 어노테이션을 자주 사용한다.  @ConditionalOnClass: 해당 클래스가 클래스 패스에 존재하는 경우  @ConditionlOnBean: 해당 클래스나 이름이 빈 팩토리에 포함되어 있는 경우  @ConditionalOnMissingBean: 해당 빈이 등록되어있지 않은 경우 -&gt; bean이 없을 경우만 올라가게 할 수 있다.  @ComponentScan빈을 등록하기 위한 어노테이션을 탐색하는 basePackage를 지정한다.    @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan { @AliasFor(\"basePackages\") String[] value() default {}; @AliasFor(\"value\") String[] basePackages() default {}; Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN; boolean useDefaultFilters() default true; Filter[] includeFilters() default {}; Filter[] excludeFilters() default {}; boolean lazyInit() default false; @Retention(RetentionPolicy.RUNTIME) @Target({}) @interface Filter {     FilterType type() default FilterType.ANNOTATION;     @AliasFor(\"classes\")     Class&lt;?&gt;[] value() default {};     @AliasFor(\"value\")     Class&lt;?&gt;[] classes() default {};     String[] pattern() default {}; }}      ",
        "url": "//spring/2024/05/24/Spring-series-11.Spring-Boot-Application.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-10-required-args-constructor-html": {
        "title": "[spring Series] 10.required Args Constructor",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Spring + Lombok-RequiredArgsConstructorSpring + @RequiredArgsConstructorspring 4.3부터 생성자가 하나만 있으면 @Autowire를 기본으로 처리한다. 이 부분이 Lombok의 @RequiredArgsConstructor와 궁합이 맞아 처리되는 것이다.",
        "url": "//spring/2024/05/23/Spring-series-10.Required-Args-Constructor.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-09-application-context-html": {
        "title": "[spring Series] 09.application Context",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Application ContextApplicationContext빈들의 생성과 의존성 주입 등의 역할을 하는 일종의 DI 컨테이너(애플리케이션을 실행하기 위한 환경)ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver 를 상속 받음StaticApplicationContext빈 설정 메타 정보를 담은 BeanDefinition을 직접 만들고, 코드를 통해 IOC 등록하기 위해 사용되는 구현체이다.GenericApplicationContextXML 등의 외부에 있는 빈 설정 메타 정보를 BeanDefinitionReader로 읽어서 BeanDefinition을 정의하기 위해서 사용한다.BeanDefinitionReader 구현체로는 XmlBeanDefinitionReader, PropertiesBeanDefinitionReader 등이 있다.  AbstractApplicationContext를 상속받고 BeanDefinitionRegistry를 구현했다. 내부에는 DefaultListableBeanFactory를 필드로 갖고 있다.GenericXMLApplicationContextXML 파일로 설정을 만들고 컨텍스트에서 XML 을 읽어서 사용하는 코드를 만들 때 사용한다.WebApplicationContextAnnotationConfigApplicationContext-&gt; 일반 애플리케이션AnnotationConfigServletWebServerApplicationContext-&gt; 서블릿 기반 웹 (Tomcat)AnnotationConfigReactiveWebServerApplicationContext-&gt; 리액터 NettyConfigurableApplicationContext거의 모든 애플리케이션 컨텍스트가 갖는 공통 애플리케이션 컨텍스트 인터페이스다. ApplicationContext, LifeCycle, Closable를 상속받는다.",
        "url": "//spring/2024/05/23/Spring-series-09.Application-Context.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-08-autowired-html": {
        "title": "[spring Series] 08.autowired",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BeanAbstractAutowireCapableBeanFactory기본 빈 생성을 구현하는 추상 BeanFactory 상위 클래스. RootBeanDefinition 클래스에서 지정한 모든 기능을 사용할 수 있다.AutowireCapableBeanFactory 인터페이스를 구현하며 빈 생성을 담당하는 createBean 메소드가 있다.Autowire 및 초기화를 제공하는 추상 beanFactory @Autowire 시 의존관계 주입이 필요한 Bean에 @Autowire 처리를 한다.AutowiredAnnotationBeanPostProcessorBeanPostProcessor를 상속 받고 있다. 내부 inject 메소드로 객체를 주입한다. ReflectionUtils를 내부에서 사용하고 있다.",
        "url": "//spring/2024/05/23/Spring-series-08.Autowired.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-07-utils-html": {
        "title": "[spring Series] 07.utils",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Spring UtilsBeanUtils빈으로 만들 클래스 또는 객체에 대해 처리를 위한 Util을 제공한다.  findMethod  findDeclaredMethod  getParameterNames  getResolvableConstructor  instantiateClassReflectionUtils리플렉션 API를 편리하게 사용할 수 있도록 해준다.  accessibleConstructor  declaresException  findField  findMethod  getDeclaredMethods  getAllDeclaredMethods  getField  setField  invokeMethod  makeAccessibleFileCopyUtils파일 복사를 위한 유틸, 파일을 바이트 배열로 복사하거나 문자열로 복사한다.  copy  copyToByteArray  copyToStringSystemPropertyUtils시스템 property를 처리하기 위한 유틸  resolvePlaceholdersInput/OutputStreamUtils  copy  copyRange  copyToByteArray  copyToStringAnnotationUtils어노테이션, 메타 어노테이션을 핸들링하게 편하게 해주는 유틸  findAnnotation(Class&lt;?&gt; clazz, Class annotationType) : 특정 clazz에서 annotationType으로 찾는다.  findAnnotation(Method method, Class annotationType) : Method로 순회하면서 annotationType으로 찾는다.참고기본적으로 어노테이션을 찾는데 주력으로 한다.AnnotatedElementUtils어노테이션 내용을 오버라이딩할 때 사용한다.",
        "url": "//spring/2024/05/23/Spring-series-07.Utils.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-06-bean-html": {
        "title": "[spring Series] 06.bean",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BeanBean~Aware콜백, 리스너, 옵저버 디자인 패넡이 혼합되어 있다.BeanNameAware  객체가 컨테이너에 정의된 빈 이름을 인식하게 한다.  빈을 생성하는 시점에 setBeanName으로 이름을 얻어올 수 있다. (@Bean(name=\"\"))BeanFactoryAware  BeanFactory 객체를 주입하는데 사용된다.  setBeanFactory를 통해서 beanFactory를 주입받을 수 있다.BeanFactory  빈을 생성하고 의존관계를 설정하는 기능을 담당하는 IOC 컨테이너  스프링 빈을 관리하고 조회하는 역할을 담당  getBean()을 제공  Lazy-loading 을 사용BeanDefinition  스프링 컨테이너는 BeanDefinition을 기반으로 Bean을 생성한다.  상세          BeanClassName: 생성할 빈의 클래스 명      factoryBeanName: 팩토리 빈을 사용할 경우      factoryMethodName: 빈을 생성할 때 팩토리 메소드 이름      Scope: 싱글톤이 기본 값이다.      lazyInit: 스프링 컨테이너 생성시 Bean을 주입하는 것이 아니라 Proxy로 지연시켜서 생성할지 여부      initMethodName: 빈을 생성하고 의존 관계를 적용하고, 호출되는 초기화 메소드 명      DestroyMethodName: 빈의 생명 주기가 끝나고 제거되기 직전에 호출되는 메소드 명      Constructor arguments, Properties: 의존 관계 주입에서 사용      AttributeAccessorSupport모든 메소드의 기본 구현을 제공, 서브클래싱으로 확장됨BeanMetadataAttributeAccessorAttributeAccessorSupport 확장. 빈 메타 데이터를 정의로 담고 있다.AbstractBeanDefinitionBeanDefinition의 추상 클래스GenericBeanDefinition, RootBeanDefinition, ChildBeanDefinition의 뼈RootBeanDefinitionSpring Beanfactory의 특정 bean을 뒷받침GenericBeanDefinitionBeanDefinition 기본 형태라고 생각하면 된다. 클래스, Optional한 생성자 파라미터, 프로퍼티 값을 사요앟ㄹ 수 있다.Bean Scope  Singleton : 싱글톤  Proto : 매번 다른 인스턴스 생성  Request : 웹 요청이 들어오고 나갈 때까지 유지  Session : 웹 세션이 생성되고 종료될 때까지  Application : 서블릿 컨텍스트와 같은 범위로 유지Life cycle  BeanNameAware  BeanClassLoaderAware  BeanFactoryAware  EnvironmentAware  EmbeddedValueResolverAware  ResourceLoaderAware  MessageSourceAware  ApplicationContextAware  ServletContextAware  postProcessBeforeInitialization  Initializing Bean(afterPropertiesSet)  initMethod  postProcessAfterInitializationBeanFactoryPostProcessorbeanDefinition을 커스터마이징하게 도와준다. 모든 definition들이 로드 된 후 스프링의 startup 프로세스에 의해서 호출된다. 그러나 아무런 Bean이 초기화된 상태는 아니다.public class ConfigBeanFactory implements BeanFactoryPostProcessor {    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {        ((DefaultListableBeanFactory)beanFactory).registerBeanDefinition(\"myBeanName\", gbd);    }}BeanPostProcessorBean을 정의하고 컨테이너에 등록하기 전에 후처리 할 수 있도록 지원한다.public interface BeanPostProcessor {  @Nullable  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {    //생성 후 초기화 작업 이전    return bean;  }  @Nullable  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {    //생성 후 초기화 작업 이후    return bean;  }}",
        "url": "//spring/2024/05/23/Spring-series-06.Bean.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-05-bom-html": {
        "title": "[spring Series] 05.bom",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BOM?BOM(Bill Of Materials)BOM(Spring-boot-dependencies)는 스프링이 사용하는 여러 의존성 라이브러리 버전이 명시되어 있다.",
        "url": "//spring/2024/05/23/Spring-series-05.BOM.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-04-eureka-html": {
        "title": "[spring Series] 04.eureka",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EurekaSpring Eurekaeureka:  client:     allow-redirect: #true/false ## 서버가 클라이언트 요청을 백업 서버/ 클러스터로 리디렉션 할 수 있는지 나타낸다.## true면 http 리디렉션을 새 서버 위치와 함께 클라인트로 보낼 수 있다.##    availability-zones: ## 리전의 가용 영역 목록을 가져옴     backup-registry-impl: {name}## BackupRegistry를 구현하는 구현의 이름을 가져온다. (레지스트리 정보에 대한 복원력이 필요할 때)         cache-refresh-executor-exponential-back-oof-bound: 10## 시간 초과 발생 시 재시도 지연에 대한 최대 승수 값이다.         cache-refresh-executor-thread-pool-size: 2## 초기화 할 cacheRefreshExecutor 쓰레드 풀 크기         client-data-accept: {name}## 클라이언트 데이터를 받을 유레카 이름         disable-delta: false## 유레카 클라이언트가 변경된 부분만 가져올지 정합니다.             dollar-replacement: _## $대신할 문자열를 지정합니다.             escape-char-replacement: __## _대신할 문자열을 지정합니다.             enabled: true## Eureka 클라이언트 활성화에 대한 설정이다.    eureka-connection-idle-timeout-second: 30## HTTP 연결이 닫히기 전 idle을 유지할 수 있는 시간을 나타낸다.    eureka-server-connect-timeout-seconds: 5## 연결 초과되기 까지 대기하는 시간을 지정한다.   eureka-server-dns-name: {DNS_NAME}## 유레카 서버 목록을 가져 오기 위해 쿼리할 DNS 이름을 가져온다.   eureka-server-port: 8761## Erureka Server port   eureka-server-read-timeout-seconds: 8## read-timeout   eureka-server-total-connections: 200## 유레카 클라이언트에서 모든 유레카 서버로 허용되는 총 연결 수   eureka-server-total-connection-per-host: 50## 유레카 클라이언트 - 서버 호스트 총 연결 수    eureka-service-url-poll-interval-seconds: 0## 서버 정보의 변경을 폴링하는 빈도를 나타낸다.   fetch-registry: true## 이 클라이언트가 유레카 레재스트리 정보를 가져와야하는지 여부를 나타낸다.   g-zip-content: true## eureka 서버에서 가져온 콘텐츠를 서버에서 지원할 때 압축할지 여부를 나타낸다.     initial-instance-info-replication-interval-seconds: 40## 인스턴스 정보를 유레카 서버에 복제하는 초기 시간을 나타낸다.     instance-info-replication-interval-seconds: 30## 유레카 서버에 복제 할 인스턴스 변경 사항을 복제하는 빈도     proxy-host: {host}   proxy-port: {port}   proxy-username: {username}   proxy-password: {password}## 프록시 설정     registry-fetch-interval-seconds: 30## 레지스트리 정보를 가져오는 빈도를 나타낸다.     service-url: url  dashboard:   enable: true   path: /## 대시보드 설정    instance:   app-group-name: 앱 그룹 이름## 애플리케이션 그룹 이름        appname: {name}  ##  유레카에 등록할 이름을 가져온다.   health-check-url: { url }## health check url 설정   health-check-url-path: /health   home-page-url: {url}   home-page-url-path: /     instance-id: {ID}## 인스턴스의 고유 아이디      lease-expiration-duration-in-seconds: 90##  마지막 heartbeat - 인스턴스 제거 전 사이 시간을 지정한다.   lease-renewal-interval-in-seconds: 30##  하트 비트 인터벌을 정한다.( exipration-duration 보다 작아야 한다.)   prefer-ip-address: false##  호스트 이름 추측에 IP 주소를 사용해야 함을 나타내는 플래그",
        "url": "//spring/2024/05/23/Spring-series-04.Eureka.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-03-webflux-html": {
        "title": "[spring Series] 03.webflux",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - WebfluxWebfluxSpringBoot Webflux는 서블릿을 버리고, 비동기로 진행하여 동시성을 최대화하여 가용성을 높히는 데 중점을 둔 프레임워크이다.기본적으로 Java는 blocking code를 사용한다. Java는 Flow.Publisher을 이용해서 ReactiveStreams를 구현해서 사용할 수 있다.이에 대한 실제 구현체는 RxJava, Reactor가 있다.추가로 Tomcat을 버리고 Netty를 채택해서 EventLoop 기반으로 처리하여 가용성을 더 높혔다.이를 사용하면  메모리 가용성이 높아진다.  파이프 라인으로 pub/sub 프로세스를 연결하여 처리한다.ReactiveJava에서 비동기 처리?  Callback -&gt; Callback Hell에 빠질 수 있음  Future -&gt; CompletableFuture를 지원하긴 하지만 까다로움백프레셔Pub/Sub의 균형이 무너질 때 생기는 형상이다. 소비보다 생성이 많을 때 발생한다. 이는 결국 메모리가 overflow 되고 OutOfMemory로 이어진다.pushPublisher가 이벤트를 밀어 넣는 형식 -&gt; backpressure 발생할 수 있다.pullSubscribe가 요청한 만큼만 전달Cold vs. Hot  Cold -&gt; Subscribe로 이벤트 발현  Hot -&gt; Subscriber로 부터 시작하지 않는다. Publisher가 Emit하는 것을 기본으로 한다.RxJavaReactiveX(Netflix)에서 만들었다.Publisher  한 건의 경우 Single  데이터가 없거나 한 건이면 Maybe  한 건 이상일 경우 Observalbe, FlowRxJava에서 백프레셔 처리 방법  Observable 대신 Flowable사용```          Observable              1000개 미만 데이터 발행시        적은 소스로 OOM 발생이 가능성이 낮을 경우        GUI 이벤트 처리              Flowable      1000개 이상 데이터 발행 시    디스크 I/O    JDBC    네트워크 I/O    Backpressure 제어 전략      MISSING(BackpressureStrategy.MISSING) -&gt; x    ERROR(BackpressureStrategy.ERROR) -&gt; 발생시 MissingBackpressureException    BUFFER(BackpressureStrategy.BUFFER) -&gt; 소비할 때까지 Queue, OOM 가능성 이씀    DROP(BackpressureStrategy.DROP) -&gt; 소비하지 못한 데이터 버림    LATEST(BackpressureStrategy.LATEST) -&gt; 받을 준비가 될 때까지 최신만 유지하고 버림```  ReactorPivotal에서 만들었다.Publisher  한 건은 Mono  없거나 여러 건은 FluxReactor에서 백프레셔 처리 방법  버퍼링 -&gt; OOM 가능성 있음  DROP -&gt; onBackpressureDrop()으로 그냥 버려서 최악의 상황을 모면함  Latest -&gt; onBackpressureLatest()으로 최근 이벤트만 유지  flatMap() -&gt; 내부 Publisher로 변환하고 Merge하여 소비 속도 조절, 동시성 수준을 조절할 수 있어서 백프레셔 관리 가능(2번 째 파라미터로 동시성 제어)OperatorCreate  just()  create()  fromStream()  fromIterable()Sequence Control  flatMap() -&gt; map() + 새로운 Sequence를 생성해서 내보 냄  concat() -&gt; Publisher의 Sequence를 연결해서 emit  merge() -&gt; Mono를 합침  zip() -&gt; 여러 개의 Sequnce에서 emit 된 데이터를 결합peeking  doOnNext() -&gt; 처리되기 전 흐름에 영향 없이 무언가 하기 위해서  doOnSuccess/doOnComplete -&gt; 성공/완료 시  doOnError -&gt; 에러 종료 시  doOnCancel -&gt; 취소 시  doFirst -&gt; 시작 시  doOnSubscribe -&gt; 구독 시  doOnRequest/doOnTerminate -&gt; 요청/ 종료 시  log() -&gt; Singal 이벤트 로깅Filter  filter -&gt; Filtering  take -&gt; 통과 개수 지정error  timeout -&gt; timeOut 이내 emit 없으면 에러  retry -&gt; 주어진 숫자만큼 재구독하도록ignoreElement  then -&gt; 작업 완료를 기다림  thenReturn -&gt; then + return some Mono  thenMany -&gt; then return + some Flux  distinct -&gt; 중복 제거split (Flux -&gt; Flux&lt;Flux&gt;)  window(int)  window(Duration)  buffertoSynchronous  blockFirst/blockLast (flux)  toIterable/toStream (flux)  block (mono)  toFuture (mono)delay  delay/delayUntil -&gt; 완료 연기참고 자료R2DBC ( Reactive Relational DataBase Connectivity )JDBC 논 블로킹 버전이라고 이해하면 그나마 낫다.장점  JDBC에서는 불가능한 논 블로킹 API를 제공한다.단점  JDBC와 다르다. (JDBC에서 당연하게 사용하던 것들을 사용할 수 없다.)(caching, lazyLoading, write-behind 등)  아직 성숙하지 않아서 공식적인 driver implementation이 없다.  R2DBC가 JDBC의 next가 되지 않을 가능성이 있다. (ProjectLoom은 JVM base DB Driver를 만들고 있다.)Java19, LoomblogSpot  JPA와 같은 관계성 매핑이 불가능하며, 캐싱, 영속성 컨텍스트 등을 제공하지 않는다.QueryDslJPA 처럼 queryDsl을 Third party로 지원하지만(QueryDsl도 thirdParty지만) 완벽하지 않다.에러 사항  네이밍 규칙infobip Querydsl의 기본 네이밍 규칙이 Pascal이다. 이를 덮어 쓰기 위해서 Bean을 지정한다.@Configurationpublic class QuerydslConfig {    @Bean    public NamingStrategy namingStrategy() {        return new NamingStrategy(){            @Override            public String getTableName(Class&lt;?&gt; type) {                return type.getSimpleName();            }            @Override            public String getColumnName(RelationalPersistentProperty property) {                return property.getName().substring(0, 1).toUpperCase() + property.getName().substring(1);            }        };    }}infobip querydsl README에서도Flyway를 쓰던 SqlTemplate을 @Bean으로 두던 하라고 한다.  템플릿 설정@Configurationpublic class SqlTemplatesConfig {    private final List&lt;String&gt; driver = Arrays.asList(\"mysql\", \"maria\");    @Bean    public SQLTemplates sqlTemplates (R2dbcProperties properties) throws SQLException {        Boolean isStorageDB = driver.stream().map(driver -&gt; properties.getUrl().contains(driver)).reduce(false, (p, n) -&gt; p || n);        return isStorageDB ?                MySQLTemplates.builder().escape('\\\\').quote().newLineToSingleSpace().build() :                H2Templates.builder().quote().escape('\\\\').newLineToSingleSpace().build();    }}이 Template에 따라 Querydsl이 쿼리를 파싱하는 결과가 바뀐다. 뭐 예를 들어interface BoardQueryDslRepository extends QuerydslR2dbcRepository&lt;Board, String&gt; {    }@Repository@RequiredArgsConstructor@Slf4jclass BoardRepository {    private final BoardQueryDslRepository boardQuery;    private BooleanBuilder condition(BoardType type, Language locale) {        BooleanBuilder builder = new BooleanBuilder();        if(Objects.nonNull(type)) board.type.eq(type);        if(Objects.nonNull(locale)) builder.and(board.locale.eq(locale));        return builder;    }    public Mono&lt;Template&gt; template(BoardType type, Language locale) {        return boardQuery.query(query -&gt; {            return query.select(                                new QBoardeDto(                                        board.boardNo,                                        board.boardType,                                        board.locale,                                        board.contents,                                        board.lastModifiedDate                                )                        )                        .from(template)                        .where(this.condition(templateType, locale));        }).one();    }}이렇게 있다면 where 절의 파라미터에 값을 바인딩할 때 '?'으로 네이밍을 잡아서 바인딩하려다 실패를 한다던가 하는 문제가 발생할 수 있다.내부적으로 MySQLSQLTemplates인지 instanceOf를 해서 파라미터 바인딩하는 것으로 보인다(Maria_r2dbc-connector). 따라서 기존에는 크게 신경 쓰지 않던 것에도주의를 기울여야 한다.  MariaConnector에서 지원하지 않아서 Enum을 parameter로 던지면 codec 문제를 일으킨다(QueryDSL 기준) -&gt; 해결 하지 못했다.",
        "url": "//spring/2024/05/23/Spring-series-03.Webflux.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-02-actuator-html": {
        "title": "[spring Series] 02.actuator",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ActuatorActuator실행 중인 애플리케이션에 대한 정보를 제공한다.  애플리케이션 환경에서 사용할 수 있는 구성 속성  애플리케이션에 포함된 다양한 패키지의 로깅 레벨  애플리케이션이 사용 중인 메모리  지정된 엔드 포인트가 받은 요청 횟수  애플리케이션의 건강 상태 정보            Method      Endpoint      Description      Default                  GET      /aduitevents      audit 이벤트 리포트를 생성한다.      X              GET      /beans      컨텍스트의 모든 빈을 리스트 업      X              GET      /conditions      성공 또는 실패한 자동 구성 조건의 내역을 생성      X              GET      /configprop      모든 구성 속성들을 현재 값과 같이 알려준다.      X              GET, POST, DELETE      /env      스프링에서 사용할 수 있는 모든 env를 보여준다.      X              GET      /env/{toMatch}      특정 황경 속성 값을 보여준다.      X              GET      /health      건강상태를 보여준다.      O              GET      /heapdump      힙 덤프를 다운로드 한다.      X              GET      /httptrace      최근의 100개 요청을 tracing한다.      X              GET      /info      개발자가 정의한 info를 반환      O              GET      /loggers      패키지 - 로깅 레벨을 반환      X              GET, POST      /loggers/{name}      지정한 로거의 로깅레벨을 반환      X              GET      /mappings      HTTP 매핑과 매핑을 처리하는 핸들러의 메소드들 내역을 제공      X              GET      /metrics      모든 메트릭 리스트 반환      X              GET      /metrics/{name}      지정한 메트릭 값을 반환      X              GET      /scheduledtasks      스케쥴링된 모든 태스크의 내역을 제공      X              GET      /threaddump      모든 애플리케이션 쓰레드의 내역을 반환      X              POST      /shutdown      애플리케이션을 종료한다.                     POST      /refresh      애플리케이션 정보를 갱신한다.               Refresh =&gt; Yaml은 다시 불러온다. 그러나 이미 주입된 Bean은 다시 주입되지 않는다. -&gt; 아직까지 큰 실효성을 모르겠다.",
        "url": "//spring/2024/05/23/Spring-series-02.Actuator.html"
      }
      ,
    
      "spring-2024-05-23-spring-series-01-configuration-html": {
        "title": "[spring Series] 01.configuration",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Spring Yaml settingsSpring Configuration1. Shutdown Gracefullyserver:  shutdown: graceful ##[default immediate]spring:  lifecycle:    timeout-per-shutdown-phase: 2m이러면 -9로 끝내는게 아니라 할 일을 다 마치고 종료된다.2. server portserver:  port: 8080  error:    whitelabel:      enabled: true    ## 에러 페이지 활성화 여부    include-exception: false    ## 에러에 Exception 포함 여부    include-message: never    ## 에러에 메시지 포함 여부    include-stacktrace: never    ## 에러에 stacktrace 포함 여부3. eureka 4. antPatternMatchspring:  mvc:    pathmatch:      matching-strategy: ant_path_matcher    ## 2.6 이상에서 path_pattern_parser로 변경됨    ## legacy matching-strategy가 ant_path_matcher다.5. applicationTypeapplication:  main:    web-application-type: reactive## 웹 어플리케이션을 어떤 모드로 실행시킬지에 대한 설정## MVC, Webflux 둘 다 있을 경우 유효하다.6. Spring cloud gatewayspring:  cloud:    gateway:      routes:        - id: service-id          ## route의 고유 식별자          uri: lb://eureka-id          ## 보낼 원격지          predicates:            - Path=/v1/**, /v2/**, /v3/api-docs          ## pattern Predicate          filters:            #필터            - RewritePath=/(?&lt;segment&gt;.*), /v1/$\\{segment}            - LoggingFilter            - name: Retry              args:                retries: 2                statuses: INTERNAL_SERVER_ERROR,SERVICE_UNAVAILABLE                methods: GET,POST,PUT,PATCH,DELETE                backoff:                  firstBackoff: 100ms                  maxBackoff: 100ms                  factor: 27. eureka clienteureka:  instance:    instance-id: ${spring.cloud.client.hostname}:${spring.application.instance_id:${random.value}}    app-group-name: application-server    prefer-ip-address: true    lease-renewal-interval-in-seconds: 30    metadata-map:      prometheus:        scrape: true      metrics:        path: /actuator/prometheus  client:    service-url:      defaultZone: http://localhost:8761/eureka    eureka-service-url-poll-interval-seconds: 58. elastic searchspring:  elasticsearch:    connection-timeout: 5s    socket-timeout: 30s    #uri    uris: http://localhost:9200    username: elastic    password: elasticlogging:  level:    org:      springframework:        data:          elasticsearch:            core: DEBUG            client: TRACE9. hibernatespring:  jpa:    ## oiv 활성화 여부 true -&gt; controller까지 entityManager가 살아있다.    open-in-view: false    hibernate:      naming:        ## naming 전략        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl      ## hibernate ddl 전략      ddl-auto: update    ## DDL을 할지 여부      generate-ddl: true    show-sql: true    properties:      hibernate:        format_sql: true        use_sql_comments: true        javax:          persistence:            sharedCache:              mode: ENABLE_SELECTIVE          cache:            provider: org.ehcache.jsr107.EhcacheCachingProvider        cache:          use_query_cache: true          use_second_level_cache: true          region:            factory_class: org.hibernate.cache.jcache.internal.JCacheRegionFactory        generate_statistics: truelogging:  level:    org:      hibernate:#        SQL: debug        #        type: trace        orm:          jdbc:            bind: trace#            extract: trace10. mongodbspring:  data:    mongodb:      host: 192.168.0.42      authentication-database: admin      port: 27017      username: root      password: root      database: boardlogging:  level:    org:      springframework:        data:          mongodb:            core:              ReactiveMongoTemplate: DEBUG              MongoTemplate: DEBUG          document:            mongodb: DEBUG11. r2dbcspring:  data:    r2dbc:      repositories:        enabled: true  r2dbc:    pool:      enabled: true    username: root    password: root    url: r2dbc:mariadb://localhost:3307/application12. spring config importpath:  common: config/services/common  local:  config/services/local  test:  config/services/test  prod:  config/services/prodspring:  config:    activate:      on-profile: local    import:      - classpath:${path.common}/actuator.yaml      - classpath:${path.common}/constant.yaml      - classpath:${path.common}/hibernate.yaml      - classpath:${path.common}/pathMatcher.yaml      - classpath:${path.common}/server.yaml      - classpath:${path.local}/r2dbc.yaml      - classpath:${path.local}/eureka.yaml",
        "url": "//spring/2024/05/23/Spring-series-01.Configuration.html"
      }
      ,
    
      "others-2024-05-23-others-series-transaction-html": {
        "title": "[others Series] Transaction",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Transaction트랜잭션격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED가 있으며, 왼쪽으로 가면 갈수록 격리성이 강해지며, 오른쪽으로 가면 갈수록 동시성이 강해진다.REPEATABLE_READ는 팬텀리드, READ_COMMITTED는 팬텀리드, 반복 가능하지 않은 조회가 발생하며, READ_UNCOMMITTED는 팬텀 리드, 반복 가능하지 않은조회, 더티 리드가 발생할 수도 있다.격리 수준에 따라 발생하는 현상  팬텀 리드 (Phantom read) : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.  반복 가능하지 않은 조회 (Non-repeatable read) : 한 트랜잭션 내의 같은 행이 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킨다.  더티 리드 (dirty read) : 반복 가능하지 않은 조회와 유사하며, 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생격리 수준  Serializable : 트랜잭션을 순차적으로 진행시키는 것을 의미한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.  Repeatable_read : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만, 새로운 행을 추가하는 것을 막아주지는 않는다.  Read_committed : 기본 값이다. read_uncommitted와 다르게 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수는 있다.  read_uncommitted : 가장 낮은 격리 수준으로 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다.",
        "url": "//others/2024/05/23/Others-series-Transaction.html"
      }
      ,
    
      "others-2024-05-23-others-series-semaphore-and-mutex-html": {
        "title": "[others Series] Semaphore And Mutex",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Semaphore vs. MutexMutex한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로한 상호배제 기법프로세스, 쓰레가 공유 자원을 lock()을 통해 잠금을 설정하고 사용한 뒤 unlock()으로 잠금 해제하는 객체 객체다.SemaphoreSignaling mechanism. 현재 공유 자원에 접근할 수 있는 쓰레드, 프로세스 수를 나타내는 값을 둬서 상호배제를 이루는 기법일반화된 뮤텍스, 간단한 정수 값과 두 가지 함수 wait 및 signal로 공유 자원에 대한 접근을 처리한다. wait()은 자신의 차례가 올 때까지 기다리는 함수이며,signal()은 다음 프로세스로 순서를 넘겨주는 함수다.      바이너리 세마포어0, 1의 두 가지 값만 가질 수 있는 세마포어. 구현의 유사성으로 뮤텍스는 바이너리 세마포어라고 할 수 있지만 엄밀히 말하면 뮤텍스는 잠금 기반으로 상호 배제가 일어나는 잠금 메커니즘이고, 세마포어는신호를 기반으로 상호 배제를 하는 신호 메커니즘이다.        카운팅 세마포어여러 개의 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는 데 사용한다.  Monitor모니터는 둘 이상의 쓰레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다.",
        "url": "//others/2024/05/23/Others-series-Semaphore-and-Mutex.html"
      }
      ,
    
      "others-2024-05-23-others-series-process-service-and-daemon-html": {
        "title": "[others Series] Process, Service And Daemon",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Process vs. Service vs. DaemonProcess vs. Service vs. DaemonProcess프로세스는 메모리에 적재되어 CPU에 의해 실행되는 컴퓨터 프로그램을 지칭한다. 각 프로세스는 고유한 프로세스 ID(PID)를 가지며, 운영체제는 프로세스 간의 자원 공유를 관리한다.예를 들어, 웹 브라우저를 실행하는 경우 브라우저라는 프로그램은 하나의 프로세스로 실행되는 것이다. 그리고 프로세스는 눈에 보이는 프로세스(foreground process)와눈에 보이지 않은 프로세스(background process)로 구분된다.            foreground      background                  사용자와 상호작용하는 프로세스      프로세스는 사용자와 상호작용하지 않고 시스템에서 실행되는 프로세스              최소화를 하더라도 눈에 보이는 프로세스를 포그라운드 프로세스      눈에 보이지 않지만 뒤에서 일을 하고 있는 프로세스를 백그라운드 프로세스              인터넷, 카카오톡, 메모장, 그림판 등 눈에 보이는 프로그램      백신 프로그램, 그래픽 드라이버, 마이크 드라이버 등 눈에 보이지 않는 프로그램      Service서비스는 백그라운드에서 실행되는 응용 프로그램이다. 윈도우 서비스는 일반적으로 사용자 인터페이스를 필요로 하지 않는 작업(네트워크 서비스, 데이터베이스 서버, 백업 서비스) 등을 수행한다.이러한 서비스들은 시스템이 부팅될 때 자동으로 시작되며, 사용자가 로그인하지 않은 상태에서도 계속해서 실행된다.이렇게만 보면 데몬과 서비스의 차이가 잘 와닿지 않을 것인데, 윈도우 OS에서는 백그라운드에서 실행되는 응용 프로그램을 service 라 부르고 유닉스(리눅스) OS에서는 daemon 이라고 불린다고 보면 된다.Daemon데몬은 백그라운드에서 실행되는 프로그램으로, 사용자가 직접적으로 제어하지 않고 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다. 사용자의 요청을 기다리고 있다가요청이 발생하면 이에 적절히 대응하는 리스너와 같은 역할을 한다. 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응 할 수 있도록 대기중인 프로세스를 말한다.예시)            서비스 명      데몬 명      정의                  Linux 슈퍼데몬      xinetd      Linux 내 여러 서비스를 한번에 관리              File Transfer Protocol      vsftpd      File을 전송하는 서비스              Secure Shell Service      sshd      암호화 원격 작업이 가능한 서비스      Service vs. DaemonDaemon 과 Service는 비슷한 개념이지만, 운영 체제 차이점 있다고 했다. 그외에도 사용처에도 차이가 있는데, 데몬은 일반적으로 서버에서 주로 사용되고, 서비스는 다른 프로그램이나 서비스를 지원하기 위해 실행된다.데몬은 시스템에서 독립적으로 실행되고, 서비스는 시스템의 상태를 모니터링하고, 백그라운드에서 실행되는 애플리케이션을 제어하고, 작업을 수행하는 등의 역할 지원하는데 초점이 맞춰져 있다는 뜻이다.",
        "url": "//others/2024/05/23/Others-series-Process,-Service-and-Daemon.html"
      }
      ,
    
      "others-2024-05-23-others-series-os-html": {
        "title": "[others Series] Os",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - OSOS운영체제의 역할  CPU 스케쥴링 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다.  메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지 관리한다.  디스크 파일 관리 : 디스크 파일을 어떤 방법으로 보관할지 관리한다.  I/O 디바이스 관리 : I/O 디바이스들과 컴퓨터 간의 데이터를 주고 받는 것을 관리한다.시스템 호출(systemCall)이란 운영체제가 커널에 접근한기 위한 인터페이스이며, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다.컴퓨터의 요소컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이뤄져 있다.CPU  CU(ControlUnit) : 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다.  레지스터 : 매우 빠른 임시기억 장치  산술논리연산장치 : 덧셈, 뺄셈 같은 두 숫자의 산술연산, 배타적 논리합, 곱 등같은 논리 연산을 계산하는 디지털 회로DMAI/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU에만  너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며, CPU의 일을 부담하는 역할을 한다.메모리메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다.  레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음  캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음, L3도 있다.  주기억장치 : RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량이 보통  보조기억장치 : HDD, SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량 많음캐시캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목을 줄이기 위해서 사용하는 메모리를 말한다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.지역성의 원리자주 사용하는 데이터를 기반으로 설정해야 한다. 자주 사용하는 데이터에 대한 근거가 무엇일까? 시간 지역성(temporal locality), 공간 지역성(spatiaal locality)가 있다.      시간 지역성최근 사용한 데이터에 다시 접근하려는 특성을 말한다.        공간 지역성최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.  캐시 미스, 히트원하는 데이터를 찾는 것을 캐시 히트 반대를 캐시 미스라고 한다.메모리 관리가상 메모리는 메모리 관리 기법의 하나로 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 의미한다.스와핑가상 메모리에 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다. 이때 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 HDD의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 한다.페이지 폴트프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우 발생한다.  명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 없다면 트랩이 발생해서 운영체제에 알리게 된다.  OS는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.  해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체(스와핑)  페이지 테이블을 갱신시킨 후 해당 명령을 다시 시쓰레싱Thrashing은 메모리의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터의 성능 저하를 초래한다.메모리 할당시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.  연속 할당 : 메모리에 ‘연속적으로’ 공간을 할당하는 것을 의미          고정 분할 방식(fixed partition allocation) : 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어 있기 때문에 융통성이 없다. 또한 내부 단편화가 발생한다.      가변 불할 방식(variable partition allocation) : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 없지만 외부 단편화가 있을 수 있다. (최초 적합, 최적 적합, 최악 적합이 있다.)                  이름      설명                  First Fit      위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당              Best Fit      프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당              Worst Fit      프로세스의 크기와 가장 많이 차이가 나는 홀에 할당        내부 단편화(Internal Fragmentation) : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상외부 단편화(External Fragmentation) : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 경우 홀 (hole) : 할당할 수 있는 비어 있는 메모리 공간  불연속 할당현대 OS가 쓰는 방법, 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것, 페이징 말고 세그맨테이션, 페이지드 세그멘테이션이 있다.          Paging : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다. 홀의 크긱가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.      Segmentation : 페이지가 아닌 의미 단위인 세그먼트로 나누는 방식이다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이뤄지는데, 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수도 있다. 이는 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않는 단점이 있다.      Paged Segmentation : 세그먼트로 나누는데, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 의미한다.        페이지 교체 알고리즘offline : 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다. FIFO(First In First Out) : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미한다. LRU(Least Recently Used) : 참조가 가장 오래된 페이지를 바꾼다. NUR(Not Used Recently) : LRU에서 발, clock 알고리즘, 시계 방향으로 돌며 참조하면 1, 아니면 0. 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘LFU(Least Frequently Used) : 가장 참조 횟수가 적은 페이지를 교체한다.프로세스 상태New : 프로세스 생성 상태, fork(), exec() 함수로 생성  fork() : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수 (주소 공간만 복사)  exec() : 새롭게 프로세스를 생성하는 함수Ready : 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기, CPU 소유권이 넘어오기를 기다림Ready Suspend : 메모리 부족으로 일시 중단된 상태Blocked : 어떤 이벤크가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다. Blocked Suspend : 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태Terminated : 메모리와 CPU 소유권을 모두 놓고 가는 상태부모가 자식 프로세스를 강제로 비자발적 종료로 종료되는 것도 있다. 자식 프로세스가 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process kill로 프로세스를 종료할 때 발컨텍스트 스위칭PCB를 기반으로 프로세스 상태를 저장하고 로드시키는 과정, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.  PCB ( Process Control Block ) : 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 프로세스 제어 블록이라고도 한다.쓰레드, 멀티 쓰레딩쓰레드 : 프로셋의 실행 가능한 가장 작은 단위멀티쓰레드 : 프로세스 내 여러 개의 쓰레드, 멀티 쓰레드로 처리하는 기법 쓰레드끼리 자원을 공유하기 때문에 효율성이 높음공유 자원shared resource는  시스템 안에서 각 프로세스, 쓰레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원이나 변수를 의미한다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을경쟁 상태(race condition)이라고 한다.  동시 접근 시 타이밍, 순서 등이 결과에 영향을 준다.임계 영역둘 이상의 프로세스, 쓰레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 말한다. 임계영역을 해결하는 방법은 뮤텍스, 세마포어, 모니터 세 가지가 있다. 모두 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.  상호 배제(mutual exclusion)한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.  한정 대기(bounded waiting)특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하면 안 된다.  융통성(progress)만약 어떠한 프로세스도 임계 영역을 사용하지 않으면 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며, 이 때 프로세스끼리 서로 방해하지 않는다.세마포어, 뮤텍스, 모니터교착 상태(Deadlock)의 원인  상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가  점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태  비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다.  환형 대기 : 프로세스A는 프로세스B의 자원을 요구하고, 프로세스B는 A의 자원을 요고하는 상황해결 방법  자원 할당 시 조건이 설림하지 않도록 설계  교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은행원 알고리즘을 쓴다.  교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.  거의 일어나지 않지만 처리하는데 비용이 크다. 그래서 사용자에게 판단을 위임한다.",
        "url": "//others/2024/05/23/Others-series-OS.html"
      }
      ,
    
      "others-2024-05-23-others-series-network-html": {
        "title": "[others Series] Network",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - NetworkNetworkBasic  LAN : Local Area Network  MAN : Metropolitan Area Network  WAN : Wide Area NetworkTCP/IP 4계층 - OSI 7계층TCP/IP 4계층  L4 (애플리케이션 계층) : FTP/ HTTP/ SSH/ SMTP/ DNS -&gt; 프로토콜 계층  L3 (전송 계층): TCP/ UDP/ QUIC -&gt; 송,수신자를 연결하는 계층  L2 (인터넷 계층) : IP/ ARP/ ICMP -&gt; 네트워크 패킷을 IP주소로 지정된 목적지로 전송하기 위해서 사용하는 계층  L1 (링크 계층) : ethernet -&gt; 전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달하며 장치 간의 신호를 주고 받는 규칙을 정하는 계층OSI 7  L7 (응용 계층) : HTTP/ FTP/ SMTP/ POP3/ IMAP/ Telnet과 같은 프로토콜이 있다. -&gt; 응용 서비스를 수행 (L7 스위치)  L6 (표현 계층) : 코드 간의 번역을 담당하며, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 덜어준다. -&gt; MIME 인코딩, 암호화 같은 동작을 수행 (압축, 포장, 암호화)  L5 (세션 계층) : 데이터가 통신하기 위한 노리적 연결을 한다. -&gt; 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 (duplex, half-duplex, full-duplex), TCP/IP 세션을 만들고 없애는 책임을 가진다.  L4 (전송 계층) : 통신을 활성화 하기 위한 계층 단대단 오류제어 및 흐름 제어(UDP/TCP) -&gt; 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있으며 연결 기반이다. (이는 전송계층이 패킷들의 전송이 유효한지 확인하고 실패한 패킷들을 다시 전송한다는 것이다.)  L3 (네트워크 계층) : 라우팅이 가장 중요한 기능이다. -&gt; IP주소 부여, 라우팅 (라우터, L3 스위치)  L2 (데이터 링크 계층) : 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보 전달을 수행할 수 있도록 도와주는 역할을 한다. -&gt; mac을 가지고 통신한다. 이 계층에서 전송되는 단위를 프레임이라고 한다. (L2 스위치, 브리지)  L1 (물리 계층) : 전기적, 기계적 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송한다. -&gt; 단순 전기적 신호를 변환해서 주고 받는다. ( NIC, 리피터, AP)",
        "url": "//others/2024/05/23/Others-series-Network.html"
      }
      ,
    
      "others-2024-05-23-others-series-multiprocess-and-multithread-html": {
        "title": "[others Series] Multiprocess And Multithread",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - MultiProcess vs. MultiThreadMultiProcess vs. MultiThreadMultiProcess멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다. 보통 하나의 프로그램 실행에 대해 하나의 프로세스가 메모리에 생성되지만, 부가적인 기능을 위해 여러개의 프로세스를 생성하는 것이다.멀티 프로세스 내부를 보면, 하나의 부모 프로세스가 여러 개의 자식 프로세스를 생성함으로서 다중 프로세스를 구성하는 구조이다.한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성할 수 있는데, 다른 프로세스를 생성하는 프로세스를 부모 프로세스(Parent Process)라 하고,다른 프로세스에 의해 생성된 프로세스를 자식 프로세스(Child Process)라 한다.부모 프로세스와 자식 프로세스는 각각 고유한 PID(Process ID)를 가지고 있다. 부모 프로세스는 자식 프로세스의 PID를 알고 있으며, 이를 통해 자식 프로세스를 제어할 수 있다. 또한, 자식 프로세스는 부모 프로세스의 PID와 PPID(Parent Process ID)를 알고 있어, 이를 통해 부모 프로세스와의 통신이 가능하다.ex) 브라우저 탭장점1. 프로그램 안정성독립적 메모리 공간을 가져서 한 프로세스가 비정상 종료되도 다른 프로세스에 영향을 주지 않는다.2. 병렬성3. 시스템 확장성멀티 프로세스는 각 프로세스가 독립적이므로, 새로운 기능이나 모듈을 추가하거나 수정할때 다른 프로세스에 영향을 주지 않는다. 그래서 시스템의 규모를 쉽게 확장할 수 있다.단점1. Context Switching OverHead멀티태스킹을 구성하는데 핵심 기술인 컨텍스트 스위칭(context switching) 과정에서 성능 저하가 올 수 있다2. 자원 공유 비효율성멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 결과적으로 메모리 사용량이 증가하게 된다.만일 각 프로세스간에 자원 공유가 필요할 경우 프로세스 사이의 어렵고 복잡한 통신 기법인 IPC(Inter-Process Commnuication)을 사용하여야 한다.MultiThread스레드는 하나의 프로세스 내에 있는 실행 흐름이다. 그리고 멀티 스레드는 하나의 프로세스 안에 여러개의 스레드가 있는 것을 말한다. 따라서 하나의 프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능해진다.멀티 프로세스는 웹 브라우저에서의 여러 탭이나 여러 창이라고 말했었다. 대신 멀티 스레드는 웹 브라우저의 단일 탭 또는 창 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리하고 처리하는데 사용된다고 보면된다.장점1. 쓰레드가 프로세스보다 저렴함2. 공유 메모리에 따른 자원 효율성3. Context Switching 비용 감소 (비용이 상대적으로 낮다.)4. 응답 시간 단축단점1. 안정성2. 공유 메모리 동기화로 인한 성능 저하3. 데드락4. Context Switch Overhead [1]5. 디버깅이 어려움[1] : running상태가 끝난 프로세스는 PC, SP, 레지스터, Base Register, limit Register 등 많은 내용들을 PCB에 저장을 해야하는 것이고, 이후 Dispatcher는 ready queue에서 running상태로 올릴 프로세스의 PCB에서 또다시 많은 내용을 복원해야 하는 것이다. 즉, context switching을 위해 context를 저장하고 context를 restore하는 것인데 이러한 일을 하는 데에는 부담이 발생할 수밖에 없을 것이다.이렇게 Context Switch(문맥 교환)에 의해 Dispatcher에 발생하게 되는 부담을 “Context Switching Overhead(문맥교환 오버헤드)”라고 한다.",
        "url": "//others/2024/05/23/Others-series-MultiProcess-and-MultiThread.html"
      }
      ,
    
      "others-2024-05-23-others-series-encryption-html": {
        "title": "[others Series] Encryption",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Encrypt암호화단방향 (Hash)1. 종류  MD5 (Message-Digest algorithm 5)  SHA-1  SHA-2(SHA-256)    2. 장점    빠른 속도    3. 단점    RainbowTable : 동일한 메시지는 동일한 다이제스트를 갖는다. (BruteForce)양방향대칭키(비공개키)1. 종류  DES  3DES  AES  SEED  ARIA2. 특징  암/복호화에 서로 동일한 키가 상용되는 암호화 방식 (그래서 비공개)    3. 장점    속도가 빠름    4. 단점    키가 탈취되면 문제가 생김비대칭키(공개키)1. 종류  RSA  DSA  ECC    2. 특징    암/복호화에 서로 다른 키가 사용된다.    3. 장점    키가 탈취되도 문제가 적다.    4. 단점    느리다.",
        "url": "//others/2024/05/23/Others-series-Encryption.html"
      }
      ,
    
      "others-2024-05-23-others-series-cpuschedule-html": {
        "title": "[others Series] Cpuschedule",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CPU schedulingCPU 스케쥴링 알고리즘1. 비선점(non-preemptive)프로세스가 스스로 CPU 소유권을 포기하는 방식. 강제로 프로세스를 중지하지 않는다. 따라서 컨텍스트 스위칭으로 인한 부하가 적다.  FCFS(First Come, First Served) : 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘 -&gt; ready Queue에서 오래 기다리는 현상(Convoy effect)가 발생하는 단점이 있다.  SJF(Shortest Job First) : 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘 -&gt; 긴 시간을 가진 프로세스가 실행되지 않는 현상(Starvation)이 일어나며, 평균 대기 시간이 가장 짧다.  우선 순위 : SJF는 긴 시간 프로세스가 무한정 밀릴 수 있다. 우선 순위는 ‘우선 순위를 높이는 방법(aging)’을 사용해서 이를 보완했다.2. 선점(preemptive)현대 OS 작동 방식으로 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 다른 프로세스에 CPU 소유권을 할당하는 방식  라운드 로빈(Round Robin) : 각 프로세스는 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 ready Queue의 뒤로 가는 알고리즘  SRF(Shortest Remaining Time First) : SJF는 중간 실행 시간이 더 짧은 작업이 들어오면 기존 작업을 수행하고 넘어가는데, SRF는 더 짧은 작업이 생기면 중간에 종료하고 더 짧은 것을 먼저 수행하는 알고리즘이다.  다단계 큐 : 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 의미한다.",
        "url": "//others/2024/05/23/Others-series-CpuSchedule.html"
      }
      ,
    
      "others-2024-05-23-others-series-compile-vs-transpile-vs-interpreter-html": {
        "title": "[others Series] Compile Vs Transpile Vs Interpreter",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Compile vs. Transpile vs. InterpreterCompile vs. Transpile vs. InterpreterCompile한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것이 컴파일이다ex) JAVA -&gt; bytecode  전체 파일을 스캔하여 한꺼번에 번역  초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.  기계어 번역과정에서 많은 메모리를 사용한다.  전체 코드를 스캔하는 과정에서 모든 오류를 한꺼번에 출력해주기 때문에 실행 전에 오류를 알 수 있다Interpreter인터프리터(Interpreter)는 사람이 알아보기 쉬운 프로그래밍 언어로 작성한 코드를 한 줄 씩 즉시 기계어로 번역하는 번역기라고 생각하면 된다.  프로그램 실행 시 한 번에 한 문장씩 번역한다.  한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.  컴파일러와 같은 오브젝트 코드 생성과정이 없기 때문에 메모리 효율이 좋다.  프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있기 때문에 사용성이 문제가 될수 있다Transpile한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것이 트랜스파일이다.ex) typeScript -&gt; javaScript",
        "url": "//others/2024/05/23/Others-series-Compile-vs-Transpile-vs-interpreter.html"
      }
      ,
    
      "others-2024-05-23-others-series-cache-strategy-html": {
        "title": "[others Series] Cache Strategy",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Caching  프로젝트에서 Redis로 캐싱 전 찾아본캐싱 전략캐싱 전략은 웹 서비스에서 시스템 향상을 기대할 수 있는 중요 기술이다.기본 지식  cache hit : 캐시 스토어에 데이터가 있는 경우  cache miss : 캐시 스토어에 데이터가 없을 경우주요 고려 사항캐시를 사용하면 데이터 정합성 문제가 발생한다. 따라서 적절한 캐시 읽기 전략(Read Cache Strategy)과 캐시 쓰기 전략(Write Cache Strategy)으로 데이터 불일치 문제를 극복하면서 성능 또한 잡아야 한다.캐시 읽기 전략( Read Cache Strategy )1. Look Aside특징  Cache Aside 패턴  데이터를 찾을 때 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인 없으면 DB에서 조회  반복적 읽기가 많은 호출에 적합  캐시, DB가 분리되어 가용. 원하는 데이터만 별도로 구성하여 캐시에 저장  캐시, DB가 분리되어 있어 캐시 장애에 대응 가능  Cache Store, Data Store 간의 정합성 유지 문지가 발생할 수 있다.  초기 조회시 DB를 무조건 조회해야 하므로 단건 호출 빈도가 높은 서비스에서는 적합하지 않다. 대신 반복적으로 동일 쿼리를 호출하는 경우 좋다.  [Cache Warming]미리 Cache로 DB 데이터를 밀어 넣는 작업. 이 작업을 하지 않으면 초기 트래픽 증가 시 cache miss가 발생해서 부하가 급장할 수 있다.expire되면 Thundering Herd가 발생할 수 있으므로 TTL 조정이 필요하다.  [Thundering Herd]캐시 데이터가 휘발됐을 때 다수의 프로세스가 하나의 이벤트를 기다리며 Waiting에 있다 해당 이벤트가 발생했을 때 모든 프로세스들이 동시에wake-up하며 자원을 낭비할 때 발생  -&gt; 동일한 많은 요청이 들어왔을 때 하나의 Cache miss만 원본 서버에 요청하고 나머지 요청은 잠시 대기 시킨 후, 응답이 오면 그 응답을 반환하게 하는 방법으로 해결 가능2. Read through 패턴특징  캐시에서만 데이터를 읽어오는 전략 (inline cache)  Look Aside와 비슷하지만 데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임하는 방식  데이터 조회 속도가 전체적으로 느림  데이터 조회를 전적으로 캐시에만 의지하므로 캐시 서버가 다운되면 서비스 이용에 문제가 생길 수 있음  위 문제는 Redis를 replication 또는 Cluster 구성으로 극복할 수 있다.  캐시, DB 간 데이터 동기화가 항상 이뤄져서 정합성 문제에서 자유로움  읽기가 많은 워크로드에 적합  Cache Aside와 비슷하지만 CacheStore 저장 주체가 Server냐, DataStore이냐 차이캐시 쓰기 전략 (Write Cache Strategy)1, Write Back특정  Write Behind 패턴이라고도 불린다.  캐시오 DB 동기화를 비동기하기 떄문에 동기화 전략이 생략  데이터를 저장할 떄 DB에 바로 쿼리하지 않고 캐시에 모아서 일정 주기 배치 작업을 통해서 진행  캐시에 모아놨다 한 번에 쓰므로 쓰기 쿼리 비용을 줄일 수 있음  Write가 빈번하면서 Read하는데 많은 양의 Resource가 소모되는 서비스에 적합  데이터 정합성 확보  자주 사용되지 않은 불필요한 리소스 저장  캐시에서 오류가 생기면 데이터를 영구 소실  Write back 방식은 DB가 아니라 캐시에 먼저 저장하여 Queue로 사용하고, 특정 시점마다 DB로 flush 하는 방식이다.  DB에 장애가 생겨도 캐시가 살아있으면 서비스를 계속할 수 있음2. Write Through 패턴특징  DB와 Cache에 동시에 데이터를 저장  데이터를 저장할 때 캐시에 먼저 저장하고 DB로 바로 저장  Read Through와 마찬가지로 DB 동기화를 캐시에 위임  DB와 캐시가 항상 동기화 되어 있어, 캐시 상테는 항상 최신  캐시와 백업 저장소 업데이트를 같이 해서 데이터 일관성을 유지할 수 있으서 안정적이다.  데이터 유실이 발생하면 안되는 곳에 사용  자주 사용하지 않는 불필요한 리소스를 저장할 수 있음  빈번한 Write가 생길 수 있음  기억 장치 속도가 느리면 CPU 유휴 시간 증가  캐시에 넣은 데이터를 저장만 하고 사용하지 않을 수도 있다.  WriteThrough, WriteBack 모두 쓰지 않은 데이터를 저장하며, 리소스 낭비를 줄이기 위해서 TTL을 설정해야 한다.3. Write Around특징  Write Through보다 빠름  모든 데이터는 DB에 저장  Cache miss가 발생하면 DB와 캐시에도 데이터를 저장  DB, Cache 간 데이터 정합성에 문제가 있을 수 있캐시 읽기 + 쓰기 조합1. Look Aside + Write AroundRead는 (Cache || DB) -&gt; ( hit - cache / miss - DB ) + Write는 DB로2. Read Through + Write AroundRead는 Cache (hit -&gt; cache / miss -&gt; 캐시가 DB에서 당겨옴 ) + Write는 DB에(항상 DB에 쓰고 읽을 때 DB에서 읽어오므로)3. Read Through + Write ThroughRead는 Cache (hit -&gt; cache / miss -&gt; 캐시가 DB에서 당겨옴 ) + Write(Cache -&gt; DB)저장 방식 지침  자주 사용되면서 자주 변경되지 않는 데이터를 캐싱한다.  캐시는 휘발성을 가져야 한다. ( 어느 정도 데이터 수집과 저장 주기를 가지도록 설계 해야 한다. )  데이터 유실, 정합성이 꺠질 수 있으므로 중요한 정보, 민감한 정보는 캐싱하지 않는 방향으로 한다.  파레토의 법칙 ( 8 : 2 법칙 )전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상삭제 방식 지침  영구 저장소 복사본으로 동작하므로 데이터 동기화가 필요하다.  캐시 구성에 만료 정책을 정해야 한다.Cache Stampede 현상대규모 트래픽에서 TTL을 너무 작게 하면 Key Expire 순간, 여러 프로세스가 Key를 조회하면 DB로 Duplicated read를 한다.또 읽어온 값을 Redis에 Duplciate Write하는 경우도 발생할 수 있다. 따라서 쓸데 없는 작업을 수반하는 현상을 의미한다.캐시 가용성캐시 구성하는 목적은 빠른 성능 확보와 데이터 전달에 있다.",
        "url": "//others/2024/05/23/Others-series-Cache-strategy.html"
      }
      ,
    
      "others-2024-05-23-others-series-cicd-html": {
        "title": "[others Series] Cicd",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CI/CDCI/CDCI(Continuous Integration)CI/CD의 “CI”는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미한다.CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로,여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있다.CD (Continuous Delivery / Deployment)CI/CD의 “CD”는 지속적인 서비스 제공(Continuous Delivery) 및/또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용된다.두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.Continuous Delivery이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리(예: GitHub 또는 컨테이너 레지스트리)에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 리포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다.이는 개발팀과 비즈니스팀 간의 가시성과 커뮤니케이션 부족 문제를 해결해 준다.지속적인 제공은 귀찮은 push 작업없이 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 한다.Continuous Deployment란 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미한다.이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결한다.지속적인 배포는 파이프라인의 다음 단계를 자동화함으로써 지속적인 제공이 가진 장점을 활용한다.장점  변경 사항을 자주 푸시하고자 하는 개발자와 안정적인 애플리케이션을 원하는 운영 담당자 사이의 마찰을 해결한다.  코드 변경을 사용자에게 푸시하기 전에 검증하기 위해 개발 팀은 지속적인 테스트를 실행해야 한다.  큰 변경보다 안정적으로 통합 및 테스트가 가능한 더 작은 규모의 증분적 코드 변경을 수행하도록 개발자를 독려한다.  새로운 기능을 위한 더 넓은 범위의 개발 작업을 수행하는 동시에 신속한 수정 요청까지 받는 팀에 작업의 유연성을 부여한다.  기능, 성능 및 데이터 중심 테스트를 더 많이 실행해서 더 높은 품질의 애플리케이션을 제공하고 프로덕션 결함을 줄일 수 있게 해준다.파이프라인컴퓨터 과학에서 데이터 파이프 라인 (일반적으로 파이프 라인이라고 함)은 제공된 데이터 또는 코드에 대해 사전 정의 된 작업을 수행하는 일련의 처리 단계다.파이프 라인 사용의 목적은 반복적 인 프로세스를 자동화하여 시간을 절약하고 정밀도를 높이는 것이다.파이프 라인의 이러한 장점은 CI / CD 인프라와의 호환성과 효율성을 높여준다. 특히 CI / CD 파이프 라인은 최신 버전의 소프트웨어 애플리케이션을 업데이트하고 제공하려는 일련의 처리 단계를 수행할 수 있다.구성 요소  빌드 (소프트웨어 컴파일),  테스트 (호환성 및 오류 검사)  릴리스 (버전 제어 저장소의 애플리케이션 업데이트)  배포 (개발에서 프로덕션 환경으로의 변환)  규정 준수 및 유효성 검사",
        "url": "//others/2024/05/23/Others-series-CICD.html"
      }
      ,
    
      "others-2024-05-23-others-series-authentication-and-authorization-html": {
        "title": "[others Series] Authentication And Authorization",
        "tags": "",
        "date": "May 23, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Authentication vs. AuthorizationAuthentication vs. Authorization  인증(Authentication) : 본인이 누구인지 확인 (로그인)  승인(Authorization) : 특정 리소스에 권한이 있는지 확인 (등급 권한)                   인증 (Authentication)      인가 (Authorization)                  기능      자격 증명 확인      권한 허가/거부              진행 방식      비밀번호, 생체인식, 일회용 핀 또는 앱      보안 팀에서 관리하는 설정 사용              사용자가 볼 수 있는가?      예      아니오              사용자가 직접 변경할 수 있는가?      부분적으로 가능      불가능              데이터 전송      ID 토큰 사용      액세스 토큰 사용      ",
        "url": "//others/2024/05/23/Others-series-Authentication-and-Authorization.html"
      }
      ,
    
      "test-2024-05-22-test-series-02-mockito-html": {
        "title": "[test Series] 02 Mockito",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - MockitoMockito직접 제어할 수 있는 가짜 객체를 지원하는 테스트 프레임워크다.  mocking          @Mock : 가짜 객체를 반환해주는 어노테이션      @Spy : Stub하지 @Mock과 비슷하지만 실제 객체를 할당하는 어노테이션      @InjectMocks: @Mock, @Spy를 자동으로 주입시키는 어노테이션        Stub가짜 객체를 주입했을 때 원하는 동작을 오버라이딩하기 위해서          doReturn()      doNothing()      doThrow()를 사용할 수 있다.      ",
        "url": "//test/2024/05/22/test-series-02-Mockito.html"
      }
      ,
    
      "test-2024-05-22-test-series-01-bdd-html": {
        "title": "[test Series] 01 Bdd",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BDDBDD(Behavior-Driven Development)시나리오를 기반으로 테스트하는 패턴을 의마한다.  given : 시나리오 진행에 필요한 조건을 미리 설정해두는 단계  when : 시나리오를 진행 시 필요한 변화를 명시(mocking/ stubbing)  Then : 예상되는 결과BDDMockitowhen().thenReturn();  메소드를 실제 호출하지만 리턴 값을 정의할 수 있다.  메소드 작업이 오래 걸린다면 끝까지 기다려야 한다.  실제 메소드를 호출하기에 호출 대상이 문제가 있으면 안된다.doReturn().when();  실제 메소드 호출하지 않으면서 리턴 값을 정의할 수 있다.  실제 메소드 호출하지 않기 때문에 호출 대상의 문제 여부는 확인할 수 없다.  void 리턴 메소드 stubbing 가능",
        "url": "//test/2024/05/22/test-series-01-BDD.html"
      }
      ,
    
      "network-2024-05-22-nginx-series-01-reverseproxy-html": {
        "title": "[nginx Series] 01 Reverseproxy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - NginxNginx 기본 + ReverseProxyReverseProxy에 대한 기본 내용 참조 Configserver {    listen 80;    server_name www.example.com;## 띄어쓰기 민감한 편    if ($http_x_forwarded_proto = 'http'){            return 301 https://$host$request_uri;    }}server {    listen 443;    server_name www.example.com;    root /{rootPath};    index index.html;        location /api {        proxy_pass http://localhost:8080;    }}Syntaxnginx -t 로 syntax 점검을 받을 수도 있다.",
        "url": "//network/2024/05/22/nginx-series-01-ReverseProxy.html"
      }
      ,
    
      "network-2024-05-22-network-series-02-tls-html": {
        "title": "[network Series] 02 Tls",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TLSTLS(Transport Layer Security)TLS 란전송 계층 보안(TLS)은 인터넷 상의 커뮤니케이션을 위한 개인 정보와 데이터 보안을 용이하게 하기 위해 설계되어 널리 채택된 보안 프로토콜입니다.TLS의 주요 사용 사례는 웹 사이트를 로드하는 웹 브라우저와 같이 웹 응용 프로그램과 서버 간의 커뮤니케이션을 암호화하는 것입니다.어떤 일을 하는가?  암호화 : 제3자로부터 전송되는 데이터를 숨깁니다.  인증 : 정보를 교환하는 당사자가 요청된 당사자임을 보장합니다.  무결성 : 데이터가 위조되거나 변조되지 않았는지 확인합니다.TLS vs. SSLTLS는 Netscape가 개발한 SSL(Secure Sockets Layer)이라고 불리는 이전의 암호화 프로토콜에서 발전한 것입니다. TLS 버전 1.0은 SSL 버전 3.1로서 개발을 시작했지만 Netscape와 더 이상 연관이 없음을 명시하기 위해서 발표 전에 프로토콜의 이름이 변경되었습니다.이러한 역사 때문에 용어 TLS와 SSL은 가끔 서로 바꿔서 사용됩니다.TLS vs. HTTPSHTTPS는 HTTP 프로토콜 상위에서 TLS 암호화를 구현한 것으로 모든 웹 사이트와 다른 웹 서비스에서 사용됩니다. 따라서 HTTPS를 사용하는 웹 사이트는 TLS 암호화를 이용합니다.TLS 인증서란웹 사이트나 응용 프로그램이 TLS를 사용하기 위해서는 원본 서버에 TLS 인증서가 설치되어 있어야 합니다(위에서 설명한 이름 혼동 때문에 이 인증서는 “SSL 인증서”라고도 알려져 있습니다).인증 기관이 도메인을 소유한 사람 혹은 비즈니스에게 TLS 인증서를 발행합니다.인증서는 서버의 공개 키와 더불어 누가 도메인 소유자인지에 대한 중요한 정보를 포함하며, 이 두 가지는 모두 서버의 신원을 확인하는 데 중요합니다.어떤 과정으로 작동하는가?TLS 연결은 TLS Handshake로 알려진 일련의 순서를 사용하여 초기화됩니다.사용자가 TLS를 사용하는 웹 사이트를 돌아다니면 사용자 장치(클라이언트 장치로도 알려짐)와 웹 서버 간에 TLS Handshake가 시작됩니다.TLS Handshake 동안 사용자 장치와 웹 서버는 다음과 같은 일을 수행합니다.  사용할 TLS 버전(TLS 1.0, 1.2, 1.3 등)을 지정합니다  사용할 암호 제품군(아래 참고)을 결정합니다  서버의 TLS 인증서를 사용하여 서버의 신원을 인증합니다.  Handshake가 완료된 후 키 간의 메시지를 암호화하기 위한 세션 키를 생성합니다.TLS Handshake는 각 커뮤니케이션 세션을 위한 암호 제품군을 구축합니다.암호 제품군은 공유된 암호화 키 또는 세션 키와 같은 세부 정보를 명시하는 알고리즘 집합으로 해당 특정 세션에 사용됩니다. 공개 키 암호화로 알려진 기술 덕분에 TLS는 암호화되지 않은 채널을 통해 일치하는 세션 키를 설정할 수 있습니다.Handshake는 또한 인증을 처리하며, 이는 대개 클라이언트에게 신원을 증명하는 서버로 구성됩니다.이는 공개 키를 사용하여 수행됩니다. 공개 키는 단방향 암호화를 사용하는 암호화 키로,공개 키를 가진 누구나 신뢰성을 보장하기 위해 서버의 개인 키로 암호화된 데이터를 해독할 수 있음을 의미하지만 원래 발신자만 개인 키를 사용해 데이터를 암호화할 수 있습니다.서버의 공개 키는 TLS 인증서의 일부입니다.데이터카 암호화되고 인증되고 나면, 메시지 인증 코드(MAC)와 함께 서명됩니다. 수신자는 데이터의 무결성을 보장하기 위해 MAC를 확인할 수 있습니다. 이는 아스피린 병에서 발견할 수 있는 일종의 부정 조작 방지 포장과 같은 것입니다. 소비자는 구매할 때 포장이 손상되지 않았으면 아무도 약에 손대지 않았다는 것을 알 수 있습니다.TLS가 미치는 영향TLS의 최신 버전은 웹 응용 프로그램 성능에 거의 영향을 미치지 않습니다.TLS 연결을 설정하는 데 수반되는 복잡한 프로세스 때문에 로드 시간과 계산 능력이 소모되어야 합니다. 데이터가 전송되기 전에 클라이언트와 서버는 왔다 갔다 몇 번 커뮤니케이션해야 하며, 이는 클라이언트와 서버 모두를 위한 메모리뿐만 아니라 웹 응용 프로그램을 위한 귀중한 밀리세컨드의 로딩 시간을 소모합니다.그러나 대신에 TLS Handshake가 생성한 잠재적인 지연을 완화하는 것을 돕는 기술이 있습니다. 하나는 TLS Handshake가 완료되기 전에 서버와 클라이언트가 데이터 전송을 시작하도록 하는 TLS False Start입니다.TLS를 빠르게 하기 위한 또 다른 기술은 이전에 커뮤니케이션한 적이 있는 서버와 클라이언트가 간략화된 Handshake를 사용하도록 허용하는 TLS Session Resumption입니다.이러한 개선 사항은 TLS를 로딩 시간에 현저하게 영향을 미쳐서는 안 되는 매우 빠른 프로토콜로 만드는 데 도움을 주었습니다. TLS와 연관된 계산 비용은 오늘날 표준에 따르면 거의 무시해도 좋은 정도입니다.2018년에 발표된 TLS 1.3은 TLS를 더 빠르게 만들었습니다. TLS 1.3의 TLS Handshake는 몇 밀리세컨드로 프로세스를 단축하며 2회 왕복 대신 1회 왕복(또는 왔다 갔다하는 커뮤니케이션)만을 요구합니다.사용자가 전에 웹 사이트에 연결한 적이 있으면, TLS Handshake는 0회 왕복을 할 수 있으며, 이는 속도를 더 빠르게 할 수 있습니다.https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/https://en.wikipedia.org/wiki/Transport_Layer_Security",
        "url": "//network/2024/05/22/network-series-02-TLS.html"
      }
      ,
    
      "network-2024-05-22-network-series-01-subnet-html": {
        "title": "[network Series] 01 Subnet",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - IPIPv4, IPv6IPv4####.####.####.###0 ~ 255 (2^8)으로 구성되며4옥텟으로 구분되는 형식을 `IPv4`라고 한다.총 32비트의 주소 공간을 제공한다.    192   .    168   .     0    .    1 11000000 . 10101000 . 00000000 . 00000001|--------|                       |--------|8비트(=1바이트)                     옥텟(Octet)|-----------------------------------------|      IPv4 주소 : 8비트 * 4 = 32비트(4바이트)      IPv6IPv6의 128비트 주소공간은 다음과 같이 16비트(2옥텟)를 16진수로 표현하여8자리로 나타낸다.(8옥텟)2001:0db8:85a3:08d3:1319:8a2e:0370:7334러나 대부분의 자리가 0의 숫자를 갖게 되므로, 0000을 하나의 0으로 축약하거나,혹은 아예 연속되는 0의 그룹을 없애고 ':' 만을 남길 수 있다.따라서 아래의 IPv6 주소들은 모두 같은 주소를 나타낸다.2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0000:0000:0000::1428:57ab2001:0DB8:0:0:0:0:1428:57ab2001:0DB8:0::0:1428:57ab2001:0DB8::1428:57ab특수 주소 공간::/128 - 이 주소는 모든 값을 0으로 설정한 특수한 주소이다. 가상적으로만 사용된다. IP 미설정 상태의 발신 주소이다..::1/128 - 자기 자신의 주소를 가리키는 루프백 주소이다. 프로그램에서 이 주소로 패킷을 전송하면 네트워크는 전송자에게로 패킷을 반송한다. IPv4의 127.0.0.1 주소와 동일하다.::/96 - IPv4 호환 주소를 위해 사용되는 주소공간이다.::ffff:0:0/96 - IPv4 매핑 주소를 위해 사용되는 주소공간이다.fc00::/7 - IPv6 유니캐스트를 위한 주소공간이다.fe80::/10 - link-local address를 위한 주소공간이다. IPv4의 자동 설정 IP 주소인 169.254.x.x 에 해당한다.fec0::/10 - site-local address를 위한 주소공간이다. 네트워크 내부에서만 유효한 주소이며, 2004년 10월 RFC3879에서 폐기되어 더 이상 사용되지 않는다.ff00::/8 - IPv6 멀티캐스트를 위한 주소공간이다. IPv4의 브로드캐스트는 더 이상 지원되지 않으며, IPv6에서는 대신 멀티캐스트를 사용해야 한다.네트워크주소와 호스트주소IP 주소는 네트워크 주소와 호스트 주소 두 부분으로 나뉘게 됩니다.네트워크 주소는 호스트(단말)들을 모은 네트워크를 지칭하는 주소를 뜻합니다.네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 합니다.호스트 주소는 하나의 네트워크 내에 존재하는 호스트(단말)를 구분하기 위한 주소를 뜻합니다.그런데 IP 주소에서 네트워크 주소와 호스트 주소를 구분하는 경계점이 고정되어있지 않습니다.그렇다보니 필요한 호스트 IP 개수에 따라 네트워크의 크기를 다르게 할당할 수 있도록 클래스 라는 개념을 도입했는데요.클래스는 A, B, C, D, E 클래스가 존재하며 각각의 클래스에 할당되는 IP 주소 갯수와 역할이 다릅니다.A 클래스 -&gt; 네트워크.호스트.호스트.호스트B 클래스 -&gt; 네트워크.네트워크.호스트.호스트C 클래스 -&gt; 네트워크.네트워크.네트워크.호스트A 클래스 -&gt; 1~127.0.0.0 (로컬호스트)B 클래스 -&gt; 128~191.0.0.0C 클래스 -&gt; 192~223.0.0.0D 클래스 -&gt; 224~239.0.0.0중요한 점은 클래스 기반으로는 사용하지 않는다는 점이다.클래스 기반보다 네트워크 주소를 세밀하게 분할하고 할당하기위해서 네트워크 크기에 맞춰 1비트 단위로 네트워크를 상세히 분할하는 방법을 사용하는데요.클래스 개념 자체를 버리는 클래스리스(Classless) 기반의 주소 체계를 사용합니다.클래스 리스클래스리스에서는 구분자가 필요한데 이를 서브넷 마스크(Subnet Mask)라고 합니다.넷 마스크는 IP주소를 네트워크 포션 / 호스트 포션으로 나누는데 사용되는 숫자 조합입니다. 서브넷 마스크는 IP 주소와 같은 길이의 비트로 구성되며,이진수(Binary)로 표현했을 때 네트워크 포션은 1로, 호스트 포션은 0으로 설정됩니다.즉, 가령 210.100.100.1의 서브넷 마스크가 255.255.255.0이라면,255.255.255.0은 1111 1111. 1111 1111. 1111 1111. 0000 0000과 같습니다.여기서 1인 부분은 네트워크를, 0인 부분은 해당 네트워크 내에 속해있는 호스트를 나타내므로 IP주소와 서브넷 마스크를 논리적 AND 연산 결과 값이 바로 서브넷이 됩니다. 하나의 주소를 서브넷 마스크를 씌워서 작은 네트워크로 만드는 것을 서브넷팅(Subnetting)이라고 합니다.210.100.100.1\t=\t1101 0010. 0110 0100. 0110 0100. 0000 0001\t=\tIP주소255.255.255.0\t=\t1111 1111. 1111 1111. 1111 1111. 0000 0000\t=\t서브넷 마스크210.100.100.0\t=\t1101 0010. 0110 0100. 0110 0100. 0000 0000\t=\t서브넷 (AND 연산 결과)이러면 호스트와 네트워크의 경계를 알 수 있다.출처: medium.com출처: tistory.com표기법일반적인 표기법으로는 CIDR 표기법이 사용되며, IP 주소 뒤에 슬래시와 비트 수를 숫자로 표기합니다. 예를 들어, 192.168.0.0/24와 같이 나타낼 수 있으며,이 표기법에서 192.168.0.0은 네트워크 ID를 의미하고,/24는 서브넷 마스크의 길이를 나타냅니다. 24비트 서브넷 마스크는 첫 24비트가 네트워크 ID이고 나머지 8비트가 호스트 ID임을 의미합니다.따라서 192.168.0.0/24는 192.168.0.0부터 192.168.0.255 까지의 IP 주소 범위를 나타냅니다. 여기서 네트워크 ID와 브로드캐스트 주소를 제외하고실제로 호스트에 할당할 수 있는 IP 주소의 범위는 192.168.0.1 ~ 192.168.0.254가 됩니다.본론그래서 ip/32, ip/24는 무엇인가?IP 주소의 범위를 표현하기 위한 방식이다. 이진수 몇 자리까지 고정값으로 두는지에 대한 정의다.            Subnet      Subnet Mask (Dec)      Host 수                  /8      255.0.0.0      16,777,216              /9      255.128.0.0      8,388,608              /10      255.192.0.0      4,194,304              /11      255.224.0.0      2,097,152              /12      255.240.0.0      1,048,576              /13      255.248.0.0      524,288              /14      255.252.0.0      262,144              /15      255.254.0.0      131,072              /16      255.255.0.0      65,536              /17      255.255.128.0      32,768              /18      255.255.192.0      16,384              /19      255.255.224.0      8,192              /20      255.255.240.0      4,096              /21      255.255.248.0      2,048              /22      255.255.252.0      1,024              /23      255.255.254.0      512              /24      255.255.255.0      256              /25      255.255.255.128      128              /26      255.255.255.192      64              /27      255.255.255.224      32              /28      255.255.255.240      16              /29      255.255.255.248      8              /30      255.255.255.252      4              /31      255.255.255.254      2              /32      255.255.255.255      1      ",
        "url": "//network/2024/05/22/network-series-01-Subnet.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-12-date-html": {
        "title": "[mysql Series] 12 Date",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Date날짜 관련set @now := current_timestamp();set @now := '2024-02-01 17:15:34';select @now from dual;select week(@now) - week(date_add(@now, interval - day(@now) + 1 day)) + 1 from dual; -- 달의 몇 째주인지select DAYOFWEEK(@now) from dual; -- 주의 무슨 요일인지 (1 = SUN ~ 7 = SAT )",
        "url": "//mysql/2024/05/22/mysql-series-12-Date.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-11-temporarytable-html": {
        "title": "[mysql Series] 11 Temporarytable",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Temporary tableTemporary Table  트랜잭션 임시테이블 : 같은 트랜잭션 내에서만 데이터 유지  세션 임시테이블 : 같은 세션 내에서 데이터 유지",
        "url": "//mysql/2024/05/22/mysql-series-11-TemporaryTable.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-10-cursor-record-collection-html": {
        "title": "[mysql Series] 10 Cursor_record_collection",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Cursor/ Record/ CollectionCursor/ Record/ Collection커서1. 커서란특정 SQL 문장을 처리하 결과를 담고 있는 영역(PRIVATE SQL이라는 메모리)을 가리키고 일종의 포인터종류는 묵시/ 명시적 커서가 있다. 묵시적 커서는 오라클 내부에서 자동으로 생성되어 사용하는 커서이다. 반대로 사용자가 직접 정의해서 사용하는 커서를 명시적 커서라고 한다.a. 명시적 커서DECLARE vn_department_id emplyees.departmnet_id%TYPE := 80;BEGIN  UPDATE emplyess SET emp_name = emp_name where department_id = vn_department_id; DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT); -- oracle COMMIT;END묵시적 커서 속성            속성명      설명                  SQL%FOUND      결과 집합의 패치 로우 수가 1 이상이면 TRUE              SQL%NOTFOUND      결과 집합의 패치 로우 수가 0이면 TRUE              SQL%ROWCOUNT      영향 받은 결과 집합의 로우 수 반환, 없으면 0              SQL%ISOPEN      묵시적 커서는 항상 FALSE 반환( 이 속성으로 참조할 때는 이미 묵시적 커서는 닫힌 상태 )      b.명시적 커서커서 선언 - 커서 열기 - 패치 단게에서 커서 사용 - 커서 닫기      커서 선언    묵시적 커서와 달리 명시적 커서는 선언해야 한다. 명시적 커서는 결과 데이터 집합을 로우별로 참조하는 용도이므로 SELECT 문을 사용할 것이다.     CURSOR 커서명 [(매개변수1, ...2)]      IS SELECT ...;        커서 열기     OPEN 커서명 [(매개변수1, ...2)];        패치에서 커서 사용     LOOP  FETCH 커서명 INTO 변수 1, ...;  EXIT WEHN 커서명%NOTFOUND; END LOOP;        커서 닫기     CLOSE 커서명;        ex)     FOR record IN cursorName (매개변수)     LOOP         executtion;     END LOOP;      2. 커서 변수명시적 커서의 이름은 상수이다. 한 번 할당하면 다른 값으로 바꿀 수 없다. 대신 커서 변수라는 것이 있다.  한 개 이상의 쿼리를 연결해서 사용할 수 있다.  변수처럼 커서 변수를 함수나 프로시저의 매개변수로 전달할 수 있다.  커서 속성을 사용할 수 있다.  커셔 변수 선언          참조용 커서 타입을 생성하고 선언        TYPE 커서 타입명 IS REF CUSOR [RETURN 반환타입];커서 변수명 커서 타입명;                          RETURN을 생략하면 약한 커서 타입/ 반대는 강한 커서 타입이라고 한다.            TYPE dep_curtype IS REF CURSOR RETURN departments%ROWTYPE;TYPE dep_curtype IS REF CURSOR;                                          커서 변수 사용 (커서 변수와 쿼리문 연결)        OPEN 커서변수명 FOR select 문; (강한 타입은 RETURN 타입과 맞춰야한다. )                    커서 변수에서 결과 집합 가져오기        FETCH 커서 변수명 INTO 변수1, 변수2...;FETCH 커서 변수명 INTO 레코드명; (한 row만)                    커서 변수를 매개변수로 전달 : 커서도 변수이므로 함수/ 프로시저의 매개변수로 전달할 수 있다.      커서 표현식SELECT 문에 컬럼 형태로 커서를 사용하는 것이다.SELECT (        SELECT department_name         FROM departments d         WHERE e.department_id = d.department_id        ) AS dep_name,        e.emp_nameFROM employees eWHERE e.department_id = 90;레코드PL/SQL에서 제공하는 데이터 타입 중 하나로, 문자형, 숫자형 같은 기본 빌트인 타입과 달리 복합형 구조이다. 일반 빌트인 타입으로 변수를 선언하면해당 변수는 한 번에 하나의 값만 가질 수 있지만, 레코드는 여러 개의 값을 가질 수 있다.레코드는 선언 방식에 따라 커서형, 사용자 정의형, 테이블형 레코드로 나눌 수 있다.  사용자 정의형 : 테이블과 비슷한 구조인데 테이블의 컬럼에 해당하는 것을 필드라고 한다. TYPE 레코드명 IS RECORD (     field1_Name field1_Type [[NOT NULL] := defaultValue],     field2_Name field2_Type [[NOT NULL] := defaultValue], );       recordVariable recordName;         DECLARE         TYPE depart_rect IS RECORD (          department_id NUMBER(6),          department_name VARCHAR2(80)      )             vr_dep departRect;   BEGIN    ...   END;  테이블형 레코드 : 특정 테이블의 컬럼 값을 받아오는 변수를 선언할 때 사용할 수 있다.-- 컬럼 값을 받아오는 변수 선언    변수명 테이블명.컬럼명%TYPE;        -- 테이블의 모든 컬럼을 받아 사용하는 레코드    레코드 변수명 테이블명.%ROWTYPE;          DECLARE    vr_dep departments%ROWTYPE;  BEGIN     SELECT * INTO vr_dep     FROM departments    WHERE department_id = 20;    INSERT INTO ch11_dep2 values v_dep;    COMMIT;  END;  커서형 레코드 : 커서를 레코드 변수르 받는 것을 커서형 레코드라고 한다.   DECLARE   CURSOR c1 IS   SELECT department_id, department_name, parent_id, manager_id   FROM departments;   vr_dep c1%ROWTYPE;          BEGIN         DELETE ch11_dep;                OPEN c1;                LOOP            FETCH c1 INTO vr_dep;            EXIT WHEN c1%NOTFOUND;            INSERT INTO ch11_dep VALUES vr_dep;        END LOOP;                    COMMIT;   END;",
        "url": "//mysql/2024/05/22/mysql-series-10-Cursor_Record_Collection.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-09-exception-transaction-html": {
        "title": "[mysql Series] 09 Exception_transaction",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Exception and TransactionException/ Transaction예외처리EXCEPTION WHEN exception1 THEN handling1          WHEN expeption2 THEN handling2          WHEN   OTHERS   THEN handling트랜잭션특정 테이블에서 데이터를 읽어 조작 후 다른 테이블에 입력하거나 갱신, 삭제하는데 처리 도중 오류가 발생하면 모든 작업을 원상태로 되돌리고, 처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영하는 것이 트랜잭션 처리이다.COMMIT; -- (INSERT, UPDATE, DELETE, MERGE한 결과가 commit 하지 않으면 반영되지 않는다.)ROLLBACK; -- [WORK] [TO [SAVEPOINT] savepointName];SAVEPOINT name; -- 트랜잭션 취소 지점을 지정할 수 있다.",
        "url": "//mysql/2024/05/22/mysql-series-09-Exception_Transaction.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-08-pl-sql-html": {
        "title": "[mysql Series] 08 Pl_sql",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - PL/SQLPL/SQL블록PL/SQL 소스 프로그램의 기본 단위, 선언부, 실행부, 예외처리부로 구성된다. 이 블록은 다시 이름이 없는 블록, 이름이 있는 블록으로 구분할 수 있는데 전자는 익명 블록이고 함수, 프로시저, 패키지 등이 후자에 속한다.    NAMEING : 생략하면 익명 블록IS (AS)    DECLARATION : 각종 변수, 상수, 커서 등을 선언한다. 반드시 ;로 끝나야한다.     ex) 변수명 데이터 타입 := 초깃값;    ex) 상수명 CONSTANT 데이터타입 := 상수값;BEGIN    EXECUTION : 실제 로직 처리부 DML만 사용 가능EXCEPTION    EXCEPTIONS : 로직 처리 중 문제가 발생하면 처리할 내용을 기술하는 부분이다.END;제어문IFIF 조건 THEN   처리 ;END IF;     --IF 조건 THEN   처리 1;ELSE   처리 2; END IF;    --IF 조건 1 THEN   처리 1;ELSIF 조건 2 THEN   처리 2;ELSE    처리 3; END IF;CASECASE 표현식    WHEN 결과 1 THEN         처리 1;    WHEN 결과2 THEN         처리 2;     ...    ELSE         기타 처리; END CASE;LOOPLOOP    처리 ;    EXIT [WHEN 종료 조건];END LOOP;WHILEWHILE 조건LOOP    처리문;END LOOP;FORFOR 인덱스( 카운트 변수 ) IN [REVERSE] 초기..최종LOOP    처리문;END LOOP;CONTINUE, GOTOCONTINUE WHEN 조건으로 로직을 건너뛸 수 있다.GOTO로 흐름을 변경할 수 있다. ex) «third»     ….로직    GOTO third;NULL문ELSE NULL로 아무것도 하지 않고 넘어가도록 할 수도 있다. (if-else/ case-when-then 모두)IF condition1    LOGIC1;ELSIF condition2    LOGIC2;ELSE NULL;END IF;함수사용자가 직접 로직을 구현하는 사용자 정의 함수(내장 함수와 비교해서)CREATE OR REPLACE FUNCTION functionName (parameter)RETURN returnType;IS[AS]    variables, constantsBEGIN     executions    RETURN returnValue;    EXCEPTION        failOverLogicsEND;        functionName(val1...)프로시저함수는 특정 연산을 수행한 뒤 결과 값을 반환하지만, 프로시저는 특정한 로직을 처리하기만 하고 결과 값을 반환하지 않는 서브 프로그램이다.CREATE OR REPLACE PROCEDURE procedureName ( parameter IN | OUT | INOUT datatype [:= defaultValue], ...)IS[AS]    variables, constans..BEGIN    executions    RETURN returnValue;EXCEPTION        failOverLogicsEND;    EXECUTE procedureName(param..)",
        "url": "//mysql/2024/05/22/mysql-series-08-PL_SQL.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-07-subquery-html": {
        "title": "[mysql Series] 07 Subquery",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SubquerySubQuerySQL 문장 안에서 보조로 사용되는 또 다른 SELECT문을 의미한다.  메인 쿼리와의 연관성에 따라          연관성 없는 (Noncorrelated) 서브쿼리 : 메인 테이블과 조인 조건이 걸리지 않는 경우      연관성이 있는 서브 쿼리  : 메인 테이블과 연관성이 있는 서브 쿼리 ( 세미 조인 )        형태에 따라          일반 서브 쿼리( SELECT )      인라인뷰 ( FROM )      중첩 쿼리 ( WHERE )      서브쿼리가 너무 복잡해진다면 WITH 절로 가상테이블을 만들어서 처리할 수도 있다.SELECT b.*FROM (        SELECT * FROM kor_loan_status     ) b;-- WITH 사용WITH b AS (   SELECT * FROM kor_loan_status  );SELECT b.* FROM b;               ",
        "url": "//mysql/2024/05/22/mysql-series-07-SubQuery.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-06-join-html": {
        "title": "[mysql Series] 06 Join",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JoinJoin종류  조인 연산자에 따른 분류 : 동등 조인, 안티 조인  조인 대상에 따른 구분 : 셀프 조인  조인 조건에 따른 분류 : 내부 조인, 외부 조인, 세미 조인, 카타시안 조인  기타 : ANSI 조인외부 조인 / 내부 조인  동등 조인    SELECT a.* FROM A_TABLE a, B_TABLE b WHERE a.id = b.id;        세미 조인 : 서브 쿼리를 사용해서 서브 쿼리에 존재하는 데이터만 메인쿼리에서 추출하는 조인 (Join 없이 서브쿼리 + 조건으로 )    -- EXISTS 사용SELECT a.* FROM A_TABLE a WHERE EXISTS ( SELECT *  FROM B_TABLE b WHERE a.id = b.id AND [condition]);-- IN 사용SELECT a.* FROM A_TABLE a WHERE a.id IN ( SELECT b.id FROM B_TABLE b WHERE [condition]);        안티 조인 : A에서 B에 없는 요소만 추출  셀프 조인 : 동일한 테이블끼리 조인하는 방법  외부 조인 : 한 테이블을 기준으로 다른 테이블 값이 NULL이라도 추출하는 것  카티시안 조인 WHERE에 조건이 없는 조인 (모든 경우의 수, 카티시안 곱)  ANSI : join … on",
        "url": "//mysql/2024/05/22/mysql-series-06-Join.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-05-function-html": {
        "title": "[mysql Series] 05 Function",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Function함수숫자 관련 함수  ABS  CEIL / FLOOR  ROUND(n, i) / TRUNC(n1, n2) : 반올림 / 잘라냄  POWER / SQRT : 제곱 / 제곱근  MOD(n2, n1) / REMAINDER(n2, n1) : n2를 n1으로 나눈 값 / n2를 n1으로 나눈 나머지  EXP(n) / LN(n) / LOG(n2, n1) : e의 n제곱 / 자연 로그 함수로 밑수가 e인 로그 함수 / n2를 밑수로 하는 n1의 로그문자 함수  INITCAP(char), LOWER(char), UPPER(char) : 첫 글자 대문자 / lowerCase / upperCase  CONCAT(char1, char2), SUBSTR(char, pos, len), SUBSTRB(char, pos, len) : 문자 결합 / char의 pos부터 len 길이만큼 잘라냄 / len이 길이가 아닌 문자열 바이트  LTRIM(char, set), RTRIM(char set) : char 문자열에서 set으로 지정된 문자열을 왼쪽 끝에서 제거한 후 반환 / ~ 오른쪽 끝에서  LPAD(expr1, n, expr2), RPAD(expr1, n, expr2) : exp2을 왼/오른쪽부터 n자리만큼 채워 expr1을 반환  REPLACE(char, search_str, replace_str), TRANSLATE(expr, from_str, to_str) : char에서 search_str문자열을 찾아 replace_str로 대체 / REPLACE와 유사하지만 문자열 자체가 아닌 한 글자씩 매핑해 바꾼 결과를 반환  INSTR(str, substr, pos, occur), LENGTH(chr), LENGTHB(chr) : str에서 substr과 일치하는 위치를 반환하는데 pos는 시작 위치로 기본 값은 1, occur은 몇 번째 일치하는지 / LENGTH는 길이 / LENGTHB는 바이트 수날짜 함수  SYSDATE, SYSTIMESTAMP : DATE, TIMESTAMP 형으로 반환  ADD_MONTHS(date, integer)  MONTHS_BETWEEN(date1, date2) : 두 날짜 사이 개월 수  LAST_DAY(date) : date날짜를 기준으로 해당 월의 마지막 일자를 반환  ROUND(date, format), TRUNC(date, format) : format에 반올림한 날짜 / 잘라낸 날짜```sqlSELECT SYSDATE, ROUND(SYSDATE, ‘month’), TRUNC(SYSDATE, ‘month’) FROM DUAL;2023-10-01 22:09:24 | 2023-11-01 00:00:00 | 2023-09-01 00:00:00 |6. NEXT_DAY( date, char ) : date를 char에 명시한 날짜로 다음 주 주중 날짜를 반환(char =&gt; 요일)## 변환 함수1. TO_CHAR(숫자 혹은 날짜, format) : 형식에 맞게 출력2. TO_NUMBER(expr, format) : 문자나 다른 유형의 숫자를 NUMBER형으로 변환3. TO_DATE(char, format), TO_TIMESTAMP(char, format)## NULL 관련 함수1. NVL(expr1, expr2), NVL2(expr1, expr2, expr3) : ifnull2. COALESCE3. NULLIF## 집계함수1. COUNT2. SUM3. AVG4. MIN, MAX, 5. VARIANCE, STDDEV : 분산/ 표준편차### ROLLUP / CUBE1. ROLLUP : 집계 정보를 보여준다.2. CUBE : ROLLUP과 유사하지만 가능한 모든 조합으로 집계한 결과를 반환```sql PERIOD GUBUN TOTAL_JAN------------------------201310  기타대출  676078201310  주택담보  1234201311  기타대출  4423201311  주택담보  1412SELECT period, gubun, SUM(loan_jan_amt) total_jan FROM ~WHERE period LIKE ~GROUP BY ROLLUP(period, gubun);## ROLLUPPERIOD GUBUN TOTAL_JAN------------------------201310  기타대출  1423201310  주택담보  1234201310          2657201311  기타대출  4423201311  주택담보  1412201311          5835SELECT period, gubun, SUM(loan_jan_amt) total_jan FROM ~WHERE period LIKE ~GROUP BY CUBE(period, gubun);## CUBEPERIOD GUBUN TOTAL_JAN------------------------                (전체 합)        기타대출  (기타대출 전체 합)        주택담보  (주택담보 전체 합)201310          2657201310  기타대출  1423201310  주택담보  1234201311          5835201311  기타대출  4423201311  주택담보  1412집합 연산자  UNION : 합집합  UNION_ALL : 중복된 항목도 모두 조회 (합집합 + 교집합)  INTERSECT : 교집합  MINUS : 차집합  제약 사항    1. 집한 연산자 컬럼 개수, 데이터 타입이 일치해야 한다.2. ORDER BY는 맨 마지막 문장에서만 사용 가능3. BLOB, CLOB, BFILE은 집한 연산자 사용이 불가4. UNION, INTERSECT, MINUS는 LONG 형 컬럼에 사용할 수 없다.       GROUPING SETGROUPING SET ( expr1, expr2, expr3 ) ==(GROUP BY expr1    UNION ALLGROUP BY expr2   UNION ALLGROUP BY expr3)",
        "url": "//mysql/2024/05/22/mysql-series-05-Function.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-04-operatorandexpression-html": {
        "title": "[mysql Series] 04 Operatorandexpression",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Operator and Expressions연산자  수식 연산자 : +, -, *, /                              문자 연산자 :                                 논리 연산자 : &gt;, &lt;, &gt;=, &lt;=, =, &lt;&gt;, !=, ^=  집한 연산자 : UNION, UNION ALL, INTERSECT, MINUS표현식한 개 이상의 값과 연산자, SQL 함수 등이 결합된 식CASE WHEN condition1 THEN value1     WHEN condition2 THEN value2        ...        ELSE otherValueEND조건식한 개 이상의 표현식과 논리 연산자가 결합된 식 TRUE/ FALSE/ UNKNOWN 세 가지 타입을 반환한다.비교 조건식논리 연산자나 ANY, SOME, ALL 키워드로 비교하는 조건식NULL 조건식BETWEEN AND 조건식IN 조건식EXIST 조건식LIKE 조건식",
        "url": "//mysql/2024/05/22/mysql-series-04-OperatorAndExpression.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-03-sql-html": {
        "title": "[mysql Series] 03 Sql",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SQLSQL  SELECT  INSERT  UPDATE  MERGE : 조건을 비교해서 테이블에 해당 조건에 맞는 데이터가 없으면 INSERT / 있으면 UPDATE    MERGE INTO [SCHEMA.]tableName USING (update or insert target) ON (update condition)WHEN MATCHED THEN SET (col1 = val1, col2 = val2, ...)WHERE (update condition) DELETE WHERE (update_delete condition)WHEN NOT MATCHED THEN INSERT ( col1, col2 ... ) VALUES ( val1, val2, ... ) WHERE ( insert conditoin );        DELETE  COMMIT / ROLLBACK : COMMIT은 변경한 데이터를 데이터베이스에 마지막으로 반영하는 역할을, ROLLBACK은 그 반대로 변경한 데이터를 변경하기 이전 상태로 되돌리는 역할    COMMIT [WORK] [TO SAVEPOINT savePointName];ROLLBACK [WORK] [TO SAVEPOINT savePointName];        TRUNCATE : DELETE와 같은 기능을 수행하지만 삭제한 후 COMMIT을 해야 데이터가 완전히 삭제되고, 반대로 ROLLBACK을 실행하면 데이터가 삭제되기 전으로 복귀한다.단, DDL에 속하는 TRUNCATE는 실행하면 데이터가 바로 삭제되고, ROLLBACK을 실행하더라도 삭제 전 상태로 복귀되지 않는다.    TRUNCATE TABLE [SCHEMA.]tableName;      ",
        "url": "//mysql/2024/05/22/mysql-series-03-SQL.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-02-objects-html": {
        "title": "[mysql Series] 02 Objects",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Objects데이터베이스 객체            데이터베이스 객체      설명                  테이블      데이터를 담고 있는 객체              뷰      하나 이상의 테이블을 연결해서 마치 테이블인 것처럼 사용하는 객체              인덱스      테이블에 있는 데이터를 빠르게 찾기 위한 객체              시노님(Synonym)      데이터베이스 객체에 별칭을 부여한 객체              시퀀스      일련 번호 채번을 할 때 사용하는 객체              함수      특정 연상을 하고 값을 반환하는 객체              프로시저      함수와 비슷하지만 값을 반환하지는 않는 객체              패키지      용도에 맞게 함수나 프로시저를 하나로 묶어 놓은 객체      테이블  테이블명, 컬럼명의 최대 크기는 30byte  테이블명, 컬럼명으로 예약어 사용 불가  테이블명, 컬럼명으로 문자, 숫자, ‘_’, ‘$’, ‘#’을 사용할 수는 있지만 첫 글자는 문자로 고정  한 테이블에 사용 가능한 컬럼은 최대 255제약 조건  NOT NULL / NULLABLE  UNIQUE  PRIMARY KEY ( UNIQUE + NOT NULL )  FOREIGN KEY  CHECK ( 컬럼에 입력되는 데이터를 체크해서 특정 조건에 맞는 데이터만 입력 받고 나머지는 오류 )뷰하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게하는 데이터베이스 객체 SELECT 문으로 구성된다.CREATE OR REPLACE VIEW [SCHEMA.]viewName AS    SELECT ~ ; DROP VIEW [SCHEMA.]viewName;인덱스테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체  인덱스 구성 컬럼 개수에 따른 분류 : 단일 인덱스와 결합 인덱스  유일성 여부에 따른 분류 : UNIQUE/ NON-UNIQUE 인덱스  인덱스 내부 구조에 따른 분류 : B-tree/ R-tree / Bitmap / 함수 기반 인덱스CREATE [UNIQUE] INDEX [SCHEMA.]indexName    ON [SCHEMA.]tableName( col1, col2 ... );인덱스 생성 시 고려해야 할 사항  일반적으로 테이블 전체 Row 수의 15% 이하의 데이터를 조회할 때 인덱스를 생성한다.  테이블 건수가 적다면 (코드성 테이블) 굳이 인덱스를 만들 필요가 없다.  데이터의 유일성 정도가 좋거나 범위가 넓은 값을 가진 컬럼을 인덱스로 만드는 것이 좋다.  NULL이 많이 포함된 컬럼은 인덱스 컬럼으로 만들기 적당하지 않다.  결합 인덱스를 만들 떄는, 컬럼의 순서가 중요하다.  (자주 사용하는 컬럼을 순서상 앞에 두는 것이 좋다.)  테이블에 만들 수 있는 인덱스 수의 제한은 없으나, 너무 많아도 성능 부하가 발생한다.시노님(Synonym)CREATE OR REPLACE [PUBLIC] SYNONYM [SCHEMA.]synonymNameFOR [SCHEMA.]Object;PUBLIC을 생략하면 PRIVATE이 된다. FOR 이하에는 테이블, 뷰, 프로시저, 함수, 패키지, 시퀀스 등이 올 수 있다.시퀀스(Sequence)자동 순번을 반환하는 데이터베이스 객체.파티션논리적으로 하나의 테이블이지만, 물리적으로는 분할한 만큼 파티션이 만들어져 입력되는 컬럼 값에 따라 분할된 파티션 별로 데이터가 저장된다.보통 파티셔닝을 하는 목적은 대용량 테이블의 경우 데이터 조회 시 효율성과 성능을 높이기 위해서다.",
        "url": "//mysql/2024/05/22/mysql-series-02-Objects.html"
      }
      ,
    
      "mysql-2024-05-22-mysql-series-01-aboutsql-html": {
        "title": "[mysql Series] 01 Aboutsql",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - About SQLSQL? PL/SQL?SQL (structured Query Language)는 DBMS 상에서 데이터를 읽고 쓰고 삭제하는 등 데이터를 관리하기 위한 프로그램 언어Java, C 등은 절차적 언어, SQL은 집합적 언어라고 할 수 있다.DML / DDLDDL : 데이터 정의어 (데이터베이스 객체를 생성, 삭제, 변경하는 언어)    {        CREATE / DROP / ALTER / TRUNCATE(테이블, 클러스터의 데어틀 통쨰로 삭제)    }DML : 데이터 조작어    {        SELECT / INSERT / UPDATE / DELETE / COMMIT / ROLLBACK    }DCL : 데이터 제어 언어    {        GRANT / REVOKE    }PL/SQLPL/SQL 은 절차적 언어이다. 변수에 값을 할당하고 예외처리도 할 수 있으며, 특정 기능을 처리하는 함수나 프로시저를 생성할 수도 있다. 또한 DB 서버에 코드가 올라가컴파일되어 수행된다는 점이 특징이다.",
        "url": "//mysql/2024/05/22/mysql-series-01-AboutSql.html"
      }
      ,
    
      "apache-2024-05-22-httpd-series-01-reverseproxy-html": {
        "title": "[httpd Series] 01 Reverseproxy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - HTTPD CONFIGReverseProxyProxy는 Forward / Reverse Proxy 두가지가 있는데,보통 Forward Proxy는 사내망 Client에서 외부에 있는 웹서버를 접근할 때 사용되며(미리 Proxy 지정이 필요함),Reverse Proxy는 Client에서 웹서버에 접근 할 때, 내부망에 위치한 WAS서버를 대신하여 요청한 Request에 대해 Response를 하는 구조이다.아파치와 톰캣에 리버스 프록시(reverse proxy) 환경을 구축하는 이유는 톰캣에 올린 웹 서비스의 서버 ip를 외부 사용자로부터 감추기 위한 것이며(보안), 로드밸런싱 기능으로 트래픽 분산을 하여 서버의 가용성을 유지하기 위해서 인프라를 구성하기 위해서 이다.&lt;VirtualHost *:80&gt;\t\t# Forward Proxy 경우 On / Reverse Proxy Off\tProxyRequests Off\t# 호스트가 받은 HTTP 요청을 Proxy 요청시 사용    # Reverse 경우 On으로 해야함\tProxyPreserveHost On\t# Proxy에 연결할 URL     # ServerHost:localhost -&gt; Apache -&gt; ProxyPass URL\tProxyPass / http://192.168.10.146:8080/service/ # 뒤에 슬래쉬는 붙여줘야함\t# WAS 가 redirect HTTP 응답을 보냈을 경우 Location, Content-Location HTTP 헤더를 수정 클라이언트에 전달한다.\t# reverse proxy가 이 헤더를 수정하지 않으면 클라이언트는 redirect 시 제대로 연결할 수 없으므로 꼭 설정해야 한다.\tProxyPassReverse / http://192.168.10.146:8080/service/\t# 로드밸런싱 - 경로 분기\t&lt;Location /html&gt;\t\tProxyPass http://192.168.10.146:8080/html/\t\tProxyPassReverse http://192.168.10.146:8080/html/\t&lt;/Location&gt;        &lt;Location /user&gt;\t\tProxyPass http://192.168.10.146:8080/user/\t\tProxyPassReverse http://192.168.10.146:8080/user/\t&lt;/Location&gt;\t&lt;/VirtualHost&gt;",
        "url": "//apache/2024/05/22/httpd-series-01-ReverseProxy.html"
      }
      ,
    
      "gradle-2024-05-22-gradle-series-summary-html": {
        "title": "[gradle Series] Summary",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Gradle SummaryGradle 기본 정리Gradle?Groovy라는 도메인 언어를 사용하는 빌드 스크립트(태스크로 정의되는)로 정의된 빌드 도구이다. 추가적으로 종속성 관리를 지원한다.특징  유연성: Java, Kotlin, Android 등 다양한 프로그래밍 언어와 플랫폼을 지원한다.  성능 : Maven보다 효율적이며, 증분 빌드를 지원한다.  종속성 관리  빌드 라이프 사이클 관리 : 컴파일, 테스트, 배포를 위한 패키징까지 빌드 라이프사이클의 모든 단계를 지원구성  빌드: 소스컴파일, 테스트 실행, 실행 파일 빌드, 배포를 위한 바이너리 패키징 등 소프트웨어 개발의 다양한 단계를 자동화하는 작업 또는 일련의 작업,이는 빌드 스크립트에 정의되며, Gradle DSL로 작성되며 보통 build.gradle로 명명된다.  태스크: Gradle의 기본 작업 단위, 고유한 이름을 가질 수 있다.  플러그인: 빌드 스크립트에 추가하여 추가 기능을 제공할 수 있게 하는 재사용 가능한 기능    plugins { id 'java'}        구성: 프로젝트를 위한 종속성이 명명된 집합, compile, testCompile, runtime, testRuntime 등 여러 유형을 지원한다.``` groovydependencies { compile ‘junit:junit:5.0.1’ ## 컴파일 단계에서 사용 , deprecated된 구성 runtime .. ## 애플리케이션 실행에서 사용, 컴파일에는 중요하지 않지만 애플리케이션 실행에는 필요한 경우 implementation … ## 소스코드를 구현하는 데 필요한 종속성에 사용, 컴파일, 런타임에 모두 종속성 사요 가능 testImplementation … ## 소스코드를 테스트에 사용}5. 레포지토리: 의존성을 다운로드할 수 있는 위치를 명명한다. `mavenCenter()`, `jcenter()`등이 있다.6. 프로젝트: 소프트웨어 애플리케이션 또는 구성 요소를 나타내는 엔티## 빌드 스크립트 구조- 태스크: gradle이 실행해야하는 작업을 정의한다. ```groovytask clean(type: Delete) {    delete rootProject.buildDir}task build(type: Jar) {    from sourceSets.main.output    archiveBaseName.set(appName)    archiveVersion.set(version)}  소스셋: 소스코드가 포함된 디렉토리를 정의한다.    sourceSets {  main {      java {          srcDir'src/main/java'      }      resources {          srcDir'src/main/resources'      }  }  test {      java {          srcDir'src/test/java'      }      resources {          srcDir'src/test/resources'      }  }}      태스크  javaCompile: 자바 소스 코드를 클래스로 컴파일한다. 소스 및 대상 호환성, 클래스 경로, 종속성 등과 같은 옵션을 지원    task compileJava(type: JavaCompile) {  sourceCompatibility = 1.8  targetCompatibility = 1.8      sourceSets.main.java.srcDirs.each {      def file = it.toString()      options.compilerArgs += [\"-classpath\", file]  }}        test: 테스트를 실행한다.    task test(type: Test) {  testClassesDirs = sourceSets.test.output.classesDirs  classpath = sourceSets.test.runtimeClasspath  reports.html.destination file(\"${buildDir}/test-results\")}        jar: JAR를 생성한다.    task buildJar(type: Jar) {  baseName = 'myproject'  version = '1.0'  from sourceSets.main.output}        JavaExec: 자파 프로그램 실행    task runMain(type: JavaExec) {  classpath = sourceSets.main.runtimeClasspath  main = 'com.example.Main'  args = ['arg1', 'arg2']}        Copy: 소스 디렉토리에서 대상 디렉토리로 파일 및 디렉토리를 복사한다.    task copyFiles(type: Copy) {  from 'src/main/resources'  into 'build/resources/main'  include '**/*.properties'  filter { line -&gt; line.replaceAll('FOO', 'BAR') }}      태스크의 순서task myTask {    doFirst {    // runs before any other actions    }    doLast {    // runs after all actions are complete    }    finalizedBy anotherTask    dependsOn someTask}someTask -&gt; doFirst -&gt; task -&gt; doLast -&gt; anotherTask 순으로 실행된다.태스크 옵션  -D : 작업 구성 또는 종료에서 액세스할 수 있는 시스템 속성을 정의  -P : 프로젝트 객체 또는 작업의 클로저에서 액세스할 수 있는 프로젝트 속성을 정의  -x : 작업을 제외한다.Gradle Properties빌드 프로세스의 다양한 측면을 구성하는 데 사용하는 Key:Value 쌍 빌드스크립트 전체에서 액세스할 수 있다.gradle.propertiesappName=my-appversion=1.0.0java.home=/usr/share/java/bin",
        "url": "//gradle/2024/05/22/gradle-series-Summary.html"
      }
      ,
    
      "git-2024-05-22-git-series-03-convention-html": {
        "title": "[git Series] 03 Convention",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ConventionConvention메시지 컨베션  제목과 본문을 한 줄 띄워서 분리하기  제목은 영문 기준 50자 이내  제목 첫 글자는 대문자  제목 끝 . 금지  본문은 무엇, 왜에 맞춰 작성  태그: 제목(한 줄 띄우기)본문(한 줄 띄우기)꼬리말태그|     TagName      |                          Description                          ||:—————-:|:————————————————————-:||       Feat       |                           새로운 기능 추가                           ||       Fix        |                             버그 수정                             ||      Design      |                        CSS, UI 디자인 변경                         || !BREAKING CHANGE |                           큰 API 변경                            ||     !HOTFIX      |                            HOTFIX                             ||      Style       |               코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우                ||     Refactor     |                         프로덕션 코드 리팩토링                          ||     Comment      |                        필요한 주석 추가 및 변경                         ||       Docs       |                             문서 수정                             ||       Test       |         테스트 코드, 리펙토링 테스트 코드 추가 (ProductionCode 변경 X)          ||      Chore       | 빌드 업무 수정, 패키지 매니저 수정, 패키지 관리자 구성 등 업데이트 (ProductionCode 변경 X) ||      Rename      |                          파일/ 폴더명 수정                           ||      Remove      |                             파일 삭제                             |깃 모지| Git moji |  코드   | 설명||:——–:|:—–:|:—-:||    🎨    | :art: |코드의 구조/형태 개선||    ⚡     |:zap:|성능 개선||    🔥    |:fire:|코드/파일 삭제||    🐛    |:bug:|버그 수정||    ✨     |:sparkles:|새 기능||    📝    |:memo:|문서 추가/수정||    💄    |:lipstick:|UI/스타일 파일 추가/수정||    🎉    |:tada:|프로젝트 시작||    ✅     |:white_check_mark:|테스트 추가/수정||    🔒    |:lock:|보안 이슈 수정||    🔖    |:bookmark:|릴리즈/버전 태그||    💚    |:green_heart:|CI 빌드 수정||    📌    |:pushpin:|특정 버전 의존성 고정||    👷    |:construction_worker:|CI 빌드 시스템 추가/수정||    📈    |:chart_with_upwards_trend:|분석, 추적 코드 추가/수정||    ♻     |:recycle:|코드 리팩토링||    ➕     |:heavy_plus_sign:|의존성 추가||    ➖     |:heavy_minus_sign:|의존성 제거||    🔧    |:wrench:|구성 파일 추가/삭제||    🔨    |:hammer:|개발 스크립트 추가/수정||    🌐    |:globe_with_meridians:|국제화/현지화||    💩    |:poop:|똥싼 코드||    ⏪     |:rewind:|변경 내용 되돌리기||    🔀    |:twisted_rightwards_arrows:|브랜치 합병||    📦    |:package:|컴파일된 파일 추가/수정||    👽    |:alien:|외부 API 변화로 인한 수정||    🚚    |:truck:|리소스 이동, 이름 변경||    📄    |:page_facing_up:|라이센스 추가/수정||    💡    |:bulb:|주석 추가/수정||    🍻    |:beers:|술 취해서 쓴 코드||    🗃    |:card_file_box:|데이버베이스 관련 수정||    🔊    |:loud_sound:|로그 추가/수정||    🙈    |:see_no_evil:| .gitignore 추가/수정|",
        "url": "//git/2024/05/22/git-series-03-Convention.html"
      }
      ,
    
      "git-2024-05-22-git-series-02-summary-html": {
        "title": "[git Series] 02 Summary",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Summaryconfig # 현재 위치에서 지역 저장소를 생성$ git init # 깃 환경에서 사용자 이름을 [사용자명]으로 지정$ git config --global user.name \"[사용자명]\" # 깃 환경에서 사용자 이메일을 [사용자이메일명]으로 지정$ git config --global user.email \"[사용자이메일명]\"stage  # [파일명.확장자명]을 스테이지에 올림$ git add [파일명.확장자명]  # 상태를 확인$ git status  # 파일 add 취소$ git restore --staged 파일명  # 전체 add 취소$ git reset HEADcommit  # 커밋 메시지 [메시지명]을 붙여 커밋$ git commit -m \"[메시지명]\"$ git commit -am \"[메시지명]\" # 스테이징과 커밋을 동시에 진행  # 최근 순서대로 커밋을 취소$ git reset HEAD^ # 현재 HEAD의 이전 커밋으로 되돌리기$ git reset HEAD~n # 현재로 부터 n 번째 이전 커밋으로 되돌리기  # 롤백할 커밋을 지정$ git reset [커밋 해시]# - reset의 3가지 옵션$ git reset --soft [커밋ID]  # head 만 바뀜$ git reset --mixed [커밋ID] # staging 도 그 때로 바뀜$ git reset --hard [커밋ID] # working디렉토리/staging 모두 그 때로 바꿈   # 커밋을 삭제하지않고 이전 커밋을 새로 복사 추가하는 식으로 롤백$ git revert [커밋 해시] # 해당 커밋 이전상태로 되돌린다라는 명령  # 커밋 수정하는 법# ... 파일 수정 한 뒤$ git add .$ git commit --amend # 최신 커밋 수정log  # 커밋 내역 확인$ git log           # 전체 이력을 보여준다.$ git shortlog     $ git log --oneline # 커밋과 커밋 메시지를 조회$ git log -p        # 이력을 보여줄 때, 변경된 데이터도 보여준다.$ git log [filename] # 특정 파일에 대한 이력을 보여준다.$ git log -p [filename] # 특정 파일의 이력과 변경된 데이터를 보여준다.$ git log --stat    # 커밋마다 파일의 추가/삭제된 통계데이터를 보여줌$ git log --graph   # 브랜치 분기 및 병합내용을 아스키 그래프로 보여줌  # 특정 커밋 내역 확인$ git show [커밋 id]  # 최근 버전과 작업 폴더의 수정 파일 사이의 차이를 출력$ git diff               # modified 상태의 file과 마지막 commit 비교$ git diff --staged      # staged 상태의 file과 마지막 commit 비교$ git diff --color-words # 변경사항을 color 풀하게 비교$ git diff [브랜치이름]    # 현재브랜치와 선택된 브랜치와 차이점 비교$ git diff [이전커밋 id] [이후커밋 id] # 커밋 비교( Alias git config --global alias.graph 'log --oneline --graph --all --decorate' )            git log 명령어 예시      설명                  git log      HEAD와 관련된 commit들이 자세하게 나옴              git log –oneline      간단히 commit 해시와 제목만 보고 싶을 때              git log –oneline –graph –decorate      HEAD와 관련된 commit들을 조금 더 자세히 보고 싶을 때              git log –oneline –graph –all –decorate      모든 branch들을 보고 싶을 때 사용하는 명령어              git log –oneline -n7      내 branch의 최신 commit을 7개만 보고 싶을 때 사용      remote  # 원격 저장소에 연결$ git remote add origin [github 레포지 주소]  # 옵션 종류 보기$ git remote --help  # 추가한 원격저장소의 목록 확인 $ git remote$ git remote -v # 상세히  # 특정 원격 저장소의 정보를 확인할 수 있다.$ git remote show 이름  # 원격저장소 이름 변경$ git remote rename 기존이름 변경할이름  # 원격저장소를 제거$ git remote rm 이름  # 지역 저장소의 커밋을 맨 처음 원격 저장소에 올리는 경우$ git push -u origin master  # -u로 등록한 후에 지역 저장소의 커밋을 원격 저장소에 올리는 경우(업로드)$ git push$ git push origin master  # 원격 저장소의 커밋을 지역 저장소로 가져옴$ git pull origin master  # 원격 저장소 복제하기$ git clone [원격 저장소 주소]  # 원격 저장소의 커밋을 가져오기만 하고 merge하지 않는다$ git fetch# 이후엔 diff 로 비교$ git diff test origin/test # 브랜치 이름이 test일 경우 예시  # 원격저장소 삭제(끊기)$ git remote remove originremove  # 로컬저장소 원격저장소 둘다 파일 삭제$ git rm [filename]      # 원격저장소 파일만 삭제. 로컬저장소 파일은 냅둠$ git rm --cached [filename]# -rf (recursive, force)branch  # 브랜치 확인$ git branch                 # 브랜치 추가 / 삭제$ git branch [branch name]  $ git branch -d [branch name] # -delete  # 브랜치로 이동$ git switch [branch name]$ git checkout [branch name]  # 브랜치 추가하고 바로 이동$ git switch -c [branch name]$ git checkout -b [branch name]  # 현재 브랜치에서 다른 브랜치를 merge$ git merge [branch name]cherry-pick  # 만일 내가 X 브랜치에 있고   # 브랜치 Y의 커밋 중 76ae30ef와 13af32cc만 골라 현재 브랜치인 X에 적용하고 싶을때$ git cherry-pick 76ae30ef 13af32ccstash  # staged, modified 상태의 파일을 저장$ git stash       # stash로 저장한 리스트를 출력$ git stash list           # 가장 최근에 저장한 stash를 반영$ git stash apply      $ git stash apply stash@{1}  # 지정한 stash를 반영  # 지정한 stash를 삭제$ git stash drop stash@{1}  # stash를 반영하고 자동 삭제$ git stash poptag  light weight 태그 : 단순 커밋 태그용. 커밋을 바로 가리킴  annotated 태그 : 태그 메세지도 첨부할수 있어 자체 해시값을 가짐. ^{}이 커밋을 가리킴  # 태그 추가$ git tag [태그이름]           $ git tag [태그이름] [커밋번호]  # 특정 해쉬에 태그 추가$ git tag -a [태그이름] [커밋번호] # 특정 해쉬에 annotated 태그 추가  # 태그 조회$ git tag$ git tag -l 'v1.*'  # 와일드카드 패턴으로 검색조회$ git show [태그이름]  # 특정 태그 조회$ git show-ref --tags  # 해쉬값과 태그 조회blame# git 프로젝트에서 어떤 코드를 누가 수정했는지, 어떤 commit으로 수정이 되었는지 궁금할 때#  해당 파일에 대한 모든 수정 내역$ git blame &lt;파일명&gt;#  author name과 timestamp는 출력하지 않음.$ git blame -s &lt;파일명&gt;#  description과 수정사항을 보여줌$ git show &lt;커밋번호&gt;#  파일내용을 start부터 end 라인까지의 수정 내역만 보여줌$ git blame -L &lt;start,end&gt; &lt;파일명&gt; https://inpa.tistory.com/entry/GIT-⚡%EF%B8%8F-핵심-명령어-요약-🚩-총정리 ",
        "url": "//git/2024/05/22/git-series-02-Summary.html"
      }
      ,
    
      "git-2024-05-22-git-series-01-command-html": {
        "title": "[git Series] 01 Command",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Commandloggit log –all –oneline –graph : 그래프 확인Remote            command      description                  git remote -v      워킹 트리에 등록돼 있는 원격 저장소 목록 노출              git remote add [remoteName] [remoteUrl]      원격 저장소를 지정한 이름으로 등록              git remote rename [prevName] [newName]      원격 저장소의 이름을 새로운 이름으로 변경              git remote remove [remoteName]      지정한 원격저장소를 삭제      fetch/ pull/ push            command      description                  git fetch [remoteName] [branchName]      원격 저장소의 커밋과 브랜치, 태그들의 로컬 저장소를 가져온다. 워킹 트리의 내용이 변하지 않는다.              git pull [remoteName] [branchName]      fetch + merge              git push [-u remoteName, branchName]      해당 브랜치의 커밋을 원격 저장소로 업로드한다.              git push [remoteName] –all      로컬 저장소의 모든 브랜치와 커밋들을 한꺼번에 원격저장소로 업로드한다.              git push [remoteName] –tags      로컬 저장소의 모든 태그들을 원격 저장소로 업로드한다.      clean working tree            command      description                  git clean  -f -d [file or folderName]      untracked 상태 파일을 삭제한다. 파일 또는 경로 명시하지 않으면 모든 untracked를 정리      reset|           command            |                             description                             ||:—————————-:|:——————————————————————-:|| git reset –hard [checksum]  |         hard reset이라고 부른다. 해당 커밋으로 돌리고 싶을 때 사용, 워킹 트리도 초기화          || git reset –mixed [checksum] |               옵션이 없으면 mixed가 기본, 워킹 트리는 남고 스테이지만 초기화                || git reset –soft [checksum]  | soft reset이라고 부르고 HEAD만 이동한다.  커밋은 돌아가지만 스테이지와 워킹 트리의 내용은 변경되지 않는다. |            구분      soft      mixed(기본)      hard                  현재 브랜치 (HEAD)      초기화      초기화      초기화              스테이지      남아있음      초기화      초기화              워킹트리 변경사항      남아있음      남아있음      초기화      reflogreflog는 로컬 저장소의 커밋 또는 브랜치의 변경 사항을 기록해 놓은 로그를 의미한다.            command      description                  git reflog [-n 숫자]      relog를 보여주는 명령 -n 숫자로 갯수를 제한해서 볼 수 있다.      amend이건 커밋을 고칠 때는 –amend를 사용하면 된다. 이를 사용하는 경우는  HEAD가 가리키는 커밋, 즉 현재 커밋을 수정하고 싶을 때  커밋 메시지를 바꾸고자 할 때  이전 커밋의 파일 내용을 수정하고 싶을 때  이전 커밋에 중요 파일을 추가하지 않은 경우diff변경 사항을 비교할 때 사용한다.            command      description                  git diff [a] [b]      a를 토대로 b에 추가된 차이를 보여준다. 옵션을 생략하면 아직 스테이지에 추가되지 않은 변경 사항을 보여주는데, 신규 파일(untracked)는 보여주지 않는다.      git diff –check공백 문자를 체크하는데 유용하게 사용할 수 있는 명령어다.-Xmerge나 rebase에 -X [ours|theirs]를 사용하면 어떤 것을 기준으로 작업할지 정할 수 있다.rebase -i[–interactive]            command      description                  git rebase -i       HEAD와 지정한 커밋 사이의 커밋들의 히스토리를 수정한다. 옵션으로 지정한 커밋은 수정에서 제외되고 후손들만 편집이 가능하다.  p( pick ) : 해당 커밋을 그대로 변경 없이 사용  r( reword ) : 해당 커밋을 사용. 단 커밋 메시지를 편집  e( edit ) : 해당 커밋을 사용 단 커밋을 수정할 수 있도록 된다.  s( squash ) : 커밋을 사용. 단 내용은 부모 커밋에 합쳐지고 커밋은 사라진 것처럼 보임  d ( drop ) : 해당 커밋을 제거      cherry-pickgit cherry-pick은 다른 브랜치에 있는 특정 커밋을 골라 현재 브랜치에 합칠 때 사용한다.stash작업 폴더의 변경 내용을 넣어두는 명령어 git stash를 사용하면 stash 스택(.git/refs/stash)에 저장한다.stash는 변경사항을 커밋하기도, 삭제하기도 애매한 상황에서 사용한다.            command      description                  git stash [-u]      변경 사항을 스택에 저장하고 현재 작업 폴더를 clean 상태로 만든다. -u를 사용하면 untracked도 저장한다.              git stash list      stash 리스트를 확인하다.              git stash pop [stash 객체]      stash 스택에 있는 변경사항을 현재 작업 폴더에 반영한다. 반영된 stash는 제거한다. 옵션을 붙이면 해당 객체를 아니면 마지막의 객체를 꺼내온다.              git stash apply [stash 객체]      pop과 유사하지만 스택에서 제거하지는 않는다.              git stash drop [stash 객체]      지정한 stash를 제거한다.              git stash clear      스택의 모든 stash를 삭제              git stash branch [stash 객체]      마지막 체크아웃된 커밋에 stash 내용 반영해서 새로운 브랜치 생성 (테스트 할 떄 유용)        다른 브랜치에서 작업했을 때?git status -ugit checkout -b temporaryBranchgit stash popadd            command      description                  git add –patch [fileName]      변경 사항의 일부만 커밋하고 싶을 때 사용할 수 있다. ? : 도움말 y: 현재 변경사항(hunk)를 스테이징 n: 현재 변경 사항을 스테이징 하지 않는다. e: 직접 스테이지에 올릴 내용을 편집 q: 변경 사항을 무시하고 종료      untracked 파일 일부 변경 사항 커밋| command                | description                                      ||:———————–|:————————————————-|| git add –N [fileName] | untracked 상태의 파일을 스테이지에 올린다. 단 내용은 올리지 않고 상태만 변경 |add –interactive [-i]add에 인터렉티브한 작업을 선택할 수 있다.git blame으로 히스토리 조회            command      description                  git blame [-L &lt;시작줄, 끝줄&gt;]       해당 파일을 변경했던 커밋 히스토리를 보여준다. -L로 시작 - 끝 줄을 지정하고 특정 범위만 조회할 수도 있다.      filter-branch로 히스토리 파일 삭제| command                                                 | description                 ||:——————————————————–|:—————————-|| git filter-branch –tree-filter ‘rm -f ' HEAD | HEAD로부터 모든 히스토리에 지정한 파일을 삭제 |git alias단축 명령어 생성git config –global alias.st status -&gt; git st (==git status)git config –global alias.graph “ log –oneline –graph –all “-&gt; git graph -n5global ignore  ignore 생성  git conifg –global core.excludesfiles ~/path  git reflogcheckout, commit들에 대한 내역을 볼 수 있다.만일 local에 commit만 하고 reset –hard를 했다면 reflog로 찾아서 git reset –hard [revisionNumber]로 되돌려 놓을 수 있다.",
        "url": "//git/2024/05/22/git-series-01-command.html"
      }
      ,
    
      "ci-cd-2024-05-22-ci-cd-series-02-deploy-html": {
        "title": "[ci:cd Series] 02 Deploy",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DeployDeploy1. Rollingkubernetes에서 공부했던 Rolling이다. 하나씩 변경점을 반영하며 전파되는 형식단점으로 부하 계산을 잘못하면 문제가 될 수 있다.  (70, 70, 70) -&gt; (0, 105, 105)2. BlueGreen일전에 jojoldu의 책에서 nginx로 새로운 서버로 포트만 바꿔주던 식의 신, 구 서버 스위칭 형식이다. 단점으로 구/ 신버전을 모두 유지해야 하므로 리소스가 2배가 된다.3. Canary독가스 검사하는 카나리아에서 차용한 듯특정 서버만 배포하고 배포된 서버로 트래픽을 늘려서 문제가 없으면점진적 배포를 하는 방식이다. 결과적으로 모든 서버에 배포한다.",
        "url": "//ci/cd/2024/05/22/ci-cd-series-02-Deploy.html"
      }
      ,
    
      "ci-cd-2024-05-22-ci-cd-series-01-cicd-html": {
        "title": "[ci:cd Series] 01 Cicd",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CI/CDCI/CDJunit기본 개념pipeline일련의 Job으로 구성된 단위이다.Job파이프 라인을 구성하는 최소 작업 단위다.VariablesJob에서 사용하거나 다른 곳에 재사용 할 때 지정할 수 있는 환경 변수의 한 유형이다.Runnerpipeline을 따라 Job을 실행시키는 주체다. 러너의 종류로는 1. 공유 러너, 2. 그룹 러너, 3. 지정 러너가 있다.Artifacts일련의 단계에서 나온 산출물이다.예시## 파이프라인의 단계stages:  - test  - build  - packing  - deploy## 해당 파이프라인에서 사용할 로컬 변수variables:  STAGE_TARGET_PATH: /home/service  STAGE_NAME: $STAGE_NAME  STAGE_TARGET_SERVER: $STAGE_TARGET_SERVER  ##Jobtest:  ## 단계  stage: test  ##어떤 이미지를 사용 할 것이며  image: gradle-8.6.0-jdk17  ##어떤 상황에서 실행되는가  when: always  ##트리거가 되는 브랜치  only:    - stage    - master  ##태그  tags:    - test_work  before_script:    - pwd    - chmod +x gradlew  script:    - echo [INFO] TEST PROJECT $CI_PROJECT_NAME    - ./gradlew testbuild: ##Job  ## 단계  stage: build  ##어떤 이미지를 사용 할 것이며  image: gradle:7.6-jdk11-alpine  ##어떤 상황에서 실행되는가  when: on_success   ## 선행되어야만 하는 작업  needs:    - job: test  ##트리거가 되는 브랜치  only:    - stage    - master  ##job에 대한 태그  tags:    - build_work  # 스크립트 이전 실행  before_script:    - pwd    ## 자바HOME을 유동적으로 변경(Gradle -&gt; 2024-05-22-[gradle-series]-Summary.md)    - cp $JAVA_HOME_11 gradle.properties    - chmod +x gradlew    - ./gradlew clean  #스크립트  script:    - echo [INFO] BUILD PROJECT $CI_PROJECT_NAME    - ./gradlew generateDbJooqSchemaSource\"    - ./gradlew -x generateDbJooqSchemaSource bootjar  --continue\"    - echo [INFO] RENAME FILE    - cp build/libs/*.jar $CI_PROJECT_NAME.jar  ## 빌드 결과물을 저장할 아티팩트  artifacts:    paths:      - build/libs/*.jar    expire_in: 1 daysstage:  stage: deploy  needs:    - job: build      artifacts: true  when: on_success  only:    - stage  script:    - echo [INFO] DEPLOY STAGE_MODE $CI_PROJECT_NAME    - echo [INFO] move to ${STAGE_TARGET_SERVER}    - cp build/libs/*.jar $CI_PROJECT_NAME.jar     ## 파일로 된 전역 변수 가져와서    - cat $STAGE_TARGET_SERVER_KEY     ##권한 하향    - chmod 400 $STAGE_TARGET_SERVER_KEY            ## 파일 만들고 전송하고 하는 일련의 과정    - echo ssh -i $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} mkdir -p ${STAGE_TARGET_PATH}    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} mkdir -p ${STAGE_TARGET_PATH}    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} &lt;&lt; EOT    - cd ${STAGE_TARGET_PATH}    - |      exist=`ls | grep $CI_PROJECT_NAME.jar | wc -l`      if [ $exist &gt; 0 ]        then          echo create backupFile as $CI_PROJECT_NAME.jar_{CI_COMMIT_TIMESTAMP}          mv ${STAGE_TARGET_PATH}/$CI_PROJECT_NAME.jar ${STAGE_TARGET_PATH}/$CI_PROJECT_NAME.jar_${CI_COMMIT_TIMESTAMP}      fi    - scp -i  $STAGE_TARGET_SERVER_KEY $CI_PROJECT_NAME.jar ${STAGE_NAME}@${STAGE_TARGET_SERVER}:${STAGE_TARGET_PATH}    - cat $START    - scp -i  $STAGE_TARGET_SERVER_KEY $START ${STAGE_NAME}@${STAGE_TARGET_SERVER}:${STAGE_TARGET_PATH}/start.sh    - cat $STAGE_TARGET_SERVER_KEY    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} chmod 755 ${STAGE_TARGET_PATH}/start.sh    - ssh -i  $STAGE_TARGET_SERVER_KEY ${STAGE_NAME}@${STAGE_TARGET_SERVER} &lt;&lt; EOT    - cd ${STAGE_TARGET_PATH}    - ./start.sh    - EOT    - echo Congratulation. All done!deploy_as_production:  stage: deploy  needs:    - job: build      artifacts: true  when: on_success  only:    - master  script:    - echo [INFO] DEPLOY PRODUCTION_MODE $CI_PROJECT_NAME",
        "url": "//ci/cd/2024/05/22/ci-cd-series-01-CICD.html"
      }
      ,
    
      "aws-2024-05-22-aws-series-01-model-html": {
        "title": "[aws Series] 01 Model",
        "tags": "",
        "date": "May 22, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Price ModelPrice ModelAWS EC2 인스턴스에 대한 요금을 지불하는 방법에는 온 디맨드 인스턴스, 예약 인스턴스, 스팟 인스턴스 및 전용 호스트의 네 가지 방법이 존재한다.온 디멘드 (On-Demand Pricing)온 디맨드 인스턴스를 사용하면 실행하는 인스턴스에 따라 시간당 또는 초당 컴퓨팅 용량을 지불하게 된다.이를 수요에 반응한다고 말하는데, 그냥 쓴만큼 낸다라고 이해하면 된다.가장 기본적인 초보용 요금제이며, 장기 약정 없이 시간 단위로 인스턴스를 사용하기 때문에 보편적으로 가장 많이 선택하는 요금제이며, 인스턴스 생성 시에 과금이 시작되고 종료(반납)을 하면 정산되는 방식이다.애플리케이션 요구 사항을 충족하기 위해 컴퓨팅 용량을 늘리거나 줄일 수 있으며 사용하는 인스턴스에 대해 지정된 시간당 요금 만 지불하면 된다.  레드햇 같은 오픈소스가 아닌 인스턴스 - 시간당 지불  아마존 리눅스, 오픈소스 기반 - 초당 지불온 디멘드 이용 고객권장되는 소비자층은 다음과 같다.  선불 결제 또는 장기 약정없이 Amazon EC2의 저렴한 비용과 유연성을 선호하는 사용자  중단 할 수 없는 단기, 예측할 수 없는 워크로드가 있는 애플리케이션  Amazon EC2에서 처음으로 개발 또는 테스트중인 애플리케이션예약 인스턴스 (Resserved Instance - RI Pricing)미리 일정 기간(1년 ~ 3년)을 약정해서 쓰는 방식이다. 즉, 선납금을 납부하는 방식이다.최대 75% 정도 저렴하다. 당연히 온디멘드의 쓴만큼 내는 유연성을 희생해서 할인을 받는 격으로 생각하면 된다.예약 인스턴스를 특정 가용 영역에 지정하면 용량 예약이 제공되므로 필요할 때 예약한 인스턴스를 시작할 수 있다.예를들어 만일 회사가 수요일날 특히 서버자원을 많이 쓴다면 수요일은 자원을 늘려야 한다. 그러면 예약 인스턴스를 수요일날 늘리게끔 설정을 하면 돈을 아낄 수 있는 원리이다.즉, 예측 가능한 사용량이 있는 애플리케이션의 경우 예약 인스턴스는 온 디맨드 인스턴스와 비교하여 상당한 비용을 절감 할 수 있는 것이다.몇년동안 얼만큼 사용 예정 계획이 확실할때 사용하면 좋은 요금제이다.일정 규모의 인스턴스를 항상 사용하기 떄문에 주로 큰 기업들이 이용하는 편이다.예약 인스턴스 이용 고객  수요가 꾸준한 애플리케이션  예약 용량이 필요할 수 있는 애플리케이션  총 컴퓨팅 비용을 절감하기 위해 1년 또는 3년 동안 EC2를 사용하기로 약정할 수 있는 고객스팟 인스턴스 (Spot Instances Pricing)스팟 인스턴스는 경매 형식으로 시장에 남는 인스턴스를 구매해서 쓰는 방식인 요금제이다.이게 무슨 소리냐 하면은, aws에서는 항상 인스턴스를 빵빵하게 확보해 놓고 있는데, 사람들이 안쓰면 손해이기 때문에 aws 입장에서는 재고가 남은 인스턴스들을 소비 하기위해서 남은 것들을 저렴하게 내놓아서 소비자들이 그걸 입찰해서 이용하는 방식인 것이다.온디맨드 요금보다 90% 할인된 가격으로 내놓으니 가장 저렴한 요금 정책이라고 말할 수 있다.하지만 문제는 언제 반납해야할지 모른다는 것이다.남는 인스턴스가 아까워서 싸게 판매하는 취지는, 만일 언제 비싼 요금을 내고 사용하는 고객들의 인스턴스 수요가 많아지면, 이들에게 제공하기 위해 곧바로 다시 회수 해간다는 의미를 내포한다.정말로 어느순간 AWS가 인스턴스를 가져가버려 정작 내 서비스가 잠시동안 끊겨버리는 순간이 올수 있다는 말이다.물론 인스턴스 수요가 적어지면 다시 인스턴스를 할당받아 내 애플리케이션을 다시 서비스가 가능하다.따라서 반환 시간이 예측이 불가능하기에, 인스턴스가 확보되고 종료되는 것을 반복해도 문제없는 애플리케이션에 적합하며 주로 빅데이터 처리, ML등 많은 인스턴스가 필요한 작업에 사용된다. (최대 90% 저렴하니까)스팟 인스턴스 원리아래의 그래프를 보자.고객들이 인스턴스를 많이 쓰면 스팟 인스턴스 가격(노랑선)이 올라가게 된다.일단 먼저 내가 원하는 지정 가격(초록선)을 정한다.이 지정가격 보다 비싸지면 반납해서 인스턴스를 중지시키고, 가격이 싸지면 다시 인스턴스를 사용한다는 원리이다.  수요에 따라 스팟 인스턴스의 가격은 계속 변동한다.  내가 지정한 가격보다 현재 가격이 낮다면 인스턴스를 할당받고 사용한다.  내가 지정한 가격보다 현재 가격이 높다면 반환된다.  다시 가격이 낮아지면 사용한다.스팟 인스턴스 이용 고객  시작 및 종료 시간이 자유로운(유연한, flexible) 응용 애플리케이션          지금 내가 급하게 사용할 필요없고, 사용할때를 기다리고 내가 원하는 가격에 입찰되어 내가 사용할 수 있을때, 그때 해도 되는 것들에 활용하면 적합        컴퓨팅 가격이 매우 저렴해야만 수익이 나는 애플리케이션  대량의 서버 용량 추가로 긴급히 컴퓨팅 파워가 필요한 사용자전용 호스트실제 물리적인 서버를 임대하는 요금제이다.aws 인스턴스 자체가 가상환경에서 사용하는 컴퓨터인데, 그 반대라고 보면 된다.즉, 가상화된 서버에서  EC2를 빌리는 것이 아닌 지정된 물리서버에서 EC2가 대여가 된다보안적인 이유, 규정(라이센스)에 따른 이유, 퍼포먼스를 위한 이유(CPU Steal 등) 등으로 사용된다.간단히 말하자면 가상 컴퓨팅은 구조적 한계 때문에 여러사람들이 사용하면 퍼포먼스 하락 요소가 있기 때문이다.전용 호스트 이용 고객EC2에서 Microsoft 및 Oracle 같은 공급업체의 적격 소프트웨어 라이선스를 사용할 경우기존의 물리적 서버에서 EC2를 사용할 경우요금 정책  가격순서          스팟 인스턴스 &lt; 예약 인스턴스 &lt; 온디맨드 &lt; 전용 호스트2, EC2의 가격모델과 EBS와는 별도로 요금이 청구된다. (EBS는 사용한만큼 지불)        기타 데이터 통신 등의 비용은 별도로 청구 (참고로 AWS는 AWS 바깥으로 나가는 트래픽에 대해서만 요금 부과)          예를들어 50테라바이트의 파일을 업로드할때는 무료단, 그 파일을 다운받을때 요금 청구      출처: https://inpa.tistory.com/entry/AWS-📚-EC2-가격-요금-모델-원리-💰-파헤치기 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//aws/2024/05/22/aws-series-01-Model.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-16-xargs-vs-pipe-html": {
        "title": "[linux Series] 16 Xargs_vs_pipe",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - xars vs. pipexars vs. pipexars  기본적인 명령어 뒤에 파이프로 추가하여 사용  파이프 이전에 명령을 인자로 받아 명령어를 실행하는 구조xargs를 사용하는 가장 기본적인 예는 pipe to xargs를 사용하여 공백으로 구분된 여러 문자열을 전달하고 해당 문자열을 인수로 사용할 명령을 실행하는 것이다.# file1 file2 file3 이라는 문자열을 touch 의 인수로 넘겨주어,# touch file1 file2 file3 명령을 수행한것과 같은 결과를 준다. (빈파일 3개 생성)echo \"file1 file2 file3\" | xargs touchoptions|    option     |                                         description                                         ||:————-:|:——————————————————————————————-:||      -a       |                                   표준 입력 대신 파일에서 항목을 읽는다.                                    ||      -O       |                                      공백이나 특수문자 찾을 때 사용                                      ||    -printO    |                                   파일 사이의 공백을 \\O로 분리자로 출력                                    ||      -d       |                                  입력된 문자를 그대로 사용(따옴표, 백슬래시)                                  ||      -n       |                                       지정된 숫자만큼 행을 출력                                        ||      -p       |                         각 명령 행 실행 여부, 터미널에서 행을 읽어들이는 것에 대한 여부를 묻는다.                         ||      -P       |                                하나의 명령에 프로세스를 지정 (-n과 같이 사용)                                 ||      -t       |                                xargs를 통해 구성된 명령어를 표준 에러로 출력                                 ||      -s       | 한 라인에 들어갈 수 있는 문자열 수를 지정(기본적으로 128k 안으로 문자열을 만들어 하나의 명령으로 실행하나 해당 옵션으로 1024k까지 사용 가능하게 한다.) ||      -x       |                                   -s로 지정한 크기가 초과되면 종료시킨다.                                   || –show-limits |                            xargs의 버퍼 크기 선택 및 -s 옵션에 대한 길이 제한 출력                             ||      -E       |                                     문자열 끝을 eof-str로 설정                                      ||      -I       |                    xargs에 전달된 라인 전체를 뒤에 나오는 명령어의 인자로 사용 (라인 전체는 {}로 표기)                     ||      -l       |                         명령어 뒤 공백을 다음 행이 아닌 논리적으로 이어진 명령으로 인식하게 한다.                          |예제# /tmp 디랙토리 아래 core라는 파일을 찾아 삭제$ find /tmp -name core -type f -print | xargs rm -f# ls를 이용하여 text파일을 모두 읽어와 하나의 파일로 병합$ ls *.txt | xargs cat &gt;&gt; abc.txt# 디렉토리에서 txt파일을 우선 찾은 다음 이름에 abcd를 포함하는 파일을 또 찾음$ find ~/ -type f | grep -H “*.txt$” | xargs grep -H “abcd”# 파일안에 url이 있을 경우 해당 인자들을 모두 wget으로 넘겨 다운받는다$ cat url-list.txt | xargs wget -c# 모든 jpg파일을 찾아 images.tar.gz로 압축$ find / -name “*.jpg” -type -f -print | xargs tar -cvzf images.tar.gz# ls 로 출력된 모든 이미지를 하나씩 인자로 받아 외장하드로 복사$ ls *.jpg | xargs -n1 -I{} cp {} /external-hard-drive/tmpxargs vs. pipe  파이프 ‘|’ 는 앞의 결과를 인자로 받는게 아니다.파이프 ‘|’ 는 앞의 표준출력을 다음 프로그램의 표준입력으로 연결하는 것이다.파이프 ‘|’ 와의 조합으로 표준출력을 다음 프로그램의 ‘인자’로 넘길려면 xargs 를 사용한다.xargs 프로그램은 실행할 대상프로그램을 인자로 받고, xargs 프로그램의 표준입력을 실행 대상프로그램의 인자로 전달하여 실행한다.예시  &lt;&lt;&lt; 뒤에는 문자열이나 변수가 바로 붙는다&lt; 는 표준입력 리다이렉션이다.vi err.txterr:wqecho err.txt | cat ## err.txt## 파일명 자체를 echo err.txt | xargs cat ## err## 파일을출처: https://inpa.tistory.com/entry/LINUX-📚-xargs-명령-파이프-와-차이점-완벽-정리-표준입력-인자-차이 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-16-xargs_vs_pipe.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-15-volume-html": {
        "title": "[linux Series] 15 Volume",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Volume  aws 재시작으로 볼륨 마운트 해제되어서 해결하면서 찾은Volume  lsblk : 블록 장치를 나열하는 유틸리티 추가 정보를 보려면 lsblk -f  blkid : 블록 디바이스의 uuid를 출력  hwinfo: 하드웨어, 특히 스토리지 디스크에 대한 정보를 볼 수 있는 유틸리티이다. hwinfo --disk | --short | --block                              mount : mount [-o [옵션]] &lt;partition          disk&gt;  (* 영구 마운트 : /etc/fstab에 추가)                      unmount: umount [-o [옵션]] Device의 종류Block Device : Block 단위로 입출력을 하는 Device, Block은 File System의 섹터를 의미Character Device : Character 단위, 즉 바이트 단위로 입출력을 하는 Device, 데이터 관리 기능을 가진 응용 프로그램Network Device : 네트워크 층과 연결되어 있음(루프백 장치, 랜카드와 같은...)|           |      blockDevice       |                   characterDevice                    ||:———:|:———————-:|:—————————————————-:|| 데이터 전송 단위 | Block(File System의 섹터) |                 Character(문자, Byte)                  ||       전송 버퍼 처리     |    System Buffer 사용    |                    응용 프로그램 Buffer                    ||       대표 장치     |        HDD, SSD        |                키보드, 마우스, 모니터, 프린터 등..                 ||         주요 특징  |      File System       | 자체적으로 데이터를 관리하기 위한 기능을 가진  응용 프로그램 사용(DBMS….) |블록 디바이스(Block Device) 요청 처리 방식리눅스 커널은 블록 디바이스를 효율적으로 처리하기 위해 처리할 내용을 큐에 모아두었다가 일정 시간이 지나거나 임계치에 도달하면 블록 디바이스 드라이버에 처리를 요구, 블록 디바이스 드라이버에 요구하는 처리 함수는 두 가지 형식으로 존재(커널 처리에 있어서 두 가지가 동시에 일어나는 경우는 없음)",
        "url": "//linux/2024/05/21/linux-series-15-Volume.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-14-vieditor-html": {
        "title": "[linux Series] 14 Vieditor",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VIVI/ VIMvi –version어떤 vi가 설치됐는지 확인할 수 있다.VIM - Vi IMproved 9.0 (2022 Jun 28, compiled Dec 20 2023 18:58:31)macOS version - arm64Included patches: 1-2136Compiled by root@apple.comNormal version without GUI.  Features included (+) or not (-):+acl               +file_in_path      +mouse_urxvt       -tag_any_white-arabic            +find_in_path      +mouse_xterm       -tcl+autocmd           +float             +multi_byte        +termguicolors+autochdir         +folding           +multi_lang        +terminal-autoservername    -footer            -mzscheme          +terminfo-balloon_eval      +fork()            +netbeans_intg     +termresponse-balloon_eval_term -gettext           +num64             +textobjects-browse            -hangul_input      +packages          +textprop++builtin_terms    +iconv             +path_extra        +timers+byte_offset       +insert_expand     -perl              +title+channel           +ipv6              +persistent_undo   -toolbar+cindent           +job               +popupwin          +user_commands-clientserver      +jumplist          +postscript        -vartabs+clipboard         -keymap            +printer           +vertsplit+cmdline_compl     +lambda            -profile           +vim9script+cmdline_hist      -langmap           -python            +viminfo+cmdline_info      +libcall           -python3           +virtualedit+comments          +linebreak         +quickfix          +visual+conceal           +lispindent        +reltime           +visualextra+cryptv            +listcmds          -rightleft         +vreplace+cscope            +localmap          -ruby              +wildignore+cursorbind        -lua               +scrollbind        +wildmenu+cursorshape       +menu              +signs             +windows+dialog_con        +mksession         +smartindent       +writebackup+diff              +modify_fname      -sodium            -X11+digraphs          +mouse             -sound             -xattr-dnd               -mouseshape        +spell             -xfontset-ebcdic            +mouse_dec         +startuptime       -xim-emacs_tags        -mouse_gpm         +statusline        -xpm+eval              -mouse_jsbterm     -sun_workshop      -xsmp+ex_extra          +mouse_netterm     +syntax            -xterm_clipboard+extra_search      +mouse_sgr         +tag_binary        -xterm_save-farsi             -mouse_sysmouse    -tag_old_static       system vimrc file: \"$VIM/vimrc\"     user vimrc file: \"$HOME/.vimrc\" 2nd user vimrc file: \"~/.vim/vimrc\"      user exrc file: \"$HOME/.exrc\"       defaults file: \"$VIMRUNTIME/defaults.vim\"  fall-back for $VIM: \"/usr/share/vim\"Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H   -DMACOS_X_UNIX  -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1      Linking: gcc   -L/usr/local/lib -o vim        -lm -lncurses  -liconv -framework Cocoa           예시로 +clipboard 여부에 따라 vi에서 클립보드 사용이 불가할 수도 있다.이래서 그냥 대고 복사가 안됐던 것이기도 하다.vi 내용 삭제 명령어            명령어      설명                  x      커서가 있는 문자 한글자 삭제 (반대인 del은 윈도우와 똑같다)              nx      커서가 있는 위치부터 n개의 문자를 삭제              dw      현재 커서에 있는 한 단어 삭제              dd      커서가 있는 라인(행) 삭제              ndd      커서가 있는 라인부터 n개의 라인 삭제              db      커서의 위치에서 거꾸로 한 단어 삭제              D      커서 오른쪽 행 삭제              :5,10d      5~10번째 행 삭제      vi 되돌리기 명령어            명령어      설명                  u      이전 명령 취소 (되돌리기)              U      행 변경 사항 취소, 이전의 최종 행 취소              .      이전 최종 명령 반복      vi 복붙 및 이동 명령어            명령어      설명                  yy      커서가 위치한 줄 복사              Y      행 yank 또는 복사              yh      커서의 왼쪽 문자 복사              yl      커서에 위치한 문자 복사              yi      커서가 위치한 줄과 그 아랫줄 복사              yk      커서가 위치한 줄과 그 윗줄 복사              p      붙여넣기 (행 위로 삽입)              P      붙여넣기 (행 아래에 삽입)              :1,2 co 3      1~2행을 3행 다음으로 복사              :4,5 m 6      4~5행을 6행 위로 이동      # 한줄 복사해당 라인에서 'yy' 누르면 캐시에 저장이 된다.붙여넣기를 원하는 곳으로 이동하여 'p'를 누르면 커서 다음 라인에 붙여넣기가 된다.# 블럭 복사'v'키를 누른 후 커서를 이동하여 블력을 설정한다.(putty의 경우 블럭이 설정되는 모습이 보이나, ssh의 경우 블럭 모습이 나타나지 않으나 실제로는 설정되고 있다.)원하는 부분을 블럭으로 설정한 뒤(설정 완료키는 없다) 'y'키를 누르면 캐시에 복사가 된다.같은 방법으로 원하는 곳으로 이동하여 'p'를 누르면 커서 다음 라인에 붙여넣기가 된다.vi 행 번호 표시            명령어      설명                  :set nu 또는 :set number      에디터의 각 행의 좌측에 행 번호 표시.              :set nonu      에디터의 각 행의 좌측 행 번호 숨기기      vi 검색 명령어            명령어      설명                  /{검색할 문자열}      오른쪽 아래 방향으로 문자열 검색              ?{검색할 문자열}      왼쪽 위 방향으로 문자열 검색              n      문자열의 다음으로 계속 검색              N      문자열의 이전으로 계속 검색      vi 저장 및 종료            명령어      설명                  :w      변경사항 저장              :w      {파일명}\t변경사항 입력한 파일명으로 저장              :wq      변경사항 보관 후 vi 종료.              ZZ      명령과 같음. :w(기록)과 :q(종료) 를 연속적으로 수행.              ZZ      변경사항 보관 후 vi 종료.임시 버퍼의 내용을 vi로 호출할때 사용되었던 파일에 기록한 후 vi를 빠져나옴.              :q!      변경 내용을 저장하지 않고 종료              :q      작업한게 없으면 그대로 종료              :e!      마지막으로 저장했던 내용 이후의 수정한 것들을 취소하고 다시 편집상태로      vi 내용 바꾸기 명령어            명령어      설명                  :s/[대상문자열]/[바꿀문자열]      커서가 위치한 행에서 첫번째로 나오는 대상문자열을 바꿀문자열로 치환              :%s[대상문자열]/[바꿀문자열]      파일 전체에서 모든 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]      범위 내 모든 각 행에서 첫번쨰로 나오는 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]g      범위 내 모든 행에서 대상문자열을 바꿀문자열로 치환              :[범위]s[대상문자열]/[바꿀문자열]gc      범위 내 모든 행에서 대상문자열을 바꿀문자열로 바꾸되 수정할 지 여부를 묻는다      vi 화면 정리            명령어      설명                  Ctrl + l      불필요한 화면정리 후 다시 표시      vi 파일 명령어            명령어      설명      ex                  :r {파일명}      커서 다음에 파일 삽입      :r test.txt              :{행번호} r {파일명}      입력한 파일을 입력한 행번호 다음에 삽입      :10 r test.txt      vi  기타 명령어            문자      설명                  .      현재 line              %      전체 line              $      파일 맨끝 line              1,$      %              2,3      2 ~ 3 line      https://inpa.tistory.com/entry/LINUX-📚-Vi-Vim-에디터-다루기-명령어-💯-정리#vi_내용_삭제_명령어",
        "url": "//linux/2024/05/21/linux-series-14-ViEditor.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-13-tree-html": {
        "title": "[linux Series] 13 Tree",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Linux fileTreeLinuxbin, sbin  bin : user command binaries -&gt; 커맨드 라인 인터페이스 관련된 명령어 실행 파일을 포함 ( ex. cat, cd, ls … )  sbin : system command binaries -&gt; 시스템을 컨트롤하기 위한 파일들 ( ex. systemctl, reboot)연관된 디렉토리 종류는 usr/bin, usr/sbin, usr/local/bin, usr/local/sbin  bin: cd, ls 등의 사용자 커맨드 파일이 위치한 디렉토리 (필수적인 파일만 관리)  sbin: systemctl 등의 시스템 커맨드 파일이 위치한 디렉토리 (필수적인 파일만 관리)  usr/bin: 필요에 의해 설치된 사용자 커맨드 파일이 위치한 디렉토리 (yum 등 패키지 관리자가 관리)  usr/sbin: 필요에 의해 설치된 시스템 커맨드 파일이 위치한 디렉토리 (yum 등 패키지 관리자가 관리)  usr/local/bin: 기타 사용자 커맨드 파일이 위치한 디렉토리 (사용자 또는 설치 파일이 해당 디렉토리에 파일 설치)  usr/local/sbin: 기타 시스템 커맨드 파일이 위치한 디렉토리 (사용자 또는 설치 파일이 해당 디렉토리에 파일 설치)PATHOS 어디서든 해당 위치에 접근할 수 있게 만드는 환경변수이다. 위의 6개 디렉토리는 모두 환경 변수에 등록되어 있어서 해당 폴더들 내부에 있다면바로 명령어로 실행할 수 있다.lib, lib64lib, lib64는 시스템 부팅이나 bin, sbin 디렉토리에 있는 바이너리 파일들 실행에 필요한 공유 라이브러리 디렉토리다.etcetc는 설정 파일을 관리한다. .d를 붙여서 디렉토리인 것을 구별하기도 하는 경우가 있다. 설정 파일은 .conf라는 이름의 형식으로 많이 관리 되어 있다.varvariable data를 뜻한다. 시스템 로그나 웹 로그 파일들을 포함한다.usruniversal system resource 혹은 user의 약자라고 하기도 한다. 리눅스의 여러 사용자들이 공유하는 파일들을 관리한다.optoptional을 의미한다.home, roothome은 개별 사용자의 디렉토리를 관리하는 디렉토리다. 만약 ec2-user라는 이름의 사용자를 만들면 /home/ec2-user라는 디렉토리가 생성된다.FHS( Filesystem Hierarchy Standard ) - 기타 디렉토리media, mnt시스템이 마운팅되는 디렉토리 media는 os가 관리하는 디렉토리 mnt는 커맨드라인으로 마운트하는 디렉토리boot부팅에 필요한 파일들을 포함하는 디렉토리dev마우스 등 디바이스 관련 파일이 존재하는 디렉토리sys디바이스를 관리하기 위한 가상 파일 시스템 디렉토리proc현재 실행 중인 프로세스에 대한 정보를 관리하는 디렉토리runRun-time variable data를 관리한다. 부팅 후 시스템 정보를 관리하는 디렉토리srvFTP, WWW 또는 CVS(???) 같은 특정 서비스의 데이터 파일 위치를 포함한 디렉토리tmp임시 파일을 저장하기 위한 디렉토리 재부팅 시 삭제, 정기적으로 10일 정도 간격으로 삭제된다.lost+found파일 시스템의 복구에 사용되는 데이터 조각들을 포함하고 있다. 재부팅이나 파일 시스템 체크 커맨드 등을 이용할 때 참조https://inpa.tistory.com/entry/LINUX-📚-리눅스-디렉토리-구조#",
        "url": "//linux/2024/05/21/linux-series-13-Tree.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-12-systeminfo-html": {
        "title": "[linux Series] 12 Systeminfo",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SystemInfocat /proc/cpuinfoCPU 정보를 열람할 수 있다.processor       : 0BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 1BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 2BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3processor       : 3BogoMIPS        : 108.00Features        : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant     : 0x0CPU part        : 0xd08CPU revision    : 3Hardware        : BCM2835Revision        : c03114Serial          : 10000000e19a2b57Model           : Raspberry Pi 4 Model B Rev 1.4ex)#코어 수grep -c processor /proc/cpuinfo # 물리 CPU 개수$ grep ^processor /proc/cpuinfo  | wc -l&gt; 4 # 현재 PC의 물리 CPU 수는 4개.# CPU 당 물리 코어 개수$ grep 'cpu cores' /proc/cpuinfo | tail -1&gt; 4 # 현재 PC의 CPU 당 물리 코어 개수는 4개# Hyper Threading 여부$ cat /proc/cpuinfo | egrep 'siblings|cpu cores' | head -2&gt; siblings     :    4&gt; cpu cores    :    4lscpu/proc/cpu를 더 간단하게 볼 수 있는 명령top-n : 지정한 숫자만큼 화면 출력을 갱신한 후 수행-u : 지정한 사용자의 프로세스를 모니터링-b : 출력 결과를 파일이나 다른 프로그램으로 전달-d : 화면 갱신 주기를 초 단위로 설정-p : 지정한 PID 프로시스를 모니터링free전체 메모리(사용하고 있는 메모리, 남은 메모리, 버퍼 메모리)에 대한 상태를 확인-b : byte 단위 표시-m : mb 단위 표시-g : gb 단위 표시-k : kb 단위 표시-l : 최고/최저 메모리 상황 구분해서 표현-s N : N초마다 출력df디스크 남은 용량(disk free) 확인-k : kb-m : mb-h : human(??)du현재 디렉토리에서 서브 디렉토리까지 사용량(disk usage) 확인-a : 하위 디렉토리에 포함된 파일까지 모든 파일 사용정보 용량 표시-s : 지정한 디렉토리 내에 존재하는 모든 파일, 서브 디렉토리의 합 -h : 깔끔하게hostname -I호스트 네임 출력ifconfig== ipconfig[enp0s3] : 네트워크 인터페이스[flags] : 네트워크 카드의 상태 표시[mtu] : 네트워크 인터페이스의 최대 전송 단위(Maximum Transfer Unit)[inet] : 네트워크 인터페이스에 할당된 IP 주소[netmask] : 네트워크 인터페이스에 할당된 넷마스크 주소[broadcast] : 네트워크 인터페이스에 할당된 브로드캐스트 주소[inet6] : 네트워크 인터페이스에 할당된 IPv6 주소[prefixlen] : IP 주소에서 서브 넷 마스크로 사용될 비트 수[scopeid] : IPv6의 범위. LOOPBACK / LINKLOCAL / SITELOCAL / COMPATv4 / GLOBAL[ether] : 네트워크 인터페이스의 하드웨어 주소[RX packets] : 받은 패킷 정보[TX packets] : 보낸 패킷 정보[collision] : 충돌된 패킷 수[Interrupt] : 네트워크 인터페이스가 사용하는 인터럽트 번호ip aifconfig와 흡사하지만 UP&amp;DOWN 정보, ip, mac 정보 확인 가능",
        "url": "//linux/2024/05/21/linux-series-12-SystemInfo.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-11-symbolic-html": {
        "title": "[linux Series] 11 Symbolic",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Symbolic linkHardLink vs. Symbolic Link(softLink)먼저 리눅스에는 inode라는 개념이 있다. inode는 유닉스 계통의 파일 시스템에서 사용하는 자료구ㄷ조이다. 모든 파일과 디렉토리는 inode를 가지고 있다. 그리고 여기에는 파일의 허가권, 소유권, 파일의 실제 위치 등 중요한 정보들이 있다.inode는 실제 파일 내용을 갖고 있는 것이 아니라 파일의 내용을 갖고 있는 주소를 포함한다.776844 app  388947 config  259817 cronLog  389047 file  260194 homebridge  128107 pi  260893 projectspi@ubuntu:/home$HardLink하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다. 따라서 원본 파일이 사라지더라도 데이터만 살아 있다면 원본 파일에 접근 가능하다.  동일한 파일 시스템 내에서만 하드 링크 생성 가능  디렉터리 링크 불가능  대상파일과 동일한 inode 번호와 허가권을 가짐  대상 파일을 옮기거나 삭제해도 대상 파일을 참조한다.  소프트링크는 원본의 존폐에 따라 사용할 수 있지만 하드링크는 원본이 삭제되더라도 원본과 동일한 내용의 파일을 가지므로 자원을 공유하면서도 데이터를 안전하게 관리하고자할 때 사용한다.# 하드링크 생성$ ln [대상파일] [하드링크파일]Symbolic(soft) link심볼릭 링크는 생성하면 또 다른 inode를 생성해서 이를 바라본다.  심볼릭 링크는 하드 링크의 단점을 보완하려고 탄생  파일 시스템과 대상 파일이 존재하는 파일 시스템이 달라도 생성 가능하다.  하드 링크는 파일만 참조 가능하고 디렉토리는 참조 불가하지만 심볼릭 링크는 가능하다.  대상 파일과 심볼릭 링크 파일은 서로 inode 번호와 파일 허가권이 다르다.  대상 파일의 inode가 아닌 이상 파일의 데이터 경로만을 참조  원본이 존폐 여부에 영향을 받는다.  파일 종류 l로 시작한다.# 심볼릭 링크 생성$ ln -s [대상파일] [심볼릭링크파일]",
        "url": "//linux/2024/05/21/linux-series-11-Symbolic.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-10-status-html": {
        "title": "[linux Series] 10 Status",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - status  프로젝트 중 OOM 으로 모니터링할 필요가 있어서 찾은vmstat(Virtual Memory STAT)리눅스의 프로세스, 메모리, 페이징, I/O 블록, CPU 활동 사항 출력-n\t주기적으로 헤더를 출력하지 말고, 한번만 헤더를 출력-a (active)\tbuffer와 cache대신 active/inactivate로 메모리사용량 결과 출력-t (timestamp)\t날짜 + 시간을 출력-w  (wide)\t출력결과의 너비를 맞춤-d  (disk)\t디스크 상태조회",
        "url": "//linux/2024/05/21/linux-series-10-Status.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-09-shellscript-html": {
        "title": "[linux Series] 09 Shellscript",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ShellScript  CICD 등 작업 중 찾은 문서ShellScriptShell 문법 검사기쉘 종류#!/usr/bin/bash ## 어떤 쉘로 스크립트를 실행할지 정의echo $(which bash)실행 방법  권한 주고 실행    $ vi script.sh# ... 작성후 종료$ chmod +x script.sh or chmod 755 script.sh$ ./script.sh # 쉘 스크립트 실행        bash로 실행```shell$ vi script.sh    … 작성후 종료  bash script.sh## Declare variables변수의 타입에는 로컬변수와 전역변수, 환경변수, 예약변수, 매개변수 등 다양히이 존재한다.- 변수는 대, 소문자를 구별한다.- 변수의 이름은 숫자를 포함할 수 있지만, 숫자로 시작할 수 없다.- 변수에는 모든 값을 문자열로 저장된다.- 변수에는 자료형을 기입하지 않는다. (int number, char names[10]), 즉 아무런 값을 다 넣을 수 있다.- 값을 사용할 때는 변수명 앞에 특수문자 \"$\"를 사용한다. (Ex. echo ${data})- 값을 대입(삽입)할 때는 특수문자 \"$\"를 사용하지 않는다. (Ex. data=mac)- 변수를 생성할 때는 \"=\" 대입문자 앞뒤로 공백이 없어야 한다. (Ex. data=\"abcd\")## Local/ Global variables기본적으로 변수 선언하면 전역이다. 함수 내부에서만 지역변수다. ```shell# 기본적으로 전역 변수로 지정string=\"hello world\"function string_test() {    # local을 붙여야 지역변수로 인식. 만일 local을 빼면 전역변수 덮어쓰기가 되버림    local string=\"hello local @@\"    echo ${string}}# 함수 호출string_test # &gt; hello local @@echo ${string} # &gt; hello world# 변수 초기화unset stringType# -r 읽기 전용 타입 (상수 const라고 보면 된다)declare -r var1readonly var1# -i 정수형 타입declare -i numbernumber=3echo \"number = $number\"     # number = 3# -a 배열 타입declare -a indices# -A 연관배열(MAP) 타입declare -A map# -f 함수 타입declare -f# -x 환경변수(export) 지정declare -x var3 # 스크립트 외부 환경에서도 이 변수를 쓸 수 있게 해준다.Environment variables쉘 스크립트에서 변수 명 앞에 export을 붙여주면 환경 변수(environment variable)로 설정되어 자식 스크립트에서 사용 가능하다.다만 환경 변수 사용시 시스템에 미리 정의된 예약 변수(reserved variable)와 변수명이 겹치지 않게 주의하자.Parameter./test($0) a($1) b($2) …shell 실행 시 매개변수를 받을 수 있다. $와 숫자 조합으로 표현한다.  $0은 scriptName으로 고정 $숫자로 변수를 받을 수 있다.  $#는 변수 개수  $*는 전체 인자  $!는 실행을 백그라운드로 보내진 마지막 프로그램 프로세스 번호  $$는 PID  $?는 리턴 값Reserved variables변수| 설명:—:|:—:HOME| 사용자 홈 디렉토리PATH| 실행 파일의 경로여러분이 chmod, mkdir 등의 명령어들은 /bin이나 /usr/bin, /sbin에 위치하는데, 이 경로들을 PATH 지정하면 여러분들은 굳이 /bin/chmod를 입력하지 않고, chmod 입력만 해주면 된다.LANG| 프로그램 실행 시 지원되는 언어UID| 사용자의 UIDSHELL| 사용자가 로그인시 실행되는 쉘USER| 사용자의 계정 이름FUNCNAME| 현재 실행되고 있는 함수 이름TERM| 로그인 터미널command  set : 셸 변수를 출력하는 명령어  env : 환경 변수를 출력하는 명령어  export : 특정 변수의 범위를 환경 변수의 데이터 공간으로 전송하여 자식 프로세스에서도 특정 변수를 사용 가능하게 한다. 전역 변수의 개념  unset : 선언된 변수를 제거한다.operation  expr  let  $(())expr  expr는 역따옴표를 반드시 감싸준다. 역따옴표 대신 $(( )) 해줘도 동작은 한다.  expr을 사용할 때 피연산자와 연산자 사이에 공백이 필요하다.  산술 연산할때 우선순위를 지정하기위해 괄호를 사용하려면 \\처리를 해줘야 한다.  곱셈 문자 *는 \\처리를 해주어야 한다.```shell#!/bin/bashnumber1=10number2=20plus=expr $number1 + $number2 minus=expr $number1 - $number2mul=expr $number1 \\* $number2 # 곱셈에는 * 를 이용한다.div=expr $number1 / $number2rem=expr $number1 % $number2echo “plus:     ${plus}”echo “minus:    ${minus}”echo “mul:      ${mul}”echo “div:      ${div}”echo “rem:      ${rem}”### let```shellnum1=42num2=9 let re=num1+num2 #Addecho \"add:$re\"let re=num1-num2 #Subecho \"sub:$re\"let re=num1*num2 #Mulecho \"mul:$re\"let re=num1/num2 #Divecho \"div:$re\"let re=num1%num2 #Modecho \"mod:$re\"$(())num1=42num2=9 echo add:$((num1+num2))echo sub:$((num1-num2))echo mul:$((num1*num2))echo div:$((num1/num2))echo mod:$((num1%num2))block annotation&lt;코드라인&gt;: &lt;&lt; \"END\"              #주석 시작echo \"여기서부터 \"echo \"test_01\"echo \"test_02\"echo \"test_03\"echo \"test_04\"echo \"test_05\"echo \"test_06\"echo \"test_07\"echo \"여기까지 주석처리 됨\"END                    #주석 끝echo \"여기는 주석이 안되어 있어 출력 \"vi 에디터로 여러줄 주석 방법기본 여러줄 주석 문법이 별로라면, vi 단축키를 이용한 주석 처리 방법이 있다.  vi 편집기를 열고  ctrl + v를 눌러 비주얼 모드로 진입한다. (비주얼 모드는 vim 이 설치 되어 있어야 한다.)  주석을 처리하고자 하는 라인까지 방향키 또는  vi방향키를 이용하여 이동한다.  shift + i 누르고 #을 입력한다.  esc 키를 여러번 누른다.  주석 처리 됨을 확인한다.if배쉬의 if문의 특이한 점은 fi 와 대괄호[ ] 이다.여타 언어와 달리 중괄호를 안쓰기 떄문에 fi로 if문의 끝을 알려주어야 하며,주의해야 할 점은 if문 뒤에 나오는 대괄호 [ ] 와 조건식 사이에는 반드시 공백이 존재해야 한다.if [ 값1 조건식 값2 ]then    수행1else    수행2fi# 가독성 좋기 위해 then을 if [] 와 붙여쓰려면 반드시 세미콜론 ; 을 써야한다.if [ 값1 조건식 값2 ]; then    수행1else    수행2fi비교 연산문자1 = 문자2             # 문자1 과 문자2가 일치 (sql같이 = 하나만 써도 일치로 인식)문자1 == 문자2            # 문자1 과 문자2가 일치문자1 != 문자2            # 문자1 과 문자2가 일치하지 않음-z 문자                   # 문자가 null 이면 참-n 문자                   # 문자가 null 이 아니면 참문자 == 패턴              # 문자열이 패턴과 일치문자 != 패턴              # 문자열이 패턴과 일치하지 않음값1 -eq 값2             # 값이 같음(equal)값1 -ne 값2             # 값이 같지 않음(not equal)값1 -lt 값2             # 값1이 값2보다 작음(less than)값1 -le 값2             # 값1이 값2보다 작거나 같음(less or equal)값1 -gt 값2             # 값1이 값2보다 큼(greater than)값1 -ge 값2             # 값1이 값2보다 크거나 같음(greater or equal)  이중 괄호  (( expression ))expression 에는 수식이나 비교 표현식이 들어갈 수 있다.수식| 설명:—:|:—:!|논리 부정~|비트 부정**|지수화&lt;&lt;|비트 왼쪽 쉬프트&gt;&gt;|비트 오른쪽 쉬프트&amp;|비트 단위AND||비트 단위 OR&amp;&amp; |논리 AND|| |논리 ORnum++ |후위증가num-- |후위감소++num |전위증가--num |전위감소num1=35num2=48# 이중 소괄호를 쓰면 조건문을 문자 대신 기호로 표현 가능하다. 단, 소괄호 안에 따옴표 쓰면 안된다.if (( ${num1} &lt; ${num2} )); then    echo \"yes\"fiif (( ($num1 * $num2) - $num2 &gt; 200 )); then\techo \"&gt;200\"else\techo \"&lt;200\"fi파일 검사 연산  이중 대괄호  [[ “1.8.3” == 1.7.* ]]&amp;&amp;, ||, = ~ * (정규식 매칭) 과 같은 확장 expression test 기능을 대괄호 내에 사용할 수 있게 한다.그냥 대괄호의 개선버젼 정도로 생각하면 된다.switch-casecase ${var} in    \"linux\") echo \"리눅스\" ;; # 변수var값이 linux라면 실행     \"unix\") echo \"유닉스\" ;;        \"windows\") echo \"윈도우즈\" ;;        \"MacOS\") echo \"맥OS\" ;;        *) echo \"머야\" ;; # default 부분esacCOUNTRY=koreacase $COUNTRY in  \"korea\"|\"japan\"|\"china\") # or 연산도 가능하다    echo \"$COUNTRY is Asia\"    ;;  \"USA\"|\"Canada\"|\"Mexico\")    echo \"$COUNTRY is Ameria\"    ;;  * )    echo \"I don't know where is $COUNTRY\"    ;;esacfor statementfor#!/bin/bash## FOR# 초기값; 조건값; 증가값을 사용한 정통적인 for문for ((i=1; i&lt;=4; i++)); do    echo $idonefor-in#!/bin/bash# 루프 돌 데이터에 띄어쓰기가 있으면 각각 돌음for x in 1 2 3 4 5do\techo \"${x}\"done# 변수를 사용한 반복문data=\"1 2 3 4 5\"for x in $datado\techo ${x}done# !/bin/bash# 루프 돌 데이터에 띄어쓰기가 있으면 각각 돌음for x in 1 2 3 4 5do\techo \"${x}\"done# 변수를 사용한 반복문data=\"1 2 3 4 5\"for x in $datado\techo ${x}done# 배열을 사용한 반복문arr=(1 2 3 4 5)for i in \"${arr[@]}\" # arr[@] : 배열 전체 출력do\techo \"${i}\"done# sequence를 통한 for문. seq라는 프로세스가 순서대로 숫자를 출력해 주는 역할을 bash에 사용한 것이다.for num in `seq 1 5`do  echo $numdone# range를 사용한 반복문. {..} 중괄호와 점 두개를 쓰면 range처리가 된다.for x in {1..5}do\techo ${x}done# 배열을 사용한 반복문arr=(1 2 3 4 5)for i in \"${arr[@]}\" # arr[@] : 배열 전체 출력do\techo \"${i}\"done##FOR-IN# sequence를 통한 for문. seq라는 프로세스가 순서대로 숫자를 출력해 주는 역할을 bash에 사용한 것이다.for num in `seq 1 5`do  echo $numdone# range를 사용한 반복문. {..} 중괄호와 점 두개를 쓰면 range처리가 된다.for x in {1..5}do\techo ${x}doneexample# 파일 리스트 출력for line in `ls` # 역따옴표 써서 ls를 문자가 아닌 하나의 명령어로 실행do echo $line # 해당 위치에 파일이나 디렉토리들이 출력done# 한줄 문법 (한줄로 쓰면 터미널에서 직접 스크립트를 실행 할 수 있다)for line in `ls`; do echo $line; donewhilecount=0while [ ${count} -le 5 ]; do    echo ${count}    count=$(( ${count}+1 ))donecount=0while (( ${count} &lt;= 5 ));  # 이중괄호 사용하면 논리기호 사용 가능do    echo ${count}    count=$(( ${count}+1 ))doneArray#!/bin/bash# 배열의 크기 지정없이 배열 변수 선언# 굳이 'declare -a' 명령으로 선언하지 않아도 바로 배열 변수 사용 가능함declare -a arrayarr=(\"test1\" \"test2\" \"test3\") # 배열 선언 및 지정echo ${arr[0]}  # test1# 기존 배열에 1개의 배열 값 추가 3가지 방법arr[3]=\"test4\" arr+=(\"test5\")arr[${#arr[@]}]=\"test6\" # 배열 길이를 인덱스로 사용해 pushecho ${arr[@]}  # arr의 모든 데이터 출력echo ${arr[*]}  # arr의 모든 데이터 출력echo ${#arr[@]} # arr 배열 길이 출력echo ${arr[@]:2:3} # 2부터 3개의 요소Map# 연관배열 생성declare -A map=([hello]='world' [long]='long long long string' [what is it]=123)declare -p map # 연관배열 정보 출력# &gt; declare -A map=([long]=\"long long long string\" [\"what is it\"]=\"123\" [hello]=\"world\" )echo \"map[hello]=${map[hello]}\" # &gt; map[hello]=worldkey=hello # 변수를 인덱스로 넣어줘도 된다. (MAP의 특성)echo \"map[key]=${map[${key}]}\" # &gt; map[key]=worldScannerecho -n \"String input : \"read [변수명] # &lt;- 터미널에서 입력된 인풋값이 변수에 저장되게 된다.echo \"user input : $변수명 # 입력된 값 출력function다른 프로그래밍 언어와 달리 쉘 스크립트에서는 함수명 앞 function은 써주지 않아도 알아서 인식된다. 또한, 함수를 호출할때는 괄호를 써주지 않고 호출해야한다는 점이 다르다.그리고 함수 호출 코드는 함수 코드보다 반드시 뒤에 있어야 된다. 함수 코드 보다 앞에서 호출 시 오류가 발생하기 때문이다.#!/bin/bashfunc(){\techo \"func()\"}function string_test() {    echo \"string test\"    echo \"인자값: ${@}\"}#함수 호출func# 함수에 인자값 전달하기(공백의로 뛰어서 2개의 인자값을 넘김)string_test \"hello\" \"world\"인자는 공백으로 구분하여 하나씩 넣으면 된다.function test3(){    param1=$1    param2=$2    echo $param1 # a    echo $param2 # b    echo $@ # 파라미터 전체 출력}test3 \"a\" \"b\"종료 상태종료 코드란, exit 명령으로 프로그램을 종료시키면서 사용자에게 프로그램 종료의 이유를 알리기 위하여 반환하는 값이다.쉘 스크립트 내에서 exit 명령어가 실행되면 스크립트가 종료되며 부모 프로세스에 종료 상태를 전달할 수 있는데 이 값은 프로그램 내에서 임의로 지정할 수도 있다.#!/bin/bashexit 16 # 강제 종료echo \"wtf\" # 실행안됨0 은 성공 이외는 모두 오류다.Shell command(command substitution)$() 안의 실행문을 실행하고 그 결과를 $()으로 리턴한다.#!/bin/bash# 그냥 date 문자열 출력echo date# 백틱으로 감싸주면 date 명령어가 실행되게 된다.echo `date`# $()도 마찬가지echo $(date)# shell executionecho \"I'm in `pwd`\"echo \"I'm in $(pwd)\"출처: https://inpa.tistory.com/entry/LINUX-쉘-프로그래밍-핵심-문법-총정리 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-09-ShellScript.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-08-permission-html": {
        "title": "[linux Series] 08 Permission",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Permission  서버 반영/CICD 작업 중 권한 문제로 고생해서 정리Permissionuser : 파일 소유주group : 파일을 만든 소유주가 속한 그룹의 사용자other : 기타 사용자            문자 값      파일      디렉토리                  r(4)      파일에 대한 읽기 권한. 열기, 읽기 허용      디렉토리 내의 파일을 나열할 수 있게 허용              w(2)      파일에 대한 쓰기 권한. 쓰기, 잘라내기 허용  이름 변경이나 파일 삭제 허용하지 않음. 파일 삭제나 파일 이름 변경은 디렉토리 속성에 의해 결정됨      디렉토리 내의 파일들을 생성, 삭제, 이름변경이 가능하도록 허용              x(1)      파일에 대한 실행 권한 파일이 프로그램으로 처리되고 파일이 실행되도록 허용 스크립트 언어에서 작성된 프로그램 파일들은 읽기 가능으로 설정 되어 있어야만 실행 가능함      디렉토리 내에서 탐색을 위해 이동 할 수 있도록 허용 (디렉토리에 들어올 수 있도록 허용 )      chmod : 허가권 변경-R, --recursive\t특정 디렉터리 내의 파일과 디렉터리에 대해 재귀적으로 허가권 변경-C, --changes\t변경된 파일이나 디렉터리에 대한 자세한 정보를 출력-f , --silent, --quite\t대부분의 에러메시지 출력을 제한--reference\t모드 대신 파일에 지정한 모드를 사용 chown : 사용자 및 그룹 소유권 변경chown [options] owner:[group] filesoption-R, --recursive\t특정 디렉터리 내의 파일과 디렉터리에 대해 재귀적으로 허가권 변경-C, --changes\t변경된 파일이나 디렉터리에 대한 자세한 정보를 출력-f , --silent, --quite\t대부분의 에러메시지 출력을 제한--reference\t모드 대신 파일에 지정한 모드를 사용 chgrp : 파일이나 디렉토리의 그룹 소유권만 변경chgrp [options] group filehttps://inpa.tistory.com/entry/LINUX-📚-파일-권한-소유권허가권-💯-정리#",
        "url": "//linux/2024/05/21/linux-series-08-Permission.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-07-network-html": {
        "title": "[linux Series] 07 Network",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - NetstatNetstatnetstat [option] [|grep portNumber or ServiceName]options  -l (listen) : 연결 가능한 상태  -n (number port) : port  -t (tcp) : tcp  -u (udp) : udp  -p (pid) : PID  -a (all) : all  -i : 이더넷 카드별 정상/ 에러/ 드랍 송수신 패킷 수 확인  -r : 라우팅 테이블  -s : 네트워크 통계nslookupDNS 관련 확인하기 위해서 사용traceroutetraceroute는 목적지에 도달하기까지 경로를 추적한다.",
        "url": "//linux/2024/05/21/linux-series-07-Network.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-06-journalctl-html": {
        "title": "[linux Series] 06 Journalctl",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Journalctl  당시 프로젝트 중 oom이 잦아서 아마존 리눅스에서 로그를 보려하는데amazonlinux가 /var/log/messages에 로그를 저장을 안해서 찾아본 문서AmazonLinux /var/log/messages 에 로그가 없어서journalctl 이란?  systemd의 서비스 로그를 확인할 수 있다.  systemd-journald.service에 의해서 systemd의 정보들을 분석한다.옵션  -a : 표시할 수 없는 문자가 있거나 매우 긴 경우에도 모든 Log 내용을 출력  -b : 마지막 부팅 후의 Log만 출력  -r : 최신항목이 먼저 표시되도록 역순으로 출력  -c : 커서가 지정한 저널의 위치부터 Log 표시를 시작  -f : 가장 최근 Log만 표시하고 새롭게 추가되는 Log는 계속 출력  -k : 커널 메시지만 출력 (dmesg랑 같음)  -q : 일반 사용자로 실행될 때 접근할 수 없는 시스템 저널에 관한 경고메시지를 표시하지 않음  -u : unit으로 systemctl list-units에서 출력되는 첫번째 항목  -p : 메시지의 우선순위로 log level을 의미  emerg=0, alert=1, crit=2, err=3, warning=4, notice=5, info=6, debug=7  -o : Log 출력 형식을 설정          short : 기본값으로 syslog파일의 형식과 동일하다. 한 행에 하나의 Log만 출력      short-iso : short와 비슷하지만 ISO 8601의 시간 형식으로 출력      short-precise : short와 비슷하지만 마이크로 초 단위로 시간 출력      short-monotonic : short와 비슷하지만 단조로운 시간 형식으로 출력      verbose : 전체 Log를 모두 자세하게 출력      export : Log내용을 내보낸다. (백업 및 전송에 적합한 바이너리 스트림으로 직렬화)      json : 한줄에 하나씩 JSON 데이터 구조로 형식화      json-pretty : JSON 데이터 구조로 형식화 하지만 여러줄로 형식을 지정하여 사람이 읽을 수 있게 한다.      json-see : JSON 데이터 구조로 형식화 하지만 Server-Sent Events에 적합한 형식으로 한다.      cat : 매우 간결한 출력을 생성하며 메타 데이터가 없고 Log만 표시하며 시간은 표시하지 않음        -l : 출력되는 Log의 필드를 줄일때 사용, 기본값은 전체 필드를 표시하여 사용자가 해당 필드를 붙이거나 자를 수 있도록 한다.  _UID= 33 : 33번 UID를 가진 프로세스에 대한 Log를 출력  --disk-usage : 저널 파일의 디스크 사용량을 표시 (압춘된 모든 더널 파일과 사용중인 저널 파일의 합계를 표시)설정파일vi /etc/systemd/journald.conf[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitInterval=30s#RateLimitBurst=1000#SystemMaxUse=    -&gt; journal log 파일의 최대 Size를 지정#SystemKeepFree=#SystemMaxFileSize=#RuntimeMaxUse=#RuntimeKeepFree=#RuntimeMaxFileSize=#MaxRetentionSec=#MaxFileSec=1month  -&gt; journal log 파일의 최대보관일수를 지정#ForwardToSyslog=yes#ForwardToKMsg=no#ForwardToConsole=no#ForwardToWall=yes#TTYPath=/dev/console#MaxLevelStore=debug#MaxLevelSyslog=debug#MaxLevelKMsg=notice#MaxLevelConsole=info#MaxLevelWall=emerg사용법  마지막 부팅 후 로그 보기    journalctl -b    오늘 날짜 로그 보기    journalctl –since=today    특정 기간별 로그 보기    journalctl –since “2017-05-25 00:00:00” –until “2017-05-30 10:30:00”    journalctl –since “1 hour ago”    journalctl –since “2 days ago”    특정 서비스 데몬 로그 보기    journalctl -u sshd    특정 이벤트 속성 조회    journalctl -p crit    특정 서비스데몬 및 속성과 날짜 로그 보기    journalctl -u libvirtd –since=yesterday -p err    Error 로그 자세히 보기    journalctl -p err -o verbose    특정 이벤트 조회    journalctl /sbin/crond    밑에서부터 로그 보기    journalctl -f    journalctl -r -b    UID 로 검색 (id)journalctl _UID=108journalctl이 느릴때(btrfs)  Log의 크기를 확인    journalctl –disk-usage    로그를 저장하는 파일 데이터베이스에 단편화를 확인    filefrag /var/log/journal//    단편화를 제거    btrfs fi defrag -v -f -clzo /var/log/journal//  ",
        "url": "//linux/2024/05/21/linux-series-06-Journalctl.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-05-input-output-html": {
        "title": "[linux Series] 05 Input_output",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Input/ OutputInput/ Output명령을 재지정해서 파일로부터 입력받거나 파일로 출력하는 등 출력, 입력 방향을 변경할수 있다.      표준 입력(stdin) : 표준 입력이라고 부르는 곳에서 입력 내용을 가져옴, 기본적으로 키보드에 직접 연결    표준 출력(stdout) : 명령이나 프로그램 등의 실행 결과를 표준 출력에 전송, 기본적으로 화면과 연결 되어 있고 디스크파일에 따로 저장하지 않음    표준 오류(stderr) : 명령이나 프로그램 등의 상태 및 오류 메시지를 표준 에러에 전송, 기본적으로 화면과 연결되어 있고 디스크파일에 따로 저장하지 않음  Output Redirection  명령의 실행 결과나 에러 상황을 화면에 출력하지 않고 파일로 저장  &gt; 연산자를 사용한 표준 출력 재지정 (파일명 앞에 &gt; 연산자를 사용)  &gt; 연산자로 출력 방향을 지정할 때 목적 파일은 항상 처음부터 다시 작성된다. (파일 덮어씀)  만일 파일 내용을 초기화 안시키고 이어서 쓰고싶다면, &gt;&gt; 연산자로 이어쓰기 를 지정한다. &gt;&gt;연산자는 기존 파일에 있는 정보에 이어서 추가적으로 내용을 기입 해준다.연산 조합$ 명령 &gt;&amp; 파일명 # : 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력$ 명령 &gt;&gt;&amp; 파일명 # : 명령이 실행된 표준 출력의 결과와 에러를 파일로 덧붙여 출력$ 명령 &gt;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과를 파일로 출력$ 명령 &gt;&amp;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력$ 명령 &gt;&gt;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 파일에 덧붙여 출력$ 명령 &gt;&gt;&amp;! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일에 덧붙여 출력Input Redirection  키보드 입력을 파일에서 받도록 대체 하는 것  &lt; 연산자를 사용해서 키보드로 연결한 표준 입력 방향을 파일로 변경  cat 명령어를 사용하는 것과 동일한 결과를 나타냄Error Redirection명령어 실행에서 에러가 발생했을때, 원래동작은 그냥 화면에 출력하고 끝이지만,명령어를 통해 출력되는 에러 내용을 파일등으로 저장 및 출력하도록 재지정하는 것이다.$ ls -l nullfile 2&gt; err.txt# ls -l nullfile은 실패하는 명령어이다. nullfile이 디렉토리에 없을경우 실패하게 된다.# 그러한 실패err를 (2)표준오류 지정을 통해 err.txt파일에 저장한다# 표준 입력 : 0# 표준 출력 : 1# 표준 오류 : 2pipe표준 출력을 표준 입력으로 받는 것 즉, 명령어의 결과를 다시 어떤 명령어의 입력으로 받을 때 사용한다.  둘 이상의 명령을 함께 묶어 출력의 결과를 다른 프로그램의 입력으로 전환 하는 기능  즉, 명령어의 표준 출력을 또 다른 명령어의 표준 입력과 연결  명령어와 명령어의 연결은 | 기호를 사용  | 기호 앞의 명령 결과가 뒤의 명령에 입력 데이터로 사용cat /etc/passwd | grep \"root\" # == grep \"root\" /etc/passwd# /etc/passwd의 내용이 grep의 입력값으로 받아 root를 필터링# 디렉토리 개수 확인하기 $ ll | grep \"^d\" | wc -l# * ll = ls -l : List 형태로 출력# * grep \"^d\" : d로 시작하는 행 필터링 (행의 앞글자 d는 directory를 의미)# * wc -l은 행의 개수를 출력# -&gt; ll로 디렉토리 파일들을 출력하고, 그 출력 내용을 d로 시작되는 파일만 필터링하고, 필터링 된 내용의 개수를 출력출처: https://inpa.tistory.com/entry/LINUX-📚-입출력-재지정-파이프-명령어-정리 [Inpa Dev 👨‍💻:티스토리]EOT/ EOFBash 쉘에서 HEREDOC 구문의 전형적인 형식직접 입력한 텍스트를 파일에 저장할 때 주로 사용한다.시작 및 종료를 알리는 키워드로는 흔히 EOF(또는 EOT)를 쓰는데, 임의로 정하는 것이므로 다른 것(예: AAA, HELLO)도 가능하다.EOF는 End of File, EOT는 End of Text이라는 의미이다.cat &lt;&lt;EOF &gt; file1.txt&gt; hello&gt; world&gt; EOFuser01@localhost:~$ cat file1.txthelloworld",
        "url": "//linux/2024/05/21/linux-series-05-Input_Output.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-04-grep-html": {
        "title": "[linux Series] 04 Grep",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GrepGrep참조Input/Ouput Redirection사전 지식Regexp            메타문자      의미      예시      설명                                ^      행의 시작      $ grep ‘^linux’      linux로 시작하는 행                            $      행의 끝      $ grep ‘linux$’      linux로 끝나는 행                            ＼&lt;      단어의 시작      $ grep ‘＼&lt;linux’      linux로 시작하는 단어를 포함하는 행                            ＼&gt;      단어의 끝      $ grep ‘linux＼&gt;’      linux로 끝나는 단어를 포함하는 행                            .      임의의 모든 문자 종류 하나      $ grep ‘l…x’      l과 x사이에 세글자만 있을 수 있음                            ?      문자가 한개가 있거나 없거나      $ grep ‘lin?x’      ?에 문자하나가 들어가는 것을 검색                            *      문자가 여러개 들어가거나 없거나      $ grep ‘linux’$ grep ‘lin’$ grep ‘lx’$ grep ‘linux’      linux를 모두 검색(여러 파일의 이름을 표현할 때 사용하고, 단독으로 * 사용하면 모든 파일을 나타냄)                            |      or 기호      $ grep ‘ab      cd      ef’      ab나 cd나 ef 셋 중 하나라도 들어있으면 검색              ＼()      특정 기호 or 메타 문자를 무시(문자 그 자체를 나타냄)      $ grep ‘lin＼.＼x’      .문자를 대응하는 것이 아니라 lin.x라는 문자를 검색                            []      []는 안에 내용을 넣어 그 문자들 중 한문자를 의미      $ grep ‘linux[123]’      linux1, linux2, linux3을 검색                            [0-9], [a-z]      숫자나 알파벳은 범위로 설정 가능      $ grep ‘linux[0-9]’      linux1부터 linux9까지 검색                            [^]      []안에 있는 ^는 부정을 의미안에 있는 문자를 제외한다는 뜻      $ grep ‘linux[^1-3]’      linux1 부터 linux3까지를 제외한 문자 검색                            ＼&lt;＼&gt;      ＼&lt;는 단어의 시작＼&gt;는 단어의 끝(위에 있는 지시자 합친것)      $ grep ‘＼&lt;linux＼&gt;’      linux로 시작하는 단어, linux로 끝나는 단어 검색예를 들어 alinux2와 같이 중간에 linux가 있는 것은 안됨                            a＼{n＼}      문자 a를 n번 반복      $ grep ‘a＼{2＼}’      a 문자가 2번 연속 반복되는 것을 검색                            a＼{n,＼}      문자 a를 적어도 n번 이상 반복 (콤마가 있음)      $ grep ‘a＼{2,＼}’      a 문자가 최소한 2번 이상 반복되는 것을 검색                            a＼{m,n＼}      문자 a를 m번 이상 n번 이하로 반복 (반복 범위 지정)      $ grep ‘a＼{2,4＼}’      a 문자가 2번 이상 4번 이하로 반복되는 부분                            ＼(..＼)      다음 사용을 위해 태그를 붙이는 역할최대 9개까지 사용가능      $ grep ＼(linux＼)A＼1B      linuxA에 ＼1이 태그되어linuxAlinuxB로 대응                    출처: https://inpa.tistory.com/entry/LINUX-📚-정규표현식-과-grep-명령어-정복하기-패턴-검색-확장브래킷 [Inpa Dev 👨‍💻:티스토리]Bracket브래킷|의미:—:|:—:[:alnum:]|A-Z, a-z, 0-9 알파벳 문자와 숫자로 이루어진 문자열[:alpha:]|A-Z, a-z 알파벳 문자[:blank:]|\\x09 스페이스와 탭[:cntrl:]|컨트롤 제어 문자[:digit:]|0-9 숫자[:graph:]|!-~ 공백이 아닌 문자(스페이스, 제어 문자들을 제외한 문자)[:lower:]|a-z 소문자[:print:]|graph와 유사하지만 스페이스 문자를 포함[:punct:]|!-/:-@[-‘{-~ 문장 부호 문자[:space:]|\\t\\v\\f 모든 공백 문자(newline 줄바꿈, 스페이스, 탭)[:upper:]|A-Z 대문자[:xdigit:]|16진수에서 사용할 수 있는 숫자vi 에서 정규표현식으로 검색/없이$ # 없이로 끝나는 문자열 검색/...세 # 4개 문자로 구성된 문자열 중 마지막 문자가 “세”로 끝나는 문자열 검색/o*ve # o로 시작되는 문자부터 ve로 끝나는 모든 문자열 검색/[Ll]ove # Love, lovegrepgrep 은 입력으로 전달된 파일의 내용 혹은 디렉토리에서, 파일 내용이나 파일 이름의 특정 문자열 패턴을 찾고자 할 때 사용하는 명령어다.  grep 은 global / regular expression / print에서 각각의 머릿 글자를 따 온 것이며, find와 함께 리눅스에서 가장 많이 사용되는 명령어 중 하나이다.            명령어      설명      정규 표현식 사용 유무                  grep      다중 패턴      O              egrep(grep -e)      정규 표현식 패턴      O              fgrep(grep -f      문자열 표현식 패턴      X      $ grep [OPTION...] PATTERN [FILE...]#    -E        : PATTERN을 확장 정규 표현식(Extended RegEx)으로 해석.#    -F        : PATTERN을 정규 표현식(RegEx)이 아닌 일반 문자열로 해석.#    -G        : PATTERN을 기본 정규 표현식(Basic RegEx)으로 해석.#    -P        : PATTERN을 Perl 정규 표현식(Perl RegEx)으로 해석.#    -e        : 매칭을 위한 PATTERN 전달.#    -f        : 파일에 기록된 내용을 PATTERN으로 사용.#    -i        : 대/소문자 무시.#    -v        : 매칭되는 PATTERN이 존재하지 않는 라인 선택.#    -w        : 단어(word) 단위로 매칭.#    -x        : 라인(line) 단위로 매칭.#    -z        : 라인을 newline(\\n)이 아닌 NULL(\\0)로 구분.#    -m        : 최대 검색 결과 갯수 제한.#    -b        : 패턴이 매치된 각 라인(-o 사용 시 문자열)의 바이트 옵셋 출력.#    -n        : 검색 결과 출력 라인 앞에 라인 번호 출력.#    -H        : 검색 결과 출력 라인 앞에 파일 이름 표시.#    -h        : 검색 결과 출력 시, 파일 이름 무시.#    -o        : 매치되는 문자열만 표시.#    -q        : 검색 결과 출력하지 않음.#    -a        : 바이너리 파일을 텍스트 파일처럼 처리.#    -I        : 바이너리 파일은 검사하지 않음.#    -d        : 디렉토리 처리 방식 지정. (read, recurse, skip)#    -D        : 장치 파일 처리 방식 지정. (read, skip)#    -r        : 하위 디렉토리 탐색.#    -R        : 심볼릭 링크를 따라가며 모든 하위 디렉토리 탐색.#    -L        : PATTERN이 존재하지 않는 파일 이름만 표시.#    -l        : 패턴이 존재하는 파일 이름만 표시.#    -c        : 파일 당 패턴이 일치하는 라인의 갯수 출력.예시# 날짜 기준이 생성일이라고  할 때, 첫 날짜는 검색하고자 하는 날짜, 두번째는 검색하고자 하는 다음날 날짜$ find . -name *.log -newerct yyyy-MM-dd ! -newerct yyyy-MM-dd -exec grep -Hni '검색어' {} \\;pipe와 사용# 현재 프로세스를 출력에서 \"java\"라는 문자열을 포함하는 라인만 표시 $ ps -ef | grep \"java\"# 어플리케이션의 로그를 tail 하면서 \"error\" 문자열을 포함하는 라인 표시$ tail -f application.log | grep -i \"error\"# netstat명령어로 네트워크 상태를 모니터링하는데 그중 tcp만 확인$ netstat | grep \"tcp\"# 어플리케이션 로그중 \"error\" 문자열을 포함하는 라인을 한 화면씩 표시$ grep \"error\" application.log | more# mylog.txt 파일에서 Apple과 Banana이 있는 문자열들을 탐색$ cat mylog.txt | grep 'Apple' | grep 'Banana'find와 사용$ find . -name \"찾고 싶은 파일이름\" | xargs grep -n \"찾고 싶은 글자\"  xargs 의미  파이프 다음에 쓰이는 xargs는 파이프를 통해 넘어온 결과물을 다음 명령어에 매개변수로 던져주는 역할을 한다.출처: https://inpa.tistory.com/entry/LINUX-📚-정규표현식-과-grep-명령어-정복하기-패턴-검색-확장브래킷 [Inpa Dev 👨‍💻:티스토리]",
        "url": "//linux/2024/05/21/linux-series-04-Grep.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-03-environment-html": {
        "title": "[linux Series] 03 Environment",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnvironmentEnvironment0. 환경 변수 확인printenv [변수명]pringenv HOME1. 변수 설정1.1 쉘 변수현재 쉘에만 적용되는 변수Test=\"TestVariables\"set|grep Test1.2 환경 변수시스템 전체에서 사용 가능한 변수이자 자식쉘에도 상속된다.export Test=\"TestVariables\"1.2.1 /etc/profilebash 로그인 쉘에 진입할 때 로드export JAVA_HOME=\"/path/to/java/home\"export PATH=$PATH:$JAVA_HOME/bin1.2.2 ~/.bashrc사용자별 쉘 구성 파일2. 설정 해제unset [변수명]",
        "url": "//linux/2024/05/21/linux-series-03-Environment.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-02-compress-html": {
        "title": "[linux Series] 02 Compress",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Compresstar/ Compress/ gzip/ bzip2/ xz/ zip리눅스와 윈도우 파일 압축 방식리눅스는 윈도우와 다르게 압축과 대상 파일을 묶는 것을 따로 한다. 윈도우는 묶으면서 동시에 압축하는 반면 리눅스는 압축하거나 관리할 파일들을 먼저 하나의 파일로 묶고(아카이빙) 묶인 파일을 따로 압축한다.아카이브linux는 묶는 것과 압축을 따로 한다. 한 파일로 묶는 것을 아카이브(archive)라고 하며 확장자는 .tar(tape archive)를 가진다.그리고 tar를 다시 gzip으로 압축해서 .tar.gz 확장자를 볼 수 있다.tar(tape archive) 명령어tar [OPTION] [ArchiveFileName] [FILE|PATH]| 옵션  |\t동작||:—:|:—:|| -f\t |대상파일을 tar 아카이브 지정 (기본 옵션)| | -c\t |tar 아카이브 생성. 기존 아카이브 덮어 쓰기 (파일 묶을 때 사용)| | -x\t |tar 아카이브에서 파일 추출(파일 풀 때 사용)| | -v\t |처리되는 과정(파일 정보)을 자세하게 나열| | -z\t |gzip 압축 적용 옵션| | -j\t |bzip2 압축 적용 옵션| | -t\t |tar 아카이브에 포함된 내용 확인| | -C\t |대상 디렉토리 경로 지정| | -A\t |아카이브 파일을 tar 아카이브에 추가| | -d\t |tar 아카이브와 파일 시스템 간 차이점 검색| | -r\t |tar 아카이브 마지막에 파일들 추가| | -u\t |tar 아카이브에 새롭게 추가된 파일만 추가| | -k\t |tar 아카이브 추출 시, 기존 파일 유지| | -U\t |tar 아카이브 추출 전, 기존 파일 삭제| | -w\t |모든 진행 과정에 대해 확인 요청. (interactive)| | -e\t |첫 번째 에러 발생 시 중지|리눅스 압축 형식            압축형태      기본형태      축약      간략설명                  gzip      .tar.gz      .tgz      zip과 같은 압축 알고리즘을 사용하지만 더 용량이 작음.(다른 파일끼리의 중복되는 부분을 하나로 압축이 가능하기 때문)              xzip      .tar.xz      .txz      LZMA2 압축 알고리즘을 사용하는 7-zip은 윈도우에서만 제공하는데 유닉스에 제공하기위해 사용됨 압축효율이 가장 좋음.              bzip      .tar.bz2      .tb2, .tbz, .tbz2      용량이 클 때, gzip에 비해 압축률은 좋지만 비교적 느림              Z      .tar.Z      .tZ      ASCII나 바이너리 파일을 의미              lzma      .tar.lzma      .tlz      bzip2보다 더 높은 압축률 제공(최대 4GB)              lzma      .tar.lz      -      LZMA 알고리즘에 기초함 무결성을 확인하기 위한 CRC 체크섬이 지원됨      ",
        "url": "//linux/2024/05/21/linux-series-02-Compress.html"
      }
      ,
    
      "linux-2024-05-21-linux-series-01-command-html": {
        "title": "[linux Series] 01 Command",
        "tags": "",
        "date": "May 21, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Commandhistory이전에 사용했던 명령어들의 내역이 출력됨ctrl + s/ ctrl + qctrl + s : 터미널의 문자 출력을 중단하는 터미널 제어 키ctrl + q : 제어 해제tail -f | grepgrep과 함께 사용하면 의미 있는 행만 표시할 수도 있다.z-z를 사용하면 tar, gzip으로 압축된 파일을 그대로 읽을 수 있다.zcat, zmore, zgrep, zdifflessless는 파일 크기가 클수록 효과를 발휘한다. cat, vi보다 좋은 선택이 될 수 있다. 내부에서 검색어 검색, 페이지 이동, 줄 번호 표시 등을 할 수 있다.yes |yes | 명령어 를 사용하면 뒤 명령어에 yes로 자동으로 인식하게 해준다.grep -Pri특정 텍스트가 포함된 파일이 있는지 한번에 확인하려는 경우manman [명령어]로 메뉴얼 출력 가능하다.touch파일의 날짜와 시간을 수정하는 명령어간혹 0바이트 파일을 만들기 위해서 사용하기도 한다.-t 옵션으로 서버 시간이 아닌 시간을 지정해서 날짜를 변경할 수도 있다.",
        "url": "//linux/2024/05/21/linux-series-01-Command.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-04-oop-html": {
        "title": "[java Others Series] 04.oop",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - OOPDOOP ( Object-Oriented Programming )장점  코드의 재사용성이 높아진다.  유지보수가 쉽다.  코드가 간결해진다.    단점    처리 시간이 비교적 오래 걸린다.  프로그램을 설계할 때 많은 고민과 시간을 투자해야한다.원칙  S (SRP : Single Responsibility Principle) : 한 클래스는 하나의 책임만 가져야 한다.  O (OCP : Open/Closed Principle) : 확장에는 열려(Open) 있으나, 변경에는 닫혀(Closed)있어야 한다.  L (LSP : Liskov’s Substitution Principle) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.  I (ISP : Interface Segregation Principle) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.  D (DIP : Dependency Inversion Principle) : 추상화에 의존한다. 구체화에 의존하면 안된다.특징  캡슐화          실제로 구현 부분을 외부에 드러나지 않도록 하는 것변수와 메소드를 하나로 묶음데이터를 외부에서 직접 접근하지 않고 함수를 통해서만 접근      ex) public, private, protectedpublic : 클래스 외부에서 접근 가능private : 클래스 내부에서만 접근 가능protected : 상속받은 자식 클래스에서만 접근 가능        상속          자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것기능의 일부분을 변경하는 경우 자식 클래스에서 상속받아 수정 및 사용함상속은 캡슐화를 유지, 클래스의 재사용이 용이하도록 해 준다.        추상화          인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현하는 것        다형성          어떤 변수,메소드가 상황에 따라 다른 결과를 내는 것      ",
        "url": "//java_others/2024/05/20/java-others-series-04.OOP.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-03-coupling-cohesion-html": {
        "title": "[java Others Series] 03.coupling&amp;cohesion",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Coupling &amp; CohesionCoupling &amp; Cohesion일반적으로 문제를 작은 부분으로 쪼개어서 하나씩 풀어나가게 될 것인데, 이 때 문제를 작은 부분으로 쪼개나가는 것을 모듈화라고 한다.각각의 모듈은 주어진 기능만을 독립적으로 수행하기 때문에 재사용성이 높고 코드의 이해/수정이 용이하기 때문이다.결론적으로 결합도는 모듈과 모듈 간의 의존 정도를 의미하고, 응집도는 한 모듈 내의 구성요소들 간의 연관 정도를 의미한다.결합도결합도는 모듈(클래스 파일)간의 상호 의존 정도 또는 연관된 관계의 끈끈함 정도를 의미한다고 보면 된다. (결합도를 의존도라고 부르기도 한다)예를 들면 결합도가 높은 클래스는 다른 클래스와 연관 관계가 끈끈하여, 만일 하나의 클래스의 구조를 변경하게 된다면 그에 연관된 클래스들도 싹 변경해야 할수도 있고,객체 사용 코드도 변경해야 할 수도 있어서, 유지보수 측면에서 매우 마이너스적인 요소로 작용된다. 좋은 소프트웨어는 낮은 결합도(low coupling)를 가지고 있다고 말할 수 있다.  [결합도가 낮은 클래스의 특징]      Open Closed Principle의 원칙을 잘 지킨 클래스 (확장에는 열려있고 변경에는 닫혀 있는 클래스)    다형성을 잘 지킨 클래스  단계 종류    세기    종류    내용    약함   ↓   강함    자료 결합도 (Data Coupling)    모듈간의 인터페이스로 전달되는 파라미터(데이터)를 통해서만 상호 작용이 일어나는 경우 결합도가 제일 낮고 제일 좋은 형태이다.    스탬프 결합도 (Stamp Coupling)    모듈간의 인터페이스로 배열이나 객체, 자료 구조 등이 전달되는 경우    제어 결합도 (Control Coupling)    어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우    외부 결합도 (External Coupling)    어떤 모듈이 외부에 있는 다른 모듈의 데이터를 참조하는 경우 (데이터, 통신 프로토콜 등)    공통 결합도 (Common Coupling)    여러 개의 모듈이 하나의 공통 데이터 영역(전역 변수 참조 및 갱신)을 사용하는 경우    내용 결합도 (Content Coupling)    어떤 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우 결합도가 제일 높고 제일 좋지 않은 형태이다.자료 결합도  가장 결합도가 낮고, 가장 좋은 형태  모듈끼리 단순히 데이터를 주고 받는 경우 (기능 수행에 있어서 로직을 제어하거나 하지 않는 순수한 자료형 요소의 데이터를 주고 받는 것)  한 모듈을 변경하더라도 다른 모듈에는 영향을 끼치지 않는 결합 형태스탬프 결합도  두 모듈이 인터페이스로 배열이나 오브젝트와 같은 동일한 자료 구조를 참조하는 형태의 결합도  만일 모듈에 쓰일 자료구조 형태가 변경되면 그것을 참조하는 모든 모듈에 영향을 주게 됨제어 결합도  어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우  상위 모듈이 하위 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우  제어 결합은 정보은닉을 위배하는 결합으로, 한 모듈이 다른 모듈 내부에 관여하여 관계가 복잡해짐외부 결합도  모듈이 외부에 있는 다른 모듈의 데이터를 참조할 때의 결합도  외부의 데이터, 통신 프로토콜 등을 공유할때 발생 (참조할 데이터가 외부 모듈에 위치할때)  어떤 외부 모듈에서 반환한 값을 다른 모듈에서 참조하는 경우  참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다공통 결합도  여러 개의 모듈이 하나의 공통 데이터 영역을 사용하는 결합도  대표적으로 전역 변수(global variable)를 예로 들 수 있음 (전역 변수의 변경이 여러 모듈에 영향을 줌)  공통 데이터 영역의 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미침  위의 외부 결합도와 유사하게 볼수 있으나 공통 데이터가 외부냐 내부냐에 따라 차이가 있다.  공통 결합도가 외부 결합도 보다 결합도가 높은 이유는, 전역 변수의 값에 따라 결국은 외부의 모듈 반환값 까지 결정될 수 있는 가능성이 있기 때문에 외부 결합도 보다 더 결합도가 높도록 평가된다고 보면 된다.내용 결합도  가장 높은 결합도를 갖으며, 가장 좋지 않은 결합 형태  어떤 모듈이 사용하려면 다른 모듈의 내부 기능과 데이터를 직접 참조해 그대로 가져와 사용하거나 수정하는 경우  이렇게 되면 A모듈, B모듈 모두 코드를 알고 있어야 하며 A모듈이 변경되면 B모듈도 영향을 미쳐 변경해야 함응집도응집도는 하나의 클래스가 기능에 집중하기 위한 모든 정보와 역할을 갖고 있어야 한다는 의미이다.정확히 응집도는 한 모듈 내의 구성 요소 간의 밀접한 정도를 의미하는데, 한 모듈이 하나의 기능(책임)을 갖고있는 것은 응집도가 높은 것이고, 한 모듈이 여러 기능을 갖고 있는 것은 응집도가 낮은 것이다.  [응집도가 높은 클래스의 특징]      단일 책임을 가진 클래스 (Single Responsibility Principle)    다른 클래스와 잘 협력하는 클래스      세기    종류    내용    강함   ↓   약함    기능적 응집도 (Functional Cohesion)            모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우        응집도가 제일 높고 제일 좋은 형태이다.        순차적 응집도 (Sequential Cohesion)    모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우        교환적 응집도 (Communication Cohesion)    동일한 입력과 출력을 사용해 다른 기능을 수행하는 활동들이 모여있을 경우    절차적 응집도 (Procedural Cohesion)    모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우    시간적 응집도(Temporal Cohesion)    연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우    논리적 응집도(Logical Cohesion)    유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우    우연적 응집도(Coincidental Cohesion)    모듈 내부의 각 구성요소들이 연관이 없을 경우    응집도가 제일 낮고 제일 좋지 않은 형태이다.기능적 응집도  가장 응집도가 높은 형태로 가장 좋은 형태이다.  모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우  대입 되는 변수가 공통적으로 사용되는 경우  대표적인 예로 수학 연산에 관련된 모듈들을 모은 Math 클래스를 들 수 있다.순차적 응집도  모듈 내에서 한 활동으로 부터 나온 출력값이 다음 활동의 입력 데이터로 사용할 경우  어떤 모듈이 특정 파일을 읽고 처리하는 기능을 하는 등과 같다교환적 응집도  통신적 응집도 라고도 불림  동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있는 경우  메소드 호출에 공통된 파라미터가 입력되는 경우  순차적 응집도와 차이점은 대신에 처리 순서가 중요치 않다는 것이다.절차적 응집도  모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소가 그 기능을 순차적으로 수행할 경우  하나의 클래스에 있는 메소드들을 여러 개 호출하는 경우시간적 응집도  일시적 응집고 라고도 불림  각 기능 요소들이 순서에 상관없이 특정 시점에 반드시 수행되는 경우  연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우  메소드 호출이 일어나지 않고 변수의 초기화만 실행되거나, Exception 에러 로그를 보내거나 등논리적 응집도  유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우  논리적으로 비슷한 기능을 수행하지만 서로의 관계는 밀접하지 않은 형태  switch문이 쓰여 case에 따라 비슷하지만 다른 작업을 수행하는 경우우연적 응집도  가장 좋지 않은 응집도  모듈 내부의 각 구성 요소들이 서로 관련없는 요소로만 구성된 경우",
        "url": "//java_others/2024/05/20/java-others-series-03.Coupling&amp;Cohesion.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-02-composition-html": {
        "title": "[java Others Series] 02.composition",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CompositionComposition상속과 합성 개념 정리            상속(Inheritance)      합성(Composition)                  부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결      두 객체 사이의 의존성은 런타임에 해결              is-a 관계      has-a 관계              부모클래스의 구현에 의존 결합도가 높음.      구현에 의존하지 않음.  내부에 포함되는 객체의 구현이 아닌 인터페이스에 의존.              클래스 사이의 정적인 관계      객체 사이의 동적인 관계              부모 클래스 안에 구현된 코드 자체를 물려 받아 재사용      포함되는 객체의 퍼블릭 인터페이스를 재사용      상속상속(Inheritance)은 객체 지향 4가지 특징중 하나로서 클래스 기반의 프로그래밍에서 가장 먼저 배우는 개념일 것이다.클래스 상속을 통해 자식 클래스는 부모 클래스의 자원을 물려 받게 되며, 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다.그래서 상속 관계를 is-a 관계라도 표현하기도 한다.상속을 사용하는 경우는 명확한 is - a 관계에 있는 경우, 그리고 상위 클래스가 확장할 목적으로 설게되었고 문서화도 잘되어 있는 경우에 사용하면 좋다.그러나 상속을 제대로 활용하려면 부모 클래스의 내부 구현에 대해서 상세하게 알아야 하므로 결합도가 높아진다. 또한 상속 관계는 컴파일 타임에 결정되고, 고정되기 때문에코드를 실행하는 도중에 변경할 수 없다.따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하게 된다면 모든 조합별로 클래스를 하나하나 추가해주어야 한다. 이것을 클래스 폭발 문제라 한다.합성합성 기법은 기존 클래스를 상속을 통한 확장하는 대신에, 필드로 클래스의 인스턴스를 참조하게 만드는 설계이다.예를들어 서로 관련없는 이질적인 클래스의 관계에서, 한 클래스가 다른 클래스의 기능을 사용하여 구현해야 한다면합성의 방식을 사용한다고 보면 된다.상속의 문제점1. 결합도가 높아진다.상속을 하면 부모 - 자식 관계가 컴파일 시점에 결정된다.2. 불필요한 기능 상속3. 부모 클래스의 결함이 그대로 넘어온다.4. 부모 -자식 클래스의 동시 수정 문제개념적 결합으로 인해, 부모 클래스를 변경할 때 자식도 같이 변경해야 한다.5. 메소드 오버라이딩 오동작자식 클래스에서 부모의 public을 이용할 떄 의도하지 않은 동작을 수반할 수 있다. 이는 캡슐화를 위반한 것이다.6. 불필요한 인터페이스 상속 문제7. 클래스 폭발새롭게 만든 클래스에 하나의 기존 기능을 연결하기 위해서 상속을 해야하고, 또 상속을 하고… 이런 경우를 클래스 폭발이라고 한다.8. 단일 상속의 한계C에서 문제로 다중 상속을 제한했는데 이로 인해서 클래스 폭발이 유발된다.합성의 장점1. 결합도를 낮출 수 있다.2. 합성 관계는 실행 시점에 동적으로 변경할 수 있다.3. 불필요한 인터페이스 상속 문제를 해결할 수 있다.4. 메소드 오버라이딩 오동작을 방지할 수 있다.5. 단일 상속 문제를 해소할 수 있다.",
        "url": "//java_others/2024/05/20/java-others-series-02.Composition.html"
      }
      ,
    
      "java-others-2024-05-20-java-others-series-01-solid-html": {
        "title": "[java Others Series] 01.solid",
        "tags": "",
        "date": "May 20, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SOLIDSOLID  SRP(Single Responsibility Principle): 단일 책임 원칙  OCP(Open Closed Priciple): 개방 폐쇄 원칙  LSP(Listov Substitution Priciple): 리스코프 치환 원칙  ISP(Interface Segregation Principle): 인터페이스 분리 원칙  DIP(Dependency Inversion Principle): 의존 역전 원칙1. SRP단일 책임 원칙은 클래스(객체)는 단 하나의 책임만 가져야 한다는 원칙이다.여기서 ‘책임’ 이라는 의미는 하나의 ‘기능 담당’으로 보면 된다.즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러개 설계하라는 원칙이다.만일 하나의 클래스에 기능(책임)이 여러개 있다면 기능 변경(수정) 이 일어났을때 수정해야할 코드가 많아진다.예를 들어 A를 고쳤더니 B를 수정해야하고 또 C를 수정해야하고, C를 수정했더니 다시 A로 돌아가서 수정해야 하는, 마치 책임이 순환되는 형태가 되어버린다.따라서 SRP 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있게 된다.최종적으로 단일 책임 원칙의 목적은 프로그램의 유지보수 성을 높이기 위한 설계 기법이다.이때 책임의 범위는 딱 정해져있는 것이 아니고, 어떤 프로그램을 개발하느냐에 따라 개발자마다 생각 기준이 달라질 수 있다.class Employee {    String name;    String positon;    Employee(String name, String position) {        this.name = name;        this.positon = position;    }\t// * 초과 근무 시간을 계산하는 메서드 (두 팀에서 공유하여 사용)    void calculateExtraHour() {        // ...    }    // * 급여를 계산하는 메서드 (회계팀에서 사용)    void calculatePay() {        // ...        this.calculateExtraHour();        // ...    }    // * 근무시간을 계산하는 메서드 (인사팀에서 사용)    void reportHours() {        // ...        this.calculateExtraHour();        // ...    }    // * 변경된 정보를 DB에 저장하는 메서드 (기술팀에서 사용)    void saveDababase() {        // ...    }}2. OCPOCP 원칙은 클래스는 ‘확장에 열려있어야 하며, 수정에는 닫혀있어야 한다’ 를 뜻한다.기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법이다.[ 확장에 열려있다 ] - 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음[ 변경에 닫혀있다 ] - 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함.어렵게 생각할 필요없이, OCP 원칙은 추상화 사용을 통한 관계 구축을 권장을 의미하는 것이다.즉, 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙class Animal {\tString type;        Animal(String type) {    \tthis.type = type;    }}// 동물 타입을 받아 각 동물에 맞춰 울음소리를 내게 하는 클래스 모듈class HelloAnimal {    void hello(Animal animal) {        if(animal.type.equals(\"Cat\")) {            System.out.println(\"냐옹\");        } else if(animal.type.equals(\"Dog\")) {            System.out.println(\"멍멍\");        }    }}public class Main {    public static void main(String[] args) {        HelloAnimal hello = new HelloAnimal();                Animal cat = new Animal(\"Cat\");        Animal dog = new Animal(\"Dog\");        hello.hello(cat); // 냐옹        hello.hello(dog); // 멍멍    }}3. LSPLSP 원칙은 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙이다.쉽게 말하면 LSP는 다형성 원리를 이용하기 위한 원칙 개념으로 보면 된다.간단히 말하면 리스코프 치환 원칙이란, 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미하는 것이다.따라서 기본적으로 LSP 원칙은 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야한다.왜냐하면 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문이다.void myData() {\t// Collection 인터페이스 타입으로 변수 선언    Collection data = new LinkedList();    data = new HashSet(); // 중간에 전혀 다른 자료형 클래스를 할당해도 호환됨        modify(data); // 메소드 실행}void modify(Collection data){    list.add(1); // 인터페이스 구현 구조가 잘 잡혀있기 때문에 add 메소드 동작이 각기 자료형에 맞게 보장됨    // ...}4. ISPISP 원칙은 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙이다.SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조하는 것으로 보면 된다.즉, SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계하는 원칙.ISP 원칙은 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표이다.다만 ISP 원칙의 주의해야 할점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말아야 한다.(인터페이스는 한번 구성하였으면 왠만해선 변하면 안되는 정책 개념)interface ISmartPhone {    void call(String number); // 통화 기능    void message(String number, String text); // 문제 메세지 전송 기능    void wirelessCharge(); // 무선 충전 기능    void AR(); // 증강 현실(AR) 기능    void biometrics(); // 생체 인식 기능}class S20 implements ISmartPhone {    public void call(String number) {    }    public void message(String number, String text) {    }    public void wirelessCharge() {    }    public void AR() {    }    public void biometrics() {    }}class S21 implements ISmartPhone {    public void call(String number) {    }    public void message(String number, String text) {    }    public void wirelessCharge() {    }    public void AR() {    }    public void biometrics() {    }}5. DIPDIP 원칙은 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 것// 인터페이스interface Toy {}class Robot implements Toy {}class Lego implements Toy {}class Doll implements Toy {}// 클라이언트class Kid {\tToy toy; // 합성        void setToY(Toy toy) {    \tthis.toy = toy;    }        void play() {}}// 메인 메소드public class Main {\tpublic static void main(String[] args) {        Kid boy = Kid();                // 1. 아이가 로봇을 가지고 놀 때        Toy toy = new Robot();        boy.setToy(toy);        boy.play();                // ...                // 2. 아이가 레고를 가지고 놀 때        Toy toy = new Lego();        boy.setToy(toy);        boy.play();    }}",
        "url": "//java_others/2024/05/20/java-others-series-01.SOLID.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-20-enumfactorymethod-html": {
        "title": "[deisgn Pattern Series] 20 Enumfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Enum Factory MethodEnumFactoryMethodFactoryMethod 단점을 보완하기 위한 패턴이다.Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 모두 구현해야 된다는 점이다.즉, 제품 객체가 50개면 공장 객체도 50개를 구현해야 된다는 말이다.또한 기본적으로 팩토리 클래스는 한번 인스턴스화 하고 제품 객체를 생성하는 역할만 하면 되지 여러개 생성될수 있는 낭비적인 가능성이 있기 때문에 싱글톤을 일일히 적용하여야 하며 이로인해 코드가 복잡해진 다는 문제점도 있었다.이러한 문제점을 Enum으로 팩토리 메서드 패턴을 구성해 준다면, 일일히 서브 공장 클래스 구현 없이 하나의 enum Factory에서 SOLID 원칙 위반 없이 팩토리 클래스를 구성해 줄 수 있다.그러나 단점은 클래스 상속이 필요할때, enum 외의 클래스 상속은 불가능하기 때문에 다시 일반 클래스로 재구성 해야된다는 한계점이 존재한다.기존 팩토리 메서드 패턴Factory Method 패턴에서 유의할 부분은 Factory 인스턴스가 여러번 생성될 필요가 없다는 점이다.공장 객체는 한번만 생성되면 필요할때마다 제품 객체들을 얼마든지 생성할수 있기 때문에 괜히 매번 제품을 생성할때마다 인스턴스화 하면 GC에 의해 STW(Stop The World)가 일어나는 원인이 된다.Enum으로 구현한 팩토리 메소드 패턴Enum 확장 기능을 이용해 싱글톤을 구성해 줄수 도 있다. 왜냐하면 Enum 타입 자체가 public static final 이기 때문에 따로 싱글톤을 구현하지 않아도 단일한 객체만 생성됨이 보장되기 때문이다.enum EnumShapeFactory {    RECTANGLE {        public Shape createShape() {            return new Rectangle();        }    },    CIRCLE {        public Shape createShape() {            return new Circle();        }    };    public Shape create(String color) {        Shape shape = createShape();        shape.setColor(color);        return shape;    }    // 팩토리 메서드    abstract protected Shape createShape();}class Client {    public static void main(String[] args) {        Shape rectangle = EnumShapeFactory.RECTANGLE.create(\"red\");        rectangle.draw();        Shape circle = EnumShapeFactory.CIRCLE.create(\"yellow\");        circle.draw();    }}",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-20-EnumFactoryMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-19-dynamicfactory-html": {
        "title": "[deisgn Pattern Series] 19 Dynamicfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Dynamic FactoryDynamic FactoryFactory Method의 단점을 보완하기 위한 패턴기존 팩토리 메서드 패턴오리지날 Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 1:1 매칭으로 모두 구현해야 된다는 점이다. 그래서 제품 객체가 50개면 공장 객체도 50개를 구현해야 한다. 이는 곧 클래스 폭발로 이어지며 코드 복잡도를 증가시킨다.다이나믹 팩토리 패턴 적용자바의 Class 클래스를 이용한 Reflection APIVisit Website 기법을 이용하여 유형을 동적으로 등록하고 인스턴스를 초기화 하는 패턴이 바로 Dynamic Factory 패턴이다.이를 이용해 팩토리 메서드의 서브 클래싱 부피가 늘어나는 한계를 해결 할 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-19-DynamicFactory.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-18-templatecallback-html": {
        "title": "[deisgn Pattern Series] 18 Templatecallback",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Template CallbackTemplate Callback탬플릿 콜백 패턴(Template Callback Pattern)은 스프링 프레임워크에서 DI(Dependency injection) 의존성 주입에서 사용하는 특별한 전략 패턴이다.스프링의 JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate과 같은곳에 사용된다.존의 전략 패턴은 변화되는 전략 알고리즘 부분을 컴파일 타임에서 클래스로 만든뒤 구현체를 주입해 주어야 되지만, 템플릿 콜백 패턴은 런타임 타임에서 익명 클래스를 이용해 동적으로 전략 알고리즘을 주입한다.용어도 그냥 전략 패턴에서의 컨텍스트(Context)를 템플릿으로 치환한 것일 뿐이며 콜백은 익명 클래스를 만들어진 메서드를 칭하는 것이다.정리하자면 템플릿 콜백 패턴은 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 패턴이라고 보면 된다.흐름// 콜백interface Callback {    int execute(final int n);}// 템플릿class Template {    int workflow(Callback cb) {        System.out.println(\"Workflow 시작\");        int num = 100;        int result = cb.execute(num);        return result;    }}// 클라이언트public class Client {    public static void main(String[] args) {        int x = 100;        int y = 20;        Template t = new Template();        int result = t.workflow(new Callback() {            @Override            public int execute(final int n) {                return n * n;            }        });        System.out.println(result); // 100 * 100 = 10000    }}특징  전략 패턴과 스프링의 의존성 주입(DI)의 장점을 익명 내부 클래스 사용 전략과 결합해 독특하게 활용되는 패턴장점  전략패턴은 따로 전략 알고리즘을 정해놓은 별도의 전략 클래스가 필요했지만, 템플릿-콜백 패턴은 별도의 전략 클래스 없이, 전략을 사용하는 메소드에 매개변수값으로 전략 로직을 넘겨 실행하기 때문에 전략 객체를 일일히 만들 필요가 없다.  외부에서 어떤 전략을 사용하는지 감추고 중요한 부분에 집중할 수 있다.단점  스프링 클라이언트에서 DI를 사용하지 않게 되면, Bean으로 등록되지 않아 싱글톤 객체가 되지 않게 된다.  인터페이스를 사용하지만 실제 사용할 클래스를 직접 선언하기 때문에 결합도가 증가하게 된다. 다만, 그렇다고 해서 무리하게 결합도를 낮추는 행위를 할 필요는 없다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-18-TemplateCallback.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-17-staticfactorymethod-html": {
        "title": "[deisgn Pattern Series] 17 Staticfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Static Factory MethodStatic Factory Method정적 팩토리 메서드(Static Factory Method) 패턴은 개발자가 구성한 Static Method를 통해 간접적으로 생성자를 호출하는 객체를 생성하는 디자인 패턴이다. 우리는 지금까지 객체를 인스턴스화 할때 직접적으로 생성자(Constructor)를 호출하여 생성하였는데, 별도의 객체 생성의 역할을 하는 클래스 메서드를 통해 간접적으로 객체 생성을 유도하는 것이다. 그리고 이 정적 메서드를 통칭적으로 정적 팩토리 메서드 패턴이라고 부르는 것이다.class Book {    private String title;        // 생성자를 private화 하여 외부에서 생성자 호출 차단    private Book(String title) { this.title = title; }        // 정적 팩토리 메서드    public static Book titleOf(String title) {        return new Book(title); // 메서드에서 생성자를 호출하고 리턴함    }}특징1. 생성 목적에 대한 이름 표현이 가능하다.지금까지 클래스를 설계할때 다양한 타입의 객체를 생성하기 위해, 생성 목적에 따라 생성자를 오버로딩하여 구분하여 사용해왔다.하지만 문제는 이러한 객체를 new 키워드를 통해 생성자로 생성하려면, 개발자는 해당 생성자의 인자 순서와 내부 구조를 알고 있어야 목적에 맞게 객체를 생성할수가 있다는 번거로움이 있다.class Car {    private String brand;    private String color;    // private 생성자    private Car(String brand, String color) {        this.brand = brand;        this.color = color;    }    // 정적 팩토리 메서드 (매개변수 하나는 from 네이밍)    public static Car brandBlackFrom(String brand) {        return new Car(brand, \"black\");    }    // 정적 팩토리 메서드 (매개변수 여러개는 of 네이밍)    public static Car brandColorOf(String brand, String color) {        return new Car(brand, color);    }}2. 인스턴스에 대해 통제 및 관리가 가능하다.메서드를 통해 한단계 거쳐 간접적으로 객체를 생성하기 때문에, 기본적으로 전반적인 객체 생성 및 통제 관리를 할 수 있게 된다.즉, 필요에 따라 항상 새로운 객체를 생성해서 반환할 수도 있고, 아니면 객체 하나만 만들어두고 이를 공유하여 재사용하게 하여 불필요한 객체를 생성하는 것을 방지 할 수 있는 것이다.대표적인 예시가 Singleton이다.class Singleton {    private static Singleton instance;    private Singleton() {}    // 정적 팩토리 메서드    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}다른 예로는 인스턴스에 대한 캐싱(Caching) 절차 구조를 정적 팩토리 메서드로 구현할 수 있다. 인스턴스에 대해 캐싱을 한다면 필요한 인스턴스만 뽑아 재사용하여 메모리를 절약할 수 있게 된다.이렇게 인스턴스를 통제하는 것은 인스턴스가 단 하나뿐임을 보장하는 것이고, Flyweight 디자인 패턴의 근간이 되게 된다.3. 하위 자료형 객체를 반환할 수 있다.클래스의 다형성의 특징을 응용한 정적 팩토리 메서드 특징이다. 메서드 호출을 통해 얻을 객체의 인스턴스를 자유롭게 선택할수 있는 유연성을 갖는 것이다.interface SmarPhone {}class Galaxy implements SmarPhone {}class IPhone implements SmarPhone {}class Huawei implements SmarPhone {}class SmartPhones {    public static SmarPhone getSamsungPhone() {        return new Galaxy();    }    public static SmarPhone getApplePhone() {        return new IPhone();    }    public static SmarPhone getChinesePhone() {        return new Huawei();    }}4. 인자에 따라 다른 객체를 반환하도록 분기할 수 있다.메서드이니 매개변수를 받을수 있을테고, 메서드 블록 내에서 분기문을 통해 여러 자식 타입의 인스턴스를 반환하도록 응용 구성이 가능하다.interface SmarPhone {    public static SmarPhone getPhone(int price) {        if(price &gt; 100000) {            return new IPhone();        }        if(price &gt; 50000) {            return new Galaxy();        }        return new Huawei();    }}5. 객체 생성을 캡슐화 할 수 있다.생성자를 사용하는 경우 외부에 내부 구현을 드러내야 하는데, 정적 팩토리 메서드는 구현부를 외부로 부터 숨길 수 있어 캡슐화(encapsulation) 및 정보 은닉(information hiding)을 할수 있다는 특징이 있다.또한 노출하지 않는다는 특징은 정보 은닉성을 가지기도 하지만 동시에 사용하고 있는 구현체를 숨겨 의존성을 제거해주는 장점도 지니고 있다.interface Grade {    String toText();}class A implements Grade {    @Override    public String toText() {return \"A\";}}class B implements Grade {    @Override    public String toText() {return \"B\";}}class C implements Grade {    @Override    public String toText() {return \"C\";}}class D implements Grade {    @Override    public String toText() {return \"D\";}}class F implements Grade {    @Override    public String toText() {return \"F\";}}class GradeCalculator {    // 정적 팩토리 메서드    public static Grade of(int score) {        if (score &gt;= 90) {            return new A();        } else if (score &gt;= 80) {            return new B();        } else if (score &gt;= 70) {            return new C();        } else if (score &gt;= 60) {            return new D();        } else {            return new F();        }    }}Static Factory Method 네이밍 규칙  from : 하나의 매개 변수를 받아서 객체를 생성  of : 여러개의 매개 변수를 받아서 객체를 생성                              getInstance          instance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음                                                  newInstance          create : 항상 새로운 인스턴스를 생성                      get[OrderType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음  new[OrderType] : 항상 다른 타입의 새로운 인스턴스를 생성실제 사용 예시  Optional.of()  List.of()  Integer.valueOf()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-17-StaticFactoryMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-16-singleton-html": {
        "title": "[deisgn Pattern Series] 16 Singleton",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SingletonSingleton// Basicpublic class Singleton {    private static Singleton instance;        private Singleton() { }        public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) { // 쓰레드 동시 접근 시 문제가 발생            instance = new Singleton(); // 쓰레드 동시 접근 시 여러 번 생성        }                return instance;    }}// Synchronizedpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static synchronized Singleton getInstance() {        if ( Objects.isNull( instance ) ) {             instance = new Singleton();         }        //인스턴스 생성이 된 이후에도 락을 건다. 불필요!        return instance;    }}//DCL(Double-Checked-Locking) public class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {                        synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                    /**                     * 아래와 같은 재배치가 있을 수 있다.                     * some_space = allocate space for Singleton Obj;                     *                      *   instancce = some_sapce;                     *                      * create finished                     */                }            }        }        //락을 거는 부분을 최소한으로         //소스코드 상으로 문제가 없지만 컴파일러에 따라 재배치(reordering) 문제가 발생하기도 한다.         return instance;    }}//volatilepublic class Singleton {        private volatile static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {            synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                }            }        }        //문제 없음         return instance;    }}//static 초기화 이용public class Singleton {    private static Singleton instance;        static {        instance = new Singleton();  //클래스 로드 시점에 생성해서 하나임을 보장한다.    }        private Singleton() { }    public static synchronized Singleton getInstance() {        return instance;    }        // 해당 instance를 사용 여부와 상관없이 생성한다. 낭비!}//LazyHolder staticpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        return LazyHolder.INSTANCE;    }        private static class LazyHolder {        private static final Singleton INSTANCE = new Singleton();    }    //THREAD-SAFE + LAZY}",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-16-Singleton.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-15-stategy-html": {
        "title": "[deisgn Pattern Series] 15 Stategy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StrategyStrategy전략 패턴은 실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴 이다.여기서 ‘전략’이란 일종의 알고리즘이 될 수 도 있으며, 기능이나 동작이 될 수도 있는 특정한 목표를 수행하기 위한 행동 계획을 말한다.즉, 어떤 일을 수행하는 알고리즘이 여러가지 일때, 동작들을 미리 전략으로 정의함으로써 손쉽게 전략을 교체할 수 있는, 알고리즘 변형이 빈번하게 필요한 경우에 적합한 패턴이다.  전략 알고리즘 객체들 : 알고리즘, 행위, 동작을 객체로 정의한 구현체  전략 인터페이스 : 모든 전략 구현제에 대한 공용 인터페이스  컨텍스트(Context) : 알고리즘을 실행해야 할 때마다 해당 알고리즘과 연결된 전략 객체의 메소드를 호출.  클라이언트 : 특정 전략 객체를 컨텍스트에 전달 함으로써 전략을 등록하거나 변경하여 전략 알고리즘을 실행한 결과를 누린다.특징정의  동일 계열의 알고리즘군을 정의하고  각각의 알고리즘을 캡슐화하여  이들을 상호 교환이 가능하도록 만든다.  알고리즘을 사용하는 클라이언트와 상관없이 독립적으로  알고리즘을 다양하게 변경할 수 있게 한다.흐름// 전략(추상화된 알고리즘)interface IStrategy {    void doSomething();}// 전략 알고리즘 Aclass ConcreteStrateyA implements IStrategy {    public void doSomething() {}}// 전략 알고리즘 Bclass ConcreteStrateyB implements IStrategy {    public void doSomething() {}}// 컨텍스트(전략 등록/실행)class Context {    IStrategy Strategy; // 전략 인터페이스를 합성(composition)    // 전략 교체 메소드    void setStrategy(IStrategy Strategy) {        this.Strategy = Strategy;    }    // 전략 실행 메소드    void doSomething() {        this.Strategy.doSomething();    }}사용 시기  전략 알고리즘의 여러 버전 또는 변형이 필요할 때 클래스화를 통해 관리  알고리즘 코드가 노출되어서는 안 되는 데이터에 액세스 하거나 데이터를 활용할 때 (캡슐화)  알고리즘의 동작이 런타임에 실시간으로 교체 되어야 할 때주의점  알고리즘이 많아질수록 관리해야할 객체의 수가 늘어난다는 단점이 있다.  만일 어플리케이션 특성이 알고리즘이 많지 않고 자주 변경되지 않는다면, 새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다.  개발자는 적절한 전략을 선택하기 위해 전략 간의 차이점을 명확이 알고 있어야 한다.실사용 예제  Collections의 sort() 메서드에 의해 구현되는 compare() 메서드에 이용  javax.servlet.http.HttpServlet에서 service() 메서드와 모든 doXXX() 메서드에 이용  javax.servlet.Filter의 doFilter() 메서드에 이용",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-15-Stategy.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-14-templatemethod-html": {
        "title": "[deisgn Pattern Series] 14 Templatemethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TemplateMethodTemplateMethod템플릿 메서드(Template Method) 패턴은 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.즉, 변하지 않는 기능(템플릿)은 상위 클래스에 만들어두고 자주 변경되며 확장할 기능은 하위 클래스에서 만들도록 하여, 상위의 메소드 실행 동작 순서는 고정하면서 세부 실행 내용은 다양화 될 수 있는 경우에 사용된다.템플릿 메소드 패턴은 상속이라는 기술을 극대화하여, 알고리즘의 뼈대를 맞추는 것에 초점을 둔다. 이미 수많은 프레임워크에서 많은 부분에 템플릿 메소드 패턴 코드가 우리도 모르게 적용되어 있다.  AbstractClass(추상 클래스) : 템플릿 메소드를 구현하고, 템플릿 메소드에서 돌아가는 추상 메소드를 선언한다. 이 추상 메소드는 하위 클래스인 ConcreteClass 역할에 의해 구현된다.  ConcreteClass(구현 클래스) : AbstractClass를 상속하고 추상 메소드를 구체적으로 구현한다. ConcreteClass에서 구현한 메소드는 AbstractClass의 템플릿 메소드에서 호출된다.흐름abstract class AbstractTemplate {    // 템플릿 메소드 : 메서드 앞에 final 키워드를 붙이면 자식 클래스에서 오버라이딩이 불가능함.\t// 자식 클래스에서 상위 템플릿을 오버라이딩해서 자기마음대로 바꾸도록 하는 행위를 원천 봉쇄    public final void templateMethod() {        // 상속하여 구현되면 실행될 메소드들        step1();        step2();                if(hook()) { // 안의 로직을 실행하거나 실행하지 않음            // ...        }                step3();    }    boolean hook() {        return true;    }    // 상속하여 사용할 것이기 때문에 protected 접근제어자 설정    protected abstract void step1();    protected abstract void step2();    protected abstract void step3();}class ImplementationA extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}}class ImplementationB extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}    // hook 메소드를 오버라이드 해서 false로 하여 템플릿에서 마지막 로직이 실행되지 않도록 설정    @Override    protected boolean hook() {        return false;    }}특징사용 시기  클라이언트가 알고리즘의 특정 단계만 확장하고, 전체 알고리즘이나 해당 구조는 확장하지 않도록 할때  동일한 기능은 상위 클래스에서 정의하면서 확장, 변화가 필요한 부분만 하위 클래스에서 구현할 때장점  클라이언트가 대규모 알고리즘의 특정 부분만 재정의하도록 하여, 알고리즘의 다른 부분에 발생하는 변경 사항의 영향을 덜 받도록 한다.  상위 추상클래스로 로직을 공통화 하여 코드의 중복을 줄일 수 있다.  서브 클래스의 역할을 줄이고, 핵심 로직을 상위 클래스에서 관리하므로서 관리가 용이해진다          헐리우드 원칙 (Hollywood Principle) : 고수준 구성요소에서 저수준을 다루는 원칙 (추상화에 의존)      단점  알고리즘의 제공된 골격에 의해 유연성이 제한될 수 있다.  알고리즘 구조가 복잡할수록 템플릿 로직 형태를 유지하기 어려워진다.  추상 메소드가 많아지면서 클래스의 생성, 관리가 어려워질 수 있다.  상위 클래스에서 선언된 추상 메소드를 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는지 클래스 로직을 이해해야 할 필요가 있다.  로직에 변화가 생겨 상위 클래스를 수정할 때, 모든 서브 클래스의 수정이 필요 할수도 있다.  하위 클래스를 통해 기본 단계 구현을 억제하여 리스코프 치환 법칙을 위반할 여지가 있다.  할리우드 원칙 준수  헐리우드 원칙(Hollywood Principle) 이란 고수준 모듈(추상클래스, 인터페이스)에 의존하고 고수준 모듈에서 연락(메소드 실행) 하라는 원칙이다.객체 끼리 이상하게 얼키고 설켜, 의존성이 복잡하게 꼬여있는 것을 ‘의존성 부패(dependency rot)’ 라고 부르는데, 헐리우드 원칙을 활용하면 의존성 부패를 방지할 수 있게 된다.자바 프로그래밍으로 간단히 말하자면, 다형성을 이용해 고수준의 객체 타입에서만 왠만하면 메서드 실행을 하라는 말이다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-14-TemplateMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-13-state-html": {
        "title": "[deisgn Pattern Series] 13 State",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StateState상태 패턴(State Pattern)은 객체가 특정 상태에 따라 행위를 달리하는 상황에서, 상태를 조건문으로 검사해서 행위를 달리하는 것이 아닌, 상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴을 말한다.객체 지향 프로그래밍에서의 클래스는 꼭 사물 / 생물만을 표현하는 고체 형태의 데이터만 표현 할 수 있는게 아니다.경우에 따라서 무형태의 행위 / 동작도 클래스로 묶어 표현할 수 있다.그래서 상태를 클래스로 표현하면 클래스를 교체해서 ‘상태의 변화’를 표현할 수 있고, 객체 내부 상태 변경에 따라 객체의 행동을 상태에 특화된 행동들로 분리해 낼 수 있으며,새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.  전략 패턴(Strategy Pattern)이 ‘전략 알고리즘’을 클래스로 표현한 패턴이라면, 상태 패턴(State Pattern)은 ‘객체 상태’를 클래스로 표현한 패턴이라고 보면 된다.구조  State 인터페이스 : 상태를 추상화한 고수준 모듈.  ConcreteState : 구체적인 각각의 상태를 클래스로 표현. State 역할로 결정되는 인터페이스(API)를 구체적으로 구현한다. 다음 상태가 결정되면 Context에 상태 변경을 요청하는 역할도 한다.  Context : State를 이용하는 시스템. 시스템 상태를 나타내는 State 객체를 합성(composition)하여 가지고 있다. 클라이언트로부터 요청받으면 State 객체에 행위 실행을 위임한다  상태 클래스는 싱글톤 클래스로 구성한다.전략 패턴의 전략 객체 같은 경우 매개 값에 따라 알고리즘 수행 형태가 달라질수 있지만, 상태는 그 객체의 현 폼을 나타내는 것이기 때문에 대부분의 상황에서 유일하게 있어야 한다.특징사용 시기  객체의 행동(메서드)가 상태(state)에 따라 각기 다른 동작을 할때.  상태 및 전환에 걸쳐 대규모 조건 분기 코드와 중복 코드가 많을 경우  조건문의 각 분기를 별도의 클래스에 넣는것이 상태 패턴의 핵심  런타임단에서 객체의 상태를 유동적으로 변경해야 할 때장점  상태(State)에 따른 동작을 개별 클래스로 옮겨서 관리 할 수 있다.  상태(State)와 관련된 모든 동작을 각각의 상태 클래스에 분산시킴으로써, 코드 복잡도를 줄일 수 있다.  단일 책임 원칙을 준수할 수 있다. (특정 상태와 관련된 코드를 별도의 클래스로 구성)  개방 폐쇄 원칙을 준수할 수 있다. (기존 State 클래스나 컨텍스트를 변경하지 않고 새 State를 도입할 수 있다)  하나의 상태 객체만 사용하여 상태 변경을 하므로 일관성 없는 상태 주입을 방지하는데 도움이 된다.단점  상태 별로 클래스를 생성하므로, 관리해야할 클래스 수 증가  상태 클래스 갯수가 많고 상태 규칙이 자주 변경된다면, Context의 상태 변경 코드가 복잡해지게 될 수 있다.  객체에 적용할 상태가 몇가지 밖에 없거나 거의 상태 변경이 이루어지지 않는 경우 패턴을 적용하는 것이 과도할 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-13-State.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-12-factorymethod-html": {
        "title": "[deisgn Pattern Series] 12 Factorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FactoryMethodFactoryMethod팩토리 메소드 패턴은 객체 생성을 공장(Factory) 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴이다.즉, 클라이언트에서 직접 new 연산자를 통해 제품 객체를 생성하는 것이 아닌, 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것이다.또한 객체 생성에 필요한 과정을 템플릿 처럼 미리 구성해놓고, 객체 생성에 관한 전처리나 후처리를 통해 생성 과정을 다양하게 처리하여 객체를 유연하게 정할 수 있는 특징도 있다.  Creator : 최상위 공장 클래스로서, 팩토리 메서드를 추상화하여 서브 클래스로 하여금 구현하도로 함          객체 생성 처리 메서드(someOperartion) : 객체 생성에 관한 전처리, 후처리를 템플릿화한 메소드      팩토리 메서드(createProduct) : 서브 공장 클래스에서 재정의할 객체 생성 추상 메서드        ConcreteCreator : 각 서브 공장 클래스들은 이에 맞는 제품 객체를 반환하도록 생성 추상 메소드를 재정의한다. 즉, 제품 객체 하나당 그에 걸맞는 생산 공장 객체가 위치된다.  Product : 제품 구현체를 추상화  ConcreteProduct : 제품 구현체정리하자면, 팩토리 메소드 패턴은 객체를 만들어내는 공장(Factory 객체)을 만드는 패턴이라고 보면 된다. 그리고 어떤 클래스의 인스턴스를 만들지는 미리 정의한 공장 서브 클래스에서 결정한다.이렇게하면 객체 간 결합도가 낮아진다.  [ Template Method 패턴과 Factory Method 패턴과의 관계 ]  뭔가 이름 구성이 비슷해서 둘이 어떠한 관계가 있어 보이는데, 템플릿 메서드는 행동 패턴이고 팩토리 메서드는 생성 패턴이라 둘은 전혀 다른 패턴이다.다만 클래스 구조의 결은 둘이 같다고 보면 되는데, 인스턴스를 생성하는 공장을 Template Method 패턴으로 구성한 것이 Factory Method 패턴이 되기 때문이다.Template Method 패턴에서는 하위 클래스에서 구체적인 처리 알고리즘의 내용을 만들도록 추상 메소드를 상속 시켰었다. 이 로직을 알고리즘 내용이 아닌 인스턴스 생성에 적용한 것이 Factory Method 패턴 인 것이다.// 제품 객체 추상화 (인터페이스)interface IProduct {    void setting();}// 제품 구현체class ConcreteProductA implements IProduct {    public void setting() {    }}class ConcreteProductB implements IProduct {    public void setting() {    }}// 공장 객체 추상화 (추상 클래스)abstract class AbstractFactory {    // 객체 생성 전처리 후처리 메소드 (final로 오버라이딩 방지, 템플릿화)    final IProduct createOperation() {        IProduct product = createProduct(); // 서브 클래스에서 구체화한 팩토리 메서드 실행        product.setting(); // .. 이밖의 객체 생성에 가미할 로직 실행        return product; // 제품 객체를 생성하고 추가 설정하고 완성된 제품을 반환    }    // 팩토리 메소드 : 구체적인 객체 생성 종류는 각 서브 클래스에 위임    // protected 이기 때문에 외부에 노출이 안됨    abstract protected IProduct createProduct();}// 공장 객체 A (ProductA를 생성하여 반환)class ConcreteFactoryA extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductA();    }}// 공장 객체 B (ProductB를 생성하여 반환)class ConcreteFactoryB extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductB();    }}특징사용 시기  클래스 생성과 사용의 처리 로직을 분리하여 결합도를 낮추고자 할 때  코드가 동작해야 하는 객체의 유형과 종속성을 캡슐화를 통해 정보 은닉 처리 할 경우  라이브러리 혹은 프레임워크 사용자에게 구성 요소를 확장하는 방법을 제공하려는 경우  기존 객체를 재구성하는 대신 기존 객체를 재사용하여 리소스를 절약하고자 하는 경우          상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다. 그리고 객체 생성 방식의 변화는 해당되는 모든 코드 부분을 변경해야 하는 문제가 발생한다.      따라서 객체의 생성 코드를 별도의 클래스 / 메서드로 분리 함으로써 객체 생성의 변화에 대해 대비를 하기 위해 팩토리 메서드 패턴을 이용한다고 보면 된다.      특정 기능의 구현은 별개의 클래스로 제공되는 것이 바람직한 설계이기 때문이다      장점  생성자(Creator)와 구현 객체(concrete product)의 강한 결합을 피할 수 있다.  팩토리 메서드를 통해 객체의 생성 후 공통으로 할 일을 수행하도록 지정해줄 수 있다.  캡슐화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.  단일 책임 원칙 준수 : 객체 생성 코드를 한 곳 (패키지, 클래스 등)으로 이동하여 코드를 유지보수하기 쉽게 할수 있으므로 원칙을 만족  개방/폐쇄 원칙 준수 : 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있어 원칙을 만족 (확장성 있는 전체 프로젝트 구성이 가능)  생성에 대한 인터페이스 부분과 생성에 대한 구현 부분을 따로 나뉘었기 때문에 패키지 분리하여 개별로 여러 개발자가 협업을 통해 개발단점  각 제품 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에, 구현체가 늘어날때 마다 팩토리 클래스가 증가하여 서브 클래스 수가 폭발한다.  코드의 복잡성이 증가한다.실사용 예시  java.util.Calendar 의 getInstance()  java.util.ResourceBundle 의 getBundle()  java.text.NumberFormat 의 getInstance()  java.nio.charset.Charset 의 forName()  java.net.URLStreamHandlerFactory 의 createURLStreamHandler(String)  java.util.EnumSet 의 of()  jakarta.xml.bind.JAXBContext 의 createMarshaller() and other similar methods",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-12-FactoryMethod.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-11-abstractfactory-html": {
        "title": "[deisgn Pattern Series] 11 Abstractfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AbstractFactoryAbstractFactory추상 팩토리 패턴은 연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다.클라이언트에서 특정 객체을 사용할때 팩토리 클래스만을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리시킬 수 있다.즉, 추상 팩토리의 핵심은 제품 ‘군’ 집합을 타입 별로 찍어낼수 있다는 점이 포인트 이다.  AbstractFactory : 최상위 공장 클래스. 여러개의 제품들을 생성하는 여러 메소드들을 추상화 한다.  ConcreteFactory : 서브 공장 클래스들은 타입에 맞는 제품 객체를 반환하도록 메소드들을 재정의한다.  AbstractProduct : 각 타입의 제품들을 추상화한 인터페이스  ConcreteProduct (ProductA ~ ProductB) : 각 타입의 제품 구현체들. 이들은 팩토리 객체로부터 생성된다.  Client : Client는 추상화된 인터페이스만을 이용하여 제품을 받기 때문에, 구체적인 제품, 공장에 대해서는 모른다.Abstract Factory vs. Factory Method둘다 팩토리 객체를 통해 구체적인 타입을 감추고 객체 생성에 관여하는 패턴 임에는 동일하다. 또한 공장 클래스가 제품 클래스를 각각 나뉘어 느슨한 결합 구조를 구성하는 모습 역시 둘이 유사하다.그러나 주의할 것은 추상 팩토리 패턴이 팩토리 메서드 패턴의 상위 호환이 아니라는 점이다. 두 패턴의 차이는 명확하기 때문에 상황에 따라 적절한 선택을 해야 한다.예를 들어 팩토리 메서드 패턴은 객체 생성 이후 해야 할 일의 공통점을 정의하는데 초점을 맞추는 반면, 추상 팩토리 패턴은 생성해야 할 객체 집합 군의 공통점에 초점을 맞춘다.단, 이 둘을 유사점과 차이점을 조합해서 복합 패턴을 구성하는 것도 가능하다.FactoryMethodAbstractFactory공통점객체 생성 과정을 추상화한 인터페이스를 제공  객체 생성을 캡슐화함으로써 구체적인 타입을 감추고 느슨한 결합 구조를 표방차이점구체적인 객체 생성과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적관련 있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적한 Factory당 한 종류의 객체 생성 지원한 Factory에서 서로 연관된 여러 종류의 객체 생성을 지원. (제품군 생성 지원)메소드 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스의 생성 및 구성에 대한 의존을 감소클래스(Factory) 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스 군의 생성 및 구성에 대한 의존을 감소흐름// Product A 제품군interface AbstractProductA {}// Product A - 1class ConcreteProductA1 implements AbstractProductA {}// Product A - 2class ConcreteProductA2 implements AbstractProductA {}// Product B 제품군interface AbstractProductB {}// Product B - 1class ConcreteProductB1 implements AbstractProductB {}// Product B - 2class ConcreteProductB2 implements AbstractProductB {}interface AbstractFactory {    AbstractProductA createProductA();    AbstractProductB createProductB();}// Product A1와 B1 제품군을 생산하는 공장군 1 class ConcreteFactory1 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA1();    }    public AbstractProductB createProductB() {        return new ConcreteProductB1();    }}// Product A2와 B2 제품군을 생산하는 공장군 2class ConcreteFactory2 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA2();    }    public AbstractProductB createProductB() {        return new ConcreteProductB2();    }}특징사용 시기  관련 제품의 다양한 제품 군과 함께 작동해야 할때, 해당 제품의 구체적인 클래스에 의존하고 싶지 않은 경우  여러 제품군 중 하나를 선택해서 시스템을 설정해야하고 한 번 구성한 제품을 다른 것으로 대체할 수도 있을 때  제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때장점  객체를 생성하는 코드를 분리하여 클라이언트 코드와 결합도를 낮출 수 있다.  제품 군을 쉽게 대체 할 수 있다.  단일 책임 원칙 준수  개방 / 폐쇄 원칙 준수단점  각 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에 객체가 늘어날때 마다 클래스가 증가하여 코드의 복잡성이 증가한다. (팩토리 패턴의 공통적인 문제점)  기존 추상 팩토리의 세부사항이 변경되면 모든 팩토리에 대한 수정이 필요해진다. 이는 추상 팩토리와 모든 서브클래스의 수정을 가져온다.  새로운 종류의 제품을 지원하는 것이 어렵다. 새로운 제품이 추가되면 팩토리 구현 로직 자체를 변경해야한다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-11-AbstractFactory.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-10-proxy-html": {
        "title": "[deisgn Pattern Series] 10 Proxy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ProxyProxy프록시 패턴(Proxy Pattern)은 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 행동 패턴이다.프록시(Proxy)의 사전적인 의미는 ‘대리인’이라는 뜻이다. 즉, 누군가에게 어떤 일을 대신 시키는 것을 의미하는데, 이를 객체 지향 프로그래밍에 접목해보면 클라이언트가 대상 객체를 직접 쓰는게 아니라 중간에 프록시(대리인)을 거쳐서 쓰는 코드 패턴이라고 보면 된다. 따라서 대상 객체(Subject)의 메소드를 직접 실행하는 것이 아닌, 대상 객체에 접근하기 전에 프록시(Proxy) 객체의 메서드를 접근한 후 추가적인 로직을 처리한뒤 접근하게 된다.이런 방법을 사용하는 이유는 대상 클래스가 민감한 정보를 가지고 있거나 인스턴스화 하기에 무겁거나 추가 기능을 가미하고 싶은데, 원본 객체를 수정할 수 없는 상황일 때를 극복하기 위해서다.  안(Security) : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달한다.  캐싱(Caching) : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.  데이터 유효성 검사(Data validation) : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.  지연 초기화(Lazy initialization) : 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할때까지 연기할 수 있다.  로깅(Logging) : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.  원격 객체(Remote objects) : 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 할 수 있다.패턴 구조  Subject : Proxy와 RealSubject를 하나로 묶는 인터페이스 (다형성)          대상 객체와 프록시 역할을 동일하게 하는 추상 메소드 operation() 를 정의한다.      인터페이스가 있기 때문에 클라이언트는 Proxy 역할과 RealSubject 역할의 차이를 의식할 필요가 없다.        RealSubject : 원본 대상 객체  Proxy : 대상 객체(RealSubject)를 중계할 대리자 역할          프록시는 대상 객체를 합성(composition)한다.      프록시는 대상 객체와 같은 이름의 메서드를 호출하며, 별도의 로직을 수행 할수 있다 (인터페이스 구현 메소드)      프록시는 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안 된다.        Client : Subject 인터페이스를 이용하여 프록시 객체를 생성해 이용.          클라이언트는 프록시를 중간에 두고 프록시를 통해서 RealSubject와 데이터를 주고 받는다.      종류일반 프록시interface ISubject {    void action();}class RealSubject implements ISubject {    public void action() {        System.out.println(\"원본 객체 액션 !!\");    }}class Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {        this.subject = subject;    }    public void action() {        subject.action(); // 위임        /* do something */        System.out.println(\"프록시 객체 액션 !!\");    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}가상 프록시  지연 초기화 방식  가끔 필요하지만 항상 메모리에 적재되어 있는 무거운 서비스 객체가 있는 경우  이 구현은 실제 객체의 생성에 많은 자원이 소모 되지만 사용 빈도는 낮을 때 쓰는 방식이다.      서비스가 시작될 때 객체를 생성하는 대신에 객체 초기화가 실제로 필요한 시점에 초기화될수 있도록 지연할 수 있다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy() {  }    public void action() {  \t// 프록시 객체는 실제 요청(action(메소드 호출)이 들어 왔을 때 실제 객체를 생성한다.      if(subject == null){          subject = new RealSubject();      }      subject.action(); // 위임      /* do something */      System.out.println(“프록시 객체 액션 !!”);  }}  class Client {    public static void main(String[] args) {        ISubject sub = new Proxy();        sub.action();    }}## 보호 프록시- 프록시가 대상 객체에 대한 자원으로의 엑세스 제어(접근 권한)- 특정 클라이언트만 서비스 객체를 사용할 수 있도록 하는 경우- 프록시 객체를 통해 클라이언트의 자격 증명이 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있게 한다.```javaclass Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    boolean access; // 접근 권한    Proxy(RealSubject subject, boolean access) {        this.subject = subject;        this.access = access;    }    public void action() {        if(access) {            subject.action(); // 위임            /* do something */            System.out.println(\"프록시 객체 액션 !!\");        }    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject(), false);        sub.action();    }}로깅 프록시  대상 객체에 대한 로깅을 추가하려는 경우      프록시는 서비스 메서드를 실행하기 전달하기 전에 로깅을 하는 기능을 추가하여 재정의한다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {      this.subject = subject;  }    public void action() {      System.out.println(“로깅………………”);      subject.action(); // 위임  /* do something */  System.out.println(\"프록시 객체 액션 !!\");  System.out.println(\"로깅..................\");   } }      class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}```원격 프록시  프록시 클래스는 로컬에 있고, 대상 객체는 원격 서버에 존재하는 경우  프록시 객체는 네트워크를 통해 클라이언트의 요청을 전달하여 네트워크와 관련된 불필요한 작업들을 처리하고 결과값만 반환  클라이언트 입장에선 프록시를 통해 객체를 이용하는 것이니 원격이든 로컬이든 신경 쓸 필요가 없으며, 프록시는 진짜 객체와 통신을 대리하게 된다캐싱 프록시  데이터가 큰 경우 캐싱하여 재사용을 유도  클라이언트 요청의 결과를 캐시하고 이 캐시의 수명 주기를 관리특징사용 시기  접근을 제어하거가 기능을 추가하고 싶은데, 기존의 특정 객체를 수정할 수 없는 상황일때  초기화 지연, 접근 제어, 로깅, 캐싱 등, 기존 객체 동작에 수정 없이 가미하고 싶을 때장점  개방 폐쇄 원칙(OCP) 준수          기존 대상 객체의 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.        단일 책임 원칙(SRP) 준수          대상 객체는 자신의 기능에만 집중 하고, 그 이외 부가 기능을 제공하는 역할을 프록시 객체에 위임하여 다중 책임을 회피 할 수 있다.        원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행하는데 유용하다  클라이언트는 객체를 신경쓰지 않고, 서비스 객체를 제어하거나 생명 주기를 관리할 수 있다.  사용자 입장에서는 프록시 객체나 실제 객체나 사용법은 유사하므로 사용성에 문제 되지 않는다.단점  많은 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가한다.          예를들어 여러 클래스에 로깅 기능을 가미 시키고 싶다면, 동일한 코드를 적용함에도 각각의 클래스에 해당되는 프록시 클래스를 만들어서 적용해야 되기 때문에 코드량이 많아지고 중복이 발생 된다.      자바에서는 리플렉션에서 제공하는 동적 프록시(Dynamic Proxy) 기법을 이용해서 해결할 수 있다. (후술)        프록시 클래스 자체에 들어가는 자원이 많다면 서비스로부터의 응답이 늦어질 수 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-10-Proxy.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-09-adaptor-html": {
        "title": "[deisgn Pattern Series] 09 Adaptor",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AdaptorAdaptor어댑터 패턴(Adaptor Pattern) 이란 이름 그대로 클래스를 어댑터로서 사용되는 구조 패턴이다.이를 객체 지향 프로그래밍에 접목해보면, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해주도록 변환 역할을 해주는 행동 패턴이라고 보면 된다. 예를들어 기존에 있는 시스템에 새로운 써드파티 라이브러리를 추가하고 싶거나, Legacy 인터페이스를 새로운 인터페이스로 교체하는 경우에 어댑터 패턴을 사용하면 코드의 재사용성을 높일 수 있다.즉, 어댑터란 이미 구축되어 있는 것을 새로운 어떤것에 사용할때 양 쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로서, 기존 시스템에서 새로운 기능을 사용하려고 할때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할수 있다고 보면 된다.구조Adapter 패턴에는 기존 시스템의 클래스를 상속(Inheritance) 해서 호환 작업을 해주냐, 합성(Composition)해서 호환 작업을 해주냐에 따라, 두 가지 패턴 방법으로 나뉘게 된다.객체 어댑터(Object Adaptor)  합성(Composition)된 맴버에게 위임을 이용한 어댑터 패턴 (추천 🌟)  자기가 해야 할 일을 클래스 맴버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다.  합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다.  Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Client Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Object Adaptor 방식에선 합성을 이용해 구성한다.      Adaptee(Service)를 따로 클래스 멤버로 설정하고 위임을 통해 동작을 매치시킨다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter implements Target {    Service adaptee; // composition으로 Service 객체를 클래스 필드로// 어댑터가 인스턴스화되면 호환시킬 기존 서비스를 설정Adapter(Service adaptee) {    this.adaptee = adaptee;}// 어댑터의 메소드가 호출되면, Adaptee의 메소드를 호출하도록public void method(int data) {    adaptee.specificMethod(data); // 위임} } ```클래스 어댑터(Class Adaptor)  클래스 상속을 이용한 어댑터 패턴  Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.  상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 전반적으로 권장하지는 않는 방법이다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Cient Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Class Adaptor 방식에선 상속을 이용해 구성한다.      Existing Class와 Adaptee(Service) 를 동시에 implements, extends 하여 구현한다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter extends Service implements Target {// 어댑터의 메소드가 호출되면, 부모 클래스 Adaptee의 메소드를 호출public void method(int data) {    specificMethod(data);} } ```특징사용 시기  레거시 코드를 사용하고 싶지만 새로운 인터페이스가 레거시 코드와 호환되지 않을 때  이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때  이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조할때  소프트웨어의 구 버전과 신 버전을 공존시키고 싶을때장점  프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있기 때문에 단일 책임 원칙(SRP)을 만족한다.  기존 클래스 코드를 건들지 않고 클라이언트 인터페이스를 통해 어댑터와 작동하기 때문에 개방 폐쇄 원칙(OCP)을 만족한다.  만일 추가로 필요한 메소드가 있다면 어댑터에 빠르게 만들 수 있다. 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 쉬워진다.단점  새로운 인터페이스와 어댑터 클래스 세트를 도입해야 하기 때문에 코드의 복잡성이 증가한다.  때로는 직접 서비스(Adaptee) 클래스를 변경하는것이 간단할수 있는 경우가 있기 때문에 신중히 선택하여야 한다.실제 사용 예시  java.util.Arrays 의 asList()  java.util.Collections 의 list()  java.util.Collections 의 enumeration()  java.io.InputStreamReader(InputStream) (returns a Reader)  java.io.OutputStreamWriter(OutputStream) (returns a Writer)  jakarta.xml.bind.annotation.adapters.XmlAdapter 의 marshal() and unmarshal()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-09-Adaptor.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-08-decorator-html": {
        "title": "[deisgn Pattern Series] 08 Decorator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DecoratorDecorator데코레이터 패턴(Decorator Pattern)은 대상 객체에 대한 기능 확장이나 변경이 필요할때 객체의 결합을 통해 서브클래싱 대신 쓸수 있는 유연한 대안 구조 패턴이다.Decorator을 해석하자면 ‘장식자’ 라는 의미를 가지고 있는데,  마치 기본 제품에 포장지나 외부 디자인을 살짝 변경해 줌으로써 새로운 기능을 부여하는 것과 같이,객체 지향 프로그래밍에서 원본 객체에 대해서 무언가를 장식하여 더 멋진 기능을 가지게 만드는 것이기 때문에 이 명칭이 붙었다고 보면 된다.데코레이터 패턴을 이용하면 필요한 추가 기능의 조합을 런타임에서 동적으로 생성할 수 있다. 데코레이터할 대상 객체를 새로운 행동들을 포함한 특수 장식자 객체에 넣어서 행동들을 해당 장식자 객체마다 연결시켜, 서브클래스로 구성할때 보다 훨씬 유연하게 기능을 확장 할 수 있다. 그리고 기능을 구현하는 클래스들을 분리함으로써 수정이 용이해진다  Component (Interface) : 원본 객체와 장식된 객체 모두를 묶는 역할  ConcreteComponent : 원본 객체 (데코레이팅 할 객체)  Decorator : 추상화된 장식자 클래스          원본 객체를 합성(composition)한 wrappee 필드와 인터페이스의 구현 메소드를 가지고 있다        ConcreteDecorator : 구체적인 장식자 클래스          부모 클래스가 감싸고 있는 하나의 Component를 호출하면서 호출 전/후로 부가적인 로직을 추가할 수 있다.      흐름// 원본 객체와 장식된 객체 모두를 묶는 인터페이스interface IComponent {    void operation();}// 장식될 원본 객체class ConcreteComponent implements IComponent {    public void operation() {    }}// 장식자 추상 클래스abstract class Decorator implements IComponent {    IComponent wrappee; // 원본 객체를 composition    Decorator(IComponent component) {        this.wrappee = component;    }    public void operation() {        wrappee.operation(); // 위임    }}// 장식자 클래스class ComponentDecorator1 extends Decorator {    ComponentDecorator1(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}class ComponentDecorator2 extends Decorator {    ComponentDecorator2(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}패턴사용 시기  객체 책임과 행동이 동적으로 상황에 따라 다양한 기능이 빈번하게 추가/삭제되는 경우  객체의 결합을 통해 기능이 생성될 수 있는 경우  객체를 사용하는 코드를 손상시키지 않고 런타임에 객체에 추가 동작을 할당할 수 있어야 하는 경우  상속을 통해 서브클래싱으로 객체의 동작을 확장하는 것이 어색하거나 불가능 할 때장점  데코레이터를 사용하면 서브클래스를 만들때보다 훨씬 더 유연하게 기능을 확장할 수 있다.  객체를 여러 데코레이터로 래핑하여 여러 동작을 결합할 수 있다.  컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.  각 장식자 클래스마다 고유의 책임을 가져 단일 책임 원칙(SRP)을 준수  클라이언트 코드 수정없이 기능 확장이 필요하면 장식자 클래스를 추가하면 되니 개방 폐쇄 원칙(OCP)을 준수  구현체가 아닌 인터페이스를 바라봄으로써 의존 역전 원칙(DIP) 준수단점  만일 장식자 일부를 제거하고 싶다면, Wrapper 스택에서 특정 wrapper를 제거하는 것은 어렵다.  데코레이터를 조합하는 초기 생성코드가 보기 안좋을 수 있다. new A(new B(new C(new D())))  어느 장식자를 먼저 데코레이팅 하느냐에 따라 데코레이터 스택 순서가 결정지게 되는데, 만일 순서에 의존하지 않는 방식으로 데코레이터를 구현하기는 어렵다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-08-Decorator.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-07-observer-html": {
        "title": "[deisgn Pattern Series] 07 Observer",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ObserverObserver옵저버 패턴(Observer Pattern)은 옵저버(관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 패턴이다.옵저버 패턴은 여타 다른 디자인 패턴들과 다르게 일대다(one-to-many) 의존성을 가지는데, 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. Pub/Sub(발행/구독) 모델로도 알려져 있다.  ISubject : 관찰 대상자를 정의하는 인터페이스  ConcreteSubject : 관찰 당하는 대상자 / 발행자 / 게시자          Observer들을 리스트(List, Map, Set ..등)로 모아 합성(compositoin)하여 가지고 있음      Subject의 역할은 관찰자인 Observer들을 내부 리스트에 등록/삭제 하는 인프라를 갖고 있다. (register, remove)      Subject가 상태를 변경하거나 어떤 동작을 실행할때, Observer 들에게 이벤트 알림(notify)을 발행한다.        IObserver : 구독자들을 묶는 인터페이스 (다형성)  Observer : 관찰자 / 구독자 / 알림 수신자.          Observer들은 Subject가 발행한 알림에 대해 현재 상태를 취득한다.      Subject의 업데이트에 대해 전후 정보를 처리한다.      흐름// 관찰 대상자 / 발행자interface ISubject {    void registerObserver(IObserver o);    void removeObserver(IObserver o);    void notifyObserver();}class ConcreteSubject implements ISubject {    // 관찰자들을 등록하여 담는 리스트    List&lt;IObserver&gt; observers = new ArrayList&lt;&gt;();    // 관찰자를 리스트에 등록    @Override    public void registerObserver(IObserver o) {        observers.add(o);        System.out.println(o + \" 구독 완료\");    }    // 관찰자를 리스트에 제거    @Override    public void removeObserver(IObserver o) {        observers.remove(o);        System.out.println(o + \" 구독 취소\");    }    // 관찰자에게 이벤트 송신    @Override    public void notifyObserver() {        for(IObserver o : observers) { // 관찰자 리스트를 순회하며            o.update(); // 위임        }    }}// 관찰자 / 구독자interface IObserver {  void update();}class ObserverA implements IObserver {  public void update() {    System.out.println(\"ObserverA 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverA\"; }}class ObserverB implements IObserver {  public void update() {    System.out.println(\"ObserverB 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverB\"; }}특징사용 시기  앱이 한정된 시간, 특정한 케이스에만 다른 객체를 관찰해야 하는 경우  대상 객체의 상태가 변경될 때마다 다른 객체의 동작을 트리거해야 할때  한 객체의 상태가 변경되면 다른 객체도 변경해야 할때. 그런데 어떤 객체들이 변경되어야 하는지 몰라도 될 때  MVC 패턴에서도 사용됨 (Model, View, Controller)          MVC의 Model과 View의 관계는 Observer 패턴의 Subject 역할과 Observer 역할의 관계에 대응된다.      하나의 Model에 복수의 View가 대응한다.      장점  Subject의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지할 수 있다.  발행자의 코드를 변경하지 않고도 새 구독자 클래스를 도입할 수 있어 개방 폐쇄 원칙(OCP)Visit Website 준수한다  런타임 시점에서에 발행자와 구독 알림 관계를 맺을 수 있다.  상태를 변경하는 객체(Subject)와 변경을 감지하는 객체(Observer)의 관계를 느슨하게 유지할 수 있다. (느슨한 결합)단점  구독자는 알림 순서를 제어할수 없고, 무작위 순서로 알림을 받음          하드 코딩으로 구현할수는 있겠지만, 복잡성과 결합성만 높아지기 때문에 추천되지는 않는 방법이다.        옵저버 패턴을 자주 구성하면 구조와 동작을 알아보기 힘들어져 코드 복잡도가 증가한다.  다수의 옵저버 객체를 등록 이후 해지하지 않는다면 메모리 누수가 발생할 수도 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-07-Observer.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-06-iterator-html": {
        "title": "[deisgn Pattern Series] 06 Iterator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - IteratorIterator반복자(Iterator) 패턴은 일련의 데이터 집합에 대하여 순차적인 접근(순회)을 지원하는 패턴이다.데이터 집합이란 객체들을 그룹으로 묶어 자료의 구조를 취하는 컬렉션을 말한다. 대표적인 컬렉션으로 한번쯤은 들어본 리스트나 트리, 그래프, 테이블 등이 있다.  Aggregate (인터페이스) : ConcreateIterator 객체를 반환하는 인터페이스를 제공한다.          iterator() : ConcreateIterator 객체를 만드는 팩토리 메서드        ConcreateAggregate (클래스) : 여러 요소들이 이루어져 있는 데이터 집합체  Iterator (인터페이스) : 집합체 내의 요소들을 순서대로 검색하기 위한 인터페이스를 제공한다.          hasNext() : 순회할 다음 요소가 있는지 확인 (true / false)      next() : 요소를 반환하고 다음 요소를 반환할 준비를 하기 위해 커서를 이동시킴        ConcreateIterator (클래스) : 반복자 객체          ConcreateAggregate가 구현한 메서드로부터 생성되며, ConcreateAggregate 의 컬렉션을 참조하여 순회한다.      어떤 전략으로 순회할지에 대한 로직을 구체화 한다      흐름// 집합체 객체 (컬렉션)interface Aggregate {    Iterator iterator();}class ConcreteAggregate implements Aggregate {    Object[] arr; // 데이터 집합 (컬렉션)    int index = 0;    public ConcreteAggregate(int size) {        this.arr = new Object[size];    }    public void add(Object o) {        if(index &lt; arr.length) {            arr[index] = o;            index++;        }    }    // 내부 컬렉션을 인자로 넣어 이터레이터 구현체를 클라이언트에 반환    @Override    public Iterator iterator() {        return new ConcreteIterator(arr);    }}// 반복체 객체interface Iterator {    boolean hasNext();    Object next();}class ConcreteIterator implements Iterator {    Object[] arr;    private int nextIndex = 0; // 커서 (for문의 i 변수 역할)    // 생성자로 순회할 컬렉션을 받아 필드에 참조 시킴    public ConcreteIterator(Object[] arr) {        this.arr = arr;    }    // 순회할 다음 요소가 있는지 true / false    @Override    public boolean hasNext() {        return nextIndex &lt; arr.length;    }    // 다음 요소를 반환하고 커서를 증가시켜 다음 요소를 바라보도록 한다.    @Override    public Object next() {        return arr[nextIndex++];    }}특징사용 시기  컬렉션에 상관없이 객체 접근 순회 방식을 통일하고자 할 때  컬렉션을 순회하는 다양한 방법을 지원하고 싶을 때  컬렉션의 복잡한 내부 구조를 클라이언트로 부터 숨기고 싶은 경우 (편의 + 보안)  데이터 저장 컬렉션 종류가 변경 가능성이 있을 때          클라이언트가 집합 객체 내부 표현 방식을 알고 있다면, 표현 방식이 달라지면 클라이언트 코드도 변경되어야 하는 문제가 생긴다.      장점  일관된 이터레이터 인터페이스를 사용해 여러 형태의 컬렉션에 대해 동일한 순회 방법을 제공한다.  컬렉션의 내부 구조 및 순회 방식을 알지 않아도 된다.  집합체의 구현과 접근하는 처리 부분을 반복자 객체로 분리해 결합도를 줄 일 수 있다.          Client에서 iterator로 접근하기 때문에 ConcreteAggregate 내에 수정 사항이 생겨도 iterator에 문제가 없다면 문제가 발생하지 않는다.        순회 알고리즘을 별도의 반복자 객체에 추출하여 각 클래스의 책임을 분리하여 단일 책임 원칙(SRP)를 준수한다.  데이터 저장 컬렉션 종류가 변경되어도 클라이언트 구현 코드는 손상되지 않아 수정에는 닫혀 있어 개방 폐쇄 원칙(OCP)를 준수한다단점  클래스가 늘어나고 복잡도가 증가한다.          만일 앱이 간단한 컬렉션에서만 작동하는 경우 패턴을 적용하는 것은 복잡도만 증가할 수 있다.      이터레이터 객체를 만드는 것이 유용한 상황인지 판단할 필요가 있다.        구현 방법에 따라 캡슐화를 위배할 수 있다.실제 예제  java.util.Enumeration 과 java.util.Iterator  Java StAX (Streaming API for XML)의 Iterator 기반 API          XmlEventReader, XmlEventWriter      ",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-06-Iterator.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-05-facade-html": {
        "title": "[deisgn Pattern Series] 05 Facade",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FacadeFacade퍼사드 패턴(Facade Pattern)은 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스(API)를 구성하기 위한 구조 패턴이다.이처럼 파사드는 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 제공하려는 목적이라고 생각하면 된다.  Facade라는 단어의 뜻은 건축물의 정면을 의미한다.건축물의 정면은 보통 건축물의 이미지와 건축 의도를 나타내기 때문에 오래 전부터 특별한 디자인을 적용하여 의미를 부여했다.이처럼 건축물 정면만 봐도 이 건물이 어떤 목적을 하는지 단번에 알수 있다는 특징을 차용하여 명명 지은 것이다.  Facade : 서브시스템 기능을 편리하게 사용할 수 있도록 하기 위해 여러 시스템과 상호 작용하는 복잡한 로직을 재정리해서 높은 레벨의 인터페이스를 구성한다. Facade 역할은 서브 시스템의 많은 역할에 대해 ‘단순한 창구’가 된다. 클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않도록 한다.  Additional Facade : 퍼사드 클래스는 반드시 한개만 존재해야 한다는 규칙같은 건 없다. 연관 되지 않은 기능이 있다면 얼마든지 퍼사드 2세로 분리한다. 이 퍼사드 2세는 다른 퍼사드에서 사용할 수도 있고 클라이언트에서 직접 접근할 수도 있다.  SubSystem(하위 시스템) : 수십 가지 라이브러리 혹은 클래스들  Client : 서브 시스템에 직접 접근하는 대신 Facade를 사용한다.퍼사드 패턴은 전략 패턴이나 팩토리 패턴과 같은 여타 다른 디자인 패턴과는 다르게 클래스 구조가 정형화 되지 않은 패턴이다.반드시 클래스 위치는 어떻고 어떤 형식으로 위임을 해야되고 이런것이 없다. 그냥 퍼사드 클래스를 만들어 적절히 기능 집약해주는 논리라고 생각하면 된다.재귀적 Facade 패턴의 적용재귀적 퍼사드란 Additional Facade 를 말하는 것이다. 예를 들어 다수의 클래스, 다수의 패키지를 포함하고 있는 큰 시스템에 요소 마다 Facade 패턴을 여기 저기 적용하고 다시 그 Facade를 합친 Facade를 만드는 식으로,퍼사드를 재귀적으로 구성하면 시스템은 보다 편리하게 된다. 이처럼 퍼사드는 한 개만 있으라는 법은 없으며 필요에 의하면 얼마든지 늘려서 의존할 수 있다.특징사용 시기  시스템이 너무 복잡할때  그래서 간단한 인터페이스를 통해 복잡한 시스템을 접근하도록 하고 싶을때  시스템을 사용하고 있는 외부와 결합도가 너무 높을 때 의존성 낮추기 위할때장점  하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템을 사용하기 쉬워진다.  하위 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있다.  복잡한 코드를 감춤으로써, 클라이언트가 시스템의 코드를 모르더라도 Facade 클래스만 이해하고 사용 가능하다  외부에서 내부 로직을 직접 사용하기 때문에 내부 로직의 구조를 변경한다고 하거나 파라미터나 리턴값 등을 변경할 경우 직접적으로 영향을 받아 수정이 힘들거나불가능한 경우가 종종 있다. 하지만 중간에 매개체 역할을 해주는 퍼사드 객체가 있기 때문에 실제 내부 로직이 어떻게 변경이 되더라도 상관이 없어지므로 의존성이 감소된다.단점  퍼사드가 앱의 모든 클래스에 결합된 최상위 객체가 될 수 있다  퍼사드 클래스 자체가 서브시스템에 대한 의존성을 가지게 되어 의존성을 완전히는 피할 수는 없다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-05-Facade.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-04-builder-html": {
        "title": "[deisgn Pattern Series] 04 Builder",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BuilderBuilder빌더 패턴(Builder Pattern)은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성하는 방식이다.1. 점층적 생성자 패턴우리가 다양한 매개변수를 입력받아 인스턴스를 생성하고 싶을때 사용하던 생성자를 오버로딩 하는 방식이다.문제는 타입이 다양할수록 생성자 메서드 수가 기하급수적으로 늘어나 가독성이나 유지보수 측면에서 좋지 않다.2. 자바 빈(Java Beans) 패턴이러한 단점을 보완하기 위해 Setter 메소드를 사용한 자바 빈(Bean) 패턴이 고안 되었다.매개변수가 없는 생성자로 객체 생성후 Setter 메소드를 이용해 클래스 필드의 초깃값을 설정하는 방식이다기존 생성자 오버로딩에서 나타났던 가독성 문제점이 사라지고 선택적인 파라미터에 대해 해당되는 Setter 메서드를 호출함으로써 유연적으로 객체 생성이 가능해졌다.하지만 이러한 방식은 객체 생성 시점에 모든 값들을 주입 하지 않아 일관성(consistency) 문제와 불변성(immutable) 문제가 나타나게 된다.1) 일관성 문제필수 매개변수란 객체가 초기화될때 반드시 설정되어야 하는 값이다. 하지만 개발자가 깜빡하고 set~() 메서드를 호출하지 않았다면 이 객체는 일관성이 무너진 상태가 된다. 즉, 객체가 유효하지 않은 것이다. 만일 다른곳에서 햄버거 인스턴스를 사용하게 된다면 런타임 예외가 발생할 수도 있다.이는 객체를 생성하는 부분과 값을 설정하는 부분이 물리적으로 떨어져 있어서 발생하는 문제점이다.물론 이는 어느정도 생성자(Constructor)와 결합하여 극복은 할 수 있다.하지만 다음에 소개할 불변성의 문제 때문에 자바 빈즈 패턴은 지양해야 한다.2) 불변성 문제자바 빈즈 패턴의 Setter 메서드는 객체를 처음 생성할때 필드값을 설정하기 위해 존재하는 메서드이다.하지만 객체를 생성했음에도 여전히 외부적으로 Setter 메소드를 노출하고 있으므로, 협업 과정에서 언제 어디서 누군가 Setter 메서드를 호출해 함부로 객체를 조작할수 있게 된다. 이것을 불변함을 보장할 수 없다고 얘기한다.Builder 패턴빌더 패턴은 이러한 문제들을 해결하기 위해 별도의 Builder 클래스를 만들어 메소드를 통해 step-by-step 으로 값을 입력받은 후에 최종적으로 build() 메소드로 하나의 인스턴스를 생성하여 리턴하는 패턴이다.빌더 패턴 사용법을 잠시 살펴보면, StudentBuilder 빌더 클래스의 메서드를 체이닝(Chaining) 형태로 호출함으로써 자연스럽게 인스턴스를 구성하고 마지막에 build() 메서드를 통해 최종적으로 객체를 생성하도록 되어있음을 볼 수 있다.패턴 구조class Student {    private int id;    private String name = \"아무개\";    private String grade = \"freshman\";    private String phoneNumber = \"010-0000-0000\";    public Student(int id, String name, String grade, String phoneNumber) {        this.id = id;        this.name = name;        this.grade = grade;        this.phoneNumber = phoneNumber;    }        @Override    public String toString() {        return \"Student { \" +                \"id='\" + id + '\\'' +                \", name=\" + name +                \", grade=\" + grade +                \", phoneNumber=\" + phoneNumber +                \" }\";    }    public static class StudentBuilder {        private int id;        private String name;        private String grade;        private String phoneNumber;        public StudentBuilder id(int id) {            this.id = id;            return this;        }        public StudentBuilder name(String name) {            this.name = name;            return this;        }        public StudentBuilder grade(String grade) {            this.grade = grade;            return this;        }        public StudentBuilder phoneNumber(String phoneNumber) {            this.phoneNumber = phoneNumber;            return this;        }             public Student build() {            return new Student(id, name, grade, phoneNumber); // Student 생성자 호출        }    }}빌더 네이밍  멤버이름()  set멤버이름()  with멤버이름()장점  객체 생성 과정을 일관된 프로세스로 표현  디폴트 매개변수 생략을 간접적으로 지원  필수 멤버와 선택적 멤버를 분리 가능  객체 생성 단계를 지연할 수 있다.  초기화 검증을 멤버별로 분리할 수 있다.  멤버에 대한 변경 가능성 최소화를 추구한다.단점  코드 복잡성 증가  생성자보다 성능이 떨어짐Simple Builderclass Person {    // final 키워드로 필드들을 불변 객체로 만든다.    private final String name;    private final String age;    private final String gender;    private final String job;    private final String birthday;    private final String address;    // 정적 내부 빌더 클래스    public static class Builder {        // 필수 파라미터        private final String name;        private final String age;        // 선택 파라미터        private String gender;        private String job;        private String birthday;        private String address;        // 필수 파라미터는 빌더 생성자로 받게 한다        public Builder(String name, String age) {            this.name = name;            this.age = age;        }        // 선택 파라미터는 각 메서드를 통해 정의한다        public Builder gender(String gender) {            this.gender = gender;            return this;        }        public Builder job(String job) {            this.job = job;            return this;        }        public Builder birthday(String birthday) {            this.birthday = birthday;            return this;        }        public Builder address(String address) {            this.address = address;            return this;        }        // 대상 객체의 private 생성자를 호출하여 최종 인스턴스화 한다        public Person build() {            return new Person(this); // 빌더 객체 자신을 넘긴다.        }    }    // private 생성자 - 생성자는 외부에서 호출되는것이 아닌 빌더 클래스에서만 호출되기 때문에    private Person(Builder builder) {        this.name = builder.name;        this.age = builder.age;        this.gender = builder.gender;        this.job = builder.gender;        this.birthday = builder.birthday;        this.address = builder.address;    }    @Override    public String toString() {        return \"Person{\" +                \"name='\" + name + '\\'' +                \", age='\" + age + '\\'' +                \", gender='\" + gender + '\\'' +                \", job='\" + job + '\\'' +                \", birthday='\" + birthday + '\\'' +                \", address='\" + address + '\\'' +                '}';    }}Director BuilderGOF에서 정의하고 있는 디자인 패턴은 복잡한 객체의 생성 알고리즘과 조립 방법을 분리하여 빌드 공정을 구축하는것이 목적이다. 빌더를 받아 조립 방법을 정의한 클래스를 Director라고 부른다.class Data {    private String name;    private int age;    public Data(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}abstract class Builder {    // 상속한 자식 클래스에서 사용하도록 protected 접근제어자 지정    protected Data data;    public Builder(Data data) {        this.data = data;    }    // Data 객체의 데이터들을 원하는 형태의 문자열 포맷을 해주는 메서드들 (머리 - 중간 - 끝 형식)    public abstract String head();    public abstract String body();    public abstract String foot();}// Data 데이터들을 평범한 문자열로 변환해주는 빌더class PlainTextBuilder extends Builder {    public PlainTextBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"Name: \");        sb.append(data.getName());        sb.append(\", Age: \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\";    }}// Data 데이터들을 JSON 형태의 문자열로 변환해주는 빌더class JSONBuilder extends Builder {    public JSONBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"{\\n\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t\\\"Name\\\" : \");        sb.append(\"\\\"\" + data.getName() + \"\\\",\\n\");        sb.append(\"\\t\\\"Age\\\" : \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\\n}\";    }}// Data 데이터들을 XML 형태의 문자열로 변환해주는 빌더class XMLBuilder extends Builder {    public XMLBuilder(Data data) {        super(data);    }    @Override    public String head() {        StringBuilder sb = new StringBuilder();        sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?&gt;\\n\");        sb.append(\"&lt;DATA&gt;\\n\");        return sb.toString();    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t&lt;NAME&gt;\");        sb.append(data.getName());        sb.append(\"&lt;NAME&gt;\");        sb.append(\"\\n\\t&lt;AGE&gt;\");        sb.append(data.getAge());        sb.append(\"&lt;AGE&gt;\");        return sb.toString();    }    @Override    public String foot() {        return \"\\n&lt;/DATA&gt;\";    }}// 각 문자열 포맷 빌드 과정을 템플릿화 시킨 디렉터class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    // 일종의 빌드 템플릿 메서드라 보면 된다    public String build() {        StringBuilder sb = new StringBuilder();        // 빌더 구현체에서 정의한 생성 알고리즘이 실행됨        sb.append(builder.head());        sb.append(builder.body());        sb.append(builder.foot());        return sb.toString();    }}Lombok의 @Builder/ @SuperBuilder클래스에 @Builder 어노테이션만 붙여주면 클래스를 컴파일 할 때 자동으로 클래스 내부에 빌더 API가 만들어진다. 롬복의 @Builder는 GOF의 디렉터 빌더가 아닌 심플 빌더 패턴을 다룬다실무 예제  java.lang.StringBuilder의 append()  java.lang.StringBuffer의 append()  java.nio.ByteBuffer의 put() - CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer 도 마찬가지  javax.swing.GroupLayout.Group의 addComponent()  java.lang.Appendable의 구현체  java.util.stream.Stream.Builder",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-04-Builder.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-03-flyweight-html": {
        "title": "[deisgn Pattern Series] 03 Flyweight",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FlyWeightFlyWeight플라이웨이트 패턴(Flyweight Pattern)은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴이다.간단히 말하면 캐시(Cache) 개념을 코드로 패턴화 한것으로 보면 되는데, 자주 변화는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식이다. 그래서 동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 최적화를 노리는 경량 패턴이라고도 불린다.  Flyweight : 경량 객체를 묶는 인터페이스.  ConcreteFlyweight : 공유 가능하여 재사용되는 객체 (intrinsic state)  UnsahredConcreteFlyweight : 공유 불가능한 객체 (extrinsic state)  FlyweightFactory : 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스          GetFlyweight() 메서드는 팩토리 메서드 역할을 한다고 보면 된다.      만일 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다        Client : 클라이언트는 FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다.intrinsic 와 extrinsic 상태플라이웨이트 패턴에서 가장 주의 깊게 보아야 할 점이 바로 Intrinsic와 Extrinsic의 상태를 구분하는 것이다.intrinsic란 ‘고유한, 본질적인’ 이라는 의미를 가진다. 본질적인 상태란 인스턴스가 어떠한 상황에서도 변하지 않는 정보를 말한다. 그래서 값이 고정되어 있기에 충분히 언제 어디서 공유해도 문제가 없게 된다.extrinsic이란 ‘외적인, 비본질적인’ 이라는 의미를 가진다. 인스턴스를 두는 장소나 상황에 따라서 변화하는 정보를 말한다. 그래서 값이 언제 어디서 변화할지 모르기 때문에 이를 캐시해서 공유할수 는 없다.  intrinsic한 객체 : 장소나 상황에 의존하지 않기 때문에 값이 고정되어 공유할 수 있는 객체  extrinsic한 객체 : 장소나 상황에 의존하기 때문에 매번 값이 바뀌어 공유할 수 없는 객체flyWeight 패턴 특징사용 시기  어플리케이션에 의해 생성되는 객체의 수가 많아 저장 비용이 높아질 때  생성된 객체가 오래도록 메모리에 상주하며 사용되는 횟수가 많을때  공통적인 인스턴스를 많이 생성하는 로직이 포함된 경우  임베디드와 같이 메모리를 최소한으로 사용해야하는 경우에 활용장점  애플리케이션에서 사용하는 메모리를 줄일 수 있다.  프로그램 속도를 개선 할수 있다.          new로 인스턴스화를 하면 데이터가 생성되고 메모리에 적재 되는 미량의 시간이 걸리게 된다.      객체를 공유하면 인스턴스를 가져오기만 하면 되기 때문에 메모리 뿐만 아니라 속도도 향상시킬 수 있게 되는 것이다.        단점              코드 복잡도 증가예시class Memory {    public static long size = 0; // 메모리 사용량    public static void print() {        System.out.println(\"총 메모리 사용량 : \" + Memory.size + \"MB\");    }}// ConcreteFlyweight(intrinsic) - 플라이웨이트 객체는 불변성을 가져야한다. 변경되면 모든 것에 영향을 주기 때문이다.final class TreeModel {    // 메시, 텍스쳐 총 사이즈    long objSize = 90; // 90MB    String type; // 나무 종류    Object mesh; // 메쉬    Object texture; // 나무 껍질 + 잎사귀 텍스쳐    public TreeModel(String type, Object mesh, Object texture) {        this.type = type;        this.mesh = mesh;        this.texture = texture;        // 나무 객체를 생성하여 메모리에 적재했으니 메모리 사용 크기 증가        Memory.size += this.objSize;    }}// UnsahredConcreteFlyweight(extrinsic)class Tree {    // 죄표값과 나무 모델 참조 객체 크기를 합친 사이즈    long objSize = 10; // 10MB    // 위치 변수    double position_x;    double position_y;    // 나무 모델    TreeModel model;    public Tree(TreeModel model, double position_x, double position_y) {        this.model = model;        this.position_x = position_x;        this.position_y = position_y;        // 나무 객체를 생성하였으니 메모리 사용 크기 증가        Memory.size +=  this.objSize;    }}// Clientclass Terrain {    // 지형 타일 크기    static final int CANVAS_SIZE = 10000;    // 나무를 렌더릴    public void render(String type, Object mesh, Object texture, double position_x, double position_y) {        // 나무를 지형에 생성//        Tree tree = new Tree(//                type, // 나무 종류//                mesh, // mesh//                texture, // texture//                Math.random() * CANVAS_SIZE, // position_x//                Math.random() * CANVAS_SIZE // position_y//        );        // 1. 캐시 되어 있는 나무 모델 객체 가져오기        TreeModel model = TreeModelFactory.getInstance(type);        // 2. 재사용한 나무 모델 객체와 변화하는 속성인 좌표값으로 나무 생성        Tree tree = new Tree(model, position_x, position_y);        출처: https://inpa.tistory.com/entry/GOF-💠-Flyweight-패턴-제대로-배워보자 [Inpa Dev 👨‍💻:티스토리]        System.out.println(\"x:\" + tree.position_x + \" y:\" + tree.position_y + \" 위치에 \" + type + \" 나무 생성 완료\");    }}public static void main(String[] args) {        // 지형 생성        Terrain terrain = new Terrain();        // 지형에 Oak 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Oak\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Acacia 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Acacia\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Jungle 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Jungle\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 총 메모리 사용률 출력        Memory.print();    }/** * 1. intrinsic 객체와 extrinsic 객체 쪼개기 * -&gt; 같은 객체를 여러 번 올릴 필요가 없기 때문에 공유되는 객체는 따로 빼둔다. *  * 2. Flyweight 팩토리 만들기 * -&gt; Flyweight Pool : HashMap 컬렉션을 통해 키와 나무 모델 객체를 저장하는 캐시 저장소 역할 * -&gt; getInstance : Pool에서 가져오고자 하는 객체가 있는지 검사하고 있으면 가져오고 없으면 생성 */// FlyweightFactoryclass TreeModelFactory {    // Flyweight Pool - TreeModel 객체들을 Map으로 등록하여 캐싱    private static final Map&lt;String, TreeModel&gt; cache = new HashMap&lt;&gt;(); // static final 이라 Thread-Safe 함    // static factory method    public static TreeModel getInstance(String key) {        // 만약 캐시 되어 있다면        if(cache.containsKey(key)) {            return cache.get(key); // 그대로 가져와 반환        } else {            // 캐시 되어있지 않으면 나무 모델 객체를 새로 생성하고 반환            TreeModel model = new TreeModel(                    key,                    new Object(),                    new Object()            );            System.out.println(\"-- 나무 모델 객체 새로 생성 완료 --\");            // 캐시에 적재            cache.put(key, model);            return model;        }    }}/** * 3. Client 최적화  * -&gt; TreeModel에서 공유되고 있는 나무 모델을 가져온다. * -&gt; 가져온 나무 모델과 좌표값으로 나무 객체를 생성 */Garbage Collection 처리 주의사항‘인스턴스를 관리’ 하는 기능을 자바 프로그래밍에서 구현하여 사용할 때에는 반드시 ‘관리되고 있는 인스턴스는 GC(Garbage Collection) 처리되지 않는다’ 라는 점을 주의해야 한다.즉, 나무를 모두 렌더링을 완료하여 더이상 나무를 생성할 일이 없다라면, 반드시 TreeModelFactory에 잔존해있는 Flyweight Pool 을 비워줄 필요가 있는 것이다. 그래야 인스턴스에 대한 참조를 잃은 TreeModel 인스턴스들이 GC에 의해 메모리 청소가 되게 된다. 그렇지 않으면 더이상 나무를 생성할 일이 없는데도 TreeModel 데이터가 메모리에 쓸데없이 잔존하게 된다.실제 예시String Constant Pool  String Constant Pool 개념이 바로 Flyweight Pool 개념이다.  자바는 String 데이터에 대해 별도로 string constant pool 영역에 적재한다.  같은 문자열 데이터 다시 사용될때 pool을 검사해 있다면 이를 공유한다.  만일 pool에 없다면 새로 메모리를 할당하여 pool에 등록한 후 재사용한다.  String 클래스는 Flyweight 패턴을 통해 리터럴 문자열 데이터에 대한 캐싱을 하고 있는 것이다.  String 클래스는 불변(immutable) 객체 특성을 가지고 있다.",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-03-FlyWeight.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-02-composite-html": {
        "title": "[deisgn Pattern Series] 02 Composite",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CompositeComposite합체 패턴(Composite Pattern)은 복합 객체(Composite) 와 단일 객체(Leaf)를 동일한 컴포넌트로 취급하여, 클라이언트에게 이 둘을 구분하지 않고 동일한 인터페이스를 사용하도록 하는 구조 패턴이다.복합체 패턴은 전체-부분의 관계를 갖는 객체들 사이의 관계를 트리 계층 구조로 정의해야 할때 유용하다.윈도우나 리눅스의 파일 시스템 구조를 떠올려보면 쉽게 이해할 수 있다.폴더(디렉토리) 안에는 파일이 들어 있을수도 있고 파일을 담은 또 다른 폴더도 들어있을 수 있다.이를 복합적으로 담을수 있다 해서 Composite 객체라고 불리운다. 반면 파일은 단일 객체 이기 때문에 이를 Leaf 객체라고 불리운다. 즉 Leaf는 자식이 없다.복합체 패턴은 바로 이 폴더와 파일을 동일한 타입으로 취급하여 구현을 단순화 시키는 것이 목적이다.폴더 안에는 파일 뿐만 아니라 서브 폴더가 올수 있고 또 서브 폴더안에 서브 폴더가 오고.. 이런식으로 계층 구조를 구현하다 보면, 자칫 복잡해 질 수 도 있는 복합 객체를 재귀 동작을 통해 하위 객체들에게 작업을 위임한다. 그러면 복합 객체와 단일 객체를 대상으로 똑같은 작업을 적용할 수 있어 단일 / 복합 객체를 구분할 필요가 거의 없어진다.패턴  Component : Leaf와 Compsite 를 묶는 공통적인 상위 인터페이스  Composite : 복합 객체로서, Leaf 역할이나 Composite 역할을 넣어 관리하는 역할을 한다.          Component 구현체들을 내부 리스트로 관리한다      add 와 remove 메소드는 내부 리스트에 단일 / 복합 객체를 저장      Component 인터페이스의 구현 메서드인 operation은 복합 객체에서 호출되면 재귀 하여, 추가 단일 객체를 저장한 하위 복합 객체를 순회하게 된다.        Leaf: 단일 객체로서, 단순하게 내용물을 표시하는 역할을 한다.  Component 인터페이스의 구현 메서드인 operation은 단일 객체에서 호출되면 적절한 값만 반환한다  Client : 클라이언트는 Component를 참조하여 단일 / 복합 객체를 하나의 객체로서 다룬다.패턴 흐름// Component 인터페이스interface ItemComponent {    int getPrice();    String getName();}// Composite 객체class Bag implements ItemComponent {    // 아이템들과 서브 가방 모두를 저장하기 위해 인터페이스 타입 리스트로 관리    List&lt;ItemComponent&gt; components = new ArrayList&lt;&gt;();    String name; // 가방 이름    public Bag(String name) {        this.name = name;    }    // 리스트에 아이템 &amp; 가방 추가    public void add(ItemComponent item) {        components.add(item);    }    // 현재 가방의 내용물을 반환    public List&lt;ItemComponent&gt; getComponents() {        return components;    }    @Override    public int getPrice() {        int sum = 0;        for (ItemComponent component : components) {            // 만일 리스트에서 가져온 요소가 Item이면 정수값을 받을 것이고, Bag이면 '재귀 함수' 동작이 되게 된다 ☆            sum += component.getPrice(); // 자기 자신 호출(재귀)        }        return sum; // 그렇게 재귀적으로 돌아 하위 아이템들의 값을 더하고 반환하게 된다.    }    @Override    public String getName() {        return name;    }}// Leaf 객체class Item implements ItemComponent {    String name; // 아이템 이름    int price; // 아이템 가격    public Item(String name, int price) {        this.name = name;        this.price = price;    }    @Override    public int getPrice() {        return price;    }    @Override    public String getName() {        return name;    }}class Client {    public static void main(String[] args) {        // 1. 메인 가방 인스턴스 생성        Bag bag_main = new Bag(\"메인 가방\");        // 2. 아이템 인스턴스 생성        Item armor = new Item(\"갑옷\", 250);        Item sword = new Item(\"장검\", 500);        // 3. 메인 가방에는 모험에 필요한 무구 아이템만을 추가        bag_main.add(armor);        bag_main.add(sword);        // 4. 서브 가방 인스턴스 생성        Bag bag_food = new Bag(\"음식 가방\");        // 5. 아이템 인스턴스 생성        Item apple = new Item(\"사과\", 400);        Item banana = new Item(\"바나나\", 130);        // 6. 서브 가방에는 음식 아이템만을 추가        bag_food.add(apple);        bag_food.add(banana);        // 7. 서브 가방을 메인 가방에 넣음        bag_main.add(bag_food);        // ----------------------------------------------------- //        Client client = new Client();        // 가방 안에 있는 모든 아이템의 총 값어치를 출력 (가방안에 아이템 뿐만 아니라 서브 가방도 들어있음)        client.printPrice(bag_main);        // 서브 가방 안에 있는 모든 아이템의 총 값어치를 출력        client.printPrice(bag_food);    }    public void printPrice(ItemComponent bag) {        int result = bag.getPrice();        System.out.println(bag.getName() + \"의 아이템 총합 : \" + result + \" 골드\");    }}패턴 특징사용 시기  데이터를 다룰때 계층적 트리 표현을 다루어야 할때  복잡하고 난해한 단일 / 복합 객체 관계를 간편히 단순화하여 균일하게 처리하고 싶을때장점  단일체와 복합체를 동일하게 여기기 때문에 묶어서 연산하거나 관리할 때 편리하다.  다형성 재귀를 통해 복잡한 트리 구조를 보다 편리하게 구성 할 수 있다.  수평적, 수직적 모든 방향으로 객체를 확장할 수 있다.  새로운 Leaf 클래스를 추가하더라도 클라이언트는 추상화된 인터페이스 만을 바라보기 때문에 개방 폐쇄 원칙(OCP)Visit Website을 준수 한다. (단일 부분의 확장이 용이)단점  재귀 호출 특징 상 트리의 깊이(depth)가 깊어질 수록 디버깅에 어려움이 생긴다.  설계가 지나치게 범용성을 갖기 때문에 새로운 요소를 추가할 때 복합 객체에서 구성 요소에 제약을 갖기 힘들다.  계층형 구조에서 leaf 객체와 composite 객체들을 모두 동일한 인터페이스로 다루어야하는데, 이 공통 인터페이스 설계가 까다로울 수 있다.          복합 객체가 가지는 부분 객체의 종류를 제한할 필요가 있을 때      수평적 방향으로만 확장이 가능하도록 Leaf를 제한하는 Composite를 만들때      ",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-02-Composite.html"
      }
      ,
    
      "design-pattern-2024-05-19-deisgn-pattern-series-01-chainofresponsibility-html": {
        "title": "[deisgn Pattern Series] 01 Chainofresponsibility",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Chain Of ResponsibilityChain Of Responsibility책임 연쇄 패턴(Chain Of Responsibility Pattern, COR)은 클라이어트의 요청에 대한 세세한 처리를 하나의 객체가 몽땅 하는 것이 아닌,여러개의 처리 객체들로 나누고, 이들을 사슬(chain) 처럼 연결해 집합 안에서 연쇄적으로 처리하는 행동 패턴이다.이러한 처리 객체들을 핸들러(handler)라고 부르는데, 요청을 받으면 각 핸들러는 요청을 처리할 수 있는지, 없으면 체인의 다음 핸들러로 처리에 대한 책임을 전가한다.한마디로 책임 연쇄라는 말은 요청에 대한 책임을 다른 객체에 떠넘긴다는 소리이다. 떠넘긴다고 하니까 부정적인 의미로 들릴수도 있겠지만, 이러한 체인 구성은 하나의 객체에 처리에 대한 책임을 요청을 보내는 쪽(sender)과 요청을 처리하는(receiver) 쪽을 분리하여 각 객체를 부품으로 독립시키고 결합도를 느슨하게 만들며,상황에 따라서 요청을 처리할 객체가 변하는 프로그램에도 유연하게 대응할 수 있다는 장점을 가지고 있다. 특히나 중첩 if-else 들을 최적화하는데 있어 실무에서도 많이 애용되는 패턴중 하나이기도 하다.특징패턴 사용 시기  특정 요청을 2개 이상의 여러 객체에서 판별하고 처리해야 할때  특정 순서로 여러 핸들러를 실행해야 하는 경우  프로그램이 다양한 방식과 종류의 요청을 처리할 것으로 예상되지만 정확한 요청 유형과 순서를 미리 알 수 없는 경우  요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때 (체인 연결을 런타임에서 동적으로 설정)패턴 장점  클라이언트는 처리 객체의 체인 집합 내부의 구조를 알 필요가 없다.  각각의 체인은 자신이 해야하는 일만 하기 때문에 새로운 요청에 대한 처리객체 생성이 편리해진다.  클라이언트 코드를 변경하지 않고 핸들러를 체인에 동적으로 추가하거나 처리 순서를 변경하거나 삭제할 수 있어 유연해진다  요청의 호출자(invoker)와 수신자(receiver)  분리시킬 수 있다.          요청을 하는 쪽과 요청을 처리하는 쪽을 디커플링 시켜 결합도를 낮춘다      요청을 처리하는 방법이 바뀌더라도 호출자 코드는 변경되지 않는다.      패턴 단점  실행 시에 코드의 흐름이 많아져서 과정을 살펴보거나 디버깅 및 테스트가 쉽지 않다.  충분한 디버깅을 거치지 않았을 경우 집합 내부에서 무한 사이클이 발생할 수 있다.  요청이 반드시 수행된다는 보장이 없다. (체인 끝까지 갔는데도 처리되지 않을 수 있다)  책임 연쇄로 인한 처리 지연 문제가 발생할 수 있다. 다만 이는 트레이드 오프로서 요청과 처리에 대한 관계가 고정적이고 속도가 중요하면 책임 연쇄 패턴 사용을 유의하여야 한다.ex)// 구체적인 핸들러를 묶는 인터페이스 (추상 클래스)abstract class Handler {    // 다음 체인으로 연결될 핸들러    protected Handler nextHandler = null;    // 생성자를 통해 연결시킬 핸들러를 등록    public Handler setNext(Handler handler) {        this.nextHandler = handler;        return handler; // 메서드 체이닝 구성을 위해 인자를 그대로 반환함    }    // 자식 핸들러에서 구체화 하는 추상 메서드    protected abstract void process(String url);    // 핸들러가 요청에 대해 처리하는 메서드     public void run(String url) {        process(url);        // 만일 핸들러가 연결된게 있다면 다음 핸들러로 책임을 떠넘긴다        if (nextHandler != null)            nextHandler.run(url);    }}class ProtocolHandler extends Handler {    @Override    protected void process(String url) {        int index = url.indexOf(\"://\");        if (index != -1) {            System.out.println(\"PROTOCOL : \" + url.substring(0, index));        } else {            System.out.println(\"NO PROTOCOL\");        }    }}class DomianHandler extends Handler {    @Override    protected void process(String url) {        int startIndex = url.indexOf(\"://\");        int lastIndex = url.lastIndexOf(\":\");        System.out.print(\"DOMAIN : \");        if (startIndex == -1) {            if (lastIndex == -1) {                System.out.println(url);            } else {                System.out.println(url.substring(0, lastIndex));            }        } else if (startIndex != lastIndex) {            System.out.println(url.substring(startIndex + 3, lastIndex));        } else {            System.out.println(url.substring(startIndex + 3));        }    }}class PortHandler extends Handler {    @Override    protected void process(String url) {        int index = url.lastIndexOf(\":\");        if (index != -1) {            String strPort = url.substring(index + 1);            try {                int port = Integer.parseInt((strPort));                System.out.println(\"PORT : \" + port);            } catch (NumberFormatException e) {                e.printStackTrace();            }        }    }}class Client {    public static void main(String[] args) {        // 1. 핸들러 생성        Handler handler1 = new ProtocolHandler();        Handler handler2 = new DomianHandler();        Handler handler3 = new PortHandler();        // 2. 핸들러 연결 설정 (handler1 → handler2 → handler3)        handler1.setNext(handler2).setNext(handler3);        // 3. 요청에 대한 처리 연쇄 실행        String url1 = \"http://www.youtube.com:80\";        System.out.println(\"INPUT: \" + url1);        handler1.run(url1);        System.out.println();        String url2 = \"https://www.inpa.tistory.com:443\";        System.out.println(\"INPUT: \" + url2);        handler1.run(url2);        System.out.println();        String url3 = \"http://localhost:8080\";        System.out.println(\"INPUT: \" + url3);        handler1.run(url3);    }}실수에서 예시  java.util.logging.Logger의 log()  javax.servlet.Filter의 doFilter()",
        "url": "//design_pattern/2024/05/19/deisgn-pattern-series-01-ChainOfResponsibility.html"
      }
      ,
    
      "java-2024-05-18-java-series-29-virtualthread-html": {
        "title": "[java Series] 29 Virtualthread",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VirtualThreadVirtualThread! 간단 정리 버전 !기본 구성Project Loom에서 시작되었으며, Java19에는 Preview로 지원되었고 21에서 정식으로 추가됐다.기본 발상은 Java의 쓰레드는 Kernal Thread를 할당 받아서 사용했었는데 이는  할당까지 OS의 영향하에 있다.  할당까지 비용이 너무 많이 든다.  1 ~ 2MB가 최대flowchart TDsubgraph PlatformThread    subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        subgraph JVM        PlatformThread1        PlatformThread2    end        KernalThread1 --&gt; PlatformThread1    KernalThread2 --&gt; PlatformThread2end라는 문제가 근본적으로 있었다. 그래서 이를 극복하기 위해서 ThreadPool를 할당하여 쓰고 버리는 것이 아닌 반납 하는 시스템으로 자주 사용했다.VirtualThread는 기존 쓰레드(PlatformThread)와 달리 JVM 단에서 쓰레드를 만들어서 실행하는 방향으로 발상을 바꾸게 되어 생겼다. 이를 통해서  JVM의 영향력 아래 있다.  할당에 비용이 적게 들어서 쓰고 버리는 형태로 패러다임이 변경됐다.  ~ KB 단위 사이즈는 식의 변화가 생겼다. 이러면서 기존 쓰레드는 PlatformThread로 개명했다.flowchart TDsubgraph VirtualThread     subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        KernalThread1 --&gt; ForkJoinPool    KernalThread2 --&gt; ForkJoinPool        subgraph JVM        ForkJoinPool                ForkJoinPool --&gt; CarrierThread1        ForkJoinPool --&gt; CarrierThread2                CarrierThread1 --&gt; Queue1        CarrierThread2 --&gt; Queue2                Queue1 --&gt; VirtualThread1        Queue1 --&gt; VirtualThread2        Queue2 --&gt; VirtualThread3        Queue2 --&gt; VirtualThread4    endend  캐리어 쓰레드란?  Proeject Loom의 일부로 도입된 개념으로 VirtualThread를 실행하기 위한 운반체 역할을 한다. PlatformThread를 기반으로 합니다. CarrierThread는 ForkJoinPool 안에 workerThread로 생성이 되어 스케쥴링 된다.VirtualThreadVirtualThread Thread(Runnable을 구현한)를 상속 받았다. 따라서 상호 변용이 가능하다.package java.lang;sealed abstract class BaseVirtualThread extends Thread        permits VirtualThread, ThreadBuilders.BoundVirtualThread {    BaseVirtualThread(String name, int characteristics, boolean bound) {        super(name, characteristics, bound);    }    abstract void park();    abstract void parkNanos(long nanos);    abstract void unpark();}package java.lang;/** * A thread that is scheduled by the Java virtual machine rather than the operating * system. */final class VirtualThread extends BaseVirtualThread {//... 중략private static final long CARRIER_THREAD = U.objectFieldOffset(VirtualThread.class, \"carrierThread\");    // carrier thread when mounted, accessed by VM    private volatile Thread carrierThread;}주의점  쓰고 버리는게 오히려 이득이다.  커넥션 풀을 사용하는 경우(MySQL 같이)나 IO 최대 개수 제한이 있는 경우(OS 파일) 문제가 될 수 있으니 Bound를 두고 사용하는게 맞을 수 있다.",
        "url": "//java/2024/05/18/java-series-29-VirtualThread.html"
      }
      ,
    
      "java-2024-05-18-java-series-28-reactive-html": {
        "title": "[java Series] 28 Reactive",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReactiveReactive데이터 흐름과 전달에 대한 프로그래밍 패러다임이다.기존 명령형 패러다임은 콜을 받아서 당겨오는(Pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(Push) 방식이다.즉, 주변 환경과 상호작용을 하는 것을 주도하는게 아니라 일정 값이 변하면 이벤트를 받아서 동작한다. 일종의 옵저버(Observer) 패턴이다.  대략적으로 보면?      기본 골자는 Stream API와 비슷하다.    Stream API와 같이 끝 맺는 메소드 (subscribe)가 있어야 한다.    퍼블리셔가 이벤트를 발행하면 stream을 타고 subscrbie 소비가 되는 패턴이다.  Flow APIJava 9에는  java.util.concurrent.Flow를 추가했다.리액티브 표준에 따라 발행(Pub)/ 구독(Sub)을 할 수 있도록 되어 있다.  Publisher : 데이터를 발행하는 주체이다.    @FunctionalInterfacepublic static interface Publisher&lt;T&gt; {  public void subscribe(Subscriber&lt;? super T&gt; subscriber);}        Subscriber : 데이터를 소비하는 주체이다.    public static interface Subscriber&lt;T&gt; {  public void onSubscribe(Subscription subscription);  public void onNext(T item);  public void onError(Throwable throwable);  public void onComplete();}        Subscription : 구독 그 자체다. Publisher - Subscriber를 연결한다.    public static interface Subscription {  public void request(long n);  public void cancel();}        Processor : 리액티스 스트림에서 처리하는 단계이다.    public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}      ",
        "url": "//java/2024/05/18/java-series-28-Reactive.html"
      }
      ,
    
      "java-2024-05-18-java-series-27-little-html": {
        "title": "[java Series] 27 Little",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자잘한 기록물charType -&gt; integer numberclass Example {    public static void main(String[] args) {         char charNine = '9';         int nine = charNine - '0';         // -&gt; nine;    }}String -&gt; splice?class Example {    public static void main(String[] args) {         String exam = \"adcd\";         StringBuilder builder = new StringBuilder(exam);         builder.deleteCharAt(1); //like Splice    }}",
        "url": "//java/2024/05/18/java-series-27-Little.html"
      }
      ,
    
      "java-2024-05-18-java-series-26-set-html": {
        "title": "[java Series] 26 Set",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SetintersectList의 retainAll은 교집합 구현에 완벽히 사용 불가import java.util.ArrayList;class RetainTest {    @Test    public void case1() {        String first = \"aaabb\";        String second = \"aabbb\";        List&lt;String&gt; firstList = new ArrayList(); // [aa, aa, ab, bb]        List&lt;String&gt; secondList = new ArrayList(); //[aa, ab, bb, bb]        char[] firstChar = first.toCharArray();        for( int i = 1; i &lt; firstChar.length; i ++ )  firstList.add(firstChar[i - 1]+\"\"+firstChar[i]);        char[] secondChar = second.toCharArray();        for( int i = 1; i &lt; secondChar.length; i ++ )  secondList.add(secondChar[i - 1]+\"\"+secondChar[i]);                                firstList.retainAll(secondList);        System.out.println(firstChar); //[aa, aa, ab, bb]                //firstList에 영향이 없다 치고        secondList.remove(firstList);        System.out.println(secondList); //[aa, ab, bb, bb]        /**         * - 결론         * 알던 것과 결과가 굉장히 다르다.          */    }}",
        "url": "//java/2024/05/18/java-series-26-Set.html"
      }
      ,
    
      "java-2024-05-18-java-series-24-junit-html": {
        "title": "[java Series] 24 Junit",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JUnitJunitAnnotation            Annotation      Description                                @Test      메소드가 테스트 메소드임을 나타낸다.                            @ParameterizedTest      매개변수가 있는 테스트임을 나타낸다.                            @ValueSource      반복 테스트에서 지정한 배열을 파라미터 값으로 순서대로 넘겨준다. (하나의 인수일 경우)                            @NullSource      Null로 값을 전달할 떄  사용한다.                            @EmptySource      빈 값을 인수로 전달할 때 사용한다.                            @NullAndEmptySource      Null, Empty 모두 전달할 때 사용      @CsvSource      테스트 입력값을 Csv로 구성하여 던질 떄 사용한다.              @EnumSource      열거형의 배열을 테스트 메소드에 전달                            @MethodSource      Arguments로 파라미터를 여러 개 전달할 떄 사용한다. (Arguments.of(value, value….))                            @RepeatedTest      메소드가 반복 테스트 메소드임을 나타낸다.                            @DisplayName      테스트 클래스 또는 메소드에 대한 사용자 지정 표시 이름                            @DisplayNameGeneration      테스트 클래스 이름 생성기를 선언한다. *                            @BeforeEach      @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 전에 실행되는 것을 나타낸다. 테스트 마다 실행 전에 실행된다.  매 테스트마다 초기화해야 하는 경우 사용된다.                            @AfterEach      @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 후에 실행되는 것을 나타낸다.  테스트 마다 실행 후에 실행된다.      매 테스트 후 정리해야 하는 경우 사용된다.                            @BeforeAll      @BeforeEach 와 유사하지만 static 메소드여야만 하며  테스트 전에 한 번만 실행된다.                            @AfterAll      @AfterEach 와 유사하지만 static 메소드여야만 하며  테스트 후에 한 번만 실행된다.                            @Nested      주석이 달린 클래스가 중첩 테스트 클래스임을 나타낸다.                            @Tag      클래스, 메소드 수준 테스트 필터링을 위해서 사용한다.                            @Disabled      테스트 클래스, 메소드를 비활성화할 때 사용한다.                            @Timeout      테스트 타임아웃을 지정한다.                            @ExtendWith      확장을 선언적으로 등록할 때 사용한다.                            @RegisterExtension      필드를 통해 프로그래밍 방식으로 확장을 등록할 떄 사용한다.                            @TempDir      테스트 메소드에서 필드 주입 또는 매개변수 주입을 통해 임시 디렉토리를 제공                            @TestFactory      동적 테스트를 위한 테스트 팩토리임을 나타낸다.                            @TestTemplate                                   @TestClassOrder      @Nested 간 실행 순서를 구성하는 데 사용한다.                            @TestMethodOrder      테스트 메소드간 순서를 구성하는 데 사용한다.                                               @                            @TestInstance      주석이 달린 테스트 클래스의 인스턴스 수명 주기를 구성하는데 사용한다.                            @Sql      sql 파일을 지정하여 Dao 단위 테스트에 미리 구성된 쿼리를 실행한다.                    class Junit {    @TestFactory    Stream&lt;DynamicTest&gt; testFactory () {        List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        return numbers.stream()                      .forEach( num -&gt; dynamicTest(                              num,                              () -&gt; assertThat(number &lt; 10).isTrue()                      ));    }    @ParameterizedTest    @ValueSource(ints = {1,2,3,4,5,6,7,8,9,10})    public isUnderThen(int number){        assertThat(number &lt; 10).isTrue();    }}Spring Test AnnotationsController Test| Annotation                                                                                                                                                    |                                      Description                                      ||:————————————————————————————————————————————————————–|:————————————————————————————-:|| @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, properties = “spring.profiles.active=[profile]”)                  | SpringBootTest임을 알린다. 이 어노테이션이 붙으면 SpringContext를 실행하고 Component 스캔 등을 한다. (스프링을 켠다.) || @AutoConfigureMockMvc                                                                                                                                         |                                    서블릿 컨테이너를 모킹한다.                                    || @TestPropertySource                                                                                                                                           |     테스트 환경의 Property를 지정할 수 있다. (classpath:로 resource 내부에서 찾는건 덤 -&gt; build에서 찾는다.)     || @ActiveProfiles                                                                                                                                               |                               Active로 둘 Profile를 지정한다.                                |            Object      Description                  @AutowiredMockMvc      테스트용 MVC환경을 만들어 요청, 전송, 응답을 제공하는 클래스              @LocalServerPortint port      현재 mocking 혹은 지정된 포트를 반환한다. (RandomPort의 경우)      //ex)@Test@DisplayName(value = \"ContextLoadTest\")void contextLoads() throws Exception {        System.out.println(\"ContextLoaded\");        //given        String expect = \"junitTest\";        //when        mockMvc.perform(        get(\"/v1/user/test\")        .contentType(MediaType.APPLICATION_JSON)        .accept(MediaType.APPLICATION_JSON)        )        //that        .andExpect(MockMvcResultMatchers.status().isOk())        .andExpect(jsonPath(\"$\",expect).exists());        }ServiceTest| Annotation  |                 Description                  ||:————|:——————————————–:|| @ExtendWith |        단위 테스트에 공통적으로 사용할 확장 기능을 선언한다.        || @Mock       |       Mock 객체를 생성 메소드는 있지만 내부 구현이 없다.        || @Spy        | 모든 기능을 가지고 있다. 다만 Stub을 하면 해당 부분만 Mocking된다. || @InjectMock |  @Mock, @Spy로 생산한 객체를 주입한다.(생성자 주입으로 추정된다.)  |RepositoryTest| Annotation                                                                                                                                          |                         Descpription                         ||:—————————————————————————————————————————————————-|:————————————————————:|| @DataJpaTest(  showSql = true,  properties = {“classpath:application.yml”},  includeFilters = {}) | SpringContext 중 Repository에 관련된 요소들만 테스트하기 위해서 사용하는 어노테이션이다. || @AutoConfigureTestDatabase(connection=””, replace=””)                                                                                               |    TestDB를 구성할 때 유용한 어노테이션이다. 테스트 시 DB를 테스트 DB로 대체할 수 있다.    |",
        "url": "//java/2024/05/18/java-series-24-Junit.html"
      }
      ,
    
      "java-2024-05-18-java-series-23-shellcommand-html": {
        "title": "[java Series] 23  shellcommand",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - shellCommand당시 OOM이 나서 여러 옵션을 건들였었는데 이에 대해서 찾아보고 이를 기록한 문서입니다.#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jstat -gcutil -h 20 $pid 2000 10000#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jhsdb jmap --binaryheap --dumpfile /home/chat/dump.hprof --pid $pid#!/bin/bash#projectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jcmd $pid GC.class_histogram &gt; histogram.logif [ -z $pid ] then        echo \"No server is running.\" else        kill -9 \"$pid\"        echo \"Shut down the running server.\"fi/home/jdk-11/bin/java \\-XX:+UseParallelOldGC \\-Xms1024m \\-Xmx4096m \\-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=/home/chat/dump/heapdump.hprof \\-verbose:gc \\-jar \\-Dspring.profiles.active=prod \\$projectPath/$projectName-*.war \\&gt; $projectPath/out.log  \\2&gt; $projectPath/exception.log &amp;echo \"The server was successfully run.\"",
        "url": "//java/2024/05/18/java-series-23-ShellCommand.html"
      }
      ,
    
      "java-2024-05-18-java-series-22-floatingpoint-html": {
        "title": "[java Series] 22 Floatingpoint",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Floating point issue부동 소수점 관련 문제class FloatingPoint {    @Test    public void fpFailure() {        Assertions.assertEquals(1.2 , 1.1 + 0.1);        //결과는? false        //부동소수점 문제 때문에 그렇다. (특히 이 주변은 다 괜찮은데 얘만 그렇다.)        /**         * Expected :1.2         * Actual   :1.2000000000000002         */        //위와 같은 결과로 나온다.    }        @Test    public void fpSuccess() {        Assertions.assertEquals(BigDecimal.valueOf(1.2), BigDecimal.valueOf(1.1).add(BigDecimal.valueOf(0.1)));        //이러면 성공한다.    }}Java _ BigDecimal 관련 사용 시 유의점연산  ’+’ : BigDecimal.valueOf(x).add(BigDecimal.valueOf(y));  ’-‘ : BigDecimal.valueOf(x).substract(BigDecimal.valueOf(y));  ‘*’ : BigDecimal.valueOf(x).multiply(BigDecimal.valueOf(y));  ’/’ : BigDecimal.valueOf(x).divide(BigDecimal.valueOf(y));  ’%’ : BigDecimal.valueOf(x).remainder(BigDecimal.valueOf(y));  절대값 : BigDecimal.valueOf(x).abs();소수점RoundingMode  UP(BigDecimal.ROUND_UP), : 양수일 때 올림, 음수일 때 내림  DOWN(BigDecimal.ROUND_DOWN), : ROUND_UP과 반대  CEILING(BigDecimal.ROUND_CEILING), : 올림  FLOOR(BigDecimal.ROUND_FLOOR), : 내림  HALF_UP(BigDecimal.ROUND_HALF_UP), : 반올림 (5이상 올림 5미만 버림)  HALF_DOWN(BigDecimal.ROUND_HALF_DOWN), : 반올림 ( 6이상 올림, 6미만 버림)  HALF_EVEN(BigDecimal.ROUND_HALF_EVEN), : 반올림 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP  UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);: 딱 떨어지는 값이 아니면 ArithmeticException사용법BigDecimal(\"0.9999\").setScale(0, RoundingMode.CEILING);MathContext  UNLIMITED = new MathContext(0, RoundingMode.HALF_UP); : unlimit (무제한 정밀 산술)  DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal32 format, 7 digits ( 7자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal64 format, 16 digits  ( 16자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);: matching the precision of the IEEE 754-2019 decimal128 format, 34 digits ( 32자리 정밀도 및 HALF_EVENT의 반올림 모드)MethodsBigIntegerclass IntroduceBigInteger {    public void bit () {        BigInteger i = new BigInteger(\"1018\"); // 2진수로 표현하면 : 1111111010(2)        int bitCount = i.bitCount(); // 1의 갯수 : 8        int bitLength = i.bitLength(); // 비트 수 : 10        int getLowestSetBit = i.getLowestSetBit(); // 1        boolean testBit3 = i.testBit(3); // true        BigInteger setBit12 = i.setBit(12); // 우측에서 13번째 비트를 1로 변경 → 1001111111010(2) → 5114        BigInteger flipBit0 = i.flipBit(0); // 1111111011(2) → 1019        BigInteger clearBit3 = i.clearBit(3); // 1111110010(2) → 1010        }           public void bitOperate () {        BigInteger i = new BigInteger(\"17\"); // 2진수 : 10001(2)        BigInteger j = new BigInteger(\"7\"); // 2진수 : 111(2)        BigInteger and = i.and(j); // 10001(2) &amp; 111(2) = 00001(2) → 1(10)        BigInteger or = i.or(j); // 23        BigInteger not = j.not(); // -8        BigInteger xor = i.xor(j); // 22        BigInteger andNot = i.andNot(j); // 16        BigInteger shiftLeft = i.shiftLeft(1); // 34        BigInteger shiftRight = i.shiftRight(1); // 8    }}JsonSerializerBigDecimal to JsonValueclass BigDecimalScale6WithBankersRoundingSerializer  implements JsonSerializer&lt;BigDecimal&gt; {    public static Integer SCALE_SIX = 6;    public static RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;        @Override    public Object serialize( BigDecimal value, JsonGenerator gen,   SerializerProvider serializers ) {        return gen.writeString(value.setScale(SCALE_SIX, BANKERS_ROUNDING_MODE).toString());    }}",
        "url": "//java/2024/05/18/java-series-22-FloatingPoint.html"
      }
      ,
    
      "java-2024-05-18-java-series-21-yaml-html": {
        "title": "[java Series] 21 Yaml",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - YAMLYAML(Yet Another Markup Language)기존에 주로 사용되던 포맷인 JSON의 불편함을 해소하기 위해 만들어진 superset이다. (확장자만 바꿔도 JSON -&gt; YAML로 변환된다. )데이터 정의  Key:Value 표기  콤마 표기하지 않음  indent로 계층 구조를 표현  따옴표 (굳이 쓰지 않아도 된다.)  작은 따옴표, 큰 따옴표 -&gt; 이스케이필 문자를 구분해야하면, 큰 따옴표는 escapeSequence, 작은 따옴표는 그대로 문자열로 처리한다.배열 &amp; 리스트  -으로 하위 엘리먼트 표현  객체 배열이 필요하다면 객체 시작에만 -를 사용한다.    students:  - name: Mark major: Math age: 20  - name: Julie major: Arts age: 23  - name: Tommy major: Music age: 25        Boolean : yes/no, true/false를 boolean으로 구문한다. case insensitive다.  변수 선언 : &amp;으로 변수 선언하고 *으로 참조한다.default: &amp;default_school # default_school 라는 변수를 선언하고, 그 내용은 group 과 description 데이터를 지니고 있다   group: '서울대학교'   description: |      서울에 위치하는 대한민국 대학교!student:   - name: '홍길동'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다   - name: '임꺽정'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다",
        "url": "//java/2024/05/18/java-series-21-YAML.html"
      }
      ,
    
      "java-2024-05-18-java-series-20-stringandtokenizer-html": {
        "title": "[java Series] 20 Stringandtokenizer",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Split vs StringTokenizerSplit vs. StringTokenizer1. Split정규식을 받는 메소드와, 정규식 + 인덱스를 받는 메소드 두 개가 오버로딩되어 있다.class String {    public String[] split(String regex);// 반환을 String 배열로 받는다.// 구분 기호를 문자열이 아닌 정규표현식으로 받는다. (중요)    public String[] split(String regex, int limit);// 문자열을 정규식에 맞춰서 분리하는데 limit만큼 문자열을 자른다.}2. StringTokenizer구분자를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는데 사용한다.// 문자열을 공백 문자를 구분자로 자르기new StringTokenizer(String str)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// 이때 구분자는 토큰으로 간주되지 않음new StringTokenizer(String st, String delim)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// returnDelims 의 값을 true로하면 구분자도 토큰으로 간주new StringTokenizer(String str, String delim, boolean returnDelims)결론적으로 split vs. StringTokenizer  split 메소드는 String클래스에 속해있는 메소드이고, StringTokenizer는 java.util에 포함되어 있는 클래스이다.  구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.  split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.  split는 빈문자열을 토큰으로 인식하는 반면, StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다.  성능은 split 보다 StringTokenizer 가 좋다.  split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.  그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.",
        "url": "//java/2024/05/18/java-series-20-StringAndTokenizer.html"
      }
      ,
    
      "java-2024-05-18-java-series-19-clone-html": {
        "title": "[java Series] 19 Clone",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CloneCloneObject.clone()인스턴스 객체 복제를 위한 메소드, 해당 인스턴스를 복제해서 새로운 인스턴스를 생성해서 그 참조 값을 반환한다. clone() 사용을 위해서 Cloneable을 구현해야한다.Deep vs. ShallowDeep은 값 타입이든, 참조 타입이든 복사하여 원본과 구분되는 결과물을 생성해 내는 것을 의미하며, 얕은 복사는 값이든 참조든 복사하여 원본과 같은 결과물을 만들어내는 것을 의미한다.Deep의 주의사항만일 필드에 참조형이 있다면 아무리 대상을 깊은 복사했어도 필드는 참조를 복사한다. 따라서 필드의 클래스도 따로 처리를 해야한다.",
        "url": "//java/2024/05/18/java-series-19-Clone.html"
      }
      ,
    
      "java-2024-05-18-java-series-18-variableargument-html": {
        "title": "[java Series] 18 Variableargument",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 가변인자Variable Argument가변 인수 사용법메서드 파라미터 부분에 타입… 매개변수명 으로 처리하면 사용이 가능하다.가변 인수는 전달 인자를 0개부터 n개까지 넣을수 있다. 그리고 파라미터로 넘겨지는 값들을 모아서 컴파일시 배열로 처리된다. 주의할점은 인자들의 갯수에는 제한이 없지만, 배열 자료형은 매개변수 타입으로 명시된 것에 따라간다는 점이다.만일 매개변수가 가변 인자 외에 다른 매개 변수들도 받는다면, 반드시 가변 인자를 메서드 파라미터 가장 마지막에 위치하도록 정의해야 한다.그리고 매개변수가 넘겨지는 순서는, 인자들이 앞에 있는 파라미터 부터 차례대로 넘겨지고 남은 나머지 인자들이 가변 인자로 넘겨지게 된다.주의점  가변 인자 자체가 성능에 좋지않다. (배열 선언)  가변 인수 자체를 오버로딩하면 컴파일러가 어떤 메소드를 사용해야할지 구분하지 못한다.  배열 타입 매개변수와 혼용하지 않기    public void print( String ... str ) {}public void print( String[] str) {}        제네릭과 혼합하면 신중하게 -&gt; 제네릭은 배열로 실체화 불가하다.  ",
        "url": "//java/2024/05/18/java-series-18-VariableArgument.html"
      }
      ,
    
      "java-2024-05-18-java-series-17-generic-html": {
        "title": "[java Series] 17 Generic",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GenericGeneric클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 법을 의미한다.ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();제네릭 타입 매개변수위에서 보다시피, 제네릭은 &lt;&gt; 꺾쇠 괄호 키워드를 사용하는데 이를 다이아몬드 연산자라고 한다. 그리고 이 꺾쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할 수 있다. 이것을 마치 메소드가 매개변수를 받아 사용하는 것과 비슷하여 제네릭의 타입 매개변수(parameter) / 타입 변수 라고 부른다.타입 파라미터 정의이 타입 매개변수는 제네릭을 이용한 클래스나 메소드를 설계할 때 사용된다.예를들어 다음 코드는 제네릭을 감미한 클래스를 정의한 코드이다. 클래스명 옆에  기호로 제네릭을 붙여준 걸 볼 수 있다.그리고 클래스 내부에서 식별자 기호 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정되어 있다.class FruitBox&lt;T&gt; {    List&lt;T&gt; fruits = new ArrayList&lt;&gt;();    public void add(T fruit) {        fruits.add(fruit);    }}제네릭 클래스를 만들었으면 이를 인스턴스화 해보자. 마치 파라미터를 지정해서 보내는 것 처럼 생성 코드에서 꺾쇠 괄호 안에 지정해주고 싶은 타입명을 할당해주면,제네릭 클래스 선언문 부분으로 가서 타입 파라미터 T 가 지정된 타입으로 모두 변환되어 클래스의 타입이 지정되게 되는 것이다.타입 파라미터 생략제네릭 객체를 사용하는 문법 형태를 보면 양쪽 두 군데에 꺾쇠 괄호 제네릭 타입을 지정함을 볼 수 있다. 하지만 맨 앞에서 클래스명과 함께 타입을 지정해 주었는데 굳이 생성자까지 제네릭을 지정해 줄 필요가 없다.따라서 jdk 1.7 버전 이후부터,  new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다. 제네릭 나름대로 타입 추론을 해서 생략 된 곳을 넣어주기 때문에 문제가 없는 것이다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;Apple&gt;();// 다음과 같이 new 생성자 부분의 제네릭의 타입 매개변수는 생략할 수 있다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;&gt;();복수 타입 파라미터제네릭은 반드시 한개만 사용하라는 법은 없다. 만일 타입 지정이 여러개가 필요할 경우 2개, 3개 얼마든지 만들 수 있다.제네릭 타입의 구분은 꺽쇠 괄호 안에서 쉽표(,)로 하며 &lt;T, U&gt; 와 같은 형식을 통해 복수 타입 파라미터를 지정할 수 있다. 그리고 당연히 클래스 초기화할때 제네릭 타입을 두개를 넘겨주어야 한다.import java.util.ArrayList;import java.util.List;class Apple {}class Banana {}class FruitBox&lt;T, U&gt; {    List&lt;T&gt; apples = new ArrayList&lt;&gt;();    List&lt;U&gt; bananas = new ArrayList&lt;&gt;();    public void add(T apple, U banana) {        apples.add(apple);        bananas.add(banana);    }}public class Main {    public static void main(String[] args) {    \t// 복수 제네릭 타입        FruitBox&lt;Apple, Banana&gt; box = new FruitBox&lt;&gt;();        box.add(new Apple(), new Banana());        box.add(new Apple(), new Banana());    }}중첩 타입 파라미터제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.public static void main(String[] args) {    // LinkedList&lt;String&gt;을 원소로서 저장하는 ArrayList    ArrayList&lt;LinkedList&lt;String&gt;&gt; list = new ArrayList&lt;LinkedList&lt;String&gt;&gt;();    LinkedList&lt;String&gt; node1 = new LinkedList&lt;&gt;();    node1.add(\"aa\");    node1.add(\"bb\");    LinkedList&lt;String&gt; node2 = new LinkedList&lt;&gt;();    node2.add(\"11\");    node2.add(\"22\");    list.add(node1);    list.add(node2);    System.out.println(list);}타입 파라미터 기호 네이밍| 타입  |\t설명||:—:|:—–:||  |타입(Type)|||요소(Element), 예를 들어 List|||키(Key), 예를 들어 Map&lt;k, v&gt;|||리턴 값 또는 매핑된 값(Variable)|||숫자(Number)||&lt;S, U, V&gt;|2번째, 3번째, 4번째에 선언된 타입|제네릭 사용 이유, 장점  컴파일 타임에 타입 검사  불필요한 캐스팅을 없앨 수 있음주의 사항  제네릭 타입의 객체는 생성이 불가  static 멤버에 제네릭 타입이 올 수 없음 ( 제네릭 객체 생성 전에 자료 타입이 정해져 있어야 해서 )  제네릭으로 배열을 만들 수 없다.제네릭 범위 한정제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에서 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.예를들어 다음 계산기 클래스가 있다고 하자. 정수, 실수 구분없이 모두 받을 수 있게 하기위해 제네릭으로 클래스를 만들어주었다.하지만 단순히  로 지정하게 되면 숫자에 관련된 래퍼 클래스 뿐만 아니라 String이나 다른 클래스들도 대입이 가능하다는 점이 문제이다.// 숫자만 받아 계산하는 계산기 클래스 모듈class Calculator&lt;T&gt; {    void add(T a, T b) {}    void min(T a, T b) {}    void mul(T a, T b) {}    void div(T a, T b) {}}public class Main {    public static void main(String[] args) {        // 제네릭에 아무 타입이나 모두 할당이 가능        Calculator&lt;Number&gt; cal1 = new Calculator&lt;&gt;();        Calculator&lt;Object&gt; cal2 = new Calculator&lt;&gt;();        Calculator&lt;String&gt; cal3 = new Calculator&lt;&gt;();        Calculator&lt;Main&gt; cal4 = new Calculator&lt;&gt;();    }}개발자의 의도로는 계산기 클래스의 제네릭 타입 파라미터로 Number 자료형만 들어오도록 하고 문자열이나 또 다른 클래스 자료형이 들어오면 안되게 하고 싶다고 한다.그래서 나온 것이 제한된 타입 매개변수 (Bounded Type Parameter) 이다.타입 한정 키워드 extends&lt;T extends [ 제한 타입 ]&gt;인터페이스 타입 한정extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있다.interface Readable {}// 인터페이스를 구현하는 클래스public class Student implements Readable {} // 인터페이스를 Readable를 구현한 클래스만 제네릭 가능public class School &lt;T extends Readable&gt; {}다중 타입 한정만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한하고 싶다면,  &amp; 연산자를 이용하면 된다. 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 된다.단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.interface Readable {}interface Closeable {}class BoxType implements Readable, Closeable {}class Box&lt;T extends Readable &amp; Closeable&gt; {    List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T item) {        list.add(item);    }}재귀적 타입 한정재귀적 타입 한정이란 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 시키는 것을 말한다.실무에선 주로 Comparable 인터페이스와 함께 쓰인다.예를들어 다음과 같이 &lt;E extends Comparable&gt; 제네릭 E의 타입 범위를 Comparable 로 한정한다는 E를 중첩시킨 표현식을 사용할수 있는데, 이 말은 '타입 E는 자기 자신을 서브 타입으로 구현한 Comparable 구현체로 한정' 한다는 뜻이다.class Compare {\t// 외부로 들어온 타입 E는 Comparable&lt;E&gt;를 구현한 E 객체 이어야 한다.    public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; collection) {        if(collection.isEmpty()) throw new IllegalArgumentException(\"컬렉션이 비어 있습니다.\");        E result = null;        for(E e: collection) {            if(result == null) {                result = e;                continue;            }            if(e.compareTo(result) &gt; 0) {                result = e;            }        }        return result;    }}제네릭 형변환캐스팅배열과 같은 일반적인 변수 타입과 달리 지네릭 서브 타입간에는 형변환이 불가능하다. 심지어 대입된 타입이 Object라도 말이다. 자연스럽게 다형성이 적용될 것이라 생각하였지만, 실상 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능한 것이다.와일드 카드      &lt;?&gt; : Unbounded Wildcards (제한 없음)타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다        &lt;? extends 상위타입&gt; : Upper Bounded Wildcards (상위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있다        &lt;? super 하위타입&gt; : Lower Bounded Wildcards (하위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다  자바의 공변성/ 반공변성제네릭의 와일드카드를 배우기 앞서 선수 지식으로 알고 넘어가야할 개념이 있다.조금 난이도 있는 프로그래밍 부분을 학습 하다보면 한번쯤은 들어볼수 있는 공변성(Covariance) / 반공변성(Contravariance) 합쳐서 ‘변성(Variance)’ 이라하는 개념이다.변성은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타태는 지표이다. 그리고 공변성은 서로 다른 타입간에 함께 변할수 있다는 특징을 말한다.이를 객체 지향 개념으로 표현하자면 Liskov 치환 원칙[1]Visit Website에 해당된다.  공변 : S 가 T 의 하위 타입이면,          S[] 는 T[] 의 하위 타입이다.List&lt;S&gt; 는 List&lt;T&gt; 의 하위 타입이다.        반공변 : S 가 T의 하위 타입이면,  T[] 는 S[] 의 하위 타입이다. (공변의 반대)List&lt;T&gt; 는 List&lt;S&gt; 의 하위 타입이다. (공변의 반대)  무공변 / 불공변 : S 와 T 는 서로 관계가 없다.          List&lt;S&gt; 와 List&lt;T&gt; 는 서로 다른 타입이다      제네릭은 공변성이 없다객체 타입은 상하 관계가 있다 그러나 제네릭 타입은 상하관계가 없다. 즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이 불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.제네릭 와일드 카드자바 제네릭을 이용해 프로그래밍 할때 간혹 클래스 정의문을 보다보면 꺾쇠 괄호 ? 물음표 기호가 있는 것을 한번쯤 본 적이 있을 것이다. 이 물음표가 와일드카드이며, 물음표의 의미 답게 어떤 타입이든 될 수 있다는 뜻을 지니고 있다.            와일드카드      네이밍      설명                  &lt;?&gt;      Unbounded wildcards  비한정적 와일드 카드      제한 없음 (모든 타입이 가능)              &lt;? extends U&gt;      Upper Bounded Wildcards 상한 경계 와일드카드      상위 클래스 제한 (U와 그 자손들만 가능)상한이 U라 상한 경계라고 한다.              &lt;? super U&gt;      Lower Bounded Wildcards  하한 경계 와일드카드      하위 클래스 제한 (U와 그 조상들만 가능)  하한이 U라 하한 경계라고 한다.      제네릭의 공변, 반공변자바의 제네릭은 기본적으로 공변, 반공변을 지원하지 않지만, &lt;? extends T&gt; , &lt;? super T&gt; 와일드카드를 이용하면 컴파일러 트릭을 통해 공변, 반공변이 적용되도록 설정 할 수 있다. 둘을 정리하자면 다음과 같다.  상한 경계 와일드카드 &lt;? extends U&gt; : 공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U를 상속받은 하위 클래스 (U와 U의 자손 타입만 가능)상한의 뜻 : 타입의 최고 한도는 U 라는 의미. (최대 U 이하)        하한 경계 와일드카드 &lt;? super U&gt; : 반공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U가 상속한 상위 클래스 (U와 U의 조상 타입만 가능)하한의 뜻 : 타입의 최저 한도는 U 라는 의미. (최소 U 이상)        비경계          타입 매개변수의 범위는 제한이 없다. (모두 가능) &lt; ? extends Object &gt;의 줄임 표현      PECS (Producer-Extends / Consumer-Super)  외부에서 온 데이터를 생산(Producer) 한다면 &lt;? extends T&gt; 를 사용 (하위타입으로 제한)  외부에서 온 데이터를 소비(Consumer) 한다면 &lt;? super T&gt; 를 사용 (상위타입으로 제한). [1] : 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다.",
        "url": "//java/2024/05/18/java-series-17-Generic.html"
      }
      ,
    
      "java-2024-05-18-java-series-16-enum-html": {
        "title": "[java Series] 16 Enum",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnumerationEnumerationJAVA에서 enum은 interface와 같이 독립된 특수한 클래스로 구분된다. 즉, 일종의 객체이기 때문에 heap에 저장되며,각 enum 상수들은 별개의 메모리 주소 값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.장점  코드가 단순해지며 가독성이 좋아진다  허용 가능한 값들을 제한하여 유형 안전(type safe)을 제공한다.  키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 나타낼 수 있다.  자체 클래스 상수와 달리 switch문에서도 사용할 수 있다  단순 상수와 비교해 IDE의 적극적인 지원을 받을 수 있다 (자동완성, 오타검증, 텍스트 리팩토링 등등)  리팩토링시 변경 범위가 최소화 된다 (enum에서 한번에 관리하기 때문에 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다)  enum은 본질적으로 Thread safe인 싱글톤 객체 이므로 싱글톤 클래스를 생성하는데에도 사용된다메소드|메소드|\t설명\t|리턴 타입||:—–:|:——–:|:———–:||name()|열거 객체의 문자열을 리턴|String||ordinal()|열거 객체의 순번(0부터 시작)을 리턴|int||compareTo()|열거 객체를 비교해서 순번 차이를 리턴|int||valueOf(String name)|문자열을 입력받아서 일치하는 열거 객체를 리턴|enum||values()|모든 열거 객체들을 배열로 리턴|enum[]|java.lang.Enum모든 클래스가 Object 클래스를 자동 상속하는 것 처럼, Enum 클래스도 무조건 java.lang.Enum 이라는 클래스의 상속을 받는다. 그리고 java.lang.Enum 클래스에 정의되어 있는 메소드를 가져와 사용하는 것이다            메소드      내용                  clone()      객체를 복제하기 위한 메소드하지만, 이 메소드는 enum 클래스에서 사용하면 안된다.만약 호출될 경우엔 CloneNotSupportedException 이라는 예외를 발생시키도록 되어있다              finalize()      GC가 발생할 때 처리하기 위한 메소드              hashCode()      int 타입의 해시 코드 값을 리턴하는 메소드              equals()      두 개의 객체가 동일한지를 확인하는 메소드      Enum, Singleton자바에서의 enum 열거 타입은 일종의 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개하게 된다. 하지만 enum은 클래스처럼 이용할수는 있지만 인스턴스화는 할수는 없는데, 실제로 new 키워드로 인스턴스 생성을 하려고 하면 에러가 난다.이러한 제약적인 특징을 가지고 있는 이유는 enum 타입은 고정된 상수들의 집합으로써, 런타임(run-time)이 아닌 컴파일타임(compile-time)에 모든 값을 알고 있어야 하는 규칙이 있기 때문이다. 즉, 다른 패키지나 클래스에서 enum 타입에 접근해서 변수 처럼 동적으로 어떠한 값들을 할당해 주는 행위는 금지된 것이다.이 때문에 enum 객체의 생성자의 접근제어자를 private으로 설정해야 한다. 이렇게 되면 외부에서 접근 가능한 생성자가 없으므로 enum타입은 실제적으로 final 클래스와 다름이 없게 된다.이러한 특성 때문에, enum타입은 싱글톤을 구현하는 하나의 방법으로 사용되기도 한다.",
        "url": "//java/2024/05/18/java-series-16-Enum.html"
      }
      ,
    
      "java-2024-05-18-java-series-15-reflection-html": {
        "title": "[java Series] 15. Reflection",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReflectionReflectionjava.lang.Class자바 프로그래밍을 할때 우리는 보통 변수나 클래스를 직접 선언하고 만들어 사용하여 왔다. 그런데 어떤 경우에는 애플리케이션 실행 중에서 클래스를 동적으로 불러와 다루어야 할 경우가 생긴다. 즉, 코드를 실행하기전 컴파일 단에서 개발자가 직접 폴더를 뒤져가며 클래스 정의문을 찾아 클래스 정보를 얻는 것이 아닌, 코드 상에서 호출 로직을 통해 클래스 정보를 얻어와 다룸으로써 런타임 단에서 다이나믹하게 클래스를 핸들링 하는 것이다.이때 사용되는 것이 바로 Class 클래스 객체이다.Class 클래스는 java.lang.Class 패키지에 별도로 존재하는 독립형 클래스로서, 자신이 속한 클래스의 모든 멤버 정보를 담고 있기 때문에 런타임 환경에서 동적으로 저장된 클래스나 인터페이스 정보를 가져오는데 사용된다. 여기서 오해하지 말아야 할 것이 클래스 자료형을 말하는게 아니라 클래스 이름이 “Class” 인 클래스를 말하는 것이다.  JVM의 클래스 로더(class loader)는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.먼저 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환하고, 없으면 classpath에 지정된 경로를 따라서 클래스 파일을 찾아 해당 클래스 파일을 읽어서 Class 객체로 변환한다.만일 못 찾으면 우리가 익히아는 ClassNotFoundException 예외를 띄우게 된다.Class 객체 얻기Object.getClass()  모든 클래스의 최상위 클래스인 Object 클래스에서 제공하는 getClass() 메서드를 통해 가져온다.  해당 클래스가 인스턴스화 된 상태 이어야 한다는 제약이 있다.java Class&lt;? extends String&gt; cls = str.getClass();.class 리터럴로 얻기  인스턴스가 존재하지 않고, 컴파일된 클래스 파일만 있다면 리터럴로 Class 객체를 곧바로 얻을 수 있다.  가장 심플하게 Class 객체를 가져오는 방법이다.java  Class&lt;? extends String&gt; cls2 = String.class;Class.forName() 으로 얻기  위의 리터럴 방식과 같이 컴파일된 클래스 파일이 있다면 클래스 이름만으로 Class 객체를 반환 받을 수 있다.  클래스의 도메인을 상세히 적어주어야 한다. 그래서 클래스 파일 경로에 오타가 있으면 에러가 발생할 수 있기 때문에 주의해야한다. (대소문자 실수 등)  만일 Class 객체를 찾지 못한다면 ClassNotFoundException를 발생 시키기 때문에 예외처리가 강제된다.  그러나 다른 두가지 방법보다 forName을 통해 얻게 되면 메모리를 절약하며 동적 로딩 할 수 있기 때문에 가장 성능이 좋다.java Class&lt;?&gt; cls3 = Class.forName(\"java.lang.String\");  Class 클래스 객체를 forName() 메서드를 통해 가져오는 방법을 ‘동적 로딩’이라고 부른다. 보통 다른 클래스 파일을 불러올때는 컴파일 시 JVM의 Method Area에 클래스 파일이 같이 바인딩(binding)이 되지만, forName()으로 .class파일을 불러올 때는 컴파일에 바인딩이 되지않고 런타임때 불러오게 되기 때문에 동적 로딩이라고 부른다.그래서 컴파일 타입에 체크 할 수 없기 때문에 클래스 유무가 확인되지 않아 예외 처리를 해주어야 하는 이유이기도 하다.Class 메소드 종류  String getName(): 클래스의 이름을 리턴한다.  Package getPackage(): 클래스의 패키지 정보를 패키지 클래스 타입으로 리턴한다.  Field[] getFields(): public으로 선언된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.  Field getField(String name): public으로 선언된 변수를 Field 클래스 타입으로 리턴한다.  Field[] getDeclaredFields(): 해당 클래스에서 정의된 변수 목록을 field 클래스 배열 타입으로 리턴한다.  Field getDeclaredField(String name): name과 동일한 이름으로 정의된 변수를 Field 클래스 타입으로 리턴한다.  Method[] getMethods(): public으로 선언된 모든 메소드 목록을 Method 클래스 배열 타입으로 리턴한다. 해당 클래스에서 사용 가능한 상속받은 메소드도 포함된다.  Method getMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 메소드를 Method 클래스 타입으로 리턴한다.  Method[] getDeclaredMethods(): 해당 클래스에서 선언된 모든 메소드 정보를 리턴한다.  Method getDeclaredMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 해당 클래스에서 선언된 메소드를 Method 클래스 타입으로 리턴한다.  Constructor[] getConstructors(): 해당 클래스에 선언된 모든 public 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  Constructor[] getDeclaredConstructors(): 해당 클래스에서 선언된 모든 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  int getModifiers(): 해당 클래스의 접근자(modifier) 정보를 int 타입으로 리턴한다.  String toString(): 해당 클래스 객체를 문자열로 리턴한다.Reflection APIClass 객체를 이용하면 클래스에 대한 모든 정보(클래스의 정의된 멤버의 이름이나 개수 등)를 런타임 단에서 코드 로직으로 얻을 수 있다는 것을 알았다.클래스 정보들을 실행부에서 얻을 수 있는 점은 꽤나 매력적인데, 이러한 정보들을 이용하여 오로지 Class 객체만으로 본 클래스를 인스턴스화 할 수 있고,메서드를 호출 할 수 있는 ..등 보다 동적인 코드를 작성할 수 있게 된다. 이처럼 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메소드, 타입, 변수, …)에 접근할 수 있게 해주는 자바 기법을 Reflection API 라고 부른다.자바 리플렉션(Reflection - 사전적 의미 : 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그램 기법이다.클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍을 가능케 해준다.사용법동적으로 생성자 가져와서 초기화public static void main(String[] args) throws Exception {    // 클래스 객체 가져오기 (forName 메소드 방식)    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 생성자 가져오기 - Person(String name, int age)    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); // getConstructor 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.    // 가져온 생성자로 인스턴스 만들기    Person person1 = constructor.newInstance(\"홍길동\", 55);    person1.getField(); // 이름 : 홍길동, 나이 : 55}  getConstructor() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만일 어떠한 매개변수 타입을 지정해주지 않으면 기본 생성자가 호출되게 된다.  만약 해당하는 생성자를 찾지 못하면 NoSuchMethodException이 발생된다메소드 가져와서 실행하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 특정 public 메서드 가져와 실행    // getMethod(\"메서드명\", 매개변수타입들)    Method sum = personClass.getMethod(\"sum\", int.class, int.class);    int result = (int) sum.invoke(new Person(), 10, 20);    System.out.println(\"result = \" + result); // 30    // 특정 static 메서드 가져와 실행    Method staticSum = personClass.getMethod(\"staticSum\", int.class, int.class);    int staticResult = (int) staticSum.invoke(null, 100, 200);    System.out.println(\"staticResult = \" + staticResult); // 300    // 특정 private 메서드 가져와 실행    Method privateSum = personClass.getDeclaredMethod(\"privateSum\", int.class, int.class);    privateSum.setAccessible(true); // private 이기 때문에 외부에서 access 할 수 있도록 설정    int privateResult = (int) privateSum.invoke(new Person(), 1000, 2000);    System.out.println(\"privateResult = \" + privateResult); // 3000}  getMethod() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만약 매개변수가 없는 메소드라면 메소드 명만 입력해주면 된다.  실행은 Method 타입에서 제공하는 invoke()를 호출하여 실행하면 된다.          instance 메소드 - 매개변수로 인스턴스 필요      static 메소드 - 매개변수 필요 없음      private 메소드 - invoke 하기전에 공개화 할 필요있음      동적으로 필드 가져와 조작하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // static 필드를 가져와 조작하고 출력하기    Field height_field = personClass.getField(\"height\");    height_field.set(null, 200);    System.out.println(height_field.get(null)); // 200}  getField() 를 통해 클래스의 필드를 얻을 수 있다.  필드 값 변경은 set() 메서드를 호출하면 된다.  필드는 클래스가 인스턴스가 되어야 Heap 메모리에 적재됨으로 인스턴스가 필요하다.  다만, static 필드라면 Method Area에 이미 적재되어 있으므로 인스턴스가 필요없다.",
        "url": "//java/2024/05/18/java-series-15.-Reflection.html"
      }
      ,
    
      "java-2024-05-18-java-series-14-dynamicproxy-html": {
        "title": "[java Series] 14 Dynamicproxy",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 다이나믹 프록시Dynamic Proxy자바 프로그래밍의 디자인 패터중 하나인 프록시 패턴Visit Website은 초기화 지연, 접근 제어, 로깅, 캐싱 등,기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴이다.이 디자인 패턴을 적용하면 개방 폐쇄 원칙(OCP)Visit Website의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 플러스 효과를 얻을 수 있다는 장점이 있다.하지만 프록시 디자인 패턴은 대상 원본 클래스 수만큼 일일히 프록시 클래스를 하나하나 만들어 줘야하는 치명적인 단점이 존재한다. 즉, 프록시 적용 대상 객체가 100개면 프록시 객체도 100개 만들어줘야 한다는 말이다. 따라서 코드량이 많아지게 되고 중복이 발생하여 코드의 복잡도가 증가한다는 한계점이 존재한다.바로 이러한 단점들을 보완하여 컴파일 시점이 아닌 런타임 시점에 프록시 클래스를 만들어주는 방식이 자바 가상 머신(JVM)에서 공식적으로 지원하는 동적 프록시(Dynamic Proxy) 기능이다.동적 프록시는 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의 Reflection APIVisit Website 기법을 응용한 연장선의 개념이다. 프록시 패턴의 기본 흐름은 거의 같고, 프록시를 클래스로 직접만들어서 등록하냐 이미 지원하는 api를 이용하여 동적으로 등록하느냐에 따른 차이만 있을 뿐이다.Dynamic Proxy 구성 요소newProxyInstance() Methodpublic class Proxy implements java.io.Serializable {\t// ...        public static Object newProxyInstance(        ClassLoader loader,  //클래스 로더         Class&lt;?&gt;[] interfaces,  // 타깃의 인터페이스        InvocationHandler h  // 타깃 정보가 포함된 Handler    ) throws IllegalArgumentException {        // ...    }}      ClassLoader loader프록시 클래스를 만들 클래스 로더(Class Loader)Proxy 객체가 구현할 Interface에 Class Loader를 얻어오는 것이 일반적        Class&lt;?&gt;[] interfaces프록시 클래스가 구현하고자 하는 인터페이스 목록 (배열)메서드를 통해 생성 될 Proxy 객체가 구현할 Interface를 정의한다.        InvocationHandler h프록시의 메서드(invoke)가 호출되었을때 실행되는 핸들러 메서드  InvocationHandlerInvocationHandler 인터페이스는 위에서 본 newProxyInstance() 메서드의 3번째 매개변수에 들어갈 핸들러 메서드를 정의하는 함수형 인터페이스이다.이 인터페이스 코드 구성을 보면 내부에 invoke() 라는 추상메서드 하나만 정의되어있는 걸 볼 수 있다.invoke() 메서드는 동적 프록시의 메서드가 호출되었을때, 이를 낚아채어 대신 실행되는 메서드이다. 메서드의 파라미터를 통해 어떤 메서드가 실행되었는지 메서드 정보와 메서드에 전달된 인자까지 알수있다.디자인 패턴으로 프록시를 구성하면 단점이 중복된 메서드 코드 로직이 발생한다는 점인데, 이 invoke() 메서드에 동적으로 등록함으로써 반복된 코드를 줄이게 되는 것이다.public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}  Object proxy : 프록시 객체  Method method : 호출한 메서드 정보  Object[] args : 메서드에 전달된 매개변수 (배열)예시interface AInterface {    String call();    void print();    void run();}class AImpl implements AInterface {    @Override    public String call() {        System.out.println(\"A 호출\");        return \"a\";    }    @Override    public void print() {        System.out.println(\"A print @@@@@@@\");    }    @Override    public void run() {        System.out.println(\"A Running !!!!!!!!!\");    }}public class Client {    public static void main(String[] arguments) {        AInterface proxyA = (AInterface) Proxy.newProxyInstance(                AInterface.class.getClassLoader(),                new Class[]{AInterface.class},                (proxy, method, args) -&gt; { // 람다 함수                    Object target = new AImpl();                    System.out.println(\"TimeProxy 실행\");                    long startTime = System.nanoTime();                    Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행                    long endTime = System.nanoTime();                    long resultTime = endTime - startTime;                    System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);                    return result;                }        );        proxyA.call();        proxyA.print();        proxyA.run();    }}Dynamic Proxy 제약 사항지금까지 동적 프록시 구현 및 응용을 다뤄보았다. 아주 약간의 퍼포먼스를 희생하고 자유롭게 프록시를 다이나믹하게 등록할 수 있지만,여기에 추가로 한가지 제약사항이 존재한다. 동적 프록시에 타켓을 등록할때 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 된다는 점이다.인터페이스를 기반으로 프록시를 동적으로 만들어주기 때문에, 인터페이스가 필수이기 때문이다.즉, 자바에서 newProxyInstance()를 이용해 동적 프록시 객체를 만들때 Class 기반으로는 Proxy 객체를 생성할 수 없다는 말이다. 하지만 클래스의 확장성을 고려할 필요가 없거나 한가지 책임만 분명하게 하는 경우 굳이 인터페이스를 등록해 사용하지 않는 겨우도 있다. 프록시 때문에 굳이 일일히 인터페이스를 구현해야 하는 것도 결국은 디자인 패턴의 한계점의 회귀이다.CGLIB(Code Generator Library)인터페이스가 아닌 클래스를 대상으로 바이트 코드를 조작해서 프록시 생성할 수 있는 라이브러리다.효용성을 입증 받아 스프링에 기본으로 내장돼있다.  스프링 프레임워크에서 Bean을 등록할 때 Spring AOP를 이용하여 등록을 하는데, Bean으로 등록하려는 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 Interface를 구현하고 있지 않으면 CGLIB 라이브러리를 이용한다.CGLIB 프록시CGLIB 에서는 Enhancer 객체로 프록시 객체를 만들며 MethodInterceptor 인터페이스로 프록시 핸들러를 등록한다.// 프록시 핸들러class MyProxyInterceptor implements MethodInterceptor {    private final Object target;    MyProxyInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(            Object o,            Method method,            Object[] args,            MethodProxy methodProxy    ) throws Throwable {        System.out.println(\"TimeProxy 실행\");        long startTime = System.nanoTime();        Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행        long endTime = System.nanoTime();        long resultTime = endTime - startTime;        System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);        return result;    }}// 프록시를 적용할 대상 타켓class Subject {    public void call() {        System.out.println(\"서비스 호출\");    }}public class Client {    public static void main(String[] arguments) {        // 1. 프록시 등록 (CGLIB는 Enhancer를 사용해서 프록시를 등록한다)        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Subject.class); // CGLIB는 구체 클래스를 상속 받아서 프록시를 생성하기 때문에 상혹할 구체 클래스를 지정        enhancer.setCallback(new MyProxyInterceptor(new Subject())); // 프록시 핸들러 할당        // 2. 프록시 생성        Subject proxy = (Subject) enhancer.create(); // setSuperclass() 에서 지정한 클래스를 상속 받아서 프록시가 만들어진다.        // 3. 프록시 호출        proxy.call();    }}람다로?public class Client {    public static void main(String[] arguments) {                Subject proxy = (Subject) Enhancer.create(Subject.class, (MethodInterceptor) (o, method, args, methodProxy) -&gt; {            Subject target = new Subject();            System.out.println(\"TimeProxy 실행\");            long startTime = System.nanoTime();            Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행            long endTime = System.nanoTime();            long resultTime = endTime - startTime;            System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);            return result;        });                proxy.call();    }}주의사항이렇게 보면 인터페이스 기반일 때는 Dynamic Proxy를 사용하고, 클래스 기반일 때는 CGLIB를 사용하면 되겠지만, 이 라이브러리도 제약사항이 존재한다.우선 CGLIB는 기본적으로 클래스 상속(extends)을 통해 프록시 구현이 되기 때문에, 타겟 클래스가 상속이 불가능할때는 당연히 프록시 등록이 불가능하다. 또한 메서드에 final 키워드가 붙게되면 그 메서드를 오버라이딩하여 사용 할수 없게되어 결과적으로 프록시 메서드 로직이 작동되지 않는다.정리하자면 프록시 대상 객체는 상속에 있어 제한이 있으면 안된다는 것이다.  클래스와 메소드에 final 키워드 적용  추상 클래스(abstract class)  클래스의 생성자를 private화 하여 생성자를 제한할 경우",
        "url": "//java/2024/05/18/java-series-14-DynamicProxy.html"
      }
      ,
    
      "java-2024-05-18-java-series-13-serialize-deserialize-html": {
        "title": "[java Series] 13 Serialize_deserialize",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 직렬화 역직렬화Serialize &amp; Deserialize직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes)형태로 연속적인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다. 그 반대 개념인 역직렬화는(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다.이를 시스템적으로 살펴보면, JVM의 힙(heap) 혹은 스택(stack) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여데이터베이스나 파일과 같은 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역질렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.직렬화 사용처  서블릿 세션          단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 만일 세션 데이터를 저장 &amp; 공유가 필요할때 직렬화를 이용한다.      세션 데이터를 데이터베이스에 저장할때      톰캣의 세션 클러스터링Visit Website을 통해 각 서버간에 데이터 공유가 필요할때        캐시          데이터베이스로부터 조회한 객체 데이터를 다른 모듈에서도 필요할때 재차 DB를 조회하는 것이 아닌, 객체를 직렬화하여 메모리나 외부 파일에 저장해 두었다가 역직렬화하여 사용하는 캐시 데이터로서 이용이 가능하다.      물론 자바 직렬화를 이용해서만 캐시를 저장할 수 있는 것은 아니지만 자바 시스템에서 만큼은 구현이 가장 간편하기 때문에 많이 사용된다고 보면 된다.      단, 요즘은 Redis, Memcached 와 같은 캐시 DBVisit Website를 많이 사용하는 편이다.        Remote Method Invocation          자바 RMI는 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.      이 메세지에 객체 데이터를 직렬화하여 송신하는 것이다.      최근에는 소켓을 이용하기 때문에 안쓰이는 기술이다.      직렬화 vs. JSON자바 직렬화의 장점  직렬화는 자바의 고유 기술인 만큼 당연히 자바 시스템에서 개발에 최적화되어 있다.  자바의 광활한 레퍼런스 타입에 대해 제약 없이 외부에 내보낼 수 있다는 것이다.사실 그 외에는 JSON이 훨씬 낫다.직렬화 방법  Serialize 구현Serializable 인터페이스는 아무런 내용도 없는 마커 인터페이스Visit Website 로서, 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준으로 사용된다.  ObjectOutputStream 객체 직렬화직렬화(스트림에 객체를 출력) 에는 ObjectOutputStream을 사용한다.객체가 직렬화될때 오직 객체의 인스턴스 필드값 만을 저장한다. static 필드나 메서드는 직렬화하여 저장하지 않는다직렬화 요소의 제외  transient 키워드    class Customer implements Serializable { int id;  String name;  transient String password; // 직렬화 대상에서 제외 int age;  public Customer(int id, String name, String password, int age) {     this.id = id;     this.name = name;     this.password = password;     this.age = age; }     ...}        readObject / writeObject 재정의직렬화 &amp; 역직렬화할때 호출되는 readObject() 와 writeObject() 는 기본적으로 모든 요소에 대해 자동 직렬화 한다. 그런데 이 메서드들을 직렬화할 클래스에 별도로 재정의 해주면 직렬화를 선택적으로 조작할 수 있게 된다. 이를 커스텀 직렬화 라고도 불리운다.class Customer implements Serializable {    int id; // 고객 아이디    String name; // 고객 닉네임    String password; // 고객 비밀번호    int age; // 고객 나이    public Customer(int id, String name, String password, int age) {        this.id = id;        this.name = name;        this.password = password;        this.age = age;    }    // 직렬화 동작 재정의    private void writeObject(ObjectOutputStream out) throws IOException{        out.writeInt(id);        out.writeObject(name);        out.writeInt(age);    }    // 역직렬화 동작 재정의    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{        this.id = in.readInt();        this.name = (String) in.readObject();        this.age = in.readInt();    }    @Override    public String toString() {        return \"Customer{\" +                \"id=\" + id +                \", password='\" + password + '\\'' +                \", name='\" + name + '\\'' +                \", age=\" + age +                '}';    }}  상속 관계에서 직렬화만약 부모-자식 상속 관계에서 부모 클래스가 Serializable을 구현했다면 자식 클래스는 Serializable을 구현하지 않아도 직렬화가 가능하다. 그러면 반대로 부모 클래스는 Serializable을 구현하지 않고 자식 클래스만 구현했다면 어떤 방식으로 직렬화될까?직렬화할때 부모 클래스의 인스턴스 필드는 무시되고 자식 필드만 직렬화가 된다. 따라서 상위 클래스의 필드까지 직렬화하려면 부모 클래스가 Serializable을 구현하도록 설정하던지,위에서 다뤄본 writeObject / readObject 메서드를 재정의하여 직접 직렬화 코드를 추가 하면 된다.직렬화 버전 관리      SerialVersionUIDSerializable 인터페이스를 구현하는 모든 직렬화된 클래스는 serialVersionUID(이하 SUID) 이라는 고유 식별번호를 부여 받는다. 이 식별 ID는 클래스를 직렬화, 역직렬화 과정에서 동일한 특성을 갖는지 확인하는데 사용된다. 그래서 클래스 내부 구성이 수정될 경우, 기존에 직렬화한 SUID와 현재 클래스의 SUID 버전이 다르기 때문에 이를 인지하고 InvalidClassException 예외가 발생시켜 값 불일치 되는 현상을 미연에 방지한다.단, 직렬화 스펙 상 serialVersionUID 값 명시는 필수가 아니며, 만일 클래스에 SUID 필드를 명시하지 않는다면, 시스템이 런타임에 클래스의 이름, 생성자 등과 같이 클래스의 구조를 이용해 암호 해시함수를 적용해 자동으로 클래스 안에 생성하게 된다.        수동 버전 관리만일 네트워크로 객체를 직렬화하여 전송하거나 협업을 하는 경우 수신자와 송신자 모두 같은 버전의 클래스를 가지고 있어야 할텐데, 만일 클래스가 조금만 변경사항이 있으면 모든 사용자에게 재배포해야 하는 애로사항이 생겨 프로그램을 관리하기 어렵게 만든다.  따라서 직렬화 클래스는 왠만한 상황에선 serialVersionUID 를 직접 명시해주어 클래스 버전을 수동으로 관리하는 것을 권장하는 편이다.SUID를 직접 명시해주면 클래스의 내용이 변경되어도, 클래스의 버전이 시스템이 자동 생성된 값으로 변경되지 않기 때문이다. 이외에도 런타임에 SUID를 생성하는 시간도 많이 잡아먹기 때문에 미리 명시를 강력히 권장되는 바이다.  SerialVersionUID 수동 관리 유의사항  클래스 serialVersionUID를 명시하더라도 절대 만능이 아니다. 위와 같이 단순히 필드 변수 하나 추가하는 정도는 문제가 없겠지만 필드 타입을 변경하는 상황에서는 버전 수동 관리를 하여도 예외를 막을순 없다.직렬화 예외  InvalidClassException  NotSerializableException직렬화의 단점  용량이 크다. (메타 정보를 모두 가지고 있다.)  역직렬화 과정에서 공격당할 위험이 있다.  릴리즈 후 수정이 어렵다.  클래스 캡슐화가 깨진다.  버그와 보안에 취약하다.",
        "url": "//java/2024/05/18/java-series-13-Serialize_Deserialize.html"
      }
      ,
    
      "java-2024-05-18-java-series-12-brokensingleton-html": {
        "title": "[java Series] 12 Brokensingleton",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Singleton과 훼손Singleton싱글톤은 기본적으로 단 하나의 유일한 객체를 의미한다.역직렬화에 의한 싱글톤 훼손자바의 직렬화(Serialize)는 JVM의 힙 메모리에 있는 객체 데이터를 바이트 스트림(byte stream) 형태로 바꿔 외부 파일로 내보낼수 있게 하는 기술을 말한다. 반대로 외부로 내보낸 직렬화 데이터를 다시 읽어들여 자바 객체로 재변환하는 것을 역직렬화(Deserialize) 라 한다.직렬화하여 내보낸 외부 파일은 데이터베이스에 저장되기도 하며 네트워크를 통해 전송되기도 한다. 이 직렬화를 적용하기 위해선 클래스에 Serializable 인터페이스를 implements 하면 된다.그런데 만일 어떤 클래스를 직렬화하여 다른 컴퓨터에 전송하려는데, 이 클래스를 싱글톤으로 구성하려고 한다. 하지만 이 싱글톤 클래스는 송신자가 파일을 받고 역직렬화시 깨지게 되어 더이상 싱글톤이 아니게 된다.이러한 현상이 생기는 이유는 역직렬화 자체가 보이지 않은 생성자로서 역할을 수행하기 때문에 인스턴스를 또다시 만들어, 직렬화에 사용한 인스턴스와는 전혀 다른 인스턴스가 되기 때문에 일어나는 것이다. 따라서 클래스에 Serializable을 구현하면 더 이상 이 클래스는 싱글톤이 아니게 되어 메모리 이점을 더이상 얻을수 없게 된다.훼손 대응 방안이러한 싱글톤의 역직렬화의 대응 방안으로 직렬화 관련 메서드인 readResolve() 를 정의하면 된다.readResolve 메서드를 정의하게 되면, 역직렬화 과정에서 readObject를 통해 만들어진 인스턴스 대신 readResolve에서 반환되는 인스턴스를 내가 원하는 것으로 바꿀 수 있기 때문이다. 그리고 기존에 역직렬화를 통해 새로 생성된 객체는 알아서 Garbage CollectorVisit Website의 대상이 된다.class Singleton implements Serializable {    private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    // 역직렬화한 객체는 무시하고 클래스 초기화 때 만들어진 인스턴스를 반환    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}이때 싱글턴 인스턴스의 직렬화 결과에는 아무런 실 데이터를 가질 이유가 없기 때문에, 싱글톤 클래스에 필드 변수들이 있을 경우 모든 인스턴스 필드를 transient로 선언한다. 아무리 readResolve 메서드라도 역직렬화 과정 중간에 역직렬화된 인스턴스의 참조를 훔쳐오는 공격을 행할경우 다른 객체로 바뀔 위험이 있기 때문이다.class Singleton implements Serializable {    // 싱글톤 객체의 필드들을 transient 설정하여 직렬화 제외    transient String str = \"\";    transient ArrayList lists = new ArrayList();    transient Integer[] integers;        private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}리플렉션에 의한 싱글톤 훼손자바 리플렉션(Reflection - 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 조작하는 프로그램 기법이다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고 객체를 생성하는 것 또한 가능하게 해준다.이러한 리플렉션 기법은 프레임워크, 라이브러리에서 많이 사용된다. 왜냐하면 프레임워크, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버들을 구성할지 모르는데, 이러한 사용자 클래스들을 기존의 기능과 동적으로 연결 시키기 위하서 이다. 이미 Spring, Lombok 등 많은 프레임워크에서 리플렉션 기능을 사용하고 있다.그런데 문제는 리플렉션을 통해 싱글톤 객체를 생성하게 되면 다른 객체를 반환해 싱글톤이 다시 한번 깨지는 것이다. 클래스 객체를 통해 해당 객체의 생성자를 받아와 newInstance() 메서드를 실행하면 인스턴스를 생성할 수 있게 되는데, 여기서 생성된 인스턴스는 Holder가 가지고 있는 인스턴스와는 전혀 다른 새로운 인스턴스이기 때문이다.",
        "url": "//java/2024/05/18/java-series-12-BrokenSingleton.html"
      }
      ,
    
      "java-2024-05-18-java-series-11-heappollution-html": {
        "title": "[java Series] 11 Heappollution",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 힙 오염Heap Pollution힙 오염은 JVM의 Heap 메모리 영역에 저장되어 있는 특정 변수가 불량 데이터를 참조함으로써, 만일 힙에서 데이터를가져오려고 할 때 얘기치 못한 런타임 에러가 발생할 수 있는 오염 상태를 의미한다.힙 오염의 대표 이유는 Generic이다.Generic collection은 이전 버전과의 호환성을 위해서 Compile 때 Generic을 Object으로 변환하거나 제거함으로써 하위 호환을 했다.  제네릭 타입 소거(Erasure)  제네릭은 type-safe하며 실행 시간 오버헤드를 줄이기 위해서 도입된 문법으로, 이전 자바에서 제네릭 타입 파라미터가 없던 탓에 호환성을 위해서제네릭은 컴파일되면 제네릭 타입은 사라졌다. 즉, .class에는 제네릭 정보가 존재하지 않았다.  컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거하기 때문에 잠재적 힙 오염 문제에 빠질 수 있게 됐다.  Reifiable, Non-Reifiable  실체화 타입(Reifiable Type)이란 컴파일 단계에서 타입 소거에 의해 지워지지 않는 타입 정보를 말한다.      int, double, float, byte 등 원시 타입    Number, Integer 등 일반 클래스와 인터페이스 타입    List, ArrayList, Map 등 자체(Raw Type)    List&lt;?&gt;, ArrayList&lt;?&gt; 등 비한정 와일드 카드가 포함된 매개변수화 타입 (와일드 카드 &lt;?&gt; 는 애초에 타입 정보가 명시되지 않았으므로 타입 소거를 해도 별 문제가 없다. 컴파일 타임에 Object로 변환 됨)    비실체화 타입(Non-Reifiable Type) 컴파일 단계에서 타입 소거에 의해서 타입 정보가 제거된 타입을 의미한다. 제네릭 타입 파라미터는 모두 제거된다.      List, List    List, ArrayList    List&lt;? extends Number&gt;, List&lt;? super String&gt;    제네릭 소거 과정  컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 필요한 곳에 형 변환을 넣고 최종적으로 컴파일 코드에 Type Erasure로 제네릭 타입을 제거하게 된다.      제네릭 타입의 경계(bound)를 제거              제네릭  -&gt; T는 Number로 치환                  는 Object로 치환```java// T extends Type -&gt; Type /* 치환 전 */class Box {List list = new ArrayList&lt;&gt;();                    void add(T item) {    list.add(item); }      T getValue(int i) {     return list.get(i); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);} } ```              제네릭 타입을 제거한 후 타입이 일치하지 않는 곳은 형 변환을 추가한다.```java/* 치환 전 */class Box { List list = new ArrayList(); // Object      void add(Number item) {     list.add(item); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);}Number getValue(int i) {    return (Number) list.get(i); // 캐스팅 연산자 추가} } ``` 3. 소거는 똑같이 진행 ```java // T -&gt; Object /* 치환 전 */ public static &lt;T&gt; int count(T[] anArray, T elem) {int cnt = 0;for (T e : anArray)    if (e.equals(elem))        ++cnt;    return cnt; }    /* 치환 후 */public static int count(Object[] anArray, Object elem) {    int cnt = 0;    for (Object e : anArray)        if (e.equals(elem))            ++cnt;        return cnt;}```  Bridge 메소드  컴파일러는 확장된 제네릭 타입에 대해서 타입 소거를 해도 다형성 보존을 위해서 별도의 bridge method를 생성한다.제네릭 힙 오염  원시 타입과 매개변수 타입을 동시에 사용하는 경우  확인되지 않은 형 변환을 수행하는 경우//ClassCastException 발생 예정ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"A\");list1.add(\"B\");Object obj = list1; //상위 타입 Object로 변경ArrayList&lt;Double&gt; list2 = (ArrayList&lt;Double&gt;) obj; //DownCastlist2.add(1.0);list2.add(2.0);System.out.println(list2); // [홍길동, 임꺾정, 1.0, 2.0]for(double n : list2) {    System.out.println(n);}컴파일러는 위의 코드에 대해서 컴파일 에러를 내지 않는다. 이는 제네릭 타입 소거에 의해서 나타나는 문제다.1. 컴파일러는 타입 캐스팅을 검사하지 않는다.-&gt; 컴파일러는 형변환 대상 객체에 대해서 검사하지 않는다. 정확히 말하면 캐스팅 했을 때 대입되는 변수에 저장할 수 있느냐만 검사한다.2. 제네릭 타입이 소거되면 결국 Object-&gt; 컴파일되면서 결국 제네릭은 Object가 된다. 결국 위 예시는 RawType이 되면서 어떤 정보든 저장할 수 있게 되면서 컴파일 에러가 나지 않는다.제네릭 힙 오염 방지책자바에서 Collections 클래스의 checkList() 메소드를 지원한다 해당 객체에 대해서 의도치 않은 타입의 데이터가 들어갔을 때 이를 감지하여 예외를 발생시킨다. https://inpa.tistory.com/entry/JAVA-☕-제네릭-타입-소거-컴파일-과정-알아보기 ",
        "url": "//java/2024/05/18/java-series-11-HeapPollution.html"
      }
      ,
    
      "java-2024-05-18-java-series-10-equalsandhashcode-html": {
        "title": "[java Series] 10 Equalsandhashcode",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Equals And Hash CodeEqualsAndHashCodeEquals어떤 참조 변수의 값이 같은지 다른지 동등 비교를 할 때 사용비교할 대상이 객체면 주소 값을 비교한다.override Equals기본적으로 참조형은 주소 값을 비교한다. 아무래 내부 필드가 같아도 엄연히 다른 주소 값이다. 그래서 Java에서는 필드 값을 비교하도록 오버라이드 해서 주소 값 비교를 우회한다.HashCode객체 주소 값을 해싱해서 해시코드를 만든 후 반환한다.(객체의 지문과 같다.)엄밀히 말하면 주소 값으로 만든 고유한 숫자 값이다.override Hashcode만약 Equals만 오버라이드하면 에러를 낸다. java는 equals를 오버라이드하면 당연히 hashcode도 객체의 필드를 다루도록 오버라이드 하도록 한다.왜냐하면 equals()의 결과가 true면 두 객체의 해시코드는 반드시 같아야 한다는 자바의 규칙때문이다.이렇게 강요하는 이유는 hash 값을 사용하는 CollectionFrameWork 사용에 문제가 발생하기 때문이다.ex) setEquals and Hashcode 동작 순서?https://inpa.tistory.com/entry/JAVA-☕-equals-hashCode-메서드-개념-활용-파헤치기1. HashCode는 고유하지 않다.보통 해싱 알고리즘은 서로 다른 주소를 가진 경우 같은 해시코드를 가질 여지가 없다. 64bit(8바이트) 주소값을 hashCode로 이용해서 반환하면4바이트(32bit)로 강제 캐스팅 되기 때문에 값이 겹칠 수도 있다. 즉 서로 다른 객체라도 같은 해시코드를 반환할 수 있다. 2. 해결책@EqualsAndHashCode에서 볼 수 있듯 equals로 두 객체의 진짜 주소를 직접 비교하는 식으로 극복한다.진짜 주소 값이 필요할때?hashcode() 오버라이드 시 비교 대상 객체가 같은지 아닌지를 판별할 수 있다. 그런데, 오버라이드 해버리면 객체 자체의 주소 값(해시코드)가 필요할 때 난감해진다.그래서 identityHashCode()라는 메소드를 제공한다.",
        "url": "//java/2024/05/18/java-series-10-EqualsAndHashCode.html"
      }
      ,
    
      "java-2024-05-18-java-series-09-innerclassproblem-html": {
        "title": "[java Series] 09 Innerclassproblem",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Inner class에서의 문제점Inner Class ProblemInner Class를 선언하면 Inner Class를 static으로 설정하라고 경고한다.이는 Inner Class가 Inner static 보다 메모리를 더 많이 쓰고, 느리고, 바깥 클래스가 GC 대상에서 빠져 메모리 관리에 문제가 될 수 있다.Inner class는 외부 참조를 한다.일반적으로 내부 클래스를 만들기 위해서는 외부 클래스를 초기화 해야한다. 이러한 문제 때문에 inner 클래스는 외부 참조를 갖게 된다. 심지어 내부 클래스가 외부 멤버를사용하지 않아도 숨겨진 외부 참조가 생성된다.public class Outer_Class {    int field = 10;    class Inner_Class {        int inner_field = 20;    }}// Outer_class$Inner_class.class// Outer_class.class// 바이트 코드를 디컴파일하면class Outer_Class$Inner_Class {    int inner_field;        Outer_Class$Inner_Class(Outer_Class this$0) { //생성자로 외부 클래스를 매개 변수로 받아서 초기화        this.this$0 = this$0;        this.inner_field = 20;    }}// 즉 바깥 클래스의 인스턴스와 암묵적으로 연결Inner 클래스의 메모리 누수Inner 클래스가 바깥 클래스를 외부 참조하므로 외부 클래스는 필요가 없고 내부 클래스만 남아있을 경우, 외부 참조로 내부 클래스와연결되어 있기 때문에 메모리에 잔존하고 누수로 이어진다.해결법은 static  static inner는 외부 참조가 없다.  static inner는 메모리 누수가 없다.",
        "url": "//java/2024/05/18/java-series-09-InnerClassProblem.html"
      }
      ,
    
      "java-2024-05-18-java-series-08-callby-html": {
        "title": "[java Series] 08 Callby",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CallByCall By Value vs. Call By Reference프로그래밍을 하다보면 반드시 마주치는 것이 바로 call by value / call by reference 개념이다.함수의 매개변수에서 값을 복사하느냐 주소값을 참조하느냐에 따라 반환 결과가 달라지기 때문에 대부분의 프로그래밍 교육과정에선 중요시 하게 여긴다.자바에서도 역시 call by value 와 call by reference 동작 차이가 존재한다.자바의 데이터형을 알아보면 크게 두가지로 나뉘게 된다.  기본형(primitive type) - Boolean Type(boolean), Numeric Type(short, int, long, float, double, char)  참조형(reference type) - Class Type, Interface Type, Array Type, Enum Type, 기본형을 제외한 모든 것들",
        "url": "//java/2024/05/18/java-series-08-CallBy.html"
      }
      ,
    
      "java-2024-05-18-java-series-07-tuning-html": {
        "title": "[java Series] 07 Tuning",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TuningGC Tuning주의점  GC 옵션은 서비스 특징마다 적정 값이 다르다.  GC 튜닝은 최후의 수단이다. (코드 최적화가 우선이다.)목표  Old로 넘어가는 객체의 수 최소화 하기Old는 Young에서 GC보다 시간이 오래 소요된다. 따라서 Old로 넘어가는 수를 줄이면 Full GC가 줄어든다.이는 Young size를 잘 조절하는 것만으로 Old로 넘어가는 것을 줄이고 이 자체로 튜닝이 된다는 것이다.  Full GC 시간 줄이기Full GC 실행 시간은 Minor GC에 비해 길다. 그러므로 Old 사이즈를 조정하는 것도 방법이다. 그렇다고 너무 줄이면 OutOfMemoryError가 발생하거나 FUll GC가 자주 발생할 수 있다. 반대로 너무 Old를 늘리면 FullGC는 줄지만 실행 시간이 늘어날 수 있다.튜닝 진행1. GC 상황 모니터링# jstat gcutil  명령어로 현재 실행중인 8884번 프로세스에 대해 1초에 한번 씩 총 10번 GC와 관련된 정보를 출력하도록 모니터링jstat -gcutil -t 8844 1000 0            컬럼      설명                  S0      Survivor 영역 0의 사용율(현재 용량에 대한 비율)              S1      Survivor 영역 1의 사용율(현재 용량에 대한 비율)              E      Eden 영역의 사용율 (현재 용량에 대한 비율)              O      Old 영역의 사용율 (현재 용량에 대한 비율)              P      Permanent 영역의 사용율 (현재 용량에 대한 비율)              YGC      Young 세대의 GC 이벤트 수              YGCT      Young 세대의 GC 시간              FGC      Full GC 이벤트 수              FGCT      Full GC 시간              GCT      GC 총 시간      2. 모니터링 결과 분석 후 GC 튜닝 여부 결정  Minor GC 수행시간: YGCT / YGC (0.314 / 19) = 0.016초  Major GC 수행 시간: FGCT / FGC (0.291 / 3) = 0.097초# Minor GC의 처리 시간이 빠르다 (50ms 내외)# Minor GC의 주기가 빈번하지 않다 (10초 내외)# Full GC의 처리 시간이 빠르다 (1초 내외)# Full GC의 주기가 빈번하지 않다 (10분에 1회)3. GC 알고리즘 방식 지정            GC 알고리즘      내용                  Parallel GC      - ‘처리량’이 중요한 시스템에서 주로 사용 - Full GC 수행 시 compaction 작업이 수행되기 때문에 GC 시간 자체는 많이 소요되나 일정한 멈춤 시간을 제공함              CMS GC      - 응답시간이 중용한 시스템에사 주로 사용  - compaction 미수행으로 Stop-The-World 시간은 짧으나 자주 Compaction이 발생하는 시스템의 경우 오히려 Full GC 보다 Compation 시간이 오래 걸릴 수 있음  - 자원 사용량이 증가하는 점도 고려해야 함              G1 GC      - 성능적으로 가장 우수한 GC 방식이나, JDK 7 버전부터 정식 제공되었으며, Java 9 에서 Default GC 방식으로 채택      4. Heap 크기 지정JVM의 힙 크기는 GC 발생 횟수와 수행 시간에 영향을 끼치기 떄문에 옵션을 통해 조절하면 애플리케이션의 성능 향상을 가져올 수 있다. 메모리 크기는 JVM의 시작 크기 -Xms 최대 크기 -Xmx를 말한다.메모리 크기와 GC 발생 횟수, GC 수행 시간 관계는 아래와 같다.  메모리 크기가 크면          GC 발생 횟수가 감소      GC 수행 시간은 길어진다.        메모리 크기가 작으면          GC 발생 횟수는 증가한다.      GC 수행 시간은 짧아진다.                  구분      옵션      설명                  힙(heap) 영역 크기      -Xms      JVM 시작 시 힙 영역 크기              힙(heap) 영역 크기      -Xmx      최대 힙 영역 크기              New 영역의 크기      -XX:NewRatio      New 영역과 Old 영역의 비율              New 영역의 크기      -XX:NewSize      New 영역의 크기              New 영역의 크기      -XX:SurvivorRatio      Eden 영역과 Survivor 영역의 비율      # 이 중에서 중요한 옵션은 -Xms 옵션, -Xmx 옵션, -XX:NewRatio 옵션이다.# 특히 -Xms 옵션과 -Xmx 옵션은 왠만하면 필수로 지정하길 권장되며, 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.# # NewRatio는 New 영역과 Old 영역의 비율이다. # -XX:+NewRatio=1로 지정하면 (New 영역):(Old 영역)의 비율은 1:1이 된다. # 만약 1GB라면 (New 영역):(Old 영역)은 500MB:500MB가 된다. # NewRatio가 2이면 (New 영역):(Old 영역)이 1:2가 된다. # 즉, 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.# 힙 시작 크기 256mb, 힙 최대 크기 2gb# young 영역과 old 영역 비율 1:2 로 설정 (New 영역:Old 영역 = 1:2)# Parallel GC 로 실행java -Xms256m -Xmx2048m -XX:+NewRatio=2 -XX:+UseParallelGC5. 결과 분석분석할 때는 다음의 사항을 중심으로 살펴보는 것이 좋다. 이는 우선 순위 별로 나열되어 있다.  FullGC 수행 시간  MinorGC 수행 시간  Full GC 수행 간격  MinorGC 수행 간격  전체 Full GC 수행 시간  전체 Minor GC 수행 시간  전체 GC 수행 시간  Full GC 수행 횟수  Minor GC 수행 횟수",
        "url": "//java/2024/05/18/java-series-07-Tuning.html"
      }
      ,
    
      "java-2024-05-18-java-series-06-gc-algorithm-html": {
        "title": "[java Series] 06 Gc_algorithm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GC Algorithm가비지 컬렉션 알고리즘1. Serial GC  서버의 CPU 코어가 1개일 때 사용하기 위해서 개발된 GC  GC 처리하는 쓰레드가 1개라서 STW가 길다.  MinorGC에서는 Mark-Sweep, MajorGC에서는 Mark-Sweep-Compactjava -XX:+UseSerialGC -jar Application.java2. Parallel GC  Java 8의 Default  Serial GC와 기본 알고리즈은 같지만 Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old는 Single)  Serial GC에 비해서 STW가 줄어java -XX:+UseParallelGC -jar Application.java # -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수3. Parallel Old GC(Parallel Compacting Collector)  Parallel GC를 개선한 버전  Young, Old도 멀티 GC  새로운 GC 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old도 Multi)java -XX:+UseParallelOldGC -jar Application.java# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수4. CMS GC (Concurrent Mark Sweep)  어플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되어 STW를 최대한 줄이기 위래서 고안된 GC  GC 과정이 매우 복잡  GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다.  메모리 파편화 문제  CMS GC는 Java9부터 deprecated, Java14에는 중지됨# deprecated in java9 and finally dropped in java14java -XX:+UseConcMarkSweepGC -jar Application.java5. G1 GC (Garbage First)  GMC GC를 대체하기 위해서 Java 7에서 최초로 release  Java 9+의 디폴트 GC  4GB 이상의 Heap, STW이 0.5 이상이될 때 사용 (Heap이 너무 작으면 미사용 권장)  기존의 GC에서는 HEAP 영역을 물리적으로 고정된 Young/ Old로 나눴지만 G1은 Region을 도입. Eden, Survivor, Old를 고정이 아닌 동적으로 부여  Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 식java -XX:+UseG1GC -jar Application.java6. Shenandoah GC  Java 12에 release  RedHat에서 개발  기존 GMS가 가진 단편과, G1이 가진 pause 이슈를 해결  강력한 Concurrency와 가벼운 GC 로직으로 Heap 사이즈에 영향을 받지 않고 일정한 Pause 시간 소요가 특징java -XX:+UseShenandoahGC -jar Application.java7. ZGC( Z Garbage Collector )  Java 15에 release  대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해서 디자인된 GC  G1의 Region처럼 ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정이지만 ZPage는 2mb 배수로 운영됨  ZGC가 내세우는 최대 장점은 힙 크기가 증가해도 STW가 절대로 10ms를 넘지 않는다.java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java",
        "url": "//java/2024/05/18/java-series-06-GC_Algorithm.html"
      }
      ,
    
      "java-2024-05-18-java-series-05-gc-html": {
        "title": "[java Series] 05 Gc",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GCGC자바의 메모리 관리 방법 중 하나로 JVM의 HEAP 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스(C/C++ 은 수동으로 메모리 할당, 해제를 해야했다.)1. 대상판단 근거로 도달성, 도달능력(Reachability)라는 개념을 적용한다. 객체에 레퍼런스가 있다면 Reachable[1], 객체에 유효한 레퍼런스가 없으면 UnReachable[2]로 구분한다.주로 Heap Area에서 참조하고 있지 않은 객체가 GC 대상이 된다.청소 방식Mark And SweepGC가 동작하는 가장 기초적인 청소 과정.GC 대상이 될 객체를 식별(Mark), 제거(Sweep)하며 객체가 제거되며 파편화된 메모리를 영역 앞에서부터 채워나가는 작업을 수행한다.  Mark : Root Space부터 그래프 순회를 통해서 연결되나 객체를 찾아서 각각 어떤 객체를 참조하고 있는지 마킹  Sweep : Unreachable를 Heap에서 제거한다.  Compact : Heap의 시작 주소를 모아 메모리가 할당된 부분과 아닌 부분으로 압축한다. (GC 종류에 따라 하지 않는 경우도 있음 )GC 동작 과정Heap은 동적으로 레퍼런스 데이터가 저장되는 공간으로 GC 대상이 되는 공간이다. Heap은 아래 2가지를 전제(Weak Generational Hypothesis)로 설계됐다.  대부분 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.  오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.즉, 객체는 대부분 일회성, 메모리에 오랫동안 남을 경우는 드물다는 것이다.   Young          새롭게 객체가 할당되는 영역      대부분 객체가 금방 Unreachalbe이 되므로 Young에 생성됐다 사라짐      Young에 대한 GC를 Minor GC라고 부름        Old          Young에서 Reachable을 유지하면 복사되는 영역      Young보다 크게 할당됨. 크기가 큰 만큼 가비지는 적게 발생      Old에 대한 GC를 Full GC라고 부름        Eden          new를 통해 생성된 위치      정기적 쓰레기 수집 후 살아남으면 Survivor로 보냄        Survivor 0/ 1          최소 1 번 이상의 GC에서 살아남은 객체가 존재하는 영역      Survivor 0, 1 중 하나는 꼭 비어 있다.      MinorGCYoung은 Old에 비해서 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다.  처음 생성된 객체는 Young 영역의 Eden에 위치  Eden이 꽉차면 MinorGC 발생          Obj MarK로 Reachable 탐색      살아 남은 Obj Survivor로 이동      Eden의 unreachable gowp      살아남은 모든 객체 age[3] += 1      Eden이 가득 차면 비어있는 Survivor로 Eden, 기존 Survivor 내용들 이동      옮긴 Survivor 내역들 age += 1      MajorGCOld는 길게 살아남은 메모리들이 존재하는 공간. age 임계 값을 초과해서 이동되는 녀석 가끔 Young에 담을 수 없을 정도로 크면 Old로 보내기도 함그리고 MajorGC는 객체들이 계속 Promotion되어 Old가 부족해지면 발생MinorGC vs. MajorGC            GC Type      MinorGC      MajorGC                  대상      Young      Old              실행 시점      Eden이 꽉 차면      Old가 꽉차면              실행 속도      빠르다      느리다      MajorGC는 old가 꽉 차면 Unreachable을 한꺼번에 삭제하는 MajorGC가 실행된다. Young은 크기가 작기에 빠르지만 Old는 크기에 보통 10배 이상의 시간을 사용한다.또한  STOP-THE-WORLD 가 발생한다. 이 때 Thread가 멈추고 Mark and Sweep을 하므로 일시적으로 멈추기 때문[1] : 객체가 참조되고 있는 상태[2] : 객체가 참조되고 있지 않은 상태 (GC 대상)[3] : Survivor 영역에서 객체가 살아남은 횟수. Object Header에 기록 age가 임계 값에 다다르면 Promotion( Old로 이동 여부를 결정. 기본 임계값은 31)",
        "url": "//java/2024/05/18/java-series-05-GC.html"
      }
      ,
    
      "java-2024-05-18-java-series-04-jni-html": {
        "title": "[java Series] 04 Jni",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JNIJNI(Java Native Interface)자바 네이티브 인터페이스는 JVM위에서 실행되고 있는 자바 코드가 네이티브 응용 프로그램(하드웨어, 운영체제 플랫폼에 종속된 프로그램들), C, C++, 어셈블리 같은 다른 언어들로작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크1. 네이티브 메소드Java는 메소드 구현이 네이티브 코드에서 제공될 것임을 나타내는 데 사용되는 네이티브 키워드를 제공한다. 일반적으로 네이티브 실행 프로그램을 만들 때 정적 또는 공유 라이브러리를 사용할 수 있다.2. 예약어  native: 다른 언어에서 사요할 수 있게 해주는 키워드  volatile: Thread safe를 하게 해주는 키워드  strictfp: 자바와 타 플랫폼 간 부동소수점 정밀도를 맞추기 위한 키워드  assert: 인자로 주어진 값이 참인지 거짓인지 판별하는 메소드",
        "url": "//java/2024/05/18/java-series-04-JNI.html"
      }
      ,
    
      "java-2024-05-18-java-series-03-memory-html": {
        "title": "[java Series] 03 Memory",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - memoryMemory (Runtime Data Area)  Method(static) 영역  Stack 영역  Heap 영역1. 자바 변수 종류  클래스 변수: 클래스 영역에서 static이 붙는 변수 - 클래스가 메모리에 올라갈 떄  인스턴스 변수: static이 나닌 변수 (참조 없을 경우 gc 대상) - 인스턴스가 생성될 때  지역 변수: 메소드 내에서 선언, 메소드가 끝나면 소멸 - 해당 메소드가 실행될 때  매개 변수: 메소드 호출 시 전달하는 값 - 해당 메소드가 실행될 때2. Method(Static) 영역 ( == Class area, Static area)  JVM이 동작해서 클래스가 로딩될 때 생성      JVM이 읽어들인 클래스와 인터페이스에 대한 정보(멤버 변수, 런타임 상수 풀, 생성자, 메소드 등)와 함께 클래스 변수(static variable)가 저장되는 영역    ↳ Field Information: 멤버 변수의 이름, 데이터 타입, 접근 제어자에 대한 정보    ↳ Method Information: 메소드 이름, 리턴 타입, 매개변수, 접근제어자에 대한 정보    ↳ Type Information: class인지 interface인지 여부 저장, 전체 이름, super의 이름(interface, object인 경우 Heap에서 관리)    Method(Static) 영역에 있는 것은 어느 곳에서나 접근 가능  Method(Static) 영역에 있는 데이터는 프로그램 시작 ~ 종료까지 메모리에 남아 있다.2.1 Runtime Constant Poolstatic 영역에 존재하는 별도 관리 영역 상수 자료형을 저장하여 참조하고 중복을 막는다.3. Stack 영역  메소드 내에서 정의하는 기본 자료형에 해당되는 지역 변수의 데이터 값이 저장되는 공간  메소드가 호출될 때 스택 영역에 스택 프레임[1]이 생기고 그 안에서 메소드를 호출  primitive 타입에 해당되는 지역변수, 매개 변수 데이터 값이 저장됨  메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 사라짐  Stack은 LIFO이며, 스코프 범위를 벗어나면 스택 메모리에서 사라진다.4. Heap[2]  JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 여역  new 연산자로 생성되는 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간  Heap에 있는 오브젝트들을 가리키는 레퍼런스 변수는 stack에 적재  Heap는 Stack과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지. 그러나 Heap에 인스턴스를 참조하지 않는 상황이 되면 GC 대상이 된다.  stack은 쓰레드 개수마다 생성되지만 Heap은 몇 개의 쓰레드가 존재하든 상관 없이 하나의 Heap만 존재한다. https://inpa.tistory.com/entry/JAVA-☕-그림으로-보는-자바-코드의-메모리-영역스택-힙#  https://1-7171771.tistory.com/140  method(static) area? permenent generation?1. Permanent Generation : 생성된 객체들의 정보의 주소 값이 저장된 공간이다. 클래스 로더에 의해 load되는 Class, Method 드엥 대한 Meta 정보가 저장되는 영역 (Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용)  MetaSpace[3]: class의 메타 정보, 메소드의 메타 정보, static object 변수, 상수, JVM, JIT 관련 데이터 등  New/Young          메모리에 객체가 생성되면 Eden에 생성된다.      Eden에 메모리가 가득차면 Eden 데이터가 Survivor1 혹은 Survivor2로 옮겨진다. 1,2 우선 순위는 없다.      Survivor에 있으면 어디에서인가 참조되고 있는 객체들이다. 둘 중 하나가 가득차면 공간이 남아 있는 Survivor로 옮겨진다.      이러한 매커니즘으로 Survivor1 혹은 Survivor2 둘 중 하나는 항상 비워져 있다.      이 과정에서 Minor GC가 발생한다. New/Young에서 발생하는 CG로 Eden 또는 Survior1, Survior2에서 사용되지 않는 객체들을 삭제한다.  Old          Survivor 1, 2를 왔다 갔다하는 동안 살아남은 객체들은 Old로 간다. Old는 Young 보다 크게 할당한다. 이러한 이유로 Old의 GC는 Young보다 드물다.      간혹 Eden -&gt; Old로 넘어가는 경우가 있는데 Survivor에 담을 수 없을 만큼 큰 경우 발생한다.      오랫동안 살아남은 객체?  Minor GC가 발생하면 ageBit를 1씩 늘린다. ageBit이 MaxTenuringThreshold[4]를 초과하면Old로 이동한다. (너무 커서 Eden에서 Old로 바로 이동하기도 한다.)  Old에서는 Major GC(Full Gc)가 일어나며, GC를 진행하는 Thread를 제외하고 이외의 모든 Thread를 멈춘 상태로 GC가 진행된다.이 상태를 stop-the-world라고 한다.  JVM에서 GC를 튜닝하는 이유가 stop-the-world 시간을 단축시키 위함이다.GC 알고리즘 종류  Serial GC : JDK 5,6에서 사용 Minor, Major 모두 싱글 스레드로 실행 -&gt; Stop-The-World가 김.          Mark-Sweep-Compact 알고리즘 사용 (식별하고 지우고 빈공간 정리, 압축)  Parallel GC : Young에서 Minor GC 수행 시 멀티쓰레드 사용(SingleCore CPU라면 Serial로 동작)  Parallel old GC : Old에서 Full GC도 병렬로 처리. Old에서 GC를 처리할 때 Mark-Summary(살아 있는 객체를 식별)-Compaction 사용  CMS(Concurrent Mark &amp; Sweep) GC : Major GC를 최소한으로 하려는데 초점을 둠. MajorGC 수행 시간을 줄기이 위해서 GC의 대상 객체를 최대한 정밀하게 파          Initial Mark : 현재 살아남은 객체를 탐색, GC ROOT에서 참조하는 객체들만 우선적으로 탐색(STW 매우 적음)      Concurrent Mark : Initial Mark에서 탐색한 객체들이 참조하고 있는 객체를 찾아가면 GC 대상인지 판별 (STW 없음)      ReMark : Concurrent Mark 실행 중 새로 생성된 객체나, 참조가 끊어지는 등 변경된 사항이 있는지 다시 한 번 확인 (STW 발생 -&gt; 멀티쓰레딩으로 시간 단축)      Concurrent Sweep : ReMark까지 검증 완료된 GC 대상을 삭제 (STW 없이 진행)        CMS GC는 Compact를 하지 않기 때문에 메모리 단편화를 신경써야 한다. 연속적으로 메모리 할당이 불가능할 정도까지 도달했으면  Compaction을 해야하는데, 이때 다른 GC의 Compaction보다Stop-The-World가 길다.  G1 GC (Garbage First GC)기존 CG 알고리즘으로 큰 메모리에서 효율이 좋지 못해서 개선하기 위해서 등장했다. 기존의 Heap과는 다르게 Region으로 나눠서 관리한다. https://1-7171771.tistory.com/140 Region이라는 논리적인 단위로 메모리를 관히하며, CMS와ㅏ 달리 Compaction을 진행하고 메모리 단편화 문제를 없앰. STW 시간을 예측할 수 있다.  Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간. 이 공간에서 GC가 효율적으로 일어나지 않는다.  Available/Unused : 아직 사용하지 않은, 비어있는 공간Young GC를 수행할 때 STW가 발생, 멀티쓰레드로 극복한다. Young GC는 Regionwnd GC 대상 객체가 가장 많은 Region에서 진행(Eden / Survivor).이 Region에서 살아남은 객체를 다른 Region(Survivor)로 옮기고 빈 Region을 Available/Unused로 돌린다.[1] : 하나의 메소드에 필요한 메모리 덩어리를 묶어서 스택 프레임이라고 한다. 하나의 메소드당 하나의 스택 프레임이 필요하며, 메소드를 호출하기 직전 스택 프레임을 자바 Stack에 생성한 후 메소드를 호출한다.[2] : 자바 코드를 실행할때 따로 -Xms과 -Xmx 옵션을 사용하면 힙 메모리의 초기 사이즈와 최대 사이즈를 조절할 수 있다.[3] : 자바 8부터 변경되었다. 이 영역은 Native 메모리 영역으로 JVM이 아닌 OS에서 관리되도록 변경됐다.[4] :  기본 값 15",
        "url": "//java/2024/05/18/java-series-03-Memory.html"
      }
      ,
    
      "java-2024-05-18-java-series-02-jvm-html": {
        "title": "[java Series] 02 Jvm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JVMJVMJava Virtual Machine의 줄임말이다.Java는 JVM이라는 가상머신을 거쳐서 OS에 도달한다. 이때 인식하는 것이 자바 바이트코드(Java Bytecode)이다. Java Compiler는 .java를 .class로 변환해준다. 여기서 자바 바이트 코드는 명령어의 크기가 1바이트이다.바이트 코드는 다시 실시간 번역기 또는 JIT(Just-In-Time)[1] 컴파일러에 의해서 바이너리 코드로 변환된다. 이때 변환은 모든 바이트 코드를 변환하는 것이 아니라 실행하기 전에 필요한 부분을 즉석으로 컴파일 하는 방식을 말한다.또한, 자주 쓰이는 코드는 캐싱해서 같은 부분을 반복적으로 번역(interpret)하지 않도록 한다.JVM은 크게 아래와 같이 이뤄져 있다.  클래스 로더(Class Loader)  실행 엔진(Execution Engine)          인터프리터(Interpreter)      JIT 컴파일러(Just-In-Time)      가비지 콜렉터(Garbage collector)        런타임 데이터 영역(Runtime Data Area)1. 클래스 로더JVM 내로 클래스 파일(*.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.2. 실행 엔진클래스를 실행시키는 엔진, 클래스로더가 JVM 내 런타임 데이터 영역에 바이트 코드를 배치시키고 이것은 실행 엔진에 의해서 실행된다. 바이트 코드는 바이너리 코드가 아니다. 그래서 실행 엔진은 바이트 코드를 JVM 내부에서 바이너리 코드로 변환한다.2.1.1. 인터프리터바이트 코드를 명령 단위로 읽어서 실행한다.2.1.2. JIT(HotSpot)인터프리터 방식으로 사용하기 직전 기계어로 변역하고 캐싱하여 이후에는 번역하지 않는 방식으로 동작한다.2.2 가비지 콜렉터[2]더 이상 사용하지 않는 인스턴스를 찾아 메모리에서 삭제한다.2.3 Runtime Data Area3. JDK? JRE?  JDK : Java Development Kit ( JRE + (javac, jdb, javadoc…))  JRE : Java Runtime Environment ( JVM + 자바 클래스 라이브러리)[1] : 크게 나눠서 HotSpot Vm과 같이 메소드(함수) 단위로 JIT하는 방식과 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하여 컴파일할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 추가적으로, 미리 컴파일된 코드를 실행하는게 아니라 런타임에 동적으로 코드를 생성하여 실행하므로 잠재적 보안 문제가 있다. 예를 들어 인텔 스펙터가 JIT에 의존하는 JS 엔진을 가진 브라우저에서만 발생했다.",
        "url": "//java/2024/05/18/java-series-02-jvm.html"
      }
      ,
    
      "java-2024-05-18-java-series-01-version-html": {
        "title": "[java Series] 01 Version",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자바 버전별 정보JDK 1.0  안정화 작업JDK 1.1  이너 클래스, JavaBeans, RMI, Reflection, Calendar 유니코드 지원Javabeans : 자바로 작성된 소프트웨어 컴포넌트\t&gt; 1. 기본 생성자가 반드시 존재해야한다. \t&gt; 2. 모든 속성은 비공개\t&gt; 3. 속성에 접근하고 꺼내올 수 있는 getter, setter 구성\t&gt; 4. Serializable 구현RMI : Remote Method Invocation의 약자로 분산 애플리케이션을 구축하는 데 사용, 한 시스템(JVM)에 상주하는 객체가 다른 JVM에서 실행 중인 객체에 액세스, 호출할 수 있도록 도와주는 메커니즘JDK 1.2  JIT(HotSpot), Collection Framework 등 추가J2SE 1.3  HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가J2SE 1.4assert, 정규표현식, IPv6, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가J2SE 5  Generics 추가  Annotation 추가  동시성 제어 API (Concurrency API) 추가  Enumeration 추가  Auto Boxing/ Unboxing 추가Java SE 7  Diamond Operator ( ‘&lt;&gt;’ ) 추가Java SE 8 (오라클 인수 이후)  Lambda Expression 지원  Method Reference 지원  인터페이스에 default method가 추가  Optional 추가  날짜와 시간 API 추가       //javax.time.Clock   Clock.systemUTC();                    //current time of your system in UTC.    Clock.millis();                        //time in milliseconds from 1/1/1970.        //javax.tme.ZoneId   ZoneId zone = ZoneId.of(“Europe/London”);        //zoneId from a timezone.    Clock clock = Clock.system(zone);            //set the zone of a Clock.        //javax.time.LocalDate   LocalDate date = LocalDate.now();            //current date    String day = date.getDayOfMonth();            //day of the month    String month = date.getMonthValue();            //month    String year = date.getYear();                //year        Stream API 추가  PermGenArea 제거 : java8이전에는 초기 설정시 PermSize, MaxPerSize를 성정해야 했는데 이후 MetaSpace로 변경됐다. MetaSpace는 런타임 시 메모리 요규 사항에 따라 자체 크기를 조정하며, 필요하다면 MaxMetaspaceSize 매개변수를 조정하여 양을 조정할 수 있다.## Permanent Generation- Permanent Generation은 Class 혹은 Method Code가 저장되는 영역- PermGen은 Heap에 속함- Default로 제한된 크기를 가짐## Metaspace- Metaspace는 Java 클래스 로더가 현재까지 로드한 class들의 메타 데이터가 저장되는 공간- JVM에 의해 관리되는 Heap이 아닌 OS 레벨에서 관리되는 Native 메모리 영역에 위치- Default로 제한된 크기를 가지고 있지 않고, 필요한 만큼 늘어남Java SE 9  모듈 시스템 jigsaw 등장 (https://www.baeldung.com/project-jigsaw-java-modularity)  A New HTTP Client : 8까지 사용하던 HttpURLConnection을 대체할 새로운 java.net.http 패키지 추가  JsShell : main 메소드 없이 코드를 테스트할 수 있는 대화식 REPL(Read-Eval-Print-Loop) 도구를 제공  Process API 개선 : OS 프로세스 관리 및 컨트롤을 위해 (java.lang.ProcessHandle, java.lang.ProcessHandle.Info)가 추가 됐다.  Try-With-Resource 개선  다이아몬트 연산자를 익명클래스에서도 사용할 수 있도록 개선됨  Interface Private Method 인터페이스 내에서 private 메소드 사용이 가능해짐  Optional To Stream :  Optional로 Stream을 생성할 수 있게 됐다.       &gt; Stream steram = Optional.of(1).stream();Java SE 10  Local-Variable Type Interface : 로컬 변수 타입 추론 기능이다. 로컬 변수 타입을 var로 선언할 수 있다.```javavar list - new ArrayList();\t//ArrayList 으로 추론var stream = list.stream();\t\t//Stream 으로 추론var numbers = List.of(1, 2, 3, 4, 5);\t//List 으로 추론for (var number : numbers){\t\t//Integer 추론\tSystem.out.println(number);}- Garbage Collector Interface : 다양한 GC의 코드 고립도를 향상하는 인터페이스 도입- Thread-Local Handshakes : VM safepoint를 수행할 필요 없이 개별 쓰레드를 stop하고 콜백을 수행할 수 있도록 추가VM safePoint :: “Stop The World”로 모든 쓰레드를 일시 정지시키는 작업    safepoint를 발생시키는 경우    - Garbage collection pauses    - Code deoptimization    - Flusing code cache    - Class redefinition    - Biased lock revocation    - Various debug operation- Root Certificates : HTTPS 통신에 쓰이는 root CA 목록을 OracleJdk에서도 가지게 됐다.# Java SE 11- HTTP 클라이언트(JEP 321) : java 9에 포함됐던 HTTP 클라이언트 API를 정식 채택, URLConnection 기반의 HTTP 개발보다 개선된 기능, 명명 규칙을 제공한다. 특히 HTTP 2.0을 지원하여 웹소켓도 포함되어있다.- 새로운 String 메소드 추가|     Method      |                          Description                           ||:---------------:|:--------------------------------------------------------------:||     strip()     |                         문자열 앞, 뒤 공백 제거                         || stripLeading()  |                          문자열 앞의 공백 제거                          || stripTrailing() |                          문자열 뒤의 공백 제거                          ||    isBlank()    | 문자열이 비어있거나 공백만 포함되어있을 경우 true (String.trim().isEmpty()와 결과 같음) ||     lines()     |                     문자열을 라인 단위로 쪼개는 스트림 반환                     ||    repeat(n)    |                   지정된 수 만큼 문자열을 반복하여 붙여서 반환                    |```java trim()은 U+0020이하의 값만 공백으로 인식(tab, CR, LF, 공백) 하지만 유니코드에는 외에 다른 공백을 제공하는데 이를 제거하려면 Character.isWhitespace(int)를 사용해야만 했다.Java SE 11 부터는 strip()을 사용하면 된다.  Lambda 파라미터로 var 사용    (var x, var y) -&gt; x.process(y) =&gt; (x, y) -&gt; x.process(y)      Java SE 12  문법적으로 Switch 문을 확장```java//기존 방식switch (day) {    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;}//Java SE 12 부터의 방식switch (day) {    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);}- 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선# Java SE 13- Switch 문 개선을 위한 'yield' 예약어 추가```javavar a = switch (day) {    case MONDAY, FRIDAY, SUNDAY:        yield 6;    case TUESDAY:        yield 7;    case THURSDAY, SATURDAY:        yield 8;    case WEDNESDAY:        yield 9;};  textBlock 추가    String str = \"\"\" This is text block\"\"\";      Java SE 14  12, 13에서의 Switch 문이 표준화되었다.      record( preview ) : java로 많은 상용구를 작성하는 수고를 덜어주는 record 클래스 도입```javafinal class Point {  public final int x;  public final int y;    public Point(int x, int y) {      this.x = x;      this.y = y;  }}// state-based implementations of equals, hashCode, toString// nothing else  //레코드 사용record Point(int x, int y) { }```  NullPointerException track: 어떤 부분에서 NPE가 발생헀는지 설명해준다.Java SE 15  textBlock / Multiline Strings가 공식 채택 준비됐습니다.  Sealed Classes ( preview ) 상속 가능한 클래스를 지정할 수 있는 봉인 클래스가 추가된다. 상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해있어야 한다.  EdDSA 암호화 알고리즘 추가  스케일링 가능한 낮은 지연의 가비지 컬렉터 추가(ZGC)[1]Java SE 16  jdk1.8부터 시작된 PermGen 대신 Metaspace를 지원하기 시작  OpenJdk의 버전관리가 git으로 변경되었습니다.  Unix-Domain Socket Channels : Unix 도메인 소켓에 연결할 수 있다.Java SE 17  RandomGenerator : 의사 난수 생성기를 통해서 예측하기 어려운 난수를 생성하는 API가 출시됐다.  M1 정식 지원Java SE 18  UTF-8이 기본 인코딩셋이 되었다.  Simple Web Server: 간편설정, 최소한의 기능으로 바로 사용 가능한 HTTP 파일 서버를 제공한다.  Relection 기능 리팩토링( 메소드 핸들을 이용해서 다시 구현 )  switch-case 패턴 매칭 preview  try-catch-finally deprecated  ( try-with-resources 권장)Java SE 19  VirtualThread, Foreign Function &amp; Memory API, Structured Concurrency, Vector API 등이 preview로 추가Java SE 20  VirtualThread(second preview), ScopedValue(incubated), StructuredConcurrency(SecondIncubate)Java SE 21  StringTemplate(preview)  Sequenced Collections  Generational ZGC  Switch Pattern Matching 정식 출시  Unnamed Patterns and Variables (Preview)  Virtual Thread 정식 출시  Windows 32-bit x86 제거 예정Java SE 22  G1 GC에 Region Pinning 기술을 구현해 지연 시간(latency) 단축  super() 호출 전에 다른 statement 실행을 가능하게함 (프리뷰 기능).  이름없는 변수 및 패턴. 안쓰는 변수 이름을 언더스코어(_)로 표기하는 것을 허용  StructuredConcurrency(secondPreview) : 쓰레드 캔슬, 셧다운에 의한 리스크를 줄이고 Observability 향상, 여러 쓰레드에서 실행되는 관련있는 작업들을 그룹핑하는 기능  ScopedValues(secondPreview) : 같은 쓰레드 내에서의 공유 데이터를 관리하기 위한 컨테이너 오브젝트. ThreadLocal과 비슷하지만 ThreadLocal의 단점을 보완해 더 적은 리소스를 사용하고 더 안전하다고 한다. (특히 VirtualThreads, StructuredConcurrency랑 같이 활용될 때)Java SE 23  2024/06/08 Preview  2024/09 GA[1] ZGC 메소드 핸들 ",
        "url": "//java/2024/05/18/java-series-01-Version.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
