<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | newkayak12.github.io</title>
	<meta name="description"
		content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2024-05-18-java-series-29-virtualthread-html": {
        "title": "[java Series] 29 Virtualthread",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VirtualThreadVirtualThread! 간단 정리 버전 !기본 구성Project Loom에서 시작되었으며, Java19에는 Preview로 지원되었고 21에서 정식으로 추가됐다.기본 발상은 Java의 쓰레드는 Kernal Thread를 할당 받아서 사용했었는데 이는  할당까지 OS의 영향하에 있다.  할당까지 비용이 너무 많이 든다.  1 ~ 2MB가 최대flowchart TDsubgraph PlatformThread    subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        subgraph JVM        PlatformThread1        PlatformThread2    end        KernalThread1 --&gt; PlatformThread1    KernalThread2 --&gt; PlatformThread2end라는 문제가 근본적으로 있었다. 그래서 이를 극복하기 위해서 ThreadPool를 할당하여 쓰고 버리는 것이 아닌 반납 하는 시스템으로 자주 사용했다.VirtualThread는 기존 쓰레드(PlatformThread)와 달리 JVM 단에서 쓰레드를 만들어서 실행하는 방향으로 발상을 바꾸게 되어 생겼다. 이를 통해서  JVM의 영향력 아래 있다.  할당에 비용이 적게 들어서 쓰고 버리는 형태로 패러다임이 변경됐다.  ~ KB 단위 사이즈는 식의 변화가 생겼다. 이러면서 기존 쓰레드는 PlatformThread로 개명했다.flowchart TDsubgraph VirtualThread     subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        KernalThread1 --&gt; ForkJoinPool    KernalThread2 --&gt; ForkJoinPool        subgraph JVM        ForkJoinPool                ForkJoinPool --&gt; CarrierThread1        ForkJoinPool --&gt; CarrierThread2                CarrierThread1 --&gt; Queue1        CarrierThread2 --&gt; Queue2                Queue1 --&gt; VirtualThread1        Queue1 --&gt; VirtualThread2        Queue2 --&gt; VirtualThread3        Queue2 --&gt; VirtualThread4    endend  캐리어 쓰레드란?  Proeject Loom의 일부로 도입된 개념으로 VirtualThread를 실행하기 위한 운반체 역할을 한다. PlatformThread를 기반으로 합니다. CarrierThread는 ForkJoinPool 안에 workerThread로 생성이 되어 스케쥴링 된다.VirtualThreadVirtualThread Thread(Runnable을 구현한)를 상속 받았다. 따라서 상호 변용이 가능하다.package java.lang;sealed abstract class BaseVirtualThread extends Thread        permits VirtualThread, ThreadBuilders.BoundVirtualThread {    BaseVirtualThread(String name, int characteristics, boolean bound) {        super(name, characteristics, bound);    }    abstract void park();    abstract void parkNanos(long nanos);    abstract void unpark();}package java.lang;/** * A thread that is scheduled by the Java virtual machine rather than the operating * system. */final class VirtualThread extends BaseVirtualThread {//... 중략private static final long CARRIER_THREAD = U.objectFieldOffset(VirtualThread.class, \"carrierThread\");    // carrier thread when mounted, accessed by VM    private volatile Thread carrierThread;}주의점  쓰고 버리는게 오히려 이득이다.  커넥션 풀을 사용하는 경우(MySQL 같이)나 IO 최대 개수 제한이 있는 경우(OS 파일) 문제가 될 수 있으니 Bound를 두고 사용하는게 맞을 수 있다.",
        "url": "//2024/05/18/java-series-29-VirtualThread.html"
      }
      ,
    
      "2024-05-18-java-series-28-reactive-html": {
        "title": "[java Series] 28 Reactive",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReactiveReactive데이터 흐름과 전달에 대한 프로그래밍 패러다임이다.기존 명령형 패러다임은 콜을 받아서 당겨오는(Pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(Push) 방식이다.즉, 주변 환경과 상호작용을 하는 것을 주도하는게 아니라 일정 값이 변하면 이벤트를 받아서 동작한다. 일종의 옵저버(Observer) 패턴이다.  대략적으로 보면?      기본 골자는 Stream API와 비슷하다.    Stream API와 같이 끝 맺는 메소드 (subscribe)가 있어야 한다.    퍼블리셔가 이벤트를 발행하면 stream을 타고 subscrbie 소비가 되는 패턴이다.  Flow APIJava 9에는  java.util.concurrent.Flow를 추가했다.리액티브 표준에 따라 발행(Pub)/ 구독(Sub)을 할 수 있도록 되어 있다.  Publisher : 데이터를 발행하는 주체이다.    @FunctionalInterfacepublic static interface Publisher&lt;T&gt; {  public void subscribe(Subscriber&lt;? super T&gt; subscriber);}        Subscriber : 데이터를 소비하는 주체이다.    public static interface Subscriber&lt;T&gt; {  public void onSubscribe(Subscription subscription);  public void onNext(T item);  public void onError(Throwable throwable);  public void onComplete();}        Subscription : 구독 그 자체다. Publisher - Subscriber를 연결한다.    public static interface Subscription {  public void request(long n);  public void cancel();}        Processor : 리액티스 스트림에서 처리하는 단계이다.    public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}      ",
        "url": "//2024/05/18/java-series-28-Reactive.html"
      }
      ,
    
      "2024-05-18-java-series-27-little-html": {
        "title": "[java Series] 27 Little",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자잘한 기록물charType -&gt; integer numberclass Example {    public static void main(String[] args) {         char charNine = '9';         int nine = charNine - '0';         // -&gt; nine;    }}String -&gt; splice?class Example {    public static void main(String[] args) {         String exam = \"adcd\";         StringBuilder builder = new StringBuilder(exam);         builder.deleteCharAt(1); //like Splice    }}",
        "url": "//2024/05/18/java-series-27-Little.html"
      }
      ,
    
      "2024-05-18-java-series-26-set-html": {
        "title": "[java Series] 26 Set",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SetintersectList의 retainAll은 교집합 구현에 완벽히 사용 불가import java.util.ArrayList;class RetainTest {    @Test    public void case1() {        String first = \"aaabb\";        String second = \"aabbb\";        List&lt;String&gt; firstList = new ArrayList(); // [aa, aa, ab, bb]        List&lt;String&gt; secondList = new ArrayList(); //[aa, ab, bb, bb]        char[] firstChar = first.toCharArray();        for( int i = 1; i &lt; firstChar.length; i ++ )  firstList.add(firstChar[i - 1]+\"\"+firstChar[i]);        char[] secondChar = second.toCharArray();        for( int i = 1; i &lt; secondChar.length; i ++ )  secondList.add(secondChar[i - 1]+\"\"+secondChar[i]);                                firstList.retainAll(secondList);        System.out.println(firstChar); //[aa, aa, ab, bb]                //firstList에 영향이 없다 치고        secondList.remove(firstList);        System.out.println(secondList); //[aa, ab, bb, bb]        /**         * - 결론         * 알던 것과 결과가 굉장히 다르다.          */    }}",
        "url": "//2024/05/18/java-series-26-Set.html"
      }
      ,
    
      "2024-05-18-java-series-24-junit-html": {
        "title": "[java Series] 24 Junit",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JUnitJunitAnnotation|       Annotation       |                                                            Description                                                             ||:———————-:|:———————————————————————————————————————————-:||         @Test          |                                                        메소드가 테스트 메소드임을 나타낸다.                                                        ||   @ParameterizedTest   |                                                        매개변수가 있는 테스트임을 나타낸다.                                                        ||      @ValueSource      |                                         반복 테스트에서 지정한 배열을 파라미터 값으로 순서대로 넘겨준다. (하나의 인수일 경우)                                          ||      @NullSource       |                                                       Null로 값을 전달할 떄  사용한다.                                                        ||      @EmptySource      |                                                        빈 값을 인수로 전달할 때 사용한다.                                                        ||  @NullAndEmptySource   |                                                      Null, Empty 모두 전달할 때 사용                                                       |                                                                    @CsvSource                                                                | 테스트 입력값을 Csv로 구성하여 던질 떄 사용한다.|      @EnumSource       |                                                        열거형의 배열을 테스트 메소드에 전달                                                        ||     @MethodSource      |                                 Arguments로 파라미터를 여러 개 전달할 떄 사용한다. (Arguments.of(value, value….))                                 ||     @RepeatedTest      |                                                      메소드가 반복 테스트 메소드임을 나타낸다.                                                       ||      @DisplayName      |                                                  테스트 클래스 또는 메소드에 대한 사용자 지정 표시 이름                                                   || @DisplayNameGeneration |                                                      테스트 클래스 이름 생성기를 선언한다. *                                                       ||      @BeforeEach       |   @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 전에 실행되는 것을 나타낸다. 테스트 마다 실행 전에 실행된다.  매 테스트마다 초기화해야 하는 경우 사용된다.   ||       @AfterEach       | @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 후에 실행되는 것을 나타낸다.  테스트 마다 실행 후에 실행된다.      매 테스트 후 정리해야 하는 경우 사용된다. ||       @BeforeAll       |                                     @BeforeEach 와 유사하지만 static 메소드여야만 하며  테스트 전에 한 번만 실행된다.                                      ||       @AfterAll        |                                      @AfterEach 와 유사하지만 static 메소드여야만 하며  테스트 후에 한 번만 실행된다.                                      ||        @Nested         |                                                   주석이 달린 클래스가 중첩 테스트 클래스임을 나타낸다.                                                   ||          @Tag          |                                                   클래스, 메소드 수준 테스트 필터링을 위해서 사용한다.                                                   ||       @Disabled        |                                                    테스트 클래스, 메소드를 비활성화할 때 사용한다.                                                     ||        @Timeout        |                                                          테스트 타임아웃을 지정한다.                                                           ||      @ExtendWith       |                                                       확장을 선언적으로 등록할 때 사용한다.                                                        ||   @RegisterExtension   |                                                 필드를 통해 프로그래밍 방식으로 확장을 등록할 떄 사용한다.                                                  ||        @TempDir        |                                             테스트 메소드에서 필드 주입 또는 매개변수 주입을 통해 임시 디렉토리를 제공                                             ||      @TestFactory      |                                                     동적 테스트를 위한 테스트 팩토리임을 나타낸다.                                                     ||     @TestTemplate      |                                                                                                                                    ||    @TestClassOrder     |                                                   @Nested 간 실행 순서를 구성하는 데 사용한다.                                                    ||    @TestMethodOrder    |                             테스트 메소드간 순서를 구성하는 데 사용한다.                                               @                              ||     @TestInstance      |                                              주석이 달린 테스트 클래스의 인스턴스 수명 주기를 구성하는데 사용한다.                                               ||          @Sql              |                                                      sql 파일을 지정하여 Dao 단위 테스트에 미리 구성된 쿼리를 실행한다.                                                                              |class Junit {    @TestFactory    Stream&lt;DynamicTest&gt; testFactory () {        List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        return numbers.stream()                      .forEach( num -&gt; dynamicTest(                              num,                              () -&gt; assertThat(number &lt; 10).isTrue()                      ));    }    @ParameterizedTest    @ValueSource(ints = {1,2,3,4,5,6,7,8,9,10})    public isUnderThen(int number){        assertThat(number &lt; 10).isTrue();    }}Spring Test AnnotationsController Test| Annotation                                                                                                                                                    |                                      Description                                      ||:————————————————————————————————————————————————————–|:————————————————————————————-:|| @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, properties = “spring.profiles.active=[profile]”)                  | SpringBootTest임을 알린다. 이 어노테이션이 붙으면 SpringContext를 실행하고 Component 스캔 등을 한다. (스프링을 켠다.) || @AutoConfigureMockMvc                                                                                                                                         |                                    서블릿 컨테이너를 모킹한다.                                    || @TestPropertySource                                                                                                                                           |     테스트 환경의 Property를 지정할 수 있다. (classpath:로 resource 내부에서 찾는건 덤 -&gt; build에서 찾는다.)     || @ActiveProfiles                                                                                                                                               |                               Active로 둘 Profile를 지정한다.                                |            Object      Description                  @AutowiredMockMvc      테스트용 MVC환경을 만들어 요청, 전송, 응답을 제공하는 클래스              @LocalServerPortint port      현재 mocking 혹은 지정된 포트를 반환한다. (RandomPort의 경우)      //ex)@Test@DisplayName(value = \"ContextLoadTest\")void contextLoads() throws Exception {        System.out.println(\"ContextLoaded\");        //given        String expect = \"junitTest\";        //when        mockMvc.perform(        get(\"/v1/user/test\")        .contentType(MediaType.APPLICATION_JSON)        .accept(MediaType.APPLICATION_JSON)        )        //that        .andExpect(MockMvcResultMatchers.status().isOk())        .andExpect(jsonPath(\"$\",expect).exists());        }ServiceTest| Annotation  |                 Description                  ||:————|:——————————————–:|| @ExtendWith |        단위 테스트에 공통적으로 사용할 확장 기능을 선언한다.        || @Mock       |       Mock 객체를 생성 메소드는 있지만 내부 구현이 없다.        || @Spy        | 모든 기능을 가지고 있다. 다만 Stub을 하면 해당 부분만 Mocking된다. || @InjectMock |  @Mock, @Spy로 생산한 객체를 주입한다.(생성자 주입으로 추정된다.)  |RepositoryTest| Annotation                                                                                                                                          |                         Descpription                         ||:—————————————————————————————————————————————————-|:————————————————————:|| @DataJpaTest(  showSql = true,  properties = {“classpath:application.yml”},  includeFilters = {}) | SpringContext 중 Repository에 관련된 요소들만 테스트하기 위해서 사용하는 어노테이션이다. || @AutoConfigureTestDatabase(connection=””, replace=””)                                                                                               |    TestDB를 구성할 때 유용한 어노테이션이다. 테스트 시 DB를 테스트 DB로 대체할 수 있다.    |",
        "url": "//2024/05/18/java-series-24-Junit.html"
      }
      ,
    
      "2024-05-18-java-series-23-shellcommand-html": {
        "title": "[java Series] 23  shellcommand",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - shellCommand당시 OOM이 나서 여러 옵션을 건들였었는데 이에 대해서 찾아보고 이를 기록한 문서입니다.#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jstat -gcutil -h 20 $pid 2000 10000#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jhsdb jmap --binaryheap --dumpfile /home/chat/dump.hprof --pid $pid#!/bin/bash#projectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jcmd $pid GC.class_histogram &gt; histogram.logif [ -z $pid ] then        echo \"No server is running.\" else        kill -9 \"$pid\"        echo \"Shut down the running server.\"fi/home/jdk-11/bin/java \\-XX:+UseParallelOldGC \\-Xms1024m \\-Xmx4096m \\-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=/home/chat/dump/heapdump.hprof \\-verbose:gc \\-jar \\-Dspring.profiles.active=prod \\$projectPath/$projectName-*.war \\&gt; $projectPath/out.log  \\2&gt; $projectPath/exception.log &amp;echo \"The server was successfully run.\"",
        "url": "//2024/05/18/java-series-23-ShellCommand.html"
      }
      ,
    
      "2024-05-18-java-series-22-floatingpoint-html": {
        "title": "[java Series] 22 Floatingpoint",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Floating point issue부동 소수점 관련 문제class FloatingPoint {    @Test    public void fpFailure() {        Assertions.assertEquals(1.2 , 1.1 + 0.1);        //결과는? false        //부동소수점 문제 때문에 그렇다. (특히 이 주변은 다 괜찮은데 얘만 그렇다.)        /**         * Expected :1.2         * Actual   :1.2000000000000002         */        //위와 같은 결과로 나온다.    }        @Test    public void fpSuccess() {        Assertions.assertEquals(BigDecimal.valueOf(1.2), BigDecimal.valueOf(1.1).add(BigDecimal.valueOf(0.1)));        //이러면 성공한다.    }}Java _ BigDecimal 관련 사용 시 유의점연산  ’+’ : BigDecimal.valueOf(x).add(BigDecimal.valueOf(y));  ’-‘ : BigDecimal.valueOf(x).substract(BigDecimal.valueOf(y));  ‘*’ : BigDecimal.valueOf(x).multiply(BigDecimal.valueOf(y));  ’/’ : BigDecimal.valueOf(x).divide(BigDecimal.valueOf(y));  ’%’ : BigDecimal.valueOf(x).remainder(BigDecimal.valueOf(y));  절대값 : BigDecimal.valueOf(x).abs();소수점RoundingMode  UP(BigDecimal.ROUND_UP), : 양수일 때 올림, 음수일 때 내림  DOWN(BigDecimal.ROUND_DOWN), : ROUND_UP과 반대  CEILING(BigDecimal.ROUND_CEILING), : 올림  FLOOR(BigDecimal.ROUND_FLOOR), : 내림  HALF_UP(BigDecimal.ROUND_HALF_UP), : 반올림 (5이상 올림 5미만 버림)  HALF_DOWN(BigDecimal.ROUND_HALF_DOWN), : 반올림 ( 6이상 올림, 6미만 버림)  HALF_EVEN(BigDecimal.ROUND_HALF_EVEN), : 반올림 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP  UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);: 딱 떨어지는 값이 아니면 ArithmeticException사용법BigDecimal(\"0.9999\").setScale(0, RoundingMode.CEILING);MathContext  UNLIMITED = new MathContext(0, RoundingMode.HALF_UP); : unlimit (무제한 정밀 산술)  DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal32 format, 7 digits ( 7자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal64 format, 16 digits  ( 16자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);: matching the precision of the IEEE 754-2019 decimal128 format, 34 digits ( 32자리 정밀도 및 HALF_EVENT의 반올림 모드)MethodsBigIntegerclass IntroduceBigInteger {    public void bit () {        BigInteger i = new BigInteger(\"1018\"); // 2진수로 표현하면 : 1111111010(2)        int bitCount = i.bitCount(); // 1의 갯수 : 8        int bitLength = i.bitLength(); // 비트 수 : 10        int getLowestSetBit = i.getLowestSetBit(); // 1        boolean testBit3 = i.testBit(3); // true        BigInteger setBit12 = i.setBit(12); // 우측에서 13번째 비트를 1로 변경 → 1001111111010(2) → 5114        BigInteger flipBit0 = i.flipBit(0); // 1111111011(2) → 1019        BigInteger clearBit3 = i.clearBit(3); // 1111110010(2) → 1010        }           public void bitOperate () {        BigInteger i = new BigInteger(\"17\"); // 2진수 : 10001(2)        BigInteger j = new BigInteger(\"7\"); // 2진수 : 111(2)        BigInteger and = i.and(j); // 10001(2) &amp; 111(2) = 00001(2) → 1(10)        BigInteger or = i.or(j); // 23        BigInteger not = j.not(); // -8        BigInteger xor = i.xor(j); // 22        BigInteger andNot = i.andNot(j); // 16        BigInteger shiftLeft = i.shiftLeft(1); // 34        BigInteger shiftRight = i.shiftRight(1); // 8    }}JsonSerializerBigDecimal to JsonValueclass BigDecimalScale6WithBankersRoundingSerializer  implements JsonSerializer&lt;BigDecimal&gt; {    public static Integer SCALE_SIX = 6;    public static RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;        @Override    public Object serialize( BigDecimal value, JsonGenerator gen,   SerializerProvider serializers ) {        return gen.writeString(value.setScale(SCALE_SIX, BANKERS_ROUNDING_MODE).toString());    }}",
        "url": "//2024/05/18/java-series-22-FloatingPoint.html"
      }
      ,
    
      "2024-05-18-java-series-21-yaml-html": {
        "title": "[java Series] 21 Yaml",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - YAMLYAML(Yet Another Markup Language)기존에 주로 사용되던 포맷인 JSON의 불편함을 해소하기 위해 만들어진 superset이다. (확장자만 바꿔도 JSON -&gt; YAML로 변환된다. )데이터 정의  Key:Value 표기  콤마 표기하지 않음  indent로 계층 구조를 표현  따옴표 (굳이 쓰지 않아도 된다.)  작은 따옴표, 큰 따옴표 -&gt; 이스케이필 문자를 구분해야하면, 큰 따옴표는 escapeSequence, 작은 따옴표는 그대로 문자열로 처리한다.배열 &amp; 리스트  -으로 하위 엘리먼트 표현  객체 배열이 필요하다면 객체 시작에만 -를 사용한다.    students:  - name: Mark major: Math age: 20  - name: Julie major: Arts age: 23  - name: Tommy major: Music age: 25        Boolean : yes/no, true/false를 boolean으로 구문한다. case insensitive다.  변수 선언 : &amp;으로 변수 선언하고 *으로 참조한다.default: &amp;default_school # default_school 라는 변수를 선언하고, 그 내용은 group 과 description 데이터를 지니고 있다   group: '서울대학교'   description: |      서울에 위치하는 대한민국 대학교!student:   - name: '홍길동'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다   - name: '임꺽정'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다",
        "url": "//2024/05/18/java-series-21-YAML.html"
      }
      ,
    
      "2024-05-18-java-series-20-stringandtokenizer-html": {
        "title": "[java Series] 20 Stringandtokenizer",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Split vs StringTokenizerSplit vs. StringTokenizer1. Split정규식을 받는 메소드와, 정규식 + 인덱스를 받는 메소드 두 개가 오버로딩되어 있다.class String {    public String[] split(String regex);// 반환을 String 배열로 받는다.// 구분 기호를 문자열이 아닌 정규표현식으로 받는다. (중요)    public String[] split(String regex, int limit);// 문자열을 정규식에 맞춰서 분리하는데 limit만큼 문자열을 자른다.}2. StringTokenizer구분자를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는데 사용한다.// 문자열을 공백 문자를 구분자로 자르기new StringTokenizer(String str)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// 이때 구분자는 토큰으로 간주되지 않음new StringTokenizer(String st, String delim)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// returnDelims 의 값을 true로하면 구분자도 토큰으로 간주new StringTokenizer(String str, String delim, boolean returnDelims)결론적으로 split vs. StringTokenizer  split 메소드는 String클래스에 속해있는 메소드이고, StringTokenizer는 java.util에 포함되어 있는 클래스이다.  구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.  split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.  split는 빈문자열을 토큰으로 인식하는 반면, StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다.  성능은 split 보다 StringTokenizer 가 좋다.  split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.  그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.",
        "url": "//2024/05/18/java-series-20-StringAndTokenizer.html"
      }
      ,
    
      "2024-05-18-java-series-19-clone-html": {
        "title": "[java Series] 19 Clone",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CloneCloneObject.clone()인스턴스 객체 복제를 위한 메소드, 해당 인스턴스를 복제해서 새로운 인스턴스를 생성해서 그 참조 값을 반환한다. clone() 사용을 위해서 Cloneable을 구현해야한다.Deep vs. ShallowDeep은 값 타입이든, 참조 타입이든 복사하여 원본과 구분되는 결과물을 생성해 내는 것을 의미하며, 얕은 복사는 값이든 참조든 복사하여 원본과 같은 결과물을 만들어내는 것을 의미한다.Deep의 주의사항만일 필드에 참조형이 있다면 아무리 대상을 깊은 복사했어도 필드는 참조를 복사한다. 따라서 필드의 클래스도 따로 처리를 해야한다.",
        "url": "//2024/05/18/java-series-19-Clone.html"
      }
      ,
    
      "2024-05-18-java-series-18-variableargument-html": {
        "title": "[java Series] 18 Variableargument",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 가변인자Variable Argument가변 인수 사용법메서드 파라미터 부분에 타입… 매개변수명 으로 처리하면 사용이 가능하다.가변 인수는 전달 인자를 0개부터 n개까지 넣을수 있다. 그리고 파라미터로 넘겨지는 값들을 모아서 컴파일시 배열로 처리된다. 주의할점은 인자들의 갯수에는 제한이 없지만, 배열 자료형은 매개변수 타입으로 명시된 것에 따라간다는 점이다.만일 매개변수가 가변 인자 외에 다른 매개 변수들도 받는다면, 반드시 가변 인자를 메서드 파라미터 가장 마지막에 위치하도록 정의해야 한다.그리고 매개변수가 넘겨지는 순서는, 인자들이 앞에 있는 파라미터 부터 차례대로 넘겨지고 남은 나머지 인자들이 가변 인자로 넘겨지게 된다.주의점  가변 인자 자체가 성능에 좋지않다. (배열 선언)  가변 인수 자체를 오버로딩하면 컴파일러가 어떤 메소드를 사용해야할지 구분하지 못한다.  배열 타입 매개변수와 혼용하지 않기    public void print( String ... str ) {}public void print( String[] str) {}        제네릭과 혼합하면 신중하게 -&gt; 제네릭은 배열로 실체화 불가하다.  ",
        "url": "//2024/05/18/java-series-18-VariableArgument.html"
      }
      ,
    
      "2024-05-18-java-series-17-generic-html": {
        "title": "[java Series] 17 Generic",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GenericGeneric클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 법을 의미한다.ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();제네릭 타입 매개변수위에서 보다시피, 제네릭은 &lt;&gt; 꺾쇠 괄호 키워드를 사용하는데 이를 다이아몬드 연산자라고 한다. 그리고 이 꺾쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할 수 있다. 이것을 마치 메소드가 매개변수를 받아 사용하는 것과 비슷하여 제네릭의 타입 매개변수(parameter) / 타입 변수 라고 부른다.타입 파라미터 정의이 타입 매개변수는 제네릭을 이용한 클래스나 메소드를 설계할 때 사용된다.예를들어 다음 코드는 제네릭을 감미한 클래스를 정의한 코드이다. 클래스명 옆에  기호로 제네릭을 붙여준 걸 볼 수 있다.그리고 클래스 내부에서 식별자 기호 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정되어 있다.class FruitBox&lt;T&gt; {    List&lt;T&gt; fruits = new ArrayList&lt;&gt;();    public void add(T fruit) {        fruits.add(fruit);    }}제네릭 클래스를 만들었으면 이를 인스턴스화 해보자. 마치 파라미터를 지정해서 보내는 것 처럼 생성 코드에서 꺾쇠 괄호 안에 지정해주고 싶은 타입명을 할당해주면,제네릭 클래스 선언문 부분으로 가서 타입 파라미터 T 가 지정된 타입으로 모두 변환되어 클래스의 타입이 지정되게 되는 것이다.타입 파라미터 생략제네릭 객체를 사용하는 문법 형태를 보면 양쪽 두 군데에 꺾쇠 괄호 제네릭 타입을 지정함을 볼 수 있다. 하지만 맨 앞에서 클래스명과 함께 타입을 지정해 주었는데 굳이 생성자까지 제네릭을 지정해 줄 필요가 없다.따라서 jdk 1.7 버전 이후부터,  new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다. 제네릭 나름대로 타입 추론을 해서 생략 된 곳을 넣어주기 때문에 문제가 없는 것이다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;Apple&gt;();// 다음과 같이 new 생성자 부분의 제네릭의 타입 매개변수는 생략할 수 있다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;&gt;();복수 타입 파라미터제네릭은 반드시 한개만 사용하라는 법은 없다. 만일 타입 지정이 여러개가 필요할 경우 2개, 3개 얼마든지 만들 수 있다.제네릭 타입의 구분은 꺽쇠 괄호 안에서 쉽표(,)로 하며 &lt;T, U&gt; 와 같은 형식을 통해 복수 타입 파라미터를 지정할 수 있다. 그리고 당연히 클래스 초기화할때 제네릭 타입을 두개를 넘겨주어야 한다.import java.util.ArrayList;import java.util.List;class Apple {}class Banana {}class FruitBox&lt;T, U&gt; {    List&lt;T&gt; apples = new ArrayList&lt;&gt;();    List&lt;U&gt; bananas = new ArrayList&lt;&gt;();    public void add(T apple, U banana) {        apples.add(apple);        bananas.add(banana);    }}public class Main {    public static void main(String[] args) {    \t// 복수 제네릭 타입        FruitBox&lt;Apple, Banana&gt; box = new FruitBox&lt;&gt;();        box.add(new Apple(), new Banana());        box.add(new Apple(), new Banana());    }}중첩 타입 파라미터제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.public static void main(String[] args) {    // LinkedList&lt;String&gt;을 원소로서 저장하는 ArrayList    ArrayList&lt;LinkedList&lt;String&gt;&gt; list = new ArrayList&lt;LinkedList&lt;String&gt;&gt;();    LinkedList&lt;String&gt; node1 = new LinkedList&lt;&gt;();    node1.add(\"aa\");    node1.add(\"bb\");    LinkedList&lt;String&gt; node2 = new LinkedList&lt;&gt;();    node2.add(\"11\");    node2.add(\"22\");    list.add(node1);    list.add(node2);    System.out.println(list);}타입 파라미터 기호 네이밍| 타입  |\t설명||:—:|:—–:||  |타입(Type)|||요소(Element), 예를 들어 List|||키(Key), 예를 들어 Map&lt;k, v&gt;|||리턴 값 또는 매핑된 값(Variable)|||숫자(Number)||&lt;S, U, V&gt;|2번째, 3번째, 4번째에 선언된 타입|제네릭 사용 이유, 장점  컴파일 타임에 타입 검사  불필요한 캐스팅을 없앨 수 있음주의 사항  제네릭 타입의 객체는 생성이 불가  static 멤버에 제네릭 타입이 올 수 없음 ( 제네릭 객체 생성 전에 자료 타입이 정해져 있어야 해서 )  제네릭으로 배열을 만들 수 없다.제네릭 범위 한정제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에서 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.예를들어 다음 계산기 클래스가 있다고 하자. 정수, 실수 구분없이 모두 받을 수 있게 하기위해 제네릭으로 클래스를 만들어주었다.하지만 단순히  로 지정하게 되면 숫자에 관련된 래퍼 클래스 뿐만 아니라 String이나 다른 클래스들도 대입이 가능하다는 점이 문제이다.// 숫자만 받아 계산하는 계산기 클래스 모듈class Calculator&lt;T&gt; {    void add(T a, T b) {}    void min(T a, T b) {}    void mul(T a, T b) {}    void div(T a, T b) {}}public class Main {    public static void main(String[] args) {        // 제네릭에 아무 타입이나 모두 할당이 가능        Calculator&lt;Number&gt; cal1 = new Calculator&lt;&gt;();        Calculator&lt;Object&gt; cal2 = new Calculator&lt;&gt;();        Calculator&lt;String&gt; cal3 = new Calculator&lt;&gt;();        Calculator&lt;Main&gt; cal4 = new Calculator&lt;&gt;();    }}개발자의 의도로는 계산기 클래스의 제네릭 타입 파라미터로 Number 자료형만 들어오도록 하고 문자열이나 또 다른 클래스 자료형이 들어오면 안되게 하고 싶다고 한다.그래서 나온 것이 제한된 타입 매개변수 (Bounded Type Parameter) 이다.타입 한정 키워드 extends&lt;T extends [ 제한 타입 ]&gt;인터페이스 타입 한정extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있다.interface Readable {}// 인터페이스를 구현하는 클래스public class Student implements Readable {} // 인터페이스를 Readable를 구현한 클래스만 제네릭 가능public class School &lt;T extends Readable&gt; {}다중 타입 한정만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한하고 싶다면,  &amp; 연산자를 이용하면 된다. 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 된다.단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.interface Readable {}interface Closeable {}class BoxType implements Readable, Closeable {}class Box&lt;T extends Readable &amp; Closeable&gt; {    List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T item) {        list.add(item);    }}재귀적 타입 한정재귀적 타입 한정이란 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 시키는 것을 말한다.실무에선 주로 Comparable 인터페이스와 함께 쓰인다.예를들어 다음과 같이 &lt;E extends Comparable&gt; 제네릭 E의 타입 범위를 Comparable 로 한정한다는 E를 중첩시킨 표현식을 사용할수 있는데, 이 말은 '타입 E는 자기 자신을 서브 타입으로 구현한 Comparable 구현체로 한정' 한다는 뜻이다.class Compare {\t// 외부로 들어온 타입 E는 Comparable&lt;E&gt;를 구현한 E 객체 이어야 한다.    public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; collection) {        if(collection.isEmpty()) throw new IllegalArgumentException(\"컬렉션이 비어 있습니다.\");        E result = null;        for(E e: collection) {            if(result == null) {                result = e;                continue;            }            if(e.compareTo(result) &gt; 0) {                result = e;            }        }        return result;    }}제네릭 형변환캐스팅배열과 같은 일반적인 변수 타입과 달리 지네릭 서브 타입간에는 형변환이 불가능하다. 심지어 대입된 타입이 Object라도 말이다. 자연스럽게 다형성이 적용될 것이라 생각하였지만, 실상 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능한 것이다.와일드 카드      &lt;?&gt; : Unbounded Wildcards (제한 없음)타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다        &lt;? extends 상위타입&gt; : Upper Bounded Wildcards (상위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있다        &lt;? super 하위타입&gt; : Lower Bounded Wildcards (하위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다  자바의 공변성/ 반공변성제네릭의 와일드카드를 배우기 앞서 선수 지식으로 알고 넘어가야할 개념이 있다.조금 난이도 있는 프로그래밍 부분을 학습 하다보면 한번쯤은 들어볼수 있는 공변성(Covariance) / 반공변성(Contravariance) 합쳐서 ‘변성(Variance)’ 이라하는 개념이다.변성은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타태는 지표이다. 그리고 공변성은 서로 다른 타입간에 함께 변할수 있다는 특징을 말한다.이를 객체 지향 개념으로 표현하자면 Liskov 치환 원칙[1]Visit Website에 해당된다.  공변 : S 가 T 의 하위 타입이면,          S[] 는 T[] 의 하위 타입이다.List&lt;S&gt; 는 List&lt;T&gt; 의 하위 타입이다.        반공변 : S 가 T의 하위 타입이면,  T[] 는 S[] 의 하위 타입이다. (공변의 반대)List&lt;T&gt; 는 List&lt;S&gt; 의 하위 타입이다. (공변의 반대)  무공변 / 불공변 : S 와 T 는 서로 관계가 없다.          List&lt;S&gt; 와 List&lt;T&gt; 는 서로 다른 타입이다      제네릭은 공변성이 없다객체 타입은 상하 관계가 있다 그러나 제네릭 타입은 상하관계가 없다. 즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이 불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.제네릭 와일드 카드자바 제네릭을 이용해 프로그래밍 할때 간혹 클래스 정의문을 보다보면 꺾쇠 괄호 ? 물음표 기호가 있는 것을 한번쯤 본 적이 있을 것이다. 이 물음표가 와일드카드이며, 물음표의 의미 답게 어떤 타입이든 될 수 있다는 뜻을 지니고 있다.            와일드카드      네이밍      설명                  &lt;?&gt;      Unbounded wildcards  비한정적 와일드 카드      제한 없음 (모든 타입이 가능)              &lt;? extends U&gt;      Upper Bounded Wildcards 상한 경계 와일드카드      상위 클래스 제한 (U와 그 자손들만 가능)상한이 U라 상한 경계라고 한다.              &lt;? super U&gt;      Lower Bounded Wildcards  하한 경계 와일드카드      하위 클래스 제한 (U와 그 조상들만 가능)  하한이 U라 하한 경계라고 한다.      제네릭의 공변, 반공변자바의 제네릭은 기본적으로 공변, 반공변을 지원하지 않지만, &lt;? extends T&gt; , &lt;? super T&gt; 와일드카드를 이용하면 컴파일러 트릭을 통해 공변, 반공변이 적용되도록 설정 할 수 있다. 둘을 정리하자면 다음과 같다.  상한 경계 와일드카드 &lt;? extends U&gt; : 공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U를 상속받은 하위 클래스 (U와 U의 자손 타입만 가능)상한의 뜻 : 타입의 최고 한도는 U 라는 의미. (최대 U 이하)        하한 경계 와일드카드 &lt;? super U&gt; : 반공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U가 상속한 상위 클래스 (U와 U의 조상 타입만 가능)하한의 뜻 : 타입의 최저 한도는 U 라는 의미. (최소 U 이상)        비경계          타입 매개변수의 범위는 제한이 없다. (모두 가능) &lt; ? extends Object &gt;의 줄임 표현      PECS (Producer-Extends / Consumer-Super)  외부에서 온 데이터를 생산(Producer) 한다면 &lt;? extends T&gt; 를 사용 (하위타입으로 제한)  외부에서 온 데이터를 소비(Consumer) 한다면 &lt;? super T&gt; 를 사용 (상위타입으로 제한). [1] : 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다.",
        "url": "//2024/05/18/java-series-17-Generic.html"
      }
      ,
    
      "2024-05-18-java-series-16-enum-html": {
        "title": "[java Series] 16 Enum",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnumerationEnumerationJAVA에서 enum은 interface와 같이 독립된 특수한 클래스로 구분된다. 즉, 일종의 객체이기 때문에 heap에 저장되며,각 enum 상수들은 별개의 메모리 주소 값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.장점  코드가 단순해지며 가독성이 좋아진다  허용 가능한 값들을 제한하여 유형 안전(type safe)을 제공한다.  키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 나타낼 수 있다.  자체 클래스 상수와 달리 switch문에서도 사용할 수 있다  단순 상수와 비교해 IDE의 적극적인 지원을 받을 수 있다 (자동완성, 오타검증, 텍스트 리팩토링 등등)  리팩토링시 변경 범위가 최소화 된다 (enum에서 한번에 관리하기 때문에 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다)  enum은 본질적으로 Thread safe인 싱글톤 객체 이므로 싱글톤 클래스를 생성하는데에도 사용된다메소드|메소드|\t설명\t|리턴 타입||:—–:|:——–:|:———–:||name()|열거 객체의 문자열을 리턴|String||ordinal()|열거 객체의 순번(0부터 시작)을 리턴|int||compareTo()|열거 객체를 비교해서 순번 차이를 리턴|int||valueOf(String name)|문자열을 입력받아서 일치하는 열거 객체를 리턴|enum||values()|모든 열거 객체들을 배열로 리턴|enum[]|java.lang.Enum모든 클래스가 Object 클래스를 자동 상속하는 것 처럼, Enum 클래스도 무조건 java.lang.Enum 이라는 클래스의 상속을 받는다. 그리고 java.lang.Enum 클래스에 정의되어 있는 메소드를 가져와 사용하는 것이다            메소드      내용                  clone()      객체를 복제하기 위한 메소드하지만, 이 메소드는 enum 클래스에서 사용하면 안된다.만약 호출될 경우엔 CloneNotSupportedException 이라는 예외를 발생시키도록 되어있다              finalize()      GC가 발생할 때 처리하기 위한 메소드              hashCode()      int 타입의 해시 코드 값을 리턴하는 메소드              equals()      두 개의 객체가 동일한지를 확인하는 메소드      Enum, Singleton자바에서의 enum 열거 타입은 일종의 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개하게 된다. 하지만 enum은 클래스처럼 이용할수는 있지만 인스턴스화는 할수는 없는데, 실제로 new 키워드로 인스턴스 생성을 하려고 하면 에러가 난다.이러한 제약적인 특징을 가지고 있는 이유는 enum 타입은 고정된 상수들의 집합으로써, 런타임(run-time)이 아닌 컴파일타임(compile-time)에 모든 값을 알고 있어야 하는 규칙이 있기 때문이다. 즉, 다른 패키지나 클래스에서 enum 타입에 접근해서 변수 처럼 동적으로 어떠한 값들을 할당해 주는 행위는 금지된 것이다.이 때문에 enum 객체의 생성자의 접근제어자를 private으로 설정해야 한다. 이렇게 되면 외부에서 접근 가능한 생성자가 없으므로 enum타입은 실제적으로 final 클래스와 다름이 없게 된다.이러한 특성 때문에, enum타입은 싱글톤을 구현하는 하나의 방법으로 사용되기도 한다.",
        "url": "//2024/05/18/java-series-16-Enum.html"
      }
      ,
    
      "2024-05-18-java-series-15-reflection-html": {
        "title": "[java Series] 15. Reflection",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReflectionReflectionjava.lang.Class자바 프로그래밍을 할때 우리는 보통 변수나 클래스를 직접 선언하고 만들어 사용하여 왔다. 그런데 어떤 경우에는 애플리케이션 실행 중에서 클래스를 동적으로 불러와 다루어야 할 경우가 생긴다. 즉, 코드를 실행하기전 컴파일 단에서 개발자가 직접 폴더를 뒤져가며 클래스 정의문을 찾아 클래스 정보를 얻는 것이 아닌, 코드 상에서 호출 로직을 통해 클래스 정보를 얻어와 다룸으로써 런타임 단에서 다이나믹하게 클래스를 핸들링 하는 것이다.이때 사용되는 것이 바로 Class 클래스 객체이다.Class 클래스는 java.lang.Class 패키지에 별도로 존재하는 독립형 클래스로서, 자신이 속한 클래스의 모든 멤버 정보를 담고 있기 때문에 런타임 환경에서 동적으로 저장된 클래스나 인터페이스 정보를 가져오는데 사용된다. 여기서 오해하지 말아야 할 것이 클래스 자료형을 말하는게 아니라 클래스 이름이 “Class” 인 클래스를 말하는 것이다.  JVM의 클래스 로더(class loader)는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.먼저 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환하고, 없으면 classpath에 지정된 경로를 따라서 클래스 파일을 찾아 해당 클래스 파일을 읽어서 Class 객체로 변환한다.만일 못 찾으면 우리가 익히아는 ClassNotFoundException 예외를 띄우게 된다.Class 객체 얻기Object.getClass()  모든 클래스의 최상위 클래스인 Object 클래스에서 제공하는 getClass() 메서드를 통해 가져온다.  해당 클래스가 인스턴스화 된 상태 이어야 한다는 제약이 있다.java Class&lt;? extends String&gt; cls = str.getClass();.class 리터럴로 얻기  인스턴스가 존재하지 않고, 컴파일된 클래스 파일만 있다면 리터럴로 Class 객체를 곧바로 얻을 수 있다.  가장 심플하게 Class 객체를 가져오는 방법이다.java  Class&lt;? extends String&gt; cls2 = String.class;Class.forName() 으로 얻기  위의 리터럴 방식과 같이 컴파일된 클래스 파일이 있다면 클래스 이름만으로 Class 객체를 반환 받을 수 있다.  클래스의 도메인을 상세히 적어주어야 한다. 그래서 클래스 파일 경로에 오타가 있으면 에러가 발생할 수 있기 때문에 주의해야한다. (대소문자 실수 등)  만일 Class 객체를 찾지 못한다면 ClassNotFoundException를 발생 시키기 때문에 예외처리가 강제된다.  그러나 다른 두가지 방법보다 forName을 통해 얻게 되면 메모리를 절약하며 동적 로딩 할 수 있기 때문에 가장 성능이 좋다.java Class&lt;?&gt; cls3 = Class.forName(\"java.lang.String\");  Class 클래스 객체를 forName() 메서드를 통해 가져오는 방법을 ‘동적 로딩’이라고 부른다. 보통 다른 클래스 파일을 불러올때는 컴파일 시 JVM의 Method Area에 클래스 파일이 같이 바인딩(binding)이 되지만, forName()으로 .class파일을 불러올 때는 컴파일에 바인딩이 되지않고 런타임때 불러오게 되기 때문에 동적 로딩이라고 부른다.그래서 컴파일 타입에 체크 할 수 없기 때문에 클래스 유무가 확인되지 않아 예외 처리를 해주어야 하는 이유이기도 하다.Class 메소드 종류  String getName(): 클래스의 이름을 리턴한다.  Package getPackage(): 클래스의 패키지 정보를 패키지 클래스 타입으로 리턴한다.  Field[] getFields(): public으로 선언된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.  Field getField(String name): public으로 선언된 변수를 Field 클래스 타입으로 리턴한다.  Field[] getDeclaredFields(): 해당 클래스에서 정의된 변수 목록을 field 클래스 배열 타입으로 리턴한다.  Field getDeclaredField(String name): name과 동일한 이름으로 정의된 변수를 Field 클래스 타입으로 리턴한다.  Method[] getMethods(): public으로 선언된 모든 메소드 목록을 Method 클래스 배열 타입으로 리턴한다. 해당 클래스에서 사용 가능한 상속받은 메소드도 포함된다.  Method getMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 메소드를 Method 클래스 타입으로 리턴한다.  Method[] getDeclaredMethods(): 해당 클래스에서 선언된 모든 메소드 정보를 리턴한다.  Method getDeclaredMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 해당 클래스에서 선언된 메소드를 Method 클래스 타입으로 리턴한다.  Constructor[] getConstructors(): 해당 클래스에 선언된 모든 public 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  Constructor[] getDeclaredConstructors(): 해당 클래스에서 선언된 모든 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  int getModifiers(): 해당 클래스의 접근자(modifier) 정보를 int 타입으로 리턴한다.  String toString(): 해당 클래스 객체를 문자열로 리턴한다.Reflection APIClass 객체를 이용하면 클래스에 대한 모든 정보(클래스의 정의된 멤버의 이름이나 개수 등)를 런타임 단에서 코드 로직으로 얻을 수 있다는 것을 알았다.클래스 정보들을 실행부에서 얻을 수 있는 점은 꽤나 매력적인데, 이러한 정보들을 이용하여 오로지 Class 객체만으로 본 클래스를 인스턴스화 할 수 있고,메서드를 호출 할 수 있는 ..등 보다 동적인 코드를 작성할 수 있게 된다. 이처럼 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메소드, 타입, 변수, …)에 접근할 수 있게 해주는 자바 기법을 Reflection API 라고 부른다.자바 리플렉션(Reflection - 사전적 의미 : 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그램 기법이다.클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍을 가능케 해준다.사용법동적으로 생성자 가져와서 초기화public static void main(String[] args) throws Exception {    // 클래스 객체 가져오기 (forName 메소드 방식)    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 생성자 가져오기 - Person(String name, int age)    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); // getConstructor 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.    // 가져온 생성자로 인스턴스 만들기    Person person1 = constructor.newInstance(\"홍길동\", 55);    person1.getField(); // 이름 : 홍길동, 나이 : 55}  getConstructor() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만일 어떠한 매개변수 타입을 지정해주지 않으면 기본 생성자가 호출되게 된다.  만약 해당하는 생성자를 찾지 못하면 NoSuchMethodException이 발생된다메소드 가져와서 실행하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 특정 public 메서드 가져와 실행    // getMethod(\"메서드명\", 매개변수타입들)    Method sum = personClass.getMethod(\"sum\", int.class, int.class);    int result = (int) sum.invoke(new Person(), 10, 20);    System.out.println(\"result = \" + result); // 30    // 특정 static 메서드 가져와 실행    Method staticSum = personClass.getMethod(\"staticSum\", int.class, int.class);    int staticResult = (int) staticSum.invoke(null, 100, 200);    System.out.println(\"staticResult = \" + staticResult); // 300    // 특정 private 메서드 가져와 실행    Method privateSum = personClass.getDeclaredMethod(\"privateSum\", int.class, int.class);    privateSum.setAccessible(true); // private 이기 때문에 외부에서 access 할 수 있도록 설정    int privateResult = (int) privateSum.invoke(new Person(), 1000, 2000);    System.out.println(\"privateResult = \" + privateResult); // 3000}  getMethod() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만약 매개변수가 없는 메소드라면 메소드 명만 입력해주면 된다.  실행은 Method 타입에서 제공하는 invoke()를 호출하여 실행하면 된다.          instance 메소드 - 매개변수로 인스턴스 필요      static 메소드 - 매개변수 필요 없음      private 메소드 - invoke 하기전에 공개화 할 필요있음      동적으로 필드 가져와 조작하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // static 필드를 가져와 조작하고 출력하기    Field height_field = personClass.getField(\"height\");    height_field.set(null, 200);    System.out.println(height_field.get(null)); // 200}  getField() 를 통해 클래스의 필드를 얻을 수 있다.  필드 값 변경은 set() 메서드를 호출하면 된다.  필드는 클래스가 인스턴스가 되어야 Heap 메모리에 적재됨으로 인스턴스가 필요하다.  다만, static 필드라면 Method Area에 이미 적재되어 있으므로 인스턴스가 필요없다.",
        "url": "//2024/05/18/java-series-15.-Reflection.html"
      }
      ,
    
      "2024-05-18-java-series-14-dynamicproxy-html": {
        "title": "[java Series] 14 Dynamicproxy",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 다이나믹 프록시Dynamic Proxy자바 프로그래밍의 디자인 패터중 하나인 프록시 패턴Visit Website은 초기화 지연, 접근 제어, 로깅, 캐싱 등,기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴이다.이 디자인 패턴을 적용하면 개방 폐쇄 원칙(OCP)Visit Website의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 플러스 효과를 얻을 수 있다는 장점이 있다.하지만 프록시 디자인 패턴은 대상 원본 클래스 수만큼 일일히 프록시 클래스를 하나하나 만들어 줘야하는 치명적인 단점이 존재한다. 즉, 프록시 적용 대상 객체가 100개면 프록시 객체도 100개 만들어줘야 한다는 말이다. 따라서 코드량이 많아지게 되고 중복이 발생하여 코드의 복잡도가 증가한다는 한계점이 존재한다.바로 이러한 단점들을 보완하여 컴파일 시점이 아닌 런타임 시점에 프록시 클래스를 만들어주는 방식이 자바 가상 머신(JVM)에서 공식적으로 지원하는 동적 프록시(Dynamic Proxy) 기능이다.동적 프록시는 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의 Reflection APIVisit Website 기법을 응용한 연장선의 개념이다. 프록시 패턴의 기본 흐름은 거의 같고, 프록시를 클래스로 직접만들어서 등록하냐 이미 지원하는 api를 이용하여 동적으로 등록하느냐에 따른 차이만 있을 뿐이다.Dynamic Proxy 구성 요소newProxyInstance() Methodpublic class Proxy implements java.io.Serializable {\t// ...        public static Object newProxyInstance(        ClassLoader loader,  //클래스 로더         Class&lt;?&gt;[] interfaces,  // 타깃의 인터페이스        InvocationHandler h  // 타깃 정보가 포함된 Handler    ) throws IllegalArgumentException {        // ...    }}      ClassLoader loader프록시 클래스를 만들 클래스 로더(Class Loader)Proxy 객체가 구현할 Interface에 Class Loader를 얻어오는 것이 일반적        Class&lt;?&gt;[] interfaces프록시 클래스가 구현하고자 하는 인터페이스 목록 (배열)메서드를 통해 생성 될 Proxy 객체가 구현할 Interface를 정의한다.        InvocationHandler h프록시의 메서드(invoke)가 호출되었을때 실행되는 핸들러 메서드  InvocationHandlerInvocationHandler 인터페이스는 위에서 본 newProxyInstance() 메서드의 3번째 매개변수에 들어갈 핸들러 메서드를 정의하는 함수형 인터페이스이다.이 인터페이스 코드 구성을 보면 내부에 invoke() 라는 추상메서드 하나만 정의되어있는 걸 볼 수 있다.invoke() 메서드는 동적 프록시의 메서드가 호출되었을때, 이를 낚아채어 대신 실행되는 메서드이다. 메서드의 파라미터를 통해 어떤 메서드가 실행되었는지 메서드 정보와 메서드에 전달된 인자까지 알수있다.디자인 패턴으로 프록시를 구성하면 단점이 중복된 메서드 코드 로직이 발생한다는 점인데, 이 invoke() 메서드에 동적으로 등록함으로써 반복된 코드를 줄이게 되는 것이다.public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}  Object proxy : 프록시 객체  Method method : 호출한 메서드 정보  Object[] args : 메서드에 전달된 매개변수 (배열)예시interface AInterface {    String call();    void print();    void run();}class AImpl implements AInterface {    @Override    public String call() {        System.out.println(\"A 호출\");        return \"a\";    }    @Override    public void print() {        System.out.println(\"A print @@@@@@@\");    }    @Override    public void run() {        System.out.println(\"A Running !!!!!!!!!\");    }}public class Client {    public static void main(String[] arguments) {        AInterface proxyA = (AInterface) Proxy.newProxyInstance(                AInterface.class.getClassLoader(),                new Class[]{AInterface.class},                (proxy, method, args) -&gt; { // 람다 함수                    Object target = new AImpl();                    System.out.println(\"TimeProxy 실행\");                    long startTime = System.nanoTime();                    Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행                    long endTime = System.nanoTime();                    long resultTime = endTime - startTime;                    System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);                    return result;                }        );        proxyA.call();        proxyA.print();        proxyA.run();    }}Dynamic Proxy 제약 사항지금까지 동적 프록시 구현 및 응용을 다뤄보았다. 아주 약간의 퍼포먼스를 희생하고 자유롭게 프록시를 다이나믹하게 등록할 수 있지만,여기에 추가로 한가지 제약사항이 존재한다. 동적 프록시에 타켓을 등록할때 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 된다는 점이다.인터페이스를 기반으로 프록시를 동적으로 만들어주기 때문에, 인터페이스가 필수이기 때문이다.즉, 자바에서 newProxyInstance()를 이용해 동적 프록시 객체를 만들때 Class 기반으로는 Proxy 객체를 생성할 수 없다는 말이다. 하지만 클래스의 확장성을 고려할 필요가 없거나 한가지 책임만 분명하게 하는 경우 굳이 인터페이스를 등록해 사용하지 않는 겨우도 있다. 프록시 때문에 굳이 일일히 인터페이스를 구현해야 하는 것도 결국은 디자인 패턴의 한계점의 회귀이다.CGLIB(Code Generator Library)인터페이스가 아닌 클래스를 대상으로 바이트 코드를 조작해서 프록시 생성할 수 있는 라이브러리다.효용성을 입증 받아 스프링에 기본으로 내장돼있다.  스프링 프레임워크에서 Bean을 등록할 때 Spring AOP를 이용하여 등록을 하는데, Bean으로 등록하려는 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 Interface를 구현하고 있지 않으면 CGLIB 라이브러리를 이용한다.CGLIB 프록시CGLIB 에서는 Enhancer 객체로 프록시 객체를 만들며 MethodInterceptor 인터페이스로 프록시 핸들러를 등록한다.// 프록시 핸들러class MyProxyInterceptor implements MethodInterceptor {    private final Object target;    MyProxyInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(            Object o,            Method method,            Object[] args,            MethodProxy methodProxy    ) throws Throwable {        System.out.println(\"TimeProxy 실행\");        long startTime = System.nanoTime();        Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행        long endTime = System.nanoTime();        long resultTime = endTime - startTime;        System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);        return result;    }}// 프록시를 적용할 대상 타켓class Subject {    public void call() {        System.out.println(\"서비스 호출\");    }}public class Client {    public static void main(String[] arguments) {        // 1. 프록시 등록 (CGLIB는 Enhancer를 사용해서 프록시를 등록한다)        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Subject.class); // CGLIB는 구체 클래스를 상속 받아서 프록시를 생성하기 때문에 상혹할 구체 클래스를 지정        enhancer.setCallback(new MyProxyInterceptor(new Subject())); // 프록시 핸들러 할당        // 2. 프록시 생성        Subject proxy = (Subject) enhancer.create(); // setSuperclass() 에서 지정한 클래스를 상속 받아서 프록시가 만들어진다.        // 3. 프록시 호출        proxy.call();    }}람다로?public class Client {    public static void main(String[] arguments) {                Subject proxy = (Subject) Enhancer.create(Subject.class, (MethodInterceptor) (o, method, args, methodProxy) -&gt; {            Subject target = new Subject();            System.out.println(\"TimeProxy 실행\");            long startTime = System.nanoTime();            Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행            long endTime = System.nanoTime();            long resultTime = endTime - startTime;            System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);            return result;        });                proxy.call();    }}주의사항이렇게 보면 인터페이스 기반일 때는 Dynamic Proxy를 사용하고, 클래스 기반일 때는 CGLIB를 사용하면 되겠지만, 이 라이브러리도 제약사항이 존재한다.우선 CGLIB는 기본적으로 클래스 상속(extends)을 통해 프록시 구현이 되기 때문에, 타겟 클래스가 상속이 불가능할때는 당연히 프록시 등록이 불가능하다. 또한 메서드에 final 키워드가 붙게되면 그 메서드를 오버라이딩하여 사용 할수 없게되어 결과적으로 프록시 메서드 로직이 작동되지 않는다.정리하자면 프록시 대상 객체는 상속에 있어 제한이 있으면 안된다는 것이다.  클래스와 메소드에 final 키워드 적용  추상 클래스(abstract class)  클래스의 생성자를 private화 하여 생성자를 제한할 경우",
        "url": "//2024/05/18/java-series-14-DynamicProxy.html"
      }
      ,
    
      "2024-05-18-java-series-13-serialize-deserialize-html": {
        "title": "[java Series] 13 Serialize_deserialize",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 직렬화 역직렬화Serialize &amp; Deserialize직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes)형태로 연속적인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다. 그 반대 개념인 역직렬화는(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다.이를 시스템적으로 살펴보면, JVM의 힙(heap) 혹은 스택(stack) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여데이터베이스나 파일과 같은 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역질렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.직렬화 사용처  서블릿 세션          단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 만일 세션 데이터를 저장 &amp; 공유가 필요할때 직렬화를 이용한다.      세션 데이터를 데이터베이스에 저장할때      톰캣의 세션 클러스터링Visit Website을 통해 각 서버간에 데이터 공유가 필요할때        캐시          데이터베이스로부터 조회한 객체 데이터를 다른 모듈에서도 필요할때 재차 DB를 조회하는 것이 아닌, 객체를 직렬화하여 메모리나 외부 파일에 저장해 두었다가 역직렬화하여 사용하는 캐시 데이터로서 이용이 가능하다.      물론 자바 직렬화를 이용해서만 캐시를 저장할 수 있는 것은 아니지만 자바 시스템에서 만큼은 구현이 가장 간편하기 때문에 많이 사용된다고 보면 된다.      단, 요즘은 Redis, Memcached 와 같은 캐시 DBVisit Website를 많이 사용하는 편이다.        Remote Method Invocation          자바 RMI는 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.      이 메세지에 객체 데이터를 직렬화하여 송신하는 것이다.      최근에는 소켓을 이용하기 때문에 안쓰이는 기술이다.      직렬화 vs. JSON자바 직렬화의 장점  직렬화는 자바의 고유 기술인 만큼 당연히 자바 시스템에서 개발에 최적화되어 있다.  자바의 광활한 레퍼런스 타입에 대해 제약 없이 외부에 내보낼 수 있다는 것이다.사실 그 외에는 JSON이 훨씬 낫다.직렬화 방법  Serialize 구현Serializable 인터페이스는 아무런 내용도 없는 마커 인터페이스Visit Website 로서, 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준으로 사용된다.  ObjectOutputStream 객체 직렬화직렬화(스트림에 객체를 출력) 에는 ObjectOutputStream을 사용한다.객체가 직렬화될때 오직 객체의 인스턴스 필드값 만을 저장한다. static 필드나 메서드는 직렬화하여 저장하지 않는다직렬화 요소의 제외  transient 키워드    class Customer implements Serializable { int id;  String name;  transient String password; // 직렬화 대상에서 제외 int age;  public Customer(int id, String name, String password, int age) {     this.id = id;     this.name = name;     this.password = password;     this.age = age; }     ...}        readObject / writeObject 재정의직렬화 &amp; 역직렬화할때 호출되는 readObject() 와 writeObject() 는 기본적으로 모든 요소에 대해 자동 직렬화 한다. 그런데 이 메서드들을 직렬화할 클래스에 별도로 재정의 해주면 직렬화를 선택적으로 조작할 수 있게 된다. 이를 커스텀 직렬화 라고도 불리운다.class Customer implements Serializable {    int id; // 고객 아이디    String name; // 고객 닉네임    String password; // 고객 비밀번호    int age; // 고객 나이    public Customer(int id, String name, String password, int age) {        this.id = id;        this.name = name;        this.password = password;        this.age = age;    }    // 직렬화 동작 재정의    private void writeObject(ObjectOutputStream out) throws IOException{        out.writeInt(id);        out.writeObject(name);        out.writeInt(age);    }    // 역직렬화 동작 재정의    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{        this.id = in.readInt();        this.name = (String) in.readObject();        this.age = in.readInt();    }    @Override    public String toString() {        return \"Customer{\" +                \"id=\" + id +                \", password='\" + password + '\\'' +                \", name='\" + name + '\\'' +                \", age=\" + age +                '}';    }}  상속 관계에서 직렬화만약 부모-자식 상속 관계에서 부모 클래스가 Serializable을 구현했다면 자식 클래스는 Serializable을 구현하지 않아도 직렬화가 가능하다. 그러면 반대로 부모 클래스는 Serializable을 구현하지 않고 자식 클래스만 구현했다면 어떤 방식으로 직렬화될까?직렬화할때 부모 클래스의 인스턴스 필드는 무시되고 자식 필드만 직렬화가 된다. 따라서 상위 클래스의 필드까지 직렬화하려면 부모 클래스가 Serializable을 구현하도록 설정하던지,위에서 다뤄본 writeObject / readObject 메서드를 재정의하여 직접 직렬화 코드를 추가 하면 된다.직렬화 버전 관리      SerialVersionUIDSerializable 인터페이스를 구현하는 모든 직렬화된 클래스는 serialVersionUID(이하 SUID) 이라는 고유 식별번호를 부여 받는다. 이 식별 ID는 클래스를 직렬화, 역직렬화 과정에서 동일한 특성을 갖는지 확인하는데 사용된다. 그래서 클래스 내부 구성이 수정될 경우, 기존에 직렬화한 SUID와 현재 클래스의 SUID 버전이 다르기 때문에 이를 인지하고 InvalidClassException 예외가 발생시켜 값 불일치 되는 현상을 미연에 방지한다.단, 직렬화 스펙 상 serialVersionUID 값 명시는 필수가 아니며, 만일 클래스에 SUID 필드를 명시하지 않는다면, 시스템이 런타임에 클래스의 이름, 생성자 등과 같이 클래스의 구조를 이용해 암호 해시함수를 적용해 자동으로 클래스 안에 생성하게 된다.        수동 버전 관리만일 네트워크로 객체를 직렬화하여 전송하거나 협업을 하는 경우 수신자와 송신자 모두 같은 버전의 클래스를 가지고 있어야 할텐데, 만일 클래스가 조금만 변경사항이 있으면 모든 사용자에게 재배포해야 하는 애로사항이 생겨 프로그램을 관리하기 어렵게 만든다.  따라서 직렬화 클래스는 왠만한 상황에선 serialVersionUID 를 직접 명시해주어 클래스 버전을 수동으로 관리하는 것을 권장하는 편이다.SUID를 직접 명시해주면 클래스의 내용이 변경되어도, 클래스의 버전이 시스템이 자동 생성된 값으로 변경되지 않기 때문이다. 이외에도 런타임에 SUID를 생성하는 시간도 많이 잡아먹기 때문에 미리 명시를 강력히 권장되는 바이다.  SerialVersionUID 수동 관리 유의사항  클래스 serialVersionUID를 명시하더라도 절대 만능이 아니다. 위와 같이 단순히 필드 변수 하나 추가하는 정도는 문제가 없겠지만 필드 타입을 변경하는 상황에서는 버전 수동 관리를 하여도 예외를 막을순 없다.직렬화 예외  InvalidClassException  NotSerializableException직렬화의 단점  용량이 크다. (메타 정보를 모두 가지고 있다.)  역직렬화 과정에서 공격당할 위험이 있다.  릴리즈 후 수정이 어렵다.  클래스 캡슐화가 깨진다.  버그와 보안에 취약하다.",
        "url": "//2024/05/18/java-series-13-Serialize_Deserialize.html"
      }
      ,
    
      "2024-05-18-java-series-12-brokensingleton-html": {
        "title": "[java Series] 12 Brokensingleton",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Singleton과 훼손Singleton싱글톤은 기본적으로 단 하나의 유일한 객체를 의미한다.역직렬화에 의한 싱글톤 훼손자바의 직렬화(Serialize)는 JVM의 힙 메모리에 있는 객체 데이터를 바이트 스트림(byte stream) 형태로 바꿔 외부 파일로 내보낼수 있게 하는 기술을 말한다. 반대로 외부로 내보낸 직렬화 데이터를 다시 읽어들여 자바 객체로 재변환하는 것을 역직렬화(Deserialize) 라 한다.직렬화하여 내보낸 외부 파일은 데이터베이스에 저장되기도 하며 네트워크를 통해 전송되기도 한다. 이 직렬화를 적용하기 위해선 클래스에 Serializable 인터페이스를 implements 하면 된다.그런데 만일 어떤 클래스를 직렬화하여 다른 컴퓨터에 전송하려는데, 이 클래스를 싱글톤으로 구성하려고 한다. 하지만 이 싱글톤 클래스는 송신자가 파일을 받고 역직렬화시 깨지게 되어 더이상 싱글톤이 아니게 된다.이러한 현상이 생기는 이유는 역직렬화 자체가 보이지 않은 생성자로서 역할을 수행하기 때문에 인스턴스를 또다시 만들어, 직렬화에 사용한 인스턴스와는 전혀 다른 인스턴스가 되기 때문에 일어나는 것이다. 따라서 클래스에 Serializable을 구현하면 더 이상 이 클래스는 싱글톤이 아니게 되어 메모리 이점을 더이상 얻을수 없게 된다.훼손 대응 방안이러한 싱글톤의 역직렬화의 대응 방안으로 직렬화 관련 메서드인 readResolve() 를 정의하면 된다.readResolve 메서드를 정의하게 되면, 역직렬화 과정에서 readObject를 통해 만들어진 인스턴스 대신 readResolve에서 반환되는 인스턴스를 내가 원하는 것으로 바꿀 수 있기 때문이다. 그리고 기존에 역직렬화를 통해 새로 생성된 객체는 알아서 Garbage CollectorVisit Website의 대상이 된다.class Singleton implements Serializable {    private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    // 역직렬화한 객체는 무시하고 클래스 초기화 때 만들어진 인스턴스를 반환    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}이때 싱글턴 인스턴스의 직렬화 결과에는 아무런 실 데이터를 가질 이유가 없기 때문에, 싱글톤 클래스에 필드 변수들이 있을 경우 모든 인스턴스 필드를 transient로 선언한다. 아무리 readResolve 메서드라도 역직렬화 과정 중간에 역직렬화된 인스턴스의 참조를 훔쳐오는 공격을 행할경우 다른 객체로 바뀔 위험이 있기 때문이다.class Singleton implements Serializable {    // 싱글톤 객체의 필드들을 transient 설정하여 직렬화 제외    transient String str = \"\";    transient ArrayList lists = new ArrayList();    transient Integer[] integers;        private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}리플렉션에 의한 싱글톤 훼손자바 리플렉션(Reflection - 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 조작하는 프로그램 기법이다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고 객체를 생성하는 것 또한 가능하게 해준다.이러한 리플렉션 기법은 프레임워크, 라이브러리에서 많이 사용된다. 왜냐하면 프레임워크, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버들을 구성할지 모르는데, 이러한 사용자 클래스들을 기존의 기능과 동적으로 연결 시키기 위하서 이다. 이미 Spring, Lombok 등 많은 프레임워크에서 리플렉션 기능을 사용하고 있다.그런데 문제는 리플렉션을 통해 싱글톤 객체를 생성하게 되면 다른 객체를 반환해 싱글톤이 다시 한번 깨지는 것이다. 클래스 객체를 통해 해당 객체의 생성자를 받아와 newInstance() 메서드를 실행하면 인스턴스를 생성할 수 있게 되는데, 여기서 생성된 인스턴스는 Holder가 가지고 있는 인스턴스와는 전혀 다른 새로운 인스턴스이기 때문이다.",
        "url": "//2024/05/18/java-series-12-BrokenSingleton.html"
      }
      ,
    
      "2024-05-18-java-series-11-heappollution-html": {
        "title": "[java Series] 11 Heappollution",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 힙 오염Heap Pollution힙 오염은 JVM의 Heap 메모리 영역에 저장되어 있는 특정 변수가 불량 데이터를 참조함으로써, 만일 힙에서 데이터를가져오려고 할 때 얘기치 못한 런타임 에러가 발생할 수 있는 오염 상태를 의미한다.힙 오염의 대표 이유는 Generic이다.Generic collection은 이전 버전과의 호환성을 위해서 Compile 때 Generic을 Object으로 변환하거나 제거함으로써 하위 호환을 했다.  제네릭 타입 소거(Erasure)  제네릭은 type-safe하며 실행 시간 오버헤드를 줄이기 위해서 도입된 문법으로, 이전 자바에서 제네릭 타입 파라미터가 없던 탓에 호환성을 위해서제네릭은 컴파일되면 제네릭 타입은 사라졌다. 즉, .class에는 제네릭 정보가 존재하지 않았다.  컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거하기 때문에 잠재적 힙 오염 문제에 빠질 수 있게 됐다.  Reifiable, Non-Reifiable  실체화 타입(Reifiable Type)이란 컴파일 단계에서 타입 소거에 의해 지워지지 않는 타입 정보를 말한다.      int, double, float, byte 등 원시 타입    Number, Integer 등 일반 클래스와 인터페이스 타입    List, ArrayList, Map 등 자체(Raw Type)    List&lt;?&gt;, ArrayList&lt;?&gt; 등 비한정 와일드 카드가 포함된 매개변수화 타입 (와일드 카드 &lt;?&gt; 는 애초에 타입 정보가 명시되지 않았으므로 타입 소거를 해도 별 문제가 없다. 컴파일 타임에 Object로 변환 됨)    비실체화 타입(Non-Reifiable Type) 컴파일 단계에서 타입 소거에 의해서 타입 정보가 제거된 타입을 의미한다. 제네릭 타입 파라미터는 모두 제거된다.      List, List    List, ArrayList    List&lt;? extends Number&gt;, List&lt;? super String&gt;    제네릭 소거 과정  컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 필요한 곳에 형 변환을 넣고 최종적으로 컴파일 코드에 Type Erasure로 제네릭 타입을 제거하게 된다.      제네릭 타입의 경계(bound)를 제거              제네릭  -&gt; T는 Number로 치환                  는 Object로 치환```java// T extends Type -&gt; Type /* 치환 전 */class Box {List list = new ArrayList&lt;&gt;();                    void add(T item) {    list.add(item); }      T getValue(int i) {     return list.get(i); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);} } ```              제네릭 타입을 제거한 후 타입이 일치하지 않는 곳은 형 변환을 추가한다.```java/* 치환 전 */class Box { List list = new ArrayList(); // Object      void add(Number item) {     list.add(item); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);}Number getValue(int i) {    return (Number) list.get(i); // 캐스팅 연산자 추가} } ``` 3. 소거는 똑같이 진행 ```java // T -&gt; Object /* 치환 전 */ public static &lt;T&gt; int count(T[] anArray, T elem) {int cnt = 0;for (T e : anArray)    if (e.equals(elem))        ++cnt;    return cnt; }    /* 치환 후 */public static int count(Object[] anArray, Object elem) {    int cnt = 0;    for (Object e : anArray)        if (e.equals(elem))            ++cnt;        return cnt;}```  Bridge 메소드  컴파일러는 확장된 제네릭 타입에 대해서 타입 소거를 해도 다형성 보존을 위해서 별도의 bridge method를 생성한다.제네릭 힙 오염  원시 타입과 매개변수 타입을 동시에 사용하는 경우  확인되지 않은 형 변환을 수행하는 경우//ClassCastException 발생 예정ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"A\");list1.add(\"B\");Object obj = list1; //상위 타입 Object로 변경ArrayList&lt;Double&gt; list2 = (ArrayList&lt;Double&gt;) obj; //DownCastlist2.add(1.0);list2.add(2.0);System.out.println(list2); // [홍길동, 임꺾정, 1.0, 2.0]for(double n : list2) {    System.out.println(n);}컴파일러는 위의 코드에 대해서 컴파일 에러를 내지 않는다. 이는 제네릭 타입 소거에 의해서 나타나는 문제다.1. 컴파일러는 타입 캐스팅을 검사하지 않는다.-&gt; 컴파일러는 형변환 대상 객체에 대해서 검사하지 않는다. 정확히 말하면 캐스팅 했을 때 대입되는 변수에 저장할 수 있느냐만 검사한다.2. 제네릭 타입이 소거되면 결국 Object-&gt; 컴파일되면서 결국 제네릭은 Object가 된다. 결국 위 예시는 RawType이 되면서 어떤 정보든 저장할 수 있게 되면서 컴파일 에러가 나지 않는다.제네릭 힙 오염 방지책자바에서 Collections 클래스의 checkList() 메소드를 지원한다 해당 객체에 대해서 의도치 않은 타입의 데이터가 들어갔을 때 이를 감지하여 예외를 발생시킨다. https://inpa.tistory.com/entry/JAVA-☕-제네릭-타입-소거-컴파일-과정-알아보기 ",
        "url": "//2024/05/18/java-series-11-HeapPollution.html"
      }
      ,
    
      "2024-05-18-java-series-10-equalsandhashcode-html": {
        "title": "[java Series] 10 Equalsandhashcode",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Equals And Hash CodeEqualsAndHashCodeEquals어떤 참조 변수의 값이 같은지 다른지 동등 비교를 할 때 사용비교할 대상이 객체면 주소 값을 비교한다.override Equals기본적으로 참조형은 주소 값을 비교한다. 아무래 내부 필드가 같아도 엄연히 다른 주소 값이다. 그래서 Java에서는 필드 값을 비교하도록 오버라이드 해서 주소 값 비교를 우회한다.HashCode객체 주소 값을 해싱해서 해시코드를 만든 후 반환한다.(객체의 지문과 같다.)엄밀히 말하면 주소 값으로 만든 고유한 숫자 값이다.override Hashcode만약 Equals만 오버라이드하면 에러를 낸다. java는 equals를 오버라이드하면 당연히 hashcode도 객체의 필드를 다루도록 오버라이드 하도록 한다.왜냐하면 equals()의 결과가 true면 두 객체의 해시코드는 반드시 같아야 한다는 자바의 규칙때문이다.이렇게 강요하는 이유는 hash 값을 사용하는 CollectionFrameWork 사용에 문제가 발생하기 때문이다.ex) setEquals and Hashcode 동작 순서?https://inpa.tistory.com/entry/JAVA-☕-equals-hashCode-메서드-개념-활용-파헤치기1. HashCode는 고유하지 않다.보통 해싱 알고리즘은 서로 다른 주소를 가진 경우 같은 해시코드를 가질 여지가 없다. 64bit(8바이트) 주소값을 hashCode로 이용해서 반환하면4바이트(32bit)로 강제 캐스팅 되기 때문에 값이 겹칠 수도 있다. 즉 서로 다른 객체라도 같은 해시코드를 반환할 수 있다. 2. 해결책@EqualsAndHashCode에서 볼 수 있듯 equals로 두 객체의 진짜 주소를 직접 비교하는 식으로 극복한다.진짜 주소 값이 필요할때?hashcode() 오버라이드 시 비교 대상 객체가 같은지 아닌지를 판별할 수 있다. 그런데, 오버라이드 해버리면 객체 자체의 주소 값(해시코드)가 필요할 때 난감해진다.그래서 identityHashCode()라는 메소드를 제공한다.",
        "url": "//2024/05/18/java-series-10-EqualsAndHashCode.html"
      }
      ,
    
      "2024-05-18-java-series-09-innerclassproblem-html": {
        "title": "[java Series] 09 Innerclassproblem",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Inner class에서의 문제점Inner Class ProblemInner Class를 선언하면 Inner Class를 static으로 설정하라고 경고한다.이는 Inner Class가 Inner static 보다 메모리를 더 많이 쓰고, 느리고, 바깥 클래스가 GC 대상에서 빠져 메모리 관리에 문제가 될 수 있다.Inner class는 외부 참조를 한다.일반적으로 내부 클래스를 만들기 위해서는 외부 클래스를 초기화 해야한다. 이러한 문제 때문에 inner 클래스는 외부 참조를 갖게 된다. 심지어 내부 클래스가 외부 멤버를사용하지 않아도 숨겨진 외부 참조가 생성된다.public class Outer_Class {    int field = 10;    class Inner_Class {        int inner_field = 20;    }}// Outer_class$Inner_class.class// Outer_class.class// 바이트 코드를 디컴파일하면class Outer_Class$Inner_Class {    int inner_field;        Outer_Class$Inner_Class(Outer_Class this$0) { //생성자로 외부 클래스를 매개 변수로 받아서 초기화        this.this$0 = this$0;        this.inner_field = 20;    }}// 즉 바깥 클래스의 인스턴스와 암묵적으로 연결Inner 클래스의 메모리 누수Inner 클래스가 바깥 클래스를 외부 참조하므로 외부 클래스는 필요가 없고 내부 클래스만 남아있을 경우, 외부 참조로 내부 클래스와연결되어 있기 때문에 메모리에 잔존하고 누수로 이어진다.해결법은 static  static inner는 외부 참조가 없다.  static inner는 메모리 누수가 없다.",
        "url": "//2024/05/18/java-series-09-InnerClassProblem.html"
      }
      ,
    
      "2024-05-18-java-series-08-callby-html": {
        "title": "[java Series] 08 Callby",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CallByCall By Value vs. Call By Reference프로그래밍을 하다보면 반드시 마주치는 것이 바로 call by value / call by reference 개념이다.함수의 매개변수에서 값을 복사하느냐 주소값을 참조하느냐에 따라 반환 결과가 달라지기 때문에 대부분의 프로그래밍 교육과정에선 중요시 하게 여긴다.자바에서도 역시 call by value 와 call by reference 동작 차이가 존재한다.자바의 데이터형을 알아보면 크게 두가지로 나뉘게 된다.  기본형(primitive type) - Boolean Type(boolean), Numeric Type(short, int, long, float, double, char)  참조형(reference type) - Class Type, Interface Type, Array Type, Enum Type, 기본형을 제외한 모든 것들",
        "url": "//2024/05/18/java-series-08-CallBy.html"
      }
      ,
    
      "2024-05-18-java-series-07-tuning-html": {
        "title": "[java Series] 07 Tuning",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TuningGC Tuning주의점  GC 옵션은 서비스 특징마다 적정 값이 다르다.  GC 튜닝은 최후의 수단이다. (코드 최적화가 우선이다.)목표  Old로 넘어가는 객체의 수 최소화 하기Old는 Young에서 GC보다 시간이 오래 소요된다. 따라서 Old로 넘어가는 수를 줄이면 Full GC가 줄어든다.이는 Young size를 잘 조절하는 것만으로 Old로 넘어가는 것을 줄이고 이 자체로 튜닝이 된다는 것이다.  Full GC 시간 줄이기Full GC 실행 시간은 Minor GC에 비해 길다. 그러므로 Old 사이즈를 조정하는 것도 방법이다. 그렇다고 너무 줄이면 OutOfMemoryError가 발생하거나 FUll GC가 자주 발생할 수 있다. 반대로 너무 Old를 늘리면 FullGC는 줄지만 실행 시간이 늘어날 수 있다.튜닝 진행1. GC 상황 모니터링# jstat gcutil  명령어로 현재 실행중인 8884번 프로세스에 대해 1초에 한번 씩 총 10번 GC와 관련된 정보를 출력하도록 모니터링jstat -gcutil -t 8844 1000 0            컬럼      설명                  S0      Survivor 영역 0의 사용율(현재 용량에 대한 비율)              S1      Survivor 영역 1의 사용율(현재 용량에 대한 비율)              E      Eden 영역의 사용율 (현재 용량에 대한 비율)              O      Old 영역의 사용율 (현재 용량에 대한 비율)              P      Permanent 영역의 사용율 (현재 용량에 대한 비율)              YGC      Young 세대의 GC 이벤트 수              YGCT      Young 세대의 GC 시간              FGC      Full GC 이벤트 수              FGCT      Full GC 시간              GCT      GC 총 시간      2. 모니터링 결과 분석 후 GC 튜닝 여부 결정  Minor GC 수행시간: YGCT / YGC (0.314 / 19) = 0.016초  Major GC 수행 시간: FGCT / FGC (0.291 / 3) = 0.097초# Minor GC의 처리 시간이 빠르다 (50ms 내외)# Minor GC의 주기가 빈번하지 않다 (10초 내외)# Full GC의 처리 시간이 빠르다 (1초 내외)# Full GC의 주기가 빈번하지 않다 (10분에 1회)3. GC 알고리즘 방식 지정            GC 알고리즘      내용                  Parallel GC      - ‘처리량’이 중요한 시스템에서 주로 사용 - Full GC 수행 시 compaction 작업이 수행되기 때문에 GC 시간 자체는 많이 소요되나 일정한 멈춤 시간을 제공함              CMS GC      - 응답시간이 중용한 시스템에사 주로 사용  - compaction 미수행으로 Stop-The-World 시간은 짧으나 자주 Compaction이 발생하는 시스템의 경우 오히려 Full GC 보다 Compation 시간이 오래 걸릴 수 있음  - 자원 사용량이 증가하는 점도 고려해야 함              G1 GC      - 성능적으로 가장 우수한 GC 방식이나, JDK 7 버전부터 정식 제공되었으며, Java 9 에서 Default GC 방식으로 채택      4. Heap 크기 지정JVM의 힙 크기는 GC 발생 횟수와 수행 시간에 영향을 끼치기 떄문에 옵션을 통해 조절하면 애플리케이션의 성능 향상을 가져올 수 있다. 메모리 크기는 JVM의 시작 크기 -Xms 최대 크기 -Xmx를 말한다.메모리 크기와 GC 발생 횟수, GC 수행 시간 관계는 아래와 같다.  메모리 크기가 크면          GC 발생 횟수가 감소      GC 수행 시간은 길어진다.        메모리 크기가 작으면          GC 발생 횟수는 증가한다.      GC 수행 시간은 짧아진다.                  구분      옵션      설명                  힙(heap) 영역 크기      -Xms      JVM 시작 시 힙 영역 크기              힙(heap) 영역 크기      -Xmx      최대 힙 영역 크기              New 영역의 크기      -XX:NewRatio      New 영역과 Old 영역의 비율              New 영역의 크기      -XX:NewSize      New 영역의 크기              New 영역의 크기      -XX:SurvivorRatio      Eden 영역과 Survivor 영역의 비율      # 이 중에서 중요한 옵션은 -Xms 옵션, -Xmx 옵션, -XX:NewRatio 옵션이다.# 특히 -Xms 옵션과 -Xmx 옵션은 왠만하면 필수로 지정하길 권장되며, 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.# # NewRatio는 New 영역과 Old 영역의 비율이다. # -XX:+NewRatio=1로 지정하면 (New 영역):(Old 영역)의 비율은 1:1이 된다. # 만약 1GB라면 (New 영역):(Old 영역)은 500MB:500MB가 된다. # NewRatio가 2이면 (New 영역):(Old 영역)이 1:2가 된다. # 즉, 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.# 힙 시작 크기 256mb, 힙 최대 크기 2gb# young 영역과 old 영역 비율 1:2 로 설정 (New 영역:Old 영역 = 1:2)# Parallel GC 로 실행java -Xms256m -Xmx2048m -XX:+NewRatio=2 -XX:+UseParallelGC5. 결과 분석분석할 때는 다음의 사항을 중심으로 살펴보는 것이 좋다. 이는 우선 순위 별로 나열되어 있다.  FullGC 수행 시간  MinorGC 수행 시간  Full GC 수행 간격  MinorGC 수행 간격  전체 Full GC 수행 시간  전체 Minor GC 수행 시간  전체 GC 수행 시간  Full GC 수행 횟수  Minor GC 수행 횟수",
        "url": "//2024/05/18/java-series-07-Tuning.html"
      }
      ,
    
      "2024-05-18-java-series-06-gc-algorithm-html": {
        "title": "[java Series] 06 Gc_algorithm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GC Algorithm가비지 컬렉션 알고리즘1. Serial GC  서버의 CPU 코어가 1개일 때 사용하기 위해서 개발된 GC  GC 처리하는 쓰레드가 1개라서 STW가 길다.  MinorGC에서는 Mark-Sweep, MajorGC에서는 Mark-Sweep-Compactjava -XX:+UseSerialGC -jar Application.java2. Parallel GC  Java 8의 Default  Serial GC와 기본 알고리즈은 같지만 Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old는 Single)  Serial GC에 비해서 STW가 줄어java -XX:+UseParallelGC -jar Application.java # -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수3. Parallel Old GC(Parallel Compacting Collector)  Parallel GC를 개선한 버전  Young, Old도 멀티 GC  새로운 GC 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old도 Multi)java -XX:+UseParallelOldGC -jar Application.java# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수4. CMS GC (Concurrent Mark Sweep)  어플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되어 STW를 최대한 줄이기 위래서 고안된 GC  GC 과정이 매우 복잡  GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다.  메모리 파편화 문제  CMS GC는 Java9부터 deprecated, Java14에는 중지됨# deprecated in java9 and finally dropped in java14java -XX:+UseConcMarkSweepGC -jar Application.java5. G1 GC (Garbage First)  GMC GC를 대체하기 위해서 Java 7에서 최초로 release  Java 9+의 디폴트 GC  4GB 이상의 Heap, STW이 0.5 이상이될 때 사용 (Heap이 너무 작으면 미사용 권장)  기존의 GC에서는 HEAP 영역을 물리적으로 고정된 Young/ Old로 나눴지만 G1은 Region을 도입. Eden, Survivor, Old를 고정이 아닌 동적으로 부여  Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 식java -XX:+UseG1GC -jar Application.java6. Shenandoah GC  Java 12에 release  RedHat에서 개발  기존 GMS가 가진 단편과, G1이 가진 pause 이슈를 해결  강력한 Concurrency와 가벼운 GC 로직으로 Heap 사이즈에 영향을 받지 않고 일정한 Pause 시간 소요가 특징java -XX:+UseShenandoahGC -jar Application.java7. ZGC( Z Garbage Collector )  Java 15에 release  대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해서 디자인된 GC  G1의 Region처럼 ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정이지만 ZPage는 2mb 배수로 운영됨  ZGC가 내세우는 최대 장점은 힙 크기가 증가해도 STW가 절대로 10ms를 넘지 않는다.java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java",
        "url": "//2024/05/18/java-series-06-GC_Algorithm.html"
      }
      ,
    
      "2024-05-18-java-series-05-gc-html": {
        "title": "[java Series] 05 Gc",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GCGC자바의 메모리 관리 방법 중 하나로 JVM의 HEAP 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스(C/C++ 은 수동으로 메모리 할당, 해제를 해야했다.)1. 대상판단 근거로 도달성, 도달능력(Reachability)라는 개념을 적용한다. 객체에 레퍼런스가 있다면 Reachable[1], 객체에 유효한 레퍼런스가 없으면 UnReachable[2]로 구분한다.주로 Heap Area에서 참조하고 있지 않은 객체가 GC 대상이 된다.청소 방식Mark And SweepGC가 동작하는 가장 기초적인 청소 과정.GC 대상이 될 객체를 식별(Mark), 제거(Sweep)하며 객체가 제거되며 파편화된 메모리를 영역 앞에서부터 채워나가는 작업을 수행한다.  Mark : Root Space부터 그래프 순회를 통해서 연결되나 객체를 찾아서 각각 어떤 객체를 참조하고 있는지 마킹  Sweep : Unreachable를 Heap에서 제거한다.  Compact : Heap의 시작 주소를 모아 메모리가 할당된 부분과 아닌 부분으로 압축한다. (GC 종류에 따라 하지 않는 경우도 있음 )GC 동작 과정Heap은 동적으로 레퍼런스 데이터가 저장되는 공간으로 GC 대상이 되는 공간이다. Heap은 아래 2가지를 전제(Weak Generational Hypothesis)로 설계됐다.  대부분 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.  오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.즉, 객체는 대부분 일회성, 메모리에 오랫동안 남을 경우는 드물다는 것이다.   Young          새롭게 객체가 할당되는 영역      대부분 객체가 금방 Unreachalbe이 되므로 Young에 생성됐다 사라짐      Young에 대한 GC를 Minor GC라고 부름        Old          Young에서 Reachable을 유지하면 복사되는 영역      Young보다 크게 할당됨. 크기가 큰 만큼 가비지는 적게 발생      Old에 대한 GC를 Full GC라고 부름        Eden          new를 통해 생성된 위치      정기적 쓰레기 수집 후 살아남으면 Survivor로 보냄        Survivor 0/ 1          최소 1 번 이상의 GC에서 살아남은 객체가 존재하는 영역      Survivor 0, 1 중 하나는 꼭 비어 있다.      MinorGCYoung은 Old에 비해서 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다.  처음 생성된 객체는 Young 영역의 Eden에 위치  Eden이 꽉차면 MinorGC 발생          Obj MarK로 Reachable 탐색      살아 남은 Obj Survivor로 이동      Eden의 unreachable gowp      살아남은 모든 객체 age[3] += 1      Eden이 가득 차면 비어있는 Survivor로 Eden, 기존 Survivor 내용들 이동      옮긴 Survivor 내역들 age += 1      MajorGCOld는 길게 살아남은 메모리들이 존재하는 공간. age 임계 값을 초과해서 이동되는 녀석 가끔 Young에 담을 수 없을 정도로 크면 Old로 보내기도 함그리고 MajorGC는 객체들이 계속 Promotion되어 Old가 부족해지면 발생MinorGC vs. MajorGC            GC Type      MinorGC      MajorGC                  대상      Young      Old              실행 시점      Eden이 꽉 차면      Old가 꽉차면              실행 속도      빠르다      느리다      MajorGC는 old가 꽉 차면 Unreachable을 한꺼번에 삭제하는 MajorGC가 실행된다. Young은 크기가 작기에 빠르지만 Old는 크기에 보통 10배 이상의 시간을 사용한다.또한  STOP-THE-WORLD 가 발생한다. 이 때 Thread가 멈추고 Mark and Sweep을 하므로 일시적으로 멈추기 때문[1] : 객체가 참조되고 있는 상태[2] : 객체가 참조되고 있지 않은 상태 (GC 대상)[3] : Survivor 영역에서 객체가 살아남은 횟수. Object Header에 기록 age가 임계 값에 다다르면 Promotion( Old로 이동 여부를 결정. 기본 임계값은 31)",
        "url": "//2024/05/18/java-series-05-GC.html"
      }
      ,
    
      "2024-05-18-java-series-04-jni-html": {
        "title": "[java Series] 04 Jni",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JNIJNI(Java Native Interface)자바 네이티브 인터페이스는 JVM위에서 실행되고 있는 자바 코드가 네이티브 응용 프로그램(하드웨어, 운영체제 플랫폼에 종속된 프로그램들), C, C++, 어셈블리 같은 다른 언어들로작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크1. 네이티브 메소드Java는 메소드 구현이 네이티브 코드에서 제공될 것임을 나타내는 데 사용되는 네이티브 키워드를 제공한다. 일반적으로 네이티브 실행 프로그램을 만들 때 정적 또는 공유 라이브러리를 사용할 수 있다.2. 예약어  native: 다른 언어에서 사요할 수 있게 해주는 키워드  volatile: Thread safe를 하게 해주는 키워드  strictfp: 자바와 타 플랫폼 간 부동소수점 정밀도를 맞추기 위한 키워드  assert: 인자로 주어진 값이 참인지 거짓인지 판별하는 메소드",
        "url": "//2024/05/18/java-series-04-JNI.html"
      }
      ,
    
      "2024-05-18-java-series-03-memory-html": {
        "title": "[java Series] 03 Memory",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - memoryMemory (Runtime Data Area)  Method(static) 영역  Stack 영역  Heap 영역1. 자바 변수 종류  클래스 변수: 클래스 영역에서 static이 붙는 변수 - 클래스가 메모리에 올라갈 떄  인스턴스 변수: static이 나닌 변수 (참조 없을 경우 gc 대상) - 인스턴스가 생성될 때  지역 변수: 메소드 내에서 선언, 메소드가 끝나면 소멸 - 해당 메소드가 실행될 때  매개 변수: 메소드 호출 시 전달하는 값 - 해당 메소드가 실행될 때2. Method(Static) 영역 ( == Class area, Static area)  JVM이 동작해서 클래스가 로딩될 때 생성      JVM이 읽어들인 클래스와 인터페이스에 대한 정보(멤버 변수, 런타임 상수 풀, 생성자, 메소드 등)와 함께 클래스 변수(static variable)가 저장되는 영역    ↳ Field Information: 멤버 변수의 이름, 데이터 타입, 접근 제어자에 대한 정보    ↳ Method Information: 메소드 이름, 리턴 타입, 매개변수, 접근제어자에 대한 정보    ↳ Type Information: class인지 interface인지 여부 저장, 전체 이름, super의 이름(interface, object인 경우 Heap에서 관리)    Method(Static) 영역에 있는 것은 어느 곳에서나 접근 가능  Method(Static) 영역에 있는 데이터는 프로그램 시작 ~ 종료까지 메모리에 남아 있다.2.1 Runtime Constant Poolstatic 영역에 존재하는 별도 관리 영역 상수 자료형을 저장하여 참조하고 중복을 막는다.3. Stack 영역  메소드 내에서 정의하는 기본 자료형에 해당되는 지역 변수의 데이터 값이 저장되는 공간  메소드가 호출될 때 스택 영역에 스택 프레임[1]이 생기고 그 안에서 메소드를 호출  primitive 타입에 해당되는 지역변수, 매개 변수 데이터 값이 저장됨  메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 사라짐  Stack은 LIFO이며, 스코프 범위를 벗어나면 스택 메모리에서 사라진다.4. Heap[2]  JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 여역  new 연산자로 생성되는 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간  Heap에 있는 오브젝트들을 가리키는 레퍼런스 변수는 stack에 적재  Heap는 Stack과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지. 그러나 Heap에 인스턴스를 참조하지 않는 상황이 되면 GC 대상이 된다.  stack은 쓰레드 개수마다 생성되지만 Heap은 몇 개의 쓰레드가 존재하든 상관 없이 하나의 Heap만 존재한다. https://inpa.tistory.com/entry/JAVA-☕-그림으로-보는-자바-코드의-메모리-영역스택-힙#  https://1-7171771.tistory.com/140  method(static) area? permenent generation?1. Permanent Generation : 생성된 객체들의 정보의 주소 값이 저장된 공간이다. 클래스 로더에 의해 load되는 Class, Method 드엥 대한 Meta 정보가 저장되는 영역 (Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용)  MetaSpace[3]: class의 메타 정보, 메소드의 메타 정보, static object 변수, 상수, JVM, JIT 관련 데이터 등  New/Young          메모리에 객체가 생성되면 Eden에 생성된다.      Eden에 메모리가 가득차면 Eden 데이터가 Survivor1 혹은 Survivor2로 옮겨진다. 1,2 우선 순위는 없다.      Survivor에 있으면 어디에서인가 참조되고 있는 객체들이다. 둘 중 하나가 가득차면 공간이 남아 있는 Survivor로 옮겨진다.      이러한 매커니즘으로 Survivor1 혹은 Survivor2 둘 중 하나는 항상 비워져 있다.      이 과정에서 Minor GC가 발생한다. New/Young에서 발생하는 CG로 Eden 또는 Survior1, Survior2에서 사용되지 않는 객체들을 삭제한다.  Old          Survivor 1, 2를 왔다 갔다하는 동안 살아남은 객체들은 Old로 간다. Old는 Young 보다 크게 할당한다. 이러한 이유로 Old의 GC는 Young보다 드물다.      간혹 Eden -&gt; Old로 넘어가는 경우가 있는데 Survivor에 담을 수 없을 만큼 큰 경우 발생한다.      오랫동안 살아남은 객체?  Minor GC가 발생하면 ageBit를 1씩 늘린다. ageBit이 MaxTenuringThreshold[4]를 초과하면Old로 이동한다. (너무 커서 Eden에서 Old로 바로 이동하기도 한다.)  Old에서는 Major GC(Full Gc)가 일어나며, GC를 진행하는 Thread를 제외하고 이외의 모든 Thread를 멈춘 상태로 GC가 진행된다.이 상태를 stop-the-world라고 한다.  JVM에서 GC를 튜닝하는 이유가 stop-the-world 시간을 단축시키 위함이다.GC 알고리즘 종류  Serial GC : JDK 5,6에서 사용 Minor, Major 모두 싱글 스레드로 실행 -&gt; Stop-The-World가 김.          Mark-Sweep-Compact 알고리즘 사용 (식별하고 지우고 빈공간 정리, 압축)  Parallel GC : Young에서 Minor GC 수행 시 멀티쓰레드 사용(SingleCore CPU라면 Serial로 동작)  Parallel old GC : Old에서 Full GC도 병렬로 처리. Old에서 GC를 처리할 때 Mark-Summary(살아 있는 객체를 식별)-Compaction 사용  CMS(Concurrent Mark &amp; Sweep) GC : Major GC를 최소한으로 하려는데 초점을 둠. MajorGC 수행 시간을 줄기이 위해서 GC의 대상 객체를 최대한 정밀하게 파          Initial Mark : 현재 살아남은 객체를 탐색, GC ROOT에서 참조하는 객체들만 우선적으로 탐색(STW 매우 적음)      Concurrent Mark : Initial Mark에서 탐색한 객체들이 참조하고 있는 객체를 찾아가면 GC 대상인지 판별 (STW 없음)      ReMark : Concurrent Mark 실행 중 새로 생성된 객체나, 참조가 끊어지는 등 변경된 사항이 있는지 다시 한 번 확인 (STW 발생 -&gt; 멀티쓰레딩으로 시간 단축)      Concurrent Sweep : ReMark까지 검증 완료된 GC 대상을 삭제 (STW 없이 진행)        CMS GC는 Compact를 하지 않기 때문에 메모리 단편화를 신경써야 한다. 연속적으로 메모리 할당이 불가능할 정도까지 도달했으면  Compaction을 해야하는데, 이때 다른 GC의 Compaction보다Stop-The-World가 길다.  G1 GC (Garbage First GC)기존 CG 알고리즘으로 큰 메모리에서 효율이 좋지 못해서 개선하기 위해서 등장했다. 기존의 Heap과는 다르게 Region으로 나눠서 관리한다. https://1-7171771.tistory.com/140 Region이라는 논리적인 단위로 메모리를 관히하며, CMS와ㅏ 달리 Compaction을 진행하고 메모리 단편화 문제를 없앰. STW 시간을 예측할 수 있다.  Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간. 이 공간에서 GC가 효율적으로 일어나지 않는다.  Available/Unused : 아직 사용하지 않은, 비어있는 공간Young GC를 수행할 때 STW가 발생, 멀티쓰레드로 극복한다. Young GC는 Regionwnd GC 대상 객체가 가장 많은 Region에서 진행(Eden / Survivor).이 Region에서 살아남은 객체를 다른 Region(Survivor)로 옮기고 빈 Region을 Available/Unused로 돌린다.[1] : 하나의 메소드에 필요한 메모리 덩어리를 묶어서 스택 프레임이라고 한다. 하나의 메소드당 하나의 스택 프레임이 필요하며, 메소드를 호출하기 직전 스택 프레임을 자바 Stack에 생성한 후 메소드를 호출한다.[2] : 자바 코드를 실행할때 따로 -Xms과 -Xmx 옵션을 사용하면 힙 메모리의 초기 사이즈와 최대 사이즈를 조절할 수 있다.[3] : 자바 8부터 변경되었다. 이 영역은 Native 메모리 영역으로 JVM이 아닌 OS에서 관리되도록 변경됐다.[4] :  기본 값 15",
        "url": "//2024/05/18/java-series-03-Memory.html"
      }
      ,
    
      "2024-05-18-java-series-02-jvm-html": {
        "title": "[java Series] 02 Jvm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JVMJVMJava Virtual Machine의 줄임말이다.Java는 JVM이라는 가상머신을 거쳐서 OS에 도달한다. 이때 인식하는 것이 자바 바이트코드(Java Bytecode)이다. Java Compiler는 .java를 .class로 변환해준다. 여기서 자바 바이트 코드는 명령어의 크기가 1바이트이다.바이트 코드는 다시 실시간 번역기 또는 JIT(Just-In-Time)[1] 컴파일러에 의해서 바이너리 코드로 변환된다. 이때 변환은 모든 바이트 코드를 변환하는 것이 아니라 실행하기 전에 필요한 부분을 즉석으로 컴파일 하는 방식을 말한다.또한, 자주 쓰이는 코드는 캐싱해서 같은 부분을 반복적으로 번역(interpret)하지 않도록 한다.JVM은 크게 아래와 같이 이뤄져 있다.  클래스 로더(Class Loader)  실행 엔진(Execution Engine)          인터프리터(Interpreter)      JIT 컴파일러(Just-In-Time)      가비지 콜렉터(Garbage collector)        런타임 데이터 영역(Runtime Data Area)1. 클래스 로더JVM 내로 클래스 파일(*.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.2. 실행 엔진클래스를 실행시키는 엔진, 클래스로더가 JVM 내 런타임 데이터 영역에 바이트 코드를 배치시키고 이것은 실행 엔진에 의해서 실행된다. 바이트 코드는 바이너리 코드가 아니다. 그래서 실행 엔진은 바이트 코드를 JVM 내부에서 바이너리 코드로 변환한다.2.1.1. 인터프리터바이트 코드를 명령 단위로 읽어서 실행한다.2.1.2. JIT(HotSpot)인터프리터 방식으로 사용하기 직전 기계어로 변역하고 캐싱하여 이후에는 번역하지 않는 방식으로 동작한다.2.2 가비지 콜렉터[2]더 이상 사용하지 않는 인스턴스를 찾아 메모리에서 삭제한다.2.3 Runtime Data Area3. JDK? JRE?  JDK : Java Development Kit ( JRE + (javac, jdb, javadoc…))  JRE : Java Runtime Environment ( JVM + 자바 클래스 라이브러리)[1] : 크게 나눠서 HotSpot Vm과 같이 메소드(함수) 단위로 JIT하는 방식과 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하여 컴파일할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 추가적으로, 미리 컴파일된 코드를 실행하는게 아니라 런타임에 동적으로 코드를 생성하여 실행하므로 잠재적 보안 문제가 있다. 예를 들어 인텔 스펙터가 JIT에 의존하는 JS 엔진을 가진 브라우저에서만 발생했다.",
        "url": "//2024/05/18/java-series-02-jvm.html"
      }
      ,
    
      "2024-05-18-java-series-01-version-html": {
        "title": "[java Series] 01 Version",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자바 버전별 정보JDK 1.0  안정화 작업JDK 1.1  이너 클래스, JavaBeans, RMI, Reflection, Calendar 유니코드 지원Javabeans : 자바로 작성된 소프트웨어 컴포넌트\t&gt; 1. 기본 생성자가 반드시 존재해야한다. \t&gt; 2. 모든 속성은 비공개\t&gt; 3. 속성에 접근하고 꺼내올 수 있는 getter, setter 구성\t&gt; 4. Serializable 구현RMI : Remote Method Invocation의 약자로 분산 애플리케이션을 구축하는 데 사용, 한 시스템(JVM)에 상주하는 객체가 다른 JVM에서 실행 중인 객체에 액세스, 호출할 수 있도록 도와주는 메커니즘JDK 1.2  JIT(HotSpot), Collection Framework 등 추가J2SE 1.3  HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가J2SE 1.4assert, 정규표현식, IPv6, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가J2SE 5  Generics 추가  Annotation 추가  동시성 제어 API (Concurrency API) 추가  Enumeration 추가  Auto Boxing/ Unboxing 추가Java SE 7  Diamond Operator ( ‘&lt;&gt;’ ) 추가Java SE 8 (오라클 인수 이후)  Lambda Expression 지원  Method Reference 지원  인터페이스에 default method가 추가  Optional 추가  날짜와 시간 API 추가       //javax.time.Clock   Clock.systemUTC();                    //current time of your system in UTC.    Clock.millis();                        //time in milliseconds from 1/1/1970.        //javax.tme.ZoneId   ZoneId zone = ZoneId.of(“Europe/London”);        //zoneId from a timezone.    Clock clock = Clock.system(zone);            //set the zone of a Clock.        //javax.time.LocalDate   LocalDate date = LocalDate.now();            //current date    String day = date.getDayOfMonth();            //day of the month    String month = date.getMonthValue();            //month    String year = date.getYear();                //year        Stream API 추가  PermGenArea 제거 : java8이전에는 초기 설정시 PermSize, MaxPerSize를 성정해야 했는데 이후 MetaSpace로 변경됐다. MetaSpace는 런타임 시 메모리 요규 사항에 따라 자체 크기를 조정하며, 필요하다면 MaxMetaspaceSize 매개변수를 조정하여 양을 조정할 수 있다.```    Permanent Generation    Permanent Generation은 Class 혹은 Method Code가 저장되는 영역  PermGen은 Heap에 속함  Default로 제한된 크기를 가짐Metaspace  Metaspace는 Java 클래스 로더가 현재까지 로드한 class들의 메타 데이터가 저장되는 공간  JVM에 의해 관리되는 Heap이 아닌 OS 레벨에서 관리되는 Native 메모리 영역에 위치  Default로 제한된 크기를 가지고 있지 않고, 필요한 만큼 늘어남# Java SE 9- 모듈 시스템 jigsaw 등장 (https://www.baeldung.com/project-jigsaw-java-modularity)- A New HTTP Client : 8까지 사용하던 HttpURLConnection을 대체할 새로운 java.net.http 패키지 추가- JsShell : main 메소드 없이 코드를 테스트할 수 있는 대화식 REPL(Read-Eval-Print-Loop) 도구를 제공- Process API 개선 : OS 프로세스 관리 및 컨트롤을 위해 (java.lang.ProcessHandle, java.lang.ProcessHandle.Info)가 추가 됐다.- Try-With-Resource 개선- 다이아몬트 연산자를 익명클래스에서도 사용할 수 있도록 개선됨- Interface Private Method 인터페이스 내에서 private 메소드 사용이 가능해짐- Optional To Stream :  Optional로 Stream을 생성할 수 있게 됐다.         &gt; Stream&lt;Integer&gt; steram = Optional.of(1).stream();# Java SE 10- Local-Variable Type Interface : 로컬 변수 타입 추론 기능이다. 로컬 변수 타입을 var로 선언할 수 있다.```javavar list - new ArrayList&lt;String&gt;();\t//ArrayList&lt;String&gt; 으로 추론var stream = list.stream();\t\t//Stream&lt;String&gt; 으로 추론var numbers = List.of(1, 2, 3, 4, 5);\t//List&lt;Integer&gt; 으로 추론for (var number : numbers){\t\t//Integer 추론\tSystem.out.println(number);}  Garbage Collector Interface : 다양한 GC의 코드 고립도를 향상하는 인터페이스 도입  Thread-Local Handshakes : VM safepoint를 수행할 필요 없이 개별 쓰레드를 stop하고 콜백을 수행할 수 있도록 추가```VM safePoint :: “Stop The World”로 모든 쓰레드를 일시 정지시키는 작업  safepoint를 발생시키는 경우          Garbage collection pauses      Code deoptimization      Flusing code cache      Class redefinition      Biased lock revocation      Various debug operation      - Root Certificates : HTTPS 통신에 쓰이는 root CA 목록을 OracleJdk에서도 가지게 됐다.# Java SE 11- HTTP 클라이언트(JEP 321) : java 9에 포함됐던 HTTP 클라이언트 API를 정식 채택, URLConnection 기반의 HTTP 개발보다 개선된 기능, 명명 규칙을 제공한다. 특히 HTTP 2.0을 지원하여 웹소켓도 포함되어있다.- 새로운 String 메소드 추가|     Method      |                          Description                           ||:---------------:|:--------------------------------------------------------------:||     strip()     |                         문자열 앞, 뒤 공백 제거                         || stripLeading()  |                          문자열 앞의 공백 제거                          || stripTrailing() |                          문자열 뒤의 공백 제거                          ||    isBlank()    | 문자열이 비어있거나 공백만 포함되어있을 경우 true (String.trim().isEmpty()와 결과 같음) ||     lines()     |                     문자열을 라인 단위로 쪼개는 스트림 반환                     ||    repeat(n)    |                   지정된 수 만큼 문자열을 반복하여 붙여서 반환                    |```java trim()은 U+0020이하의 값만 공백으로 인식(tab, CR, LF, 공백) 하지만 유니코드에는 외에 다른 공백을 제공하는데 이를 제거하려면 Character.isWhitespace(int)를 사용해야만 했다.Java SE 11 부터는 strip()을 사용하면 된다.  Lambda 파라미터로 var 사용    (var x, var y) -&gt; x.process(y) =&gt; (x, y) -&gt; x.process(y)      Java SE 12  문법적으로 Switch 문을 확장```java//기존 방식switch (day) {    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;}//Java SE 12 부터의 방식switch (day) {    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);}- 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선# Java SE 13- Switch 문 개선을 위한 'yield' 예약어 추가```javavar a = switch (day) {    case MONDAY, FRIDAY, SUNDAY:        yield 6;    case TUESDAY:        yield 7;    case THURSDAY, SATURDAY:        yield 8;    case WEDNESDAY:        yield 9;};  textBlock 추가    String str = \"\"\" This is text block\"\"\";      Java SE 14  12, 13에서의 Switch 문이 표준화되었다.      record( preview ) : java로 많은 상용구를 작성하는 수고를 덜어주는 record 클래스 도입```javafinal class Point {  public final int x;  public final int y;    public Point(int x, int y) {      this.x = x;      this.y = y;  }}// state-based implementations of equals, hashCode, toString// nothing else  //레코드 사용record Point(int x, int y) { }```  NullPointerException track: 어떤 부분에서 NPE가 발생헀는지 설명해준다.Java SE 15  textBlock / Multiline Strings가 공식 채택 준비됐습니다.  Sealed Classes ( preview ) 상속 가능한 클래스를 지정할 수 있는 봉인 클래스가 추가된다. 상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해있어야 한다.  EdDSA 암호화 알고리즘 추가  스케일링 가능한 낮은 지연의 가비지 컬렉터 추가(ZGC)[1]Java SE 16  jdk1.8부터 시작된 PermGen 대신 Metaspace를 지원하기 시작  OpenJdk의 버전관리가 git으로 변경되었습니다.  Unix-Domain Socket Channels : Unix 도메인 소켓에 연결할 수 있다.Java SE 17  RandomGenerator : 의사 난수 생성기를 통해서 예측하기 어려운 난수를 생성하는 API가 출시됐다.  M1 정식 지원Java SE 18  UTF-8이 기본 인코딩셋이 되었다.  Simple Web Server: 간편설정, 최소한의 기능으로 바로 사용 가능한 HTTP 파일 서버를 제공한다.  Relection 기능 리팩토링( 메소드 핸들을 이용해서 다시 구현 )  switch-case 패턴 매칭 preview  try-catch-finally deprecated  ( try-with-resources 권장)Java SE 19  VirtualThread, Foreign Function &amp; Memory API, Structured Concurrency, Vector API 등이 preview로 추가Java SE 20  VirtualThread(second preview), ScopedValue(incubated), StructuredConcurrency(SecondIncubate)Java SE 21  StringTemplate(preview)  Sequenced Collections  Generational ZGC  Switch Pattern Matching 정식 출시  Unnamed Patterns and Variables (Preview)  Virtual Thread 정식 출시  Windows 32-bit x86 제거 예정Java SE 22  G1 GC에 Region Pinning 기술을 구현해 지연 시간(latency) 단축  super() 호출 전에 다른 statement 실행을 가능하게함 (프리뷰 기능).  이름없는 변수 및 패턴. 안쓰는 변수 이름을 언더스코어(_)로 표기하는 것을 허용  StructuredConcurrency(secondPreview) : 쓰레드 캔슬, 셧다운에 의한 리스크를 줄이고 Observability 향상, 여러 쓰레드에서 실행되는 관련있는 작업들을 그룹핑하는 기능  ScopedValues(secondPreview) : 같은 쓰레드 내에서의 공유 데이터를 관리하기 위한 컨테이너 오브젝트. ThreadLocal과 비슷하지만 ThreadLocal의 단점을 보완해 더 적은 리소스를 사용하고 더 안전하다고 한다. (특히 VirtualThreads, StructuredConcurrency랑 같이 활용될 때)Java SE 23  2024/06/08 Preview  2024/09 GA[1] ZGC 메소드 핸들 ",
        "url": "//2024/05/18/java-series-01-Version.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
