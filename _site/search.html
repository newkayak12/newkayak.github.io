<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | newkayak12.github.io</title>
	<meta name="description"
		content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2024-05-19-deisgn-pattern-20-enumfactorymethod-html": {
        "title": "[deisgn Pattern] 20 Enumfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Enum Factory MethodEnumFactoryMethodFactoryMethod 단점을 보완하기 위한 패턴이다.Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 모두 구현해야 된다는 점이다.즉, 제품 객체가 50개면 공장 객체도 50개를 구현해야 된다는 말이다.또한 기본적으로 팩토리 클래스는 한번 인스턴스화 하고 제품 객체를 생성하는 역할만 하면 되지 여러개 생성될수 있는 낭비적인 가능성이 있기 때문에 싱글톤을 일일히 적용하여야 하며 이로인해 코드가 복잡해진 다는 문제점도 있었다.이러한 문제점을 Enum으로 팩토리 메서드 패턴을 구성해 준다면, 일일히 서브 공장 클래스 구현 없이 하나의 enum Factory에서 SOLID 원칙 위반 없이 팩토리 클래스를 구성해 줄 수 있다.그러나 단점은 클래스 상속이 필요할때, enum 외의 클래스 상속은 불가능하기 때문에 다시 일반 클래스로 재구성 해야된다는 한계점이 존재한다.기존 팩토리 메서드 패턴Factory Method 패턴에서 유의할 부분은 Factory 인스턴스가 여러번 생성될 필요가 없다는 점이다.공장 객체는 한번만 생성되면 필요할때마다 제품 객체들을 얼마든지 생성할수 있기 때문에 괜히 매번 제품을 생성할때마다 인스턴스화 하면 GC에 의해 STW(Stop The World)가 일어나는 원인이 된다.Enum으로 구현한 팩토리 메소드 패턴Enum 확장 기능을 이용해 싱글톤을 구성해 줄수 도 있다. 왜냐하면 Enum 타입 자체가 public static final 이기 때문에 따로 싱글톤을 구현하지 않아도 단일한 객체만 생성됨이 보장되기 때문이다.enum EnumShapeFactory {    RECTANGLE {        public Shape createShape() {            return new Rectangle();        }    },    CIRCLE {        public Shape createShape() {            return new Circle();        }    };    public Shape create(String color) {        Shape shape = createShape();        shape.setColor(color);        return shape;    }    // 팩토리 메서드    abstract protected Shape createShape();}class Client {    public static void main(String[] args) {        Shape rectangle = EnumShapeFactory.RECTANGLE.create(\"red\");        rectangle.draw();        Shape circle = EnumShapeFactory.CIRCLE.create(\"yellow\");        circle.draw();    }}",
        "url": "//2024/05/19/deisgn-pattern-20-EnumFactoryMethod.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-19-dynamicfactory-html": {
        "title": "[deisgn Pattern] 19 Dynamicfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Dynamic FactoryDynamic FactoryFactory Method의 단점을 보완하기 위한 패턴기존 팩토리 메서드 패턴오리지날 Factory Method 패턴의 가장 큰 단점은 제품 객체의 갯수마다 공장 서브 클래스를 1:1 매칭으로 모두 구현해야 된다는 점이다. 그래서 제품 객체가 50개면 공장 객체도 50개를 구현해야 한다. 이는 곧 클래스 폭발로 이어지며 코드 복잡도를 증가시킨다.다이나믹 팩토리 패턴 적용자바의 Class 클래스를 이용한 Reflection APIVisit Website 기법을 이용하여 유형을 동적으로 등록하고 인스턴스를 초기화 하는 패턴이 바로 Dynamic Factory 패턴이다.이를 이용해 팩토리 메서드의 서브 클래싱 부피가 늘어나는 한계를 해결 할 수 있다.",
        "url": "//2024/05/19/deisgn-pattern-19-DynamicFactory.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-18-templatecallback-html": {
        "title": "[deisgn Pattern] 18 Templatecallback",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Template CallbackTemplate Callback탬플릿 콜백 패턴(Template Callback Pattern)은 스프링 프레임워크에서 DI(Dependency injection) 의존성 주입에서 사용하는 특별한 전략 패턴이다.스프링의 JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate과 같은곳에 사용된다.존의 전략 패턴은 변화되는 전략 알고리즘 부분을 컴파일 타임에서 클래스로 만든뒤 구현체를 주입해 주어야 되지만, 템플릿 콜백 패턴은 런타임 타임에서 익명 클래스를 이용해 동적으로 전략 알고리즘을 주입한다.용어도 그냥 전략 패턴에서의 컨텍스트(Context)를 템플릿으로 치환한 것일 뿐이며 콜백은 익명 클래스를 만들어진 메서드를 칭하는 것이다.정리하자면 템플릿 콜백 패턴은 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 패턴이라고 보면 된다.흐름// 콜백interface Callback {    int execute(final int n);}// 템플릿class Template {    int workflow(Callback cb) {        System.out.println(\"Workflow 시작\");        int num = 100;        int result = cb.execute(num);        return result;    }}// 클라이언트public class Client {    public static void main(String[] args) {        int x = 100;        int y = 20;        Template t = new Template();        int result = t.workflow(new Callback() {            @Override            public int execute(final int n) {                return n * n;            }        });        System.out.println(result); // 100 * 100 = 10000    }}특징  전략 패턴과 스프링의 의존성 주입(DI)의 장점을 익명 내부 클래스 사용 전략과 결합해 독특하게 활용되는 패턴장점  전략패턴은 따로 전략 알고리즘을 정해놓은 별도의 전략 클래스가 필요했지만, 템플릿-콜백 패턴은 별도의 전략 클래스 없이, 전략을 사용하는 메소드에 매개변수값으로 전략 로직을 넘겨 실행하기 때문에 전략 객체를 일일히 만들 필요가 없다.  외부에서 어떤 전략을 사용하는지 감추고 중요한 부분에 집중할 수 있다.단점  스프링 클라이언트에서 DI를 사용하지 않게 되면, Bean으로 등록되지 않아 싱글톤 객체가 되지 않게 된다.  인터페이스를 사용하지만 실제 사용할 클래스를 직접 선언하기 때문에 결합도가 증가하게 된다. 다만, 그렇다고 해서 무리하게 결합도를 낮추는 행위를 할 필요는 없다.",
        "url": "//2024/05/19/deisgn-pattern-18-TemplateCallback.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-17-staticfactorymethod-html": {
        "title": "[deisgn Pattern] 17 Staticfactorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Static Factory MethodStatic Factory Method정적 팩토리 메서드(Static Factory Method) 패턴은 개발자가 구성한 Static Method를 통해 간접적으로 생성자를 호출하는 객체를 생성하는 디자인 패턴이다. 우리는 지금까지 객체를 인스턴스화 할때 직접적으로 생성자(Constructor)를 호출하여 생성하였는데, 별도의 객체 생성의 역할을 하는 클래스 메서드를 통해 간접적으로 객체 생성을 유도하는 것이다. 그리고 이 정적 메서드를 통칭적으로 정적 팩토리 메서드 패턴이라고 부르는 것이다.class Book {    private String title;        // 생성자를 private화 하여 외부에서 생성자 호출 차단    private Book(String title) { this.title = title; }        // 정적 팩토리 메서드    public static Book titleOf(String title) {        return new Book(title); // 메서드에서 생성자를 호출하고 리턴함    }}특징1. 생성 목적에 대한 이름 표현이 가능하다.지금까지 클래스를 설계할때 다양한 타입의 객체를 생성하기 위해, 생성 목적에 따라 생성자를 오버로딩하여 구분하여 사용해왔다.하지만 문제는 이러한 객체를 new 키워드를 통해 생성자로 생성하려면, 개발자는 해당 생성자의 인자 순서와 내부 구조를 알고 있어야 목적에 맞게 객체를 생성할수가 있다는 번거로움이 있다.class Car {    private String brand;    private String color;    // private 생성자    private Car(String brand, String color) {        this.brand = brand;        this.color = color;    }    // 정적 팩토리 메서드 (매개변수 하나는 from 네이밍)    public static Car brandBlackFrom(String brand) {        return new Car(brand, \"black\");    }    // 정적 팩토리 메서드 (매개변수 여러개는 of 네이밍)    public static Car brandColorOf(String brand, String color) {        return new Car(brand, color);    }}2. 인스턴스에 대해 통제 및 관리가 가능하다.메서드를 통해 한단계 거쳐 간접적으로 객체를 생성하기 때문에, 기본적으로 전반적인 객체 생성 및 통제 관리를 할 수 있게 된다.즉, 필요에 따라 항상 새로운 객체를 생성해서 반환할 수도 있고, 아니면 객체 하나만 만들어두고 이를 공유하여 재사용하게 하여 불필요한 객체를 생성하는 것을 방지 할 수 있는 것이다.대표적인 예시가 Singleton이다.class Singleton {    private static Singleton instance;    private Singleton() {}    // 정적 팩토리 메서드    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}다른 예로는 인스턴스에 대한 캐싱(Caching) 절차 구조를 정적 팩토리 메서드로 구현할 수 있다. 인스턴스에 대해 캐싱을 한다면 필요한 인스턴스만 뽑아 재사용하여 메모리를 절약할 수 있게 된다.이렇게 인스턴스를 통제하는 것은 인스턴스가 단 하나뿐임을 보장하는 것이고, Flyweight 디자인 패턴의 근간이 되게 된다.3. 하위 자료형 객체를 반환할 수 있다.클래스의 다형성의 특징을 응용한 정적 팩토리 메서드 특징이다. 메서드 호출을 통해 얻을 객체의 인스턴스를 자유롭게 선택할수 있는 유연성을 갖는 것이다.interface SmarPhone {}class Galaxy implements SmarPhone {}class IPhone implements SmarPhone {}class Huawei implements SmarPhone {}class SmartPhones {    public static SmarPhone getSamsungPhone() {        return new Galaxy();    }    public static SmarPhone getApplePhone() {        return new IPhone();    }    public static SmarPhone getChinesePhone() {        return new Huawei();    }}4. 인자에 따라 다른 객체를 반환하도록 분기할 수 있다.메서드이니 매개변수를 받을수 있을테고, 메서드 블록 내에서 분기문을 통해 여러 자식 타입의 인스턴스를 반환하도록 응용 구성이 가능하다.interface SmarPhone {    public static SmarPhone getPhone(int price) {        if(price &gt; 100000) {            return new IPhone();        }        if(price &gt; 50000) {            return new Galaxy();        }        return new Huawei();    }}5. 객체 생성을 캡슐화 할 수 있다.생성자를 사용하는 경우 외부에 내부 구현을 드러내야 하는데, 정적 팩토리 메서드는 구현부를 외부로 부터 숨길 수 있어 캡슐화(encapsulation) 및 정보 은닉(information hiding)을 할수 있다는 특징이 있다.또한 노출하지 않는다는 특징은 정보 은닉성을 가지기도 하지만 동시에 사용하고 있는 구현체를 숨겨 의존성을 제거해주는 장점도 지니고 있다.interface Grade {    String toText();}class A implements Grade {    @Override    public String toText() {return \"A\";}}class B implements Grade {    @Override    public String toText() {return \"B\";}}class C implements Grade {    @Override    public String toText() {return \"C\";}}class D implements Grade {    @Override    public String toText() {return \"D\";}}class F implements Grade {    @Override    public String toText() {return \"F\";}}class GradeCalculator {    // 정적 팩토리 메서드    public static Grade of(int score) {        if (score &gt;= 90) {            return new A();        } else if (score &gt;= 80) {            return new B();        } else if (score &gt;= 70) {            return new C();        } else if (score &gt;= 60) {            return new D();        } else {            return new F();        }    }}Static Factory Method 네이밍 규칙  from : 하나의 매개 변수를 받아서 객체를 생성  of : 여러개의 매개 변수를 받아서 객체를 생성                              getInstance          instance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음                                                  newInstance          create : 항상 새로운 인스턴스를 생성                      get[OrderType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음  new[OrderType] : 항상 다른 타입의 새로운 인스턴스를 생성실제 사용 예시  Optional.of()  List.of()  Integer.valueOf()",
        "url": "//2024/05/19/deisgn-pattern-17-StaticFactoryMethod.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-16-singleton-html": {
        "title": "[deisgn Pattern] 16 Singleton",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SingletonSingleton// Basicpublic class Singleton {    private static Singleton instance;        private Singleton() { }        public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) { // 쓰레드 동시 접근 시 문제가 발생            instance = new Singleton(); // 쓰레드 동시 접근 시 여러 번 생성        }                return instance;    }}// Synchronizedpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static synchronized Singleton getInstance() {        if ( Objects.isNull( instance ) ) {             instance = new Singleton();         }        //인스턴스 생성이 된 이후에도 락을 건다. 불필요!        return instance;    }}//DCL(Double-Checked-Locking) public class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {                        synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                    /**                     * 아래와 같은 재배치가 있을 수 있다.                     * some_space = allocate space for Singleton Obj;                     *                      *   instancce = some_sapce;                     *                      * create finished                     */                }            }        }        //락을 거는 부분을 최소한으로         //소스코드 상으로 문제가 없지만 컴파일러에 따라 재배치(reordering) 문제가 발생하기도 한다.         return instance;    }}//volatilepublic class Singleton {        private volatile static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        if ( Objects.isNull( instance ) ) {            synchronized (Singleton.class) {                if ( Objects.isNull( instance ) ) {                    instance = new Singleton();                }            }        }        //문제 없음         return instance;    }}//static 초기화 이용public class Singleton {    private static Singleton instance;        static {        instance = new Singleton();  //클래스 로드 시점에 생성해서 하나임을 보장한다.    }        private Singleton() { }    public static synchronized Singleton getInstance() {        return instance;    }        // 해당 instance를 사용 여부와 상관없이 생성한다. 낭비!}//LazyHolder staticpublic class Singleton {    private static Singleton instance;    private Singleton() { }    public static Singleton getInstance() {        return LazyHolder.INSTANCE;    }        private static class LazyHolder {        private static final Singleton INSTANCE = new Singleton();    }    //THREAD-SAFE + LAZY}",
        "url": "//2024/05/19/deisgn-pattern-16-Singleton.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-15-stategy-html": {
        "title": "[deisgn Pattern] 15 Stategy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StrategyStrategy전략 패턴은 실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴 이다.여기서 ‘전략’이란 일종의 알고리즘이 될 수 도 있으며, 기능이나 동작이 될 수도 있는 특정한 목표를 수행하기 위한 행동 계획을 말한다.즉, 어떤 일을 수행하는 알고리즘이 여러가지 일때, 동작들을 미리 전략으로 정의함으로써 손쉽게 전략을 교체할 수 있는, 알고리즘 변형이 빈번하게 필요한 경우에 적합한 패턴이다.  전략 알고리즘 객체들 : 알고리즘, 행위, 동작을 객체로 정의한 구현체  전략 인터페이스 : 모든 전략 구현제에 대한 공용 인터페이스  컨텍스트(Context) : 알고리즘을 실행해야 할 때마다 해당 알고리즘과 연결된 전략 객체의 메소드를 호출.  클라이언트 : 특정 전략 객체를 컨텍스트에 전달 함으로써 전략을 등록하거나 변경하여 전략 알고리즘을 실행한 결과를 누린다.특징정의  동일 계열의 알고리즘군을 정의하고  각각의 알고리즘을 캡슐화하여  이들을 상호 교환이 가능하도록 만든다.  알고리즘을 사용하는 클라이언트와 상관없이 독립적으로  알고리즘을 다양하게 변경할 수 있게 한다.흐름// 전략(추상화된 알고리즘)interface IStrategy {    void doSomething();}// 전략 알고리즘 Aclass ConcreteStrateyA implements IStrategy {    public void doSomething() {}}// 전략 알고리즘 Bclass ConcreteStrateyB implements IStrategy {    public void doSomething() {}}// 컨텍스트(전략 등록/실행)class Context {    IStrategy Strategy; // 전략 인터페이스를 합성(composition)    // 전략 교체 메소드    void setStrategy(IStrategy Strategy) {        this.Strategy = Strategy;    }    // 전략 실행 메소드    void doSomething() {        this.Strategy.doSomething();    }}사용 시기  전략 알고리즘의 여러 버전 또는 변형이 필요할 때 클래스화를 통해 관리  알고리즘 코드가 노출되어서는 안 되는 데이터에 액세스 하거나 데이터를 활용할 때 (캡슐화)  알고리즘의 동작이 런타임에 실시간으로 교체 되어야 할 때주의점  알고리즘이 많아질수록 관리해야할 객체의 수가 늘어난다는 단점이 있다.  만일 어플리케이션 특성이 알고리즘이 많지 않고 자주 변경되지 않는다면, 새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다.  개발자는 적절한 전략을 선택하기 위해 전략 간의 차이점을 명확이 알고 있어야 한다.실사용 예제  Collections의 sort() 메서드에 의해 구현되는 compare() 메서드에 이용  javax.servlet.http.HttpServlet에서 service() 메서드와 모든 doXXX() 메서드에 이용  javax.servlet.Filter의 doFilter() 메서드에 이용",
        "url": "//2024/05/19/deisgn-pattern-15-Stategy.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-14-templatemethod-html": {
        "title": "[deisgn Pattern] 14 Templatemethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TemplateMethodTemplateMethod템플릿 메서드(Template Method) 패턴은 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.즉, 변하지 않는 기능(템플릿)은 상위 클래스에 만들어두고 자주 변경되며 확장할 기능은 하위 클래스에서 만들도록 하여, 상위의 메소드 실행 동작 순서는 고정하면서 세부 실행 내용은 다양화 될 수 있는 경우에 사용된다.템플릿 메소드 패턴은 상속이라는 기술을 극대화하여, 알고리즘의 뼈대를 맞추는 것에 초점을 둔다. 이미 수많은 프레임워크에서 많은 부분에 템플릿 메소드 패턴 코드가 우리도 모르게 적용되어 있다.  AbstractClass(추상 클래스) : 템플릿 메소드를 구현하고, 템플릿 메소드에서 돌아가는 추상 메소드를 선언한다. 이 추상 메소드는 하위 클래스인 ConcreteClass 역할에 의해 구현된다.  ConcreteClass(구현 클래스) : AbstractClass를 상속하고 추상 메소드를 구체적으로 구현한다. ConcreteClass에서 구현한 메소드는 AbstractClass의 템플릿 메소드에서 호출된다.흐름abstract class AbstractTemplate {    // 템플릿 메소드 : 메서드 앞에 final 키워드를 붙이면 자식 클래스에서 오버라이딩이 불가능함.\t// 자식 클래스에서 상위 템플릿을 오버라이딩해서 자기마음대로 바꾸도록 하는 행위를 원천 봉쇄    public final void templateMethod() {        // 상속하여 구현되면 실행될 메소드들        step1();        step2();                if(hook()) { // 안의 로직을 실행하거나 실행하지 않음            // ...        }                step3();    }    boolean hook() {        return true;    }    // 상속하여 사용할 것이기 때문에 protected 접근제어자 설정    protected abstract void step1();    protected abstract void step2();    protected abstract void step3();}class ImplementationA extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}}class ImplementationB extends AbstractTemplate {    @Override    protected void step1() {}    @Override    protected void step2() {}    @Override    protected void step3() {}    // hook 메소드를 오버라이드 해서 false로 하여 템플릿에서 마지막 로직이 실행되지 않도록 설정    @Override    protected boolean hook() {        return false;    }}특징사용 시기  클라이언트가 알고리즘의 특정 단계만 확장하고, 전체 알고리즘이나 해당 구조는 확장하지 않도록 할때  동일한 기능은 상위 클래스에서 정의하면서 확장, 변화가 필요한 부분만 하위 클래스에서 구현할 때장점  클라이언트가 대규모 알고리즘의 특정 부분만 재정의하도록 하여, 알고리즘의 다른 부분에 발생하는 변경 사항의 영향을 덜 받도록 한다.  상위 추상클래스로 로직을 공통화 하여 코드의 중복을 줄일 수 있다.  서브 클래스의 역할을 줄이고, 핵심 로직을 상위 클래스에서 관리하므로서 관리가 용이해진다          헐리우드 원칙 (Hollywood Principle) : 고수준 구성요소에서 저수준을 다루는 원칙 (추상화에 의존)      단점  알고리즘의 제공된 골격에 의해 유연성이 제한될 수 있다.  알고리즘 구조가 복잡할수록 템플릿 로직 형태를 유지하기 어려워진다.  추상 메소드가 많아지면서 클래스의 생성, 관리가 어려워질 수 있다.  상위 클래스에서 선언된 추상 메소드를 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는지 클래스 로직을 이해해야 할 필요가 있다.  로직에 변화가 생겨 상위 클래스를 수정할 때, 모든 서브 클래스의 수정이 필요 할수도 있다.  하위 클래스를 통해 기본 단계 구현을 억제하여 리스코프 치환 법칙을 위반할 여지가 있다.  할리우드 원칙 준수  헐리우드 원칙(Hollywood Principle) 이란 고수준 모듈(추상클래스, 인터페이스)에 의존하고 고수준 모듈에서 연락(메소드 실행) 하라는 원칙이다.객체 끼리 이상하게 얼키고 설켜, 의존성이 복잡하게 꼬여있는 것을 ‘의존성 부패(dependency rot)’ 라고 부르는데, 헐리우드 원칙을 활용하면 의존성 부패를 방지할 수 있게 된다.자바 프로그래밍으로 간단히 말하자면, 다형성을 이용해 고수준의 객체 타입에서만 왠만하면 메서드 실행을 하라는 말이다.",
        "url": "//2024/05/19/deisgn-pattern-14-TemplateMethod.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-13-state-html": {
        "title": "[deisgn Pattern] 13 State",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - StateState상태 패턴(State Pattern)은 객체가 특정 상태에 따라 행위를 달리하는 상황에서, 상태를 조건문으로 검사해서 행위를 달리하는 것이 아닌, 상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴을 말한다.객체 지향 프로그래밍에서의 클래스는 꼭 사물 / 생물만을 표현하는 고체 형태의 데이터만 표현 할 수 있는게 아니다.경우에 따라서 무형태의 행위 / 동작도 클래스로 묶어 표현할 수 있다.그래서 상태를 클래스로 표현하면 클래스를 교체해서 ‘상태의 변화’를 표현할 수 있고, 객체 내부 상태 변경에 따라 객체의 행동을 상태에 특화된 행동들로 분리해 낼 수 있으며,새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.  전략 패턴(Strategy Pattern)이 ‘전략 알고리즘’을 클래스로 표현한 패턴이라면, 상태 패턴(State Pattern)은 ‘객체 상태’를 클래스로 표현한 패턴이라고 보면 된다.구조  State 인터페이스 : 상태를 추상화한 고수준 모듈.  ConcreteState : 구체적인 각각의 상태를 클래스로 표현. State 역할로 결정되는 인터페이스(API)를 구체적으로 구현한다. 다음 상태가 결정되면 Context에 상태 변경을 요청하는 역할도 한다.  Context : State를 이용하는 시스템. 시스템 상태를 나타내는 State 객체를 합성(composition)하여 가지고 있다. 클라이언트로부터 요청받으면 State 객체에 행위 실행을 위임한다  상태 클래스는 싱글톤 클래스로 구성한다.전략 패턴의 전략 객체 같은 경우 매개 값에 따라 알고리즘 수행 형태가 달라질수 있지만, 상태는 그 객체의 현 폼을 나타내는 것이기 때문에 대부분의 상황에서 유일하게 있어야 한다.특징사용 시기  객체의 행동(메서드)가 상태(state)에 따라 각기 다른 동작을 할때.  상태 및 전환에 걸쳐 대규모 조건 분기 코드와 중복 코드가 많을 경우  조건문의 각 분기를 별도의 클래스에 넣는것이 상태 패턴의 핵심  런타임단에서 객체의 상태를 유동적으로 변경해야 할 때장점  상태(State)에 따른 동작을 개별 클래스로 옮겨서 관리 할 수 있다.  상태(State)와 관련된 모든 동작을 각각의 상태 클래스에 분산시킴으로써, 코드 복잡도를 줄일 수 있다.  단일 책임 원칙을 준수할 수 있다. (특정 상태와 관련된 코드를 별도의 클래스로 구성)  개방 폐쇄 원칙을 준수할 수 있다. (기존 State 클래스나 컨텍스트를 변경하지 않고 새 State를 도입할 수 있다)  하나의 상태 객체만 사용하여 상태 변경을 하므로 일관성 없는 상태 주입을 방지하는데 도움이 된다.단점  상태 별로 클래스를 생성하므로, 관리해야할 클래스 수 증가  상태 클래스 갯수가 많고 상태 규칙이 자주 변경된다면, Context의 상태 변경 코드가 복잡해지게 될 수 있다.  객체에 적용할 상태가 몇가지 밖에 없거나 거의 상태 변경이 이루어지지 않는 경우 패턴을 적용하는 것이 과도할 수 있다.",
        "url": "//2024/05/19/deisgn-pattern-13-State.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-12-factorymethod-html": {
        "title": "[deisgn Pattern] 12 Factorymethod",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FactoryMethodFactoryMethod팩토리 메소드 패턴은 객체 생성을 공장(Factory) 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴이다.즉, 클라이언트에서 직접 new 연산자를 통해 제품 객체를 생성하는 것이 아닌, 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것이다.또한 객체 생성에 필요한 과정을 템플릿 처럼 미리 구성해놓고, 객체 생성에 관한 전처리나 후처리를 통해 생성 과정을 다양하게 처리하여 객체를 유연하게 정할 수 있는 특징도 있다.  Creator : 최상위 공장 클래스로서, 팩토리 메서드를 추상화하여 서브 클래스로 하여금 구현하도로 함          객체 생성 처리 메서드(someOperartion) : 객체 생성에 관한 전처리, 후처리를 템플릿화한 메소드      팩토리 메서드(createProduct) : 서브 공장 클래스에서 재정의할 객체 생성 추상 메서드        ConcreteCreator : 각 서브 공장 클래스들은 이에 맞는 제품 객체를 반환하도록 생성 추상 메소드를 재정의한다. 즉, 제품 객체 하나당 그에 걸맞는 생산 공장 객체가 위치된다.  Product : 제품 구현체를 추상화  ConcreteProduct : 제품 구현체정리하자면, 팩토리 메소드 패턴은 객체를 만들어내는 공장(Factory 객체)을 만드는 패턴이라고 보면 된다. 그리고 어떤 클래스의 인스턴스를 만들지는 미리 정의한 공장 서브 클래스에서 결정한다.이렇게하면 객체 간 결합도가 낮아진다.  [ Template Method 패턴과 Factory Method 패턴과의 관계 ]  뭔가 이름 구성이 비슷해서 둘이 어떠한 관계가 있어 보이는데, 템플릿 메서드는 행동 패턴이고 팩토리 메서드는 생성 패턴이라 둘은 전혀 다른 패턴이다.다만 클래스 구조의 결은 둘이 같다고 보면 되는데, 인스턴스를 생성하는 공장을 Template Method 패턴으로 구성한 것이 Factory Method 패턴이 되기 때문이다.Template Method 패턴에서는 하위 클래스에서 구체적인 처리 알고리즘의 내용을 만들도록 추상 메소드를 상속 시켰었다. 이 로직을 알고리즘 내용이 아닌 인스턴스 생성에 적용한 것이 Factory Method 패턴 인 것이다.// 제품 객체 추상화 (인터페이스)interface IProduct {    void setting();}// 제품 구현체class ConcreteProductA implements IProduct {    public void setting() {    }}class ConcreteProductB implements IProduct {    public void setting() {    }}// 공장 객체 추상화 (추상 클래스)abstract class AbstractFactory {    // 객체 생성 전처리 후처리 메소드 (final로 오버라이딩 방지, 템플릿화)    final IProduct createOperation() {        IProduct product = createProduct(); // 서브 클래스에서 구체화한 팩토리 메서드 실행        product.setting(); // .. 이밖의 객체 생성에 가미할 로직 실행        return product; // 제품 객체를 생성하고 추가 설정하고 완성된 제품을 반환    }    // 팩토리 메소드 : 구체적인 객체 생성 종류는 각 서브 클래스에 위임    // protected 이기 때문에 외부에 노출이 안됨    abstract protected IProduct createProduct();}// 공장 객체 A (ProductA를 생성하여 반환)class ConcreteFactoryA extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductA();    }}// 공장 객체 B (ProductB를 생성하여 반환)class ConcreteFactoryB extends AbstractFactory {    @Override    public IProduct createProduct() {        return new ConcreteProductB();    }}특징사용 시기  클래스 생성과 사용의 처리 로직을 분리하여 결합도를 낮추고자 할 때  코드가 동작해야 하는 객체의 유형과 종속성을 캡슐화를 통해 정보 은닉 처리 할 경우  라이브러리 혹은 프레임워크 사용자에게 구성 요소를 확장하는 방법을 제공하려는 경우  기존 객체를 재구성하는 대신 기존 객체를 재사용하여 리소스를 절약하고자 하는 경우          상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다. 그리고 객체 생성 방식의 변화는 해당되는 모든 코드 부분을 변경해야 하는 문제가 발생한다.      따라서 객체의 생성 코드를 별도의 클래스 / 메서드로 분리 함으로써 객체 생성의 변화에 대해 대비를 하기 위해 팩토리 메서드 패턴을 이용한다고 보면 된다.      특정 기능의 구현은 별개의 클래스로 제공되는 것이 바람직한 설계이기 때문이다      장점  생성자(Creator)와 구현 객체(concrete product)의 강한 결합을 피할 수 있다.  팩토리 메서드를 통해 객체의 생성 후 공통으로 할 일을 수행하도록 지정해줄 수 있다.  캡슐화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.  단일 책임 원칙 준수 : 객체 생성 코드를 한 곳 (패키지, 클래스 등)으로 이동하여 코드를 유지보수하기 쉽게 할수 있으므로 원칙을 만족  개방/폐쇄 원칙 준수 : 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있어 원칙을 만족 (확장성 있는 전체 프로젝트 구성이 가능)  생성에 대한 인터페이스 부분과 생성에 대한 구현 부분을 따로 나뉘었기 때문에 패키지 분리하여 개별로 여러 개발자가 협업을 통해 개발단점  각 제품 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에, 구현체가 늘어날때 마다 팩토리 클래스가 증가하여 서브 클래스 수가 폭발한다.  코드의 복잡성이 증가한다.실사용 예시  java.util.Calendar 의 getInstance()  java.util.ResourceBundle 의 getBundle()  java.text.NumberFormat 의 getInstance()  java.nio.charset.Charset 의 forName()  java.net.URLStreamHandlerFactory 의 createURLStreamHandler(String)  java.util.EnumSet 의 of()  jakarta.xml.bind.JAXBContext 의 createMarshaller() and other similar methods",
        "url": "//2024/05/19/deisgn-pattern-12-FactoryMethod.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-11-abstractfactory-html": {
        "title": "[deisgn Pattern] 11 Abstractfactory",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AbstractFactoryAbstractFactory추상 팩토리 패턴은 연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다.클라이언트에서 특정 객체을 사용할때 팩토리 클래스만을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리시킬 수 있다.즉, 추상 팩토리의 핵심은 제품 ‘군’ 집합을 타입 별로 찍어낼수 있다는 점이 포인트 이다.  AbstractFactory : 최상위 공장 클래스. 여러개의 제품들을 생성하는 여러 메소드들을 추상화 한다.  ConcreteFactory : 서브 공장 클래스들은 타입에 맞는 제품 객체를 반환하도록 메소드들을 재정의한다.  AbstractProduct : 각 타입의 제품들을 추상화한 인터페이스  ConcreteProduct (ProductA ~ ProductB) : 각 타입의 제품 구현체들. 이들은 팩토리 객체로부터 생성된다.  Client : Client는 추상화된 인터페이스만을 이용하여 제품을 받기 때문에, 구체적인 제품, 공장에 대해서는 모른다.Abstract Factory vs. Factory Method둘다 팩토리 객체를 통해 구체적인 타입을 감추고 객체 생성에 관여하는 패턴 임에는 동일하다. 또한 공장 클래스가 제품 클래스를 각각 나뉘어 느슨한 결합 구조를 구성하는 모습 역시 둘이 유사하다.그러나 주의할 것은 추상 팩토리 패턴이 팩토리 메서드 패턴의 상위 호환이 아니라는 점이다. 두 패턴의 차이는 명확하기 때문에 상황에 따라 적절한 선택을 해야 한다.예를 들어 팩토리 메서드 패턴은 객체 생성 이후 해야 할 일의 공통점을 정의하는데 초점을 맞추는 반면, 추상 팩토리 패턴은 생성해야 할 객체 집합 군의 공통점에 초점을 맞춘다.단, 이 둘을 유사점과 차이점을 조합해서 복합 패턴을 구성하는 것도 가능하다.FactoryMethodAbstractFactory공통점객체 생성 과정을 추상화한 인터페이스를 제공  객체 생성을 캡슐화함으로써 구체적인 타입을 감추고 느슨한 결합 구조를 표방차이점구체적인 객체 생성과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적관련 있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적한 Factory당 한 종류의 객체 생성 지원한 Factory에서 서로 연관된 여러 종류의 객체 생성을 지원. (제품군 생성 지원)메소드 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스의 생성 및 구성에 대한 의존을 감소클래스(Factory) 레벨에서 포커스를 맞춤으로써, 클라이언트의 ConcreteProduct 인스턴스 군의 생성 및 구성에 대한 의존을 감소흐름// Product A 제품군interface AbstractProductA {}// Product A - 1class ConcreteProductA1 implements AbstractProductA {}// Product A - 2class ConcreteProductA2 implements AbstractProductA {}// Product B 제품군interface AbstractProductB {}// Product B - 1class ConcreteProductB1 implements AbstractProductB {}// Product B - 2class ConcreteProductB2 implements AbstractProductB {}interface AbstractFactory {    AbstractProductA createProductA();    AbstractProductB createProductB();}// Product A1와 B1 제품군을 생산하는 공장군 1 class ConcreteFactory1 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA1();    }    public AbstractProductB createProductB() {        return new ConcreteProductB1();    }}// Product A2와 B2 제품군을 생산하는 공장군 2class ConcreteFactory2 implements AbstractFactory {    public AbstractProductA createProductA() {        return new ConcreteProductA2();    }    public AbstractProductB createProductB() {        return new ConcreteProductB2();    }}특징사용 시기  관련 제품의 다양한 제품 군과 함께 작동해야 할때, 해당 제품의 구체적인 클래스에 의존하고 싶지 않은 경우  여러 제품군 중 하나를 선택해서 시스템을 설정해야하고 한 번 구성한 제품을 다른 것으로 대체할 수도 있을 때  제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때장점  객체를 생성하는 코드를 분리하여 클라이언트 코드와 결합도를 낮출 수 있다.  제품 군을 쉽게 대체 할 수 있다.  단일 책임 원칙 준수  개방 / 폐쇄 원칙 준수단점  각 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에 객체가 늘어날때 마다 클래스가 증가하여 코드의 복잡성이 증가한다. (팩토리 패턴의 공통적인 문제점)  기존 추상 팩토리의 세부사항이 변경되면 모든 팩토리에 대한 수정이 필요해진다. 이는 추상 팩토리와 모든 서브클래스의 수정을 가져온다.  새로운 종류의 제품을 지원하는 것이 어렵다. 새로운 제품이 추가되면 팩토리 구현 로직 자체를 변경해야한다.",
        "url": "//2024/05/19/deisgn-pattern-11-AbstractFactory.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-10-proxy-html": {
        "title": "[deisgn Pattern] 10 Proxy",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ProxyProxy프록시 패턴(Proxy Pattern)은 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 행동 패턴이다.프록시(Proxy)의 사전적인 의미는 ‘대리인’이라는 뜻이다. 즉, 누군가에게 어떤 일을 대신 시키는 것을 의미하는데, 이를 객체 지향 프로그래밍에 접목해보면 클라이언트가 대상 객체를 직접 쓰는게 아니라 중간에 프록시(대리인)을 거쳐서 쓰는 코드 패턴이라고 보면 된다. 따라서 대상 객체(Subject)의 메소드를 직접 실행하는 것이 아닌, 대상 객체에 접근하기 전에 프록시(Proxy) 객체의 메서드를 접근한 후 추가적인 로직을 처리한뒤 접근하게 된다.이런 방법을 사용하는 이유는 대상 클래스가 민감한 정보를 가지고 있거나 인스턴스화 하기에 무겁거나 추가 기능을 가미하고 싶은데, 원본 객체를 수정할 수 없는 상황일 때를 극복하기 위해서다.  안(Security) : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달한다.  캐싱(Caching) : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.  데이터 유효성 검사(Data validation) : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.  지연 초기화(Lazy initialization) : 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할때까지 연기할 수 있다.  로깅(Logging) : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.  원격 객체(Remote objects) : 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 할 수 있다.패턴 구조  Subject : Proxy와 RealSubject를 하나로 묶는 인터페이스 (다형성)          대상 객체와 프록시 역할을 동일하게 하는 추상 메소드 operation() 를 정의한다.      인터페이스가 있기 때문에 클라이언트는 Proxy 역할과 RealSubject 역할의 차이를 의식할 필요가 없다.        RealSubject : 원본 대상 객체  Proxy : 대상 객체(RealSubject)를 중계할 대리자 역할          프록시는 대상 객체를 합성(composition)한다.      프록시는 대상 객체와 같은 이름의 메서드를 호출하며, 별도의 로직을 수행 할수 있다 (인터페이스 구현 메소드)      프록시는 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안 된다.        Client : Subject 인터페이스를 이용하여 프록시 객체를 생성해 이용.          클라이언트는 프록시를 중간에 두고 프록시를 통해서 RealSubject와 데이터를 주고 받는다.      종류일반 프록시interface ISubject {    void action();}class RealSubject implements ISubject {    public void action() {        System.out.println(\"원본 객체 액션 !!\");    }}class Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {        this.subject = subject;    }    public void action() {        subject.action(); // 위임        /* do something */        System.out.println(\"프록시 객체 액션 !!\");    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}가상 프록시  지연 초기화 방식  가끔 필요하지만 항상 메모리에 적재되어 있는 무거운 서비스 객체가 있는 경우  이 구현은 실제 객체의 생성에 많은 자원이 소모 되지만 사용 빈도는 낮을 때 쓰는 방식이다.      서비스가 시작될 때 객체를 생성하는 대신에 객체 초기화가 실제로 필요한 시점에 초기화될수 있도록 지연할 수 있다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy() {  }    public void action() {  \t// 프록시 객체는 실제 요청(action(메소드 호출)이 들어 왔을 때 실제 객체를 생성한다.      if(subject == null){          subject = new RealSubject();      }      subject.action(); // 위임      /* do something */      System.out.println(“프록시 객체 액션 !!”);  }}  class Client {    public static void main(String[] args) {        ISubject sub = new Proxy();        sub.action();    }}## 보호 프록시- 프록시가 대상 객체에 대한 자원으로의 엑세스 제어(접근 권한)- 특정 클라이언트만 서비스 객체를 사용할 수 있도록 하는 경우- 프록시 객체를 통해 클라이언트의 자격 증명이 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있게 한다.```javaclass Proxy implements ISubject {    private RealSubject subject; // 대상 객체를 composition    boolean access; // 접근 권한    Proxy(RealSubject subject, boolean access) {        this.subject = subject;        this.access = access;    }    public void action() {        if(access) {            subject.action(); // 위임            /* do something */            System.out.println(\"프록시 객체 액션 !!\");        }    }}class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject(), false);        sub.action();    }}로깅 프록시  대상 객체에 대한 로깅을 추가하려는 경우      프록시는 서비스 메서드를 실행하기 전달하기 전에 로깅을 하는 기능을 추가하여 재정의한다.```javaclass Proxy implements ISubject {  private RealSubject subject; // 대상 객체를 composition    Proxy(RealSubject subject) {      this.subject = subject;  }    public void action() {      System.out.println(“로깅………………”);      subject.action(); // 위임  /* do something */  System.out.println(\"프록시 객체 액션 !!\");  System.out.println(\"로깅..................\");   } }      class Client {    public static void main(String[] args) {        ISubject sub = new Proxy(new RealSubject());        sub.action();    }}```원격 프록시  프록시 클래스는 로컬에 있고, 대상 객체는 원격 서버에 존재하는 경우  프록시 객체는 네트워크를 통해 클라이언트의 요청을 전달하여 네트워크와 관련된 불필요한 작업들을 처리하고 결과값만 반환  클라이언트 입장에선 프록시를 통해 객체를 이용하는 것이니 원격이든 로컬이든 신경 쓸 필요가 없으며, 프록시는 진짜 객체와 통신을 대리하게 된다캐싱 프록시  데이터가 큰 경우 캐싱하여 재사용을 유도  클라이언트 요청의 결과를 캐시하고 이 캐시의 수명 주기를 관리특징사용 시기  접근을 제어하거가 기능을 추가하고 싶은데, 기존의 특정 객체를 수정할 수 없는 상황일때  초기화 지연, 접근 제어, 로깅, 캐싱 등, 기존 객체 동작에 수정 없이 가미하고 싶을 때장점  개방 폐쇄 원칙(OCP) 준수          기존 대상 객체의 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.        단일 책임 원칙(SRP) 준수          대상 객체는 자신의 기능에만 집중 하고, 그 이외 부가 기능을 제공하는 역할을 프록시 객체에 위임하여 다중 책임을 회피 할 수 있다.        원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행하는데 유용하다  클라이언트는 객체를 신경쓰지 않고, 서비스 객체를 제어하거나 생명 주기를 관리할 수 있다.  사용자 입장에서는 프록시 객체나 실제 객체나 사용법은 유사하므로 사용성에 문제 되지 않는다.단점  많은 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가한다.          예를들어 여러 클래스에 로깅 기능을 가미 시키고 싶다면, 동일한 코드를 적용함에도 각각의 클래스에 해당되는 프록시 클래스를 만들어서 적용해야 되기 때문에 코드량이 많아지고 중복이 발생 된다.      자바에서는 리플렉션에서 제공하는 동적 프록시(Dynamic Proxy) 기법을 이용해서 해결할 수 있다. (후술)        프록시 클래스 자체에 들어가는 자원이 많다면 서비스로부터의 응답이 늦어질 수 있다.",
        "url": "//2024/05/19/deisgn-pattern-10-Proxy.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-09-adaptor-html": {
        "title": "[deisgn Pattern] 09 Adaptor",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - AdaptorAdaptor어댑터 패턴(Adaptor Pattern) 이란 이름 그대로 클래스를 어댑터로서 사용되는 구조 패턴이다.이를 객체 지향 프로그래밍에 접목해보면, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해주도록 변환 역할을 해주는 행동 패턴이라고 보면 된다. 예를들어 기존에 있는 시스템에 새로운 써드파티 라이브러리를 추가하고 싶거나, Legacy 인터페이스를 새로운 인터페이스로 교체하는 경우에 어댑터 패턴을 사용하면 코드의 재사용성을 높일 수 있다.즉, 어댑터란 이미 구축되어 있는 것을 새로운 어떤것에 사용할때 양 쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로서, 기존 시스템에서 새로운 기능을 사용하려고 할때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할수 있다고 보면 된다.구조Adapter 패턴에는 기존 시스템의 클래스를 상속(Inheritance) 해서 호환 작업을 해주냐, 합성(Composition)해서 호환 작업을 해주냐에 따라, 두 가지 패턴 방법으로 나뉘게 된다.객체 어댑터(Object Adaptor)  합성(Composition)된 맴버에게 위임을 이용한 어댑터 패턴 (추천 🌟)  자기가 해야 할 일을 클래스 맴버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다.  합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다.  Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Client Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Object Adaptor 방식에선 합성을 이용해 구성한다.      Adaptee(Service)를 따로 클래스 멤버로 설정하고 위임을 통해 동작을 매치시킨다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter implements Target {    Service adaptee; // composition으로 Service 객체를 클래스 필드로// 어댑터가 인스턴스화되면 호환시킬 기존 서비스를 설정Adapter(Service adaptee) {    this.adaptee = adaptee;}// 어댑터의 메소드가 호출되면, Adaptee의 메소드를 호출하도록public void method(int data) {    adaptee.specificMethod(data); // 위임} } ```클래스 어댑터(Class Adaptor)  클래스 상속을 이용한 어댑터 패턴  Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.  상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 전반적으로 권장하지는 않는 방법이다.  Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리  Target(Cient Interface) : Adapter 가 구현하는 인터페이스.  Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.          Class Adaptor 방식에선 상속을 이용해 구성한다.      Existing Class와 Adaptee(Service) 를 동시에 implements, extends 하여 구현한다.            Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.```java// Adaptee : 클라이언트에서 사용하고 싶은 기존의 서비스 (하지만 호환이 안되서 바로 사용 불가능)class Service {    void specificMethod(int specialData) {      System.out.println(“기존 서비스 기능 호출 + “ + specialData);  }}  // Client Interface : 클라이언트가 접근해서 사용할 고수준의 어댑터 모듈interface Target {    void method(int data);}// Adapter : Adaptee 서비스를 클라이언트에서 사용하게 할 수 있도록 호환 처리 해주는 어댑터class Adapter extends Service implements Target {// 어댑터의 메소드가 호출되면, 부모 클래스 Adaptee의 메소드를 호출public void method(int data) {    specificMethod(data);} } ```특징사용 시기  레거시 코드를 사용하고 싶지만 새로운 인터페이스가 레거시 코드와 호환되지 않을 때  이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때  이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조할때  소프트웨어의 구 버전과 신 버전을 공존시키고 싶을때장점  프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있기 때문에 단일 책임 원칙(SRP)을 만족한다.  기존 클래스 코드를 건들지 않고 클라이언트 인터페이스를 통해 어댑터와 작동하기 때문에 개방 폐쇄 원칙(OCP)을 만족한다.  만일 추가로 필요한 메소드가 있다면 어댑터에 빠르게 만들 수 있다. 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 쉬워진다.단점  새로운 인터페이스와 어댑터 클래스 세트를 도입해야 하기 때문에 코드의 복잡성이 증가한다.  때로는 직접 서비스(Adaptee) 클래스를 변경하는것이 간단할수 있는 경우가 있기 때문에 신중히 선택하여야 한다.실제 사용 예시  java.util.Arrays 의 asList()  java.util.Collections 의 list()  java.util.Collections 의 enumeration()  java.io.InputStreamReader(InputStream) (returns a Reader)  java.io.OutputStreamWriter(OutputStream) (returns a Writer)  jakarta.xml.bind.annotation.adapters.XmlAdapter 의 marshal() and unmarshal()",
        "url": "//2024/05/19/deisgn-pattern-09-Adaptor.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-08-decorator-html": {
        "title": "[deisgn Pattern] 08 Decorator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - DecoratorDecorator데코레이터 패턴(Decorator Pattern)은 대상 객체에 대한 기능 확장이나 변경이 필요할때 객체의 결합을 통해 서브클래싱 대신 쓸수 있는 유연한 대안 구조 패턴이다.Decorator을 해석하자면 ‘장식자’ 라는 의미를 가지고 있는데,  마치 기본 제품에 포장지나 외부 디자인을 살짝 변경해 줌으로써 새로운 기능을 부여하는 것과 같이,객체 지향 프로그래밍에서 원본 객체에 대해서 무언가를 장식하여 더 멋진 기능을 가지게 만드는 것이기 때문에 이 명칭이 붙었다고 보면 된다.데코레이터 패턴을 이용하면 필요한 추가 기능의 조합을 런타임에서 동적으로 생성할 수 있다. 데코레이터할 대상 객체를 새로운 행동들을 포함한 특수 장식자 객체에 넣어서 행동들을 해당 장식자 객체마다 연결시켜, 서브클래스로 구성할때 보다 훨씬 유연하게 기능을 확장 할 수 있다. 그리고 기능을 구현하는 클래스들을 분리함으로써 수정이 용이해진다  Component (Interface) : 원본 객체와 장식된 객체 모두를 묶는 역할  ConcreteComponent : 원본 객체 (데코레이팅 할 객체)  Decorator : 추상화된 장식자 클래스          원본 객체를 합성(composition)한 wrappee 필드와 인터페이스의 구현 메소드를 가지고 있다        ConcreteDecorator : 구체적인 장식자 클래스          부모 클래스가 감싸고 있는 하나의 Component를 호출하면서 호출 전/후로 부가적인 로직을 추가할 수 있다.      흐름// 원본 객체와 장식된 객체 모두를 묶는 인터페이스interface IComponent {    void operation();}// 장식될 원본 객체class ConcreteComponent implements IComponent {    public void operation() {    }}// 장식자 추상 클래스abstract class Decorator implements IComponent {    IComponent wrappee; // 원본 객체를 composition    Decorator(IComponent component) {        this.wrappee = component;    }    public void operation() {        wrappee.operation(); // 위임    }}// 장식자 클래스class ComponentDecorator1 extends Decorator {    ComponentDecorator1(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}class ComponentDecorator2 extends Decorator {    ComponentDecorator2(IComponent component) {        super(component);    }    public void operation() {        super.operation(); // 원본 객체를 상위 클래스의 위임을 통해 실행하고        extraOperation(); // 장식 클래스만의 메소드를 실행한다.    }    void extraOperation() {    }}패턴사용 시기  객체 책임과 행동이 동적으로 상황에 따라 다양한 기능이 빈번하게 추가/삭제되는 경우  객체의 결합을 통해 기능이 생성될 수 있는 경우  객체를 사용하는 코드를 손상시키지 않고 런타임에 객체에 추가 동작을 할당할 수 있어야 하는 경우  상속을 통해 서브클래싱으로 객체의 동작을 확장하는 것이 어색하거나 불가능 할 때장점  데코레이터를 사용하면 서브클래스를 만들때보다 훨씬 더 유연하게 기능을 확장할 수 있다.  객체를 여러 데코레이터로 래핑하여 여러 동작을 결합할 수 있다.  컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.  각 장식자 클래스마다 고유의 책임을 가져 단일 책임 원칙(SRP)을 준수  클라이언트 코드 수정없이 기능 확장이 필요하면 장식자 클래스를 추가하면 되니 개방 폐쇄 원칙(OCP)을 준수  구현체가 아닌 인터페이스를 바라봄으로써 의존 역전 원칙(DIP) 준수단점  만일 장식자 일부를 제거하고 싶다면, Wrapper 스택에서 특정 wrapper를 제거하는 것은 어렵다.  데코레이터를 조합하는 초기 생성코드가 보기 안좋을 수 있다. new A(new B(new C(new D())))  어느 장식자를 먼저 데코레이팅 하느냐에 따라 데코레이터 스택 순서가 결정지게 되는데, 만일 순서에 의존하지 않는 방식으로 데코레이터를 구현하기는 어렵다.",
        "url": "//2024/05/19/deisgn-pattern-08-Decorator.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-07-observer-html": {
        "title": "[deisgn Pattern] 07 Observer",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ObserverObserver옵저버 패턴(Observer Pattern)은 옵저버(관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 패턴이다.옵저버 패턴은 여타 다른 디자인 패턴들과 다르게 일대다(one-to-many) 의존성을 가지는데, 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. Pub/Sub(발행/구독) 모델로도 알려져 있다.  ISubject : 관찰 대상자를 정의하는 인터페이스  ConcreteSubject : 관찰 당하는 대상자 / 발행자 / 게시자          Observer들을 리스트(List, Map, Set ..등)로 모아 합성(compositoin)하여 가지고 있음      Subject의 역할은 관찰자인 Observer들을 내부 리스트에 등록/삭제 하는 인프라를 갖고 있다. (register, remove)      Subject가 상태를 변경하거나 어떤 동작을 실행할때, Observer 들에게 이벤트 알림(notify)을 발행한다.        IObserver : 구독자들을 묶는 인터페이스 (다형성)  Observer : 관찰자 / 구독자 / 알림 수신자.          Observer들은 Subject가 발행한 알림에 대해 현재 상태를 취득한다.      Subject의 업데이트에 대해 전후 정보를 처리한다.      흐름// 관찰 대상자 / 발행자interface ISubject {    void registerObserver(IObserver o);    void removeObserver(IObserver o);    void notifyObserver();}class ConcreteSubject implements ISubject {    // 관찰자들을 등록하여 담는 리스트    List&lt;IObserver&gt; observers = new ArrayList&lt;&gt;();    // 관찰자를 리스트에 등록    @Override    public void registerObserver(IObserver o) {        observers.add(o);        System.out.println(o + \" 구독 완료\");    }    // 관찰자를 리스트에 제거    @Override    public void removeObserver(IObserver o) {        observers.remove(o);        System.out.println(o + \" 구독 취소\");    }    // 관찰자에게 이벤트 송신    @Override    public void notifyObserver() {        for(IObserver o : observers) { // 관찰자 리스트를 순회하며            o.update(); // 위임        }    }}// 관찰자 / 구독자interface IObserver {  void update();}class ObserverA implements IObserver {  public void update() {    System.out.println(\"ObserverA 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverA\"; }}class ObserverB implements IObserver {  public void update() {    System.out.println(\"ObserverB 한테 이벤트 알림이 왔습니다.\");  }  public String toString() { return \"ObserverB\"; }}특징사용 시기  앱이 한정된 시간, 특정한 케이스에만 다른 객체를 관찰해야 하는 경우  대상 객체의 상태가 변경될 때마다 다른 객체의 동작을 트리거해야 할때  한 객체의 상태가 변경되면 다른 객체도 변경해야 할때. 그런데 어떤 객체들이 변경되어야 하는지 몰라도 될 때  MVC 패턴에서도 사용됨 (Model, View, Controller)          MVC의 Model과 View의 관계는 Observer 패턴의 Subject 역할과 Observer 역할의 관계에 대응된다.      하나의 Model에 복수의 View가 대응한다.      장점  Subject의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지할 수 있다.  발행자의 코드를 변경하지 않고도 새 구독자 클래스를 도입할 수 있어 개방 폐쇄 원칙(OCP)Visit Website 준수한다  런타임 시점에서에 발행자와 구독 알림 관계를 맺을 수 있다.  상태를 변경하는 객체(Subject)와 변경을 감지하는 객체(Observer)의 관계를 느슨하게 유지할 수 있다. (느슨한 결합)단점  구독자는 알림 순서를 제어할수 없고, 무작위 순서로 알림을 받음          하드 코딩으로 구현할수는 있겠지만, 복잡성과 결합성만 높아지기 때문에 추천되지는 않는 방법이다.        옵저버 패턴을 자주 구성하면 구조와 동작을 알아보기 힘들어져 코드 복잡도가 증가한다.  다수의 옵저버 객체를 등록 이후 해지하지 않는다면 메모리 누수가 발생할 수도 있다.",
        "url": "//2024/05/19/deisgn-pattern-07-Observer.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-06-iterator-html": {
        "title": "[deisgn Pattern] 06 Iterator",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - IteratorIterator반복자(Iterator) 패턴은 일련의 데이터 집합에 대하여 순차적인 접근(순회)을 지원하는 패턴이다.데이터 집합이란 객체들을 그룹으로 묶어 자료의 구조를 취하는 컬렉션을 말한다. 대표적인 컬렉션으로 한번쯤은 들어본 리스트나 트리, 그래프, 테이블 등이 있다.  Aggregate (인터페이스) : ConcreateIterator 객체를 반환하는 인터페이스를 제공한다.          iterator() : ConcreateIterator 객체를 만드는 팩토리 메서드        ConcreateAggregate (클래스) : 여러 요소들이 이루어져 있는 데이터 집합체  Iterator (인터페이스) : 집합체 내의 요소들을 순서대로 검색하기 위한 인터페이스를 제공한다.          hasNext() : 순회할 다음 요소가 있는지 확인 (true / false)      next() : 요소를 반환하고 다음 요소를 반환할 준비를 하기 위해 커서를 이동시킴        ConcreateIterator (클래스) : 반복자 객체          ConcreateAggregate가 구현한 메서드로부터 생성되며, ConcreateAggregate 의 컬렉션을 참조하여 순회한다.      어떤 전략으로 순회할지에 대한 로직을 구체화 한다      흐름// 집합체 객체 (컬렉션)interface Aggregate {    Iterator iterator();}class ConcreteAggregate implements Aggregate {    Object[] arr; // 데이터 집합 (컬렉션)    int index = 0;    public ConcreteAggregate(int size) {        this.arr = new Object[size];    }    public void add(Object o) {        if(index &lt; arr.length) {            arr[index] = o;            index++;        }    }    // 내부 컬렉션을 인자로 넣어 이터레이터 구현체를 클라이언트에 반환    @Override    public Iterator iterator() {        return new ConcreteIterator(arr);    }}// 반복체 객체interface Iterator {    boolean hasNext();    Object next();}class ConcreteIterator implements Iterator {    Object[] arr;    private int nextIndex = 0; // 커서 (for문의 i 변수 역할)    // 생성자로 순회할 컬렉션을 받아 필드에 참조 시킴    public ConcreteIterator(Object[] arr) {        this.arr = arr;    }    // 순회할 다음 요소가 있는지 true / false    @Override    public boolean hasNext() {        return nextIndex &lt; arr.length;    }    // 다음 요소를 반환하고 커서를 증가시켜 다음 요소를 바라보도록 한다.    @Override    public Object next() {        return arr[nextIndex++];    }}특징사용 시기  컬렉션에 상관없이 객체 접근 순회 방식을 통일하고자 할 때  컬렉션을 순회하는 다양한 방법을 지원하고 싶을 때  컬렉션의 복잡한 내부 구조를 클라이언트로 부터 숨기고 싶은 경우 (편의 + 보안)  데이터 저장 컬렉션 종류가 변경 가능성이 있을 때          클라이언트가 집합 객체 내부 표현 방식을 알고 있다면, 표현 방식이 달라지면 클라이언트 코드도 변경되어야 하는 문제가 생긴다.      장점  일관된 이터레이터 인터페이스를 사용해 여러 형태의 컬렉션에 대해 동일한 순회 방법을 제공한다.  컬렉션의 내부 구조 및 순회 방식을 알지 않아도 된다.  집합체의 구현과 접근하는 처리 부분을 반복자 객체로 분리해 결합도를 줄 일 수 있다.          Client에서 iterator로 접근하기 때문에 ConcreteAggregate 내에 수정 사항이 생겨도 iterator에 문제가 없다면 문제가 발생하지 않는다.        순회 알고리즘을 별도의 반복자 객체에 추출하여 각 클래스의 책임을 분리하여 단일 책임 원칙(SRP)를 준수한다.  데이터 저장 컬렉션 종류가 변경되어도 클라이언트 구현 코드는 손상되지 않아 수정에는 닫혀 있어 개방 폐쇄 원칙(OCP)를 준수한다단점  클래스가 늘어나고 복잡도가 증가한다.          만일 앱이 간단한 컬렉션에서만 작동하는 경우 패턴을 적용하는 것은 복잡도만 증가할 수 있다.      이터레이터 객체를 만드는 것이 유용한 상황인지 판단할 필요가 있다.        구현 방법에 따라 캡슐화를 위배할 수 있다.실제 예제  java.util.Enumeration 과 java.util.Iterator  Java StAX (Streaming API for XML)의 Iterator 기반 API          XmlEventReader, XmlEventWriter      ",
        "url": "//2024/05/19/deisgn-pattern-06-Iterator.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-05-facade-html": {
        "title": "[deisgn Pattern] 05 Facade",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FacadeFacade퍼사드 패턴(Facade Pattern)은 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스(API)를 구성하기 위한 구조 패턴이다.이처럼 파사드는 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 제공하려는 목적이라고 생각하면 된다.  Facade라는 단어의 뜻은 건축물의 정면을 의미한다.건축물의 정면은 보통 건축물의 이미지와 건축 의도를 나타내기 때문에 오래 전부터 특별한 디자인을 적용하여 의미를 부여했다.이처럼 건축물 정면만 봐도 이 건물이 어떤 목적을 하는지 단번에 알수 있다는 특징을 차용하여 명명 지은 것이다.  Facade : 서브시스템 기능을 편리하게 사용할 수 있도록 하기 위해 여러 시스템과 상호 작용하는 복잡한 로직을 재정리해서 높은 레벨의 인터페이스를 구성한다. Facade 역할은 서브 시스템의 많은 역할에 대해 ‘단순한 창구’가 된다. 클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않도록 한다.  Additional Facade : 퍼사드 클래스는 반드시 한개만 존재해야 한다는 규칙같은 건 없다. 연관 되지 않은 기능이 있다면 얼마든지 퍼사드 2세로 분리한다. 이 퍼사드 2세는 다른 퍼사드에서 사용할 수도 있고 클라이언트에서 직접 접근할 수도 있다.  SubSystem(하위 시스템) : 수십 가지 라이브러리 혹은 클래스들  Client : 서브 시스템에 직접 접근하는 대신 Facade를 사용한다.퍼사드 패턴은 전략 패턴이나 팩토리 패턴과 같은 여타 다른 디자인 패턴과는 다르게 클래스 구조가 정형화 되지 않은 패턴이다.반드시 클래스 위치는 어떻고 어떤 형식으로 위임을 해야되고 이런것이 없다. 그냥 퍼사드 클래스를 만들어 적절히 기능 집약해주는 논리라고 생각하면 된다.재귀적 Facade 패턴의 적용재귀적 퍼사드란 Additional Facade 를 말하는 것이다. 예를 들어 다수의 클래스, 다수의 패키지를 포함하고 있는 큰 시스템에 요소 마다 Facade 패턴을 여기 저기 적용하고 다시 그 Facade를 합친 Facade를 만드는 식으로,퍼사드를 재귀적으로 구성하면 시스템은 보다 편리하게 된다. 이처럼 퍼사드는 한 개만 있으라는 법은 없으며 필요에 의하면 얼마든지 늘려서 의존할 수 있다.특징사용 시기  시스템이 너무 복잡할때  그래서 간단한 인터페이스를 통해 복잡한 시스템을 접근하도록 하고 싶을때  시스템을 사용하고 있는 외부와 결합도가 너무 높을 때 의존성 낮추기 위할때장점  하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템을 사용하기 쉬워진다.  하위 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있다.  복잡한 코드를 감춤으로써, 클라이언트가 시스템의 코드를 모르더라도 Facade 클래스만 이해하고 사용 가능하다  외부에서 내부 로직을 직접 사용하기 때문에 내부 로직의 구조를 변경한다고 하거나 파라미터나 리턴값 등을 변경할 경우 직접적으로 영향을 받아 수정이 힘들거나불가능한 경우가 종종 있다. 하지만 중간에 매개체 역할을 해주는 퍼사드 객체가 있기 때문에 실제 내부 로직이 어떻게 변경이 되더라도 상관이 없어지므로 의존성이 감소된다.단점  퍼사드가 앱의 모든 클래스에 결합된 최상위 객체가 될 수 있다  퍼사드 클래스 자체가 서브시스템에 대한 의존성을 가지게 되어 의존성을 완전히는 피할 수는 없다.",
        "url": "//2024/05/19/deisgn-pattern-05-Facade.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-04-builder-html": {
        "title": "[deisgn Pattern] 04 Builder",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - BuilderBuilder빌더 패턴(Builder Pattern)은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성하는 방식이다.1. 점층적 생성자 패턴우리가 다양한 매개변수를 입력받아 인스턴스를 생성하고 싶을때 사용하던 생성자를 오버로딩 하는 방식이다.문제는 타입이 다양할수록 생성자 메서드 수가 기하급수적으로 늘어나 가독성이나 유지보수 측면에서 좋지 않다.2. 자바 빈(Java Beans) 패턴이러한 단점을 보완하기 위해 Setter 메소드를 사용한 자바 빈(Bean) 패턴이 고안 되었다.매개변수가 없는 생성자로 객체 생성후 Setter 메소드를 이용해 클래스 필드의 초깃값을 설정하는 방식이다기존 생성자 오버로딩에서 나타났던 가독성 문제점이 사라지고 선택적인 파라미터에 대해 해당되는 Setter 메서드를 호출함으로써 유연적으로 객체 생성이 가능해졌다.하지만 이러한 방식은 객체 생성 시점에 모든 값들을 주입 하지 않아 일관성(consistency) 문제와 불변성(immutable) 문제가 나타나게 된다.1) 일관성 문제필수 매개변수란 객체가 초기화될때 반드시 설정되어야 하는 값이다. 하지만 개발자가 깜빡하고 set~() 메서드를 호출하지 않았다면 이 객체는 일관성이 무너진 상태가 된다. 즉, 객체가 유효하지 않은 것이다. 만일 다른곳에서 햄버거 인스턴스를 사용하게 된다면 런타임 예외가 발생할 수도 있다.이는 객체를 생성하는 부분과 값을 설정하는 부분이 물리적으로 떨어져 있어서 발생하는 문제점이다.물론 이는 어느정도 생성자(Constructor)와 결합하여 극복은 할 수 있다.하지만 다음에 소개할 불변성의 문제 때문에 자바 빈즈 패턴은 지양해야 한다.2) 불변성 문제자바 빈즈 패턴의 Setter 메서드는 객체를 처음 생성할때 필드값을 설정하기 위해 존재하는 메서드이다.하지만 객체를 생성했음에도 여전히 외부적으로 Setter 메소드를 노출하고 있으므로, 협업 과정에서 언제 어디서 누군가 Setter 메서드를 호출해 함부로 객체를 조작할수 있게 된다. 이것을 불변함을 보장할 수 없다고 얘기한다.Builder 패턴빌더 패턴은 이러한 문제들을 해결하기 위해 별도의 Builder 클래스를 만들어 메소드를 통해 step-by-step 으로 값을 입력받은 후에 최종적으로 build() 메소드로 하나의 인스턴스를 생성하여 리턴하는 패턴이다.빌더 패턴 사용법을 잠시 살펴보면, StudentBuilder 빌더 클래스의 메서드를 체이닝(Chaining) 형태로 호출함으로써 자연스럽게 인스턴스를 구성하고 마지막에 build() 메서드를 통해 최종적으로 객체를 생성하도록 되어있음을 볼 수 있다.패턴 구조class Student {    private int id;    private String name = \"아무개\";    private String grade = \"freshman\";    private String phoneNumber = \"010-0000-0000\";    public Student(int id, String name, String grade, String phoneNumber) {        this.id = id;        this.name = name;        this.grade = grade;        this.phoneNumber = phoneNumber;    }        @Override    public String toString() {        return \"Student { \" +                \"id='\" + id + '\\'' +                \", name=\" + name +                \", grade=\" + grade +                \", phoneNumber=\" + phoneNumber +                \" }\";    }    public static class StudentBuilder {        private int id;        private String name;        private String grade;        private String phoneNumber;        public StudentBuilder id(int id) {            this.id = id;            return this;        }        public StudentBuilder name(String name) {            this.name = name;            return this;        }        public StudentBuilder grade(String grade) {            this.grade = grade;            return this;        }        public StudentBuilder phoneNumber(String phoneNumber) {            this.phoneNumber = phoneNumber;            return this;        }             public Student build() {            return new Student(id, name, grade, phoneNumber); // Student 생성자 호출        }    }}빌더 네이밍  멤버이름()  set멤버이름()  with멤버이름()장점  객체 생성 과정을 일관된 프로세스로 표현  디폴트 매개변수 생략을 간접적으로 지원  필수 멤버와 선택적 멤버를 분리 가능  객체 생성 단계를 지연할 수 있다.  초기화 검증을 멤버별로 분리할 수 있다.  멤버에 대한 변경 가능성 최소화를 추구한다.단점  코드 복잡성 증가  생성자보다 성능이 떨어짐Simple Builderclass Person {    // final 키워드로 필드들을 불변 객체로 만든다.    private final String name;    private final String age;    private final String gender;    private final String job;    private final String birthday;    private final String address;    // 정적 내부 빌더 클래스    public static class Builder {        // 필수 파라미터        private final String name;        private final String age;        // 선택 파라미터        private String gender;        private String job;        private String birthday;        private String address;        // 필수 파라미터는 빌더 생성자로 받게 한다        public Builder(String name, String age) {            this.name = name;            this.age = age;        }        // 선택 파라미터는 각 메서드를 통해 정의한다        public Builder gender(String gender) {            this.gender = gender;            return this;        }        public Builder job(String job) {            this.job = job;            return this;        }        public Builder birthday(String birthday) {            this.birthday = birthday;            return this;        }        public Builder address(String address) {            this.address = address;            return this;        }        // 대상 객체의 private 생성자를 호출하여 최종 인스턴스화 한다        public Person build() {            return new Person(this); // 빌더 객체 자신을 넘긴다.        }    }    // private 생성자 - 생성자는 외부에서 호출되는것이 아닌 빌더 클래스에서만 호출되기 때문에    private Person(Builder builder) {        this.name = builder.name;        this.age = builder.age;        this.gender = builder.gender;        this.job = builder.gender;        this.birthday = builder.birthday;        this.address = builder.address;    }    @Override    public String toString() {        return \"Person{\" +                \"name='\" + name + '\\'' +                \", age='\" + age + '\\'' +                \", gender='\" + gender + '\\'' +                \", job='\" + job + '\\'' +                \", birthday='\" + birthday + '\\'' +                \", address='\" + address + '\\'' +                '}';    }}Director BuilderGOF에서 정의하고 있는 디자인 패턴은 복잡한 객체의 생성 알고리즘과 조립 방법을 분리하여 빌드 공정을 구축하는것이 목적이다. 빌더를 받아 조립 방법을 정의한 클래스를 Director라고 부른다.class Data {    private String name;    private int age;    public Data(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}abstract class Builder {    // 상속한 자식 클래스에서 사용하도록 protected 접근제어자 지정    protected Data data;    public Builder(Data data) {        this.data = data;    }    // Data 객체의 데이터들을 원하는 형태의 문자열 포맷을 해주는 메서드들 (머리 - 중간 - 끝 형식)    public abstract String head();    public abstract String body();    public abstract String foot();}// Data 데이터들을 평범한 문자열로 변환해주는 빌더class PlainTextBuilder extends Builder {    public PlainTextBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"Name: \");        sb.append(data.getName());        sb.append(\", Age: \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\";    }}// Data 데이터들을 JSON 형태의 문자열로 변환해주는 빌더class JSONBuilder extends Builder {    public JSONBuilder(Data data) {        super(data);    }    @Override    public String head() {        return \"{\\n\";    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t\\\"Name\\\" : \");        sb.append(\"\\\"\" + data.getName() + \"\\\",\\n\");        sb.append(\"\\t\\\"Age\\\" : \");        sb.append(data.getAge());        return sb.toString();    }    @Override    public String foot() {        return \"\\n}\";    }}// Data 데이터들을 XML 형태의 문자열로 변환해주는 빌더class XMLBuilder extends Builder {    public XMLBuilder(Data data) {        super(data);    }    @Override    public String head() {        StringBuilder sb = new StringBuilder();        sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?&gt;\\n\");        sb.append(\"&lt;DATA&gt;\\n\");        return sb.toString();    }    @Override    public String body() {        StringBuilder sb = new StringBuilder();        sb.append(\"\\t&lt;NAME&gt;\");        sb.append(data.getName());        sb.append(\"&lt;NAME&gt;\");        sb.append(\"\\n\\t&lt;AGE&gt;\");        sb.append(data.getAge());        sb.append(\"&lt;AGE&gt;\");        return sb.toString();    }    @Override    public String foot() {        return \"\\n&lt;/DATA&gt;\";    }}// 각 문자열 포맷 빌드 과정을 템플릿화 시킨 디렉터class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    // 일종의 빌드 템플릿 메서드라 보면 된다    public String build() {        StringBuilder sb = new StringBuilder();        // 빌더 구현체에서 정의한 생성 알고리즘이 실행됨        sb.append(builder.head());        sb.append(builder.body());        sb.append(builder.foot());        return sb.toString();    }}Lombok의 @Builder/ @SuperBuilder클래스에 @Builder 어노테이션만 붙여주면 클래스를 컴파일 할 때 자동으로 클래스 내부에 빌더 API가 만들어진다. 롬복의 @Builder는 GOF의 디렉터 빌더가 아닌 심플 빌더 패턴을 다룬다실무 예제  java.lang.StringBuilder의 append()  java.lang.StringBuffer의 append()  java.nio.ByteBuffer의 put() - CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer 도 마찬가지  javax.swing.GroupLayout.Group의 addComponent()  java.lang.Appendable의 구현체  java.util.stream.Stream.Builder",
        "url": "//2024/05/19/deisgn-pattern-04-Builder.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-03-flyweight-html": {
        "title": "[deisgn Pattern] 03 Flyweight",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - FlyWeightFlyWeight플라이웨이트 패턴(Flyweight Pattern)은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴이다.간단히 말하면 캐시(Cache) 개념을 코드로 패턴화 한것으로 보면 되는데, 자주 변화는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식이다. 그래서 동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 최적화를 노리는 경량 패턴이라고도 불린다.  Flyweight : 경량 객체를 묶는 인터페이스.  ConcreteFlyweight : 공유 가능하여 재사용되는 객체 (intrinsic state)  UnsahredConcreteFlyweight : 공유 불가능한 객체 (extrinsic state)  FlyweightFactory : 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스          GetFlyweight() 메서드는 팩토리 메서드 역할을 한다고 보면 된다.      만일 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다        Client : 클라이언트는 FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다.intrinsic 와 extrinsic 상태플라이웨이트 패턴에서 가장 주의 깊게 보아야 할 점이 바로 Intrinsic와 Extrinsic의 상태를 구분하는 것이다.intrinsic란 ‘고유한, 본질적인’ 이라는 의미를 가진다. 본질적인 상태란 인스턴스가 어떠한 상황에서도 변하지 않는 정보를 말한다. 그래서 값이 고정되어 있기에 충분히 언제 어디서 공유해도 문제가 없게 된다.extrinsic이란 ‘외적인, 비본질적인’ 이라는 의미를 가진다. 인스턴스를 두는 장소나 상황에 따라서 변화하는 정보를 말한다. 그래서 값이 언제 어디서 변화할지 모르기 때문에 이를 캐시해서 공유할수 는 없다.  intrinsic한 객체 : 장소나 상황에 의존하지 않기 때문에 값이 고정되어 공유할 수 있는 객체  extrinsic한 객체 : 장소나 상황에 의존하기 때문에 매번 값이 바뀌어 공유할 수 없는 객체flyWeight 패턴 특징사용 시기  어플리케이션에 의해 생성되는 객체의 수가 많아 저장 비용이 높아질 때  생성된 객체가 오래도록 메모리에 상주하며 사용되는 횟수가 많을때  공통적인 인스턴스를 많이 생성하는 로직이 포함된 경우  임베디드와 같이 메모리를 최소한으로 사용해야하는 경우에 활용장점  애플리케이션에서 사용하는 메모리를 줄일 수 있다.  프로그램 속도를 개선 할수 있다.          new로 인스턴스화를 하면 데이터가 생성되고 메모리에 적재 되는 미량의 시간이 걸리게 된다.      객체를 공유하면 인스턴스를 가져오기만 하면 되기 때문에 메모리 뿐만 아니라 속도도 향상시킬 수 있게 되는 것이다.        단점              코드 복잡도 증가예시class Memory {    public static long size = 0; // 메모리 사용량    public static void print() {        System.out.println(\"총 메모리 사용량 : \" + Memory.size + \"MB\");    }}// ConcreteFlyweight(intrinsic) - 플라이웨이트 객체는 불변성을 가져야한다. 변경되면 모든 것에 영향을 주기 때문이다.final class TreeModel {    // 메시, 텍스쳐 총 사이즈    long objSize = 90; // 90MB    String type; // 나무 종류    Object mesh; // 메쉬    Object texture; // 나무 껍질 + 잎사귀 텍스쳐    public TreeModel(String type, Object mesh, Object texture) {        this.type = type;        this.mesh = mesh;        this.texture = texture;        // 나무 객체를 생성하여 메모리에 적재했으니 메모리 사용 크기 증가        Memory.size += this.objSize;    }}// UnsahredConcreteFlyweight(extrinsic)class Tree {    // 죄표값과 나무 모델 참조 객체 크기를 합친 사이즈    long objSize = 10; // 10MB    // 위치 변수    double position_x;    double position_y;    // 나무 모델    TreeModel model;    public Tree(TreeModel model, double position_x, double position_y) {        this.model = model;        this.position_x = position_x;        this.position_y = position_y;        // 나무 객체를 생성하였으니 메모리 사용 크기 증가        Memory.size +=  this.objSize;    }}// Clientclass Terrain {    // 지형 타일 크기    static final int CANVAS_SIZE = 10000;    // 나무를 렌더릴    public void render(String type, Object mesh, Object texture, double position_x, double position_y) {        // 나무를 지형에 생성//        Tree tree = new Tree(//                type, // 나무 종류//                mesh, // mesh//                texture, // texture//                Math.random() * CANVAS_SIZE, // position_x//                Math.random() * CANVAS_SIZE // position_y//        );        // 1. 캐시 되어 있는 나무 모델 객체 가져오기        TreeModel model = TreeModelFactory.getInstance(type);        // 2. 재사용한 나무 모델 객체와 변화하는 속성인 좌표값으로 나무 생성        Tree tree = new Tree(model, position_x, position_y);        출처: https://inpa.tistory.com/entry/GOF-💠-Flyweight-패턴-제대로-배워보자 [Inpa Dev 👨‍💻:티스토리]        System.out.println(\"x:\" + tree.position_x + \" y:\" + tree.position_y + \" 위치에 \" + type + \" 나무 생성 완료\");    }}public static void main(String[] args) {        // 지형 생성        Terrain terrain = new Terrain();        // 지형에 Oak 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Oak\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Acacia 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Acacia\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 지형에 Jungle 나무 5 그루 생성        for (int i = 0; i &lt; 5; i++) {            terrain.render(                    \"Jungle\", // type                    new Object(), // mesh                    new Object(), // texture                    Math.random() * Terrain.CANVAS_SIZE, // position_x                    Math.random() * Terrain.CANVAS_SIZE // position_y            );        }        // 총 메모리 사용률 출력        Memory.print();    }/** * 1. intrinsic 객체와 extrinsic 객체 쪼개기 * -&gt; 같은 객체를 여러 번 올릴 필요가 없기 때문에 공유되는 객체는 따로 빼둔다. *  * 2. Flyweight 팩토리 만들기 * -&gt; Flyweight Pool : HashMap 컬렉션을 통해 키와 나무 모델 객체를 저장하는 캐시 저장소 역할 * -&gt; getInstance : Pool에서 가져오고자 하는 객체가 있는지 검사하고 있으면 가져오고 없으면 생성 */// FlyweightFactoryclass TreeModelFactory {    // Flyweight Pool - TreeModel 객체들을 Map으로 등록하여 캐싱    private static final Map&lt;String, TreeModel&gt; cache = new HashMap&lt;&gt;(); // static final 이라 Thread-Safe 함    // static factory method    public static TreeModel getInstance(String key) {        // 만약 캐시 되어 있다면        if(cache.containsKey(key)) {            return cache.get(key); // 그대로 가져와 반환        } else {            // 캐시 되어있지 않으면 나무 모델 객체를 새로 생성하고 반환            TreeModel model = new TreeModel(                    key,                    new Object(),                    new Object()            );            System.out.println(\"-- 나무 모델 객체 새로 생성 완료 --\");            // 캐시에 적재            cache.put(key, model);            return model;        }    }}/** * 3. Client 최적화  * -&gt; TreeModel에서 공유되고 있는 나무 모델을 가져온다. * -&gt; 가져온 나무 모델과 좌표값으로 나무 객체를 생성 */Garbage Collection 처리 주의사항‘인스턴스를 관리’ 하는 기능을 자바 프로그래밍에서 구현하여 사용할 때에는 반드시 ‘관리되고 있는 인스턴스는 GC(Garbage Collection) 처리되지 않는다’ 라는 점을 주의해야 한다.즉, 나무를 모두 렌더링을 완료하여 더이상 나무를 생성할 일이 없다라면, 반드시 TreeModelFactory에 잔존해있는 Flyweight Pool 을 비워줄 필요가 있는 것이다. 그래야 인스턴스에 대한 참조를 잃은 TreeModel 인스턴스들이 GC에 의해 메모리 청소가 되게 된다. 그렇지 않으면 더이상 나무를 생성할 일이 없는데도 TreeModel 데이터가 메모리에 쓸데없이 잔존하게 된다.실제 예시String Constant Pool  String Constant Pool 개념이 바로 Flyweight Pool 개념이다.  자바는 String 데이터에 대해 별도로 string constant pool 영역에 적재한다.  같은 문자열 데이터 다시 사용될때 pool을 검사해 있다면 이를 공유한다.  만일 pool에 없다면 새로 메모리를 할당하여 pool에 등록한 후 재사용한다.  String 클래스는 Flyweight 패턴을 통해 리터럴 문자열 데이터에 대한 캐싱을 하고 있는 것이다.  String 클래스는 불변(immutable) 객체 특성을 가지고 있다.",
        "url": "//2024/05/19/deisgn-pattern-03-FlyWeight.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-02-composite-html": {
        "title": "[deisgn Pattern] 02 Composite",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CompositeComposite합체 패턴(Composite Pattern)은 복합 객체(Composite) 와 단일 객체(Leaf)를 동일한 컴포넌트로 취급하여, 클라이언트에게 이 둘을 구분하지 않고 동일한 인터페이스를 사용하도록 하는 구조 패턴이다.복합체 패턴은 전체-부분의 관계를 갖는 객체들 사이의 관계를 트리 계층 구조로 정의해야 할때 유용하다.윈도우나 리눅스의 파일 시스템 구조를 떠올려보면 쉽게 이해할 수 있다.폴더(디렉토리) 안에는 파일이 들어 있을수도 있고 파일을 담은 또 다른 폴더도 들어있을 수 있다.이를 복합적으로 담을수 있다 해서 Composite 객체라고 불리운다. 반면 파일은 단일 객체 이기 때문에 이를 Leaf 객체라고 불리운다. 즉 Leaf는 자식이 없다.복합체 패턴은 바로 이 폴더와 파일을 동일한 타입으로 취급하여 구현을 단순화 시키는 것이 목적이다.폴더 안에는 파일 뿐만 아니라 서브 폴더가 올수 있고 또 서브 폴더안에 서브 폴더가 오고.. 이런식으로 계층 구조를 구현하다 보면, 자칫 복잡해 질 수 도 있는 복합 객체를 재귀 동작을 통해 하위 객체들에게 작업을 위임한다. 그러면 복합 객체와 단일 객체를 대상으로 똑같은 작업을 적용할 수 있어 단일 / 복합 객체를 구분할 필요가 거의 없어진다.패턴  Component : Leaf와 Compsite 를 묶는 공통적인 상위 인터페이스  Composite : 복합 객체로서, Leaf 역할이나 Composite 역할을 넣어 관리하는 역할을 한다.          Component 구현체들을 내부 리스트로 관리한다      add 와 remove 메소드는 내부 리스트에 단일 / 복합 객체를 저장      Component 인터페이스의 구현 메서드인 operation은 복합 객체에서 호출되면 재귀 하여, 추가 단일 객체를 저장한 하위 복합 객체를 순회하게 된다.        Leaf: 단일 객체로서, 단순하게 내용물을 표시하는 역할을 한다.  Component 인터페이스의 구현 메서드인 operation은 단일 객체에서 호출되면 적절한 값만 반환한다  Client : 클라이언트는 Component를 참조하여 단일 / 복합 객체를 하나의 객체로서 다룬다.패턴 흐름// Component 인터페이스interface ItemComponent {    int getPrice();    String getName();}// Composite 객체class Bag implements ItemComponent {    // 아이템들과 서브 가방 모두를 저장하기 위해 인터페이스 타입 리스트로 관리    List&lt;ItemComponent&gt; components = new ArrayList&lt;&gt;();    String name; // 가방 이름    public Bag(String name) {        this.name = name;    }    // 리스트에 아이템 &amp; 가방 추가    public void add(ItemComponent item) {        components.add(item);    }    // 현재 가방의 내용물을 반환    public List&lt;ItemComponent&gt; getComponents() {        return components;    }    @Override    public int getPrice() {        int sum = 0;        for (ItemComponent component : components) {            // 만일 리스트에서 가져온 요소가 Item이면 정수값을 받을 것이고, Bag이면 '재귀 함수' 동작이 되게 된다 ☆            sum += component.getPrice(); // 자기 자신 호출(재귀)        }        return sum; // 그렇게 재귀적으로 돌아 하위 아이템들의 값을 더하고 반환하게 된다.    }    @Override    public String getName() {        return name;    }}// Leaf 객체class Item implements ItemComponent {    String name; // 아이템 이름    int price; // 아이템 가격    public Item(String name, int price) {        this.name = name;        this.price = price;    }    @Override    public int getPrice() {        return price;    }    @Override    public String getName() {        return name;    }}class Client {    public static void main(String[] args) {        // 1. 메인 가방 인스턴스 생성        Bag bag_main = new Bag(\"메인 가방\");        // 2. 아이템 인스턴스 생성        Item armor = new Item(\"갑옷\", 250);        Item sword = new Item(\"장검\", 500);        // 3. 메인 가방에는 모험에 필요한 무구 아이템만을 추가        bag_main.add(armor);        bag_main.add(sword);        // 4. 서브 가방 인스턴스 생성        Bag bag_food = new Bag(\"음식 가방\");        // 5. 아이템 인스턴스 생성        Item apple = new Item(\"사과\", 400);        Item banana = new Item(\"바나나\", 130);        // 6. 서브 가방에는 음식 아이템만을 추가        bag_food.add(apple);        bag_food.add(banana);        // 7. 서브 가방을 메인 가방에 넣음        bag_main.add(bag_food);        // ----------------------------------------------------- //        Client client = new Client();        // 가방 안에 있는 모든 아이템의 총 값어치를 출력 (가방안에 아이템 뿐만 아니라 서브 가방도 들어있음)        client.printPrice(bag_main);        // 서브 가방 안에 있는 모든 아이템의 총 값어치를 출력        client.printPrice(bag_food);    }    public void printPrice(ItemComponent bag) {        int result = bag.getPrice();        System.out.println(bag.getName() + \"의 아이템 총합 : \" + result + \" 골드\");    }}패턴 특징사용 시기  데이터를 다룰때 계층적 트리 표현을 다루어야 할때  복잡하고 난해한 단일 / 복합 객체 관계를 간편히 단순화하여 균일하게 처리하고 싶을때장점  단일체와 복합체를 동일하게 여기기 때문에 묶어서 연산하거나 관리할 때 편리하다.  다형성 재귀를 통해 복잡한 트리 구조를 보다 편리하게 구성 할 수 있다.  수평적, 수직적 모든 방향으로 객체를 확장할 수 있다.  새로운 Leaf 클래스를 추가하더라도 클라이언트는 추상화된 인터페이스 만을 바라보기 때문에 개방 폐쇄 원칙(OCP)Visit Website을 준수 한다. (단일 부분의 확장이 용이)단점  재귀 호출 특징 상 트리의 깊이(depth)가 깊어질 수록 디버깅에 어려움이 생긴다.  설계가 지나치게 범용성을 갖기 때문에 새로운 요소를 추가할 때 복합 객체에서 구성 요소에 제약을 갖기 힘들다.  계층형 구조에서 leaf 객체와 composite 객체들을 모두 동일한 인터페이스로 다루어야하는데, 이 공통 인터페이스 설계가 까다로울 수 있다.          복합 객체가 가지는 부분 객체의 종류를 제한할 필요가 있을 때      수평적 방향으로만 확장이 가능하도록 Leaf를 제한하는 Composite를 만들때      ",
        "url": "//2024/05/19/deisgn-pattern-02-Composite.html"
      }
      ,
    
      "2024-05-19-deisgn-pattern-01-chainofresponsibility-html": {
        "title": "[deisgn Pattern] 01 Chainofresponsibility",
        "tags": "",
        "date": "May 19, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Chain Of ResponsibilityChain Of Responsibility책임 연쇄 패턴(Chain Of Responsibility Pattern, COR)은 클라이어트의 요청에 대한 세세한 처리를 하나의 객체가 몽땅 하는 것이 아닌,여러개의 처리 객체들로 나누고, 이들을 사슬(chain) 처럼 연결해 집합 안에서 연쇄적으로 처리하는 행동 패턴이다.이러한 처리 객체들을 핸들러(handler)라고 부르는데, 요청을 받으면 각 핸들러는 요청을 처리할 수 있는지, 없으면 체인의 다음 핸들러로 처리에 대한 책임을 전가한다.한마디로 책임 연쇄라는 말은 요청에 대한 책임을 다른 객체에 떠넘긴다는 소리이다. 떠넘긴다고 하니까 부정적인 의미로 들릴수도 있겠지만, 이러한 체인 구성은 하나의 객체에 처리에 대한 책임을 요청을 보내는 쪽(sender)과 요청을 처리하는(receiver) 쪽을 분리하여 각 객체를 부품으로 독립시키고 결합도를 느슨하게 만들며,상황에 따라서 요청을 처리할 객체가 변하는 프로그램에도 유연하게 대응할 수 있다는 장점을 가지고 있다. 특히나 중첩 if-else 들을 최적화하는데 있어 실무에서도 많이 애용되는 패턴중 하나이기도 하다.특징패턴 사용 시기  특정 요청을 2개 이상의 여러 객체에서 판별하고 처리해야 할때  특정 순서로 여러 핸들러를 실행해야 하는 경우  프로그램이 다양한 방식과 종류의 요청을 처리할 것으로 예상되지만 정확한 요청 유형과 순서를 미리 알 수 없는 경우  요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때 (체인 연결을 런타임에서 동적으로 설정)패턴 장점  클라이언트는 처리 객체의 체인 집합 내부의 구조를 알 필요가 없다.  각각의 체인은 자신이 해야하는 일만 하기 때문에 새로운 요청에 대한 처리객체 생성이 편리해진다.  클라이언트 코드를 변경하지 않고 핸들러를 체인에 동적으로 추가하거나 처리 순서를 변경하거나 삭제할 수 있어 유연해진다  요청의 호출자(invoker)와 수신자(receiver)  분리시킬 수 있다.          요청을 하는 쪽과 요청을 처리하는 쪽을 디커플링 시켜 결합도를 낮춘다      요청을 처리하는 방법이 바뀌더라도 호출자 코드는 변경되지 않는다.      패턴 단점  실행 시에 코드의 흐름이 많아져서 과정을 살펴보거나 디버깅 및 테스트가 쉽지 않다.  충분한 디버깅을 거치지 않았을 경우 집합 내부에서 무한 사이클이 발생할 수 있다.  요청이 반드시 수행된다는 보장이 없다. (체인 끝까지 갔는데도 처리되지 않을 수 있다)  책임 연쇄로 인한 처리 지연 문제가 발생할 수 있다. 다만 이는 트레이드 오프로서 요청과 처리에 대한 관계가 고정적이고 속도가 중요하면 책임 연쇄 패턴 사용을 유의하여야 한다.ex)// 구체적인 핸들러를 묶는 인터페이스 (추상 클래스)abstract class Handler {    // 다음 체인으로 연결될 핸들러    protected Handler nextHandler = null;    // 생성자를 통해 연결시킬 핸들러를 등록    public Handler setNext(Handler handler) {        this.nextHandler = handler;        return handler; // 메서드 체이닝 구성을 위해 인자를 그대로 반환함    }    // 자식 핸들러에서 구체화 하는 추상 메서드    protected abstract void process(String url);    // 핸들러가 요청에 대해 처리하는 메서드     public void run(String url) {        process(url);        // 만일 핸들러가 연결된게 있다면 다음 핸들러로 책임을 떠넘긴다        if (nextHandler != null)            nextHandler.run(url);    }}class ProtocolHandler extends Handler {    @Override    protected void process(String url) {        int index = url.indexOf(\"://\");        if (index != -1) {            System.out.println(\"PROTOCOL : \" + url.substring(0, index));        } else {            System.out.println(\"NO PROTOCOL\");        }    }}class DomianHandler extends Handler {    @Override    protected void process(String url) {        int startIndex = url.indexOf(\"://\");        int lastIndex = url.lastIndexOf(\":\");        System.out.print(\"DOMAIN : \");        if (startIndex == -1) {            if (lastIndex == -1) {                System.out.println(url);            } else {                System.out.println(url.substring(0, lastIndex));            }        } else if (startIndex != lastIndex) {            System.out.println(url.substring(startIndex + 3, lastIndex));        } else {            System.out.println(url.substring(startIndex + 3));        }    }}class PortHandler extends Handler {    @Override    protected void process(String url) {        int index = url.lastIndexOf(\":\");        if (index != -1) {            String strPort = url.substring(index + 1);            try {                int port = Integer.parseInt((strPort));                System.out.println(\"PORT : \" + port);            } catch (NumberFormatException e) {                e.printStackTrace();            }        }    }}class Client {    public static void main(String[] args) {        // 1. 핸들러 생성        Handler handler1 = new ProtocolHandler();        Handler handler2 = new DomianHandler();        Handler handler3 = new PortHandler();        // 2. 핸들러 연결 설정 (handler1 → handler2 → handler3)        handler1.setNext(handler2).setNext(handler3);        // 3. 요청에 대한 처리 연쇄 실행        String url1 = \"http://www.youtube.com:80\";        System.out.println(\"INPUT: \" + url1);        handler1.run(url1);        System.out.println();        String url2 = \"https://www.inpa.tistory.com:443\";        System.out.println(\"INPUT: \" + url2);        handler1.run(url2);        System.out.println();        String url3 = \"http://localhost:8080\";        System.out.println(\"INPUT: \" + url3);        handler1.run(url3);    }}실수에서 예시  java.util.logging.Logger의 log()  javax.servlet.Filter의 doFilter()",
        "url": "//2024/05/19/deisgn-pattern-01-ChainOfResponsibility.html"
      }
      ,
    
      "2024-05-18-java-series-29-virtualthread-html": {
        "title": "[java Series] 29 Virtualthread",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - VirtualThreadVirtualThread! 간단 정리 버전 !기본 구성Project Loom에서 시작되었으며, Java19에는 Preview로 지원되었고 21에서 정식으로 추가됐다.기본 발상은 Java의 쓰레드는 Kernal Thread를 할당 받아서 사용했었는데 이는  할당까지 OS의 영향하에 있다.  할당까지 비용이 너무 많이 든다.  1 ~ 2MB가 최대flowchart TDsubgraph PlatformThread    subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        subgraph JVM        PlatformThread1        PlatformThread2    end        KernalThread1 --&gt; PlatformThread1    KernalThread2 --&gt; PlatformThread2end라는 문제가 근본적으로 있었다. 그래서 이를 극복하기 위해서 ThreadPool를 할당하여 쓰고 버리는 것이 아닌 반납 하는 시스템으로 자주 사용했다.VirtualThread는 기존 쓰레드(PlatformThread)와 달리 JVM 단에서 쓰레드를 만들어서 실행하는 방향으로 발상을 바꾸게 되어 생겼다. 이를 통해서  JVM의 영향력 아래 있다.  할당에 비용이 적게 들어서 쓰고 버리는 형태로 패러다임이 변경됐다.  ~ KB 단위 사이즈는 식의 변화가 생겼다. 이러면서 기존 쓰레드는 PlatformThread로 개명했다.flowchart TDsubgraph VirtualThread     subgraph OS        Kernal --&gt; KernalThread1        Kernal --&gt; KernalThread2    end        KernalThread1 --&gt; ForkJoinPool    KernalThread2 --&gt; ForkJoinPool        subgraph JVM        ForkJoinPool                ForkJoinPool --&gt; CarrierThread1        ForkJoinPool --&gt; CarrierThread2                CarrierThread1 --&gt; Queue1        CarrierThread2 --&gt; Queue2                Queue1 --&gt; VirtualThread1        Queue1 --&gt; VirtualThread2        Queue2 --&gt; VirtualThread3        Queue2 --&gt; VirtualThread4    endend  캐리어 쓰레드란?  Proeject Loom의 일부로 도입된 개념으로 VirtualThread를 실행하기 위한 운반체 역할을 한다. PlatformThread를 기반으로 합니다. CarrierThread는 ForkJoinPool 안에 workerThread로 생성이 되어 스케쥴링 된다.VirtualThreadVirtualThread Thread(Runnable을 구현한)를 상속 받았다. 따라서 상호 변용이 가능하다.package java.lang;sealed abstract class BaseVirtualThread extends Thread        permits VirtualThread, ThreadBuilders.BoundVirtualThread {    BaseVirtualThread(String name, int characteristics, boolean bound) {        super(name, characteristics, bound);    }    abstract void park();    abstract void parkNanos(long nanos);    abstract void unpark();}package java.lang;/** * A thread that is scheduled by the Java virtual machine rather than the operating * system. */final class VirtualThread extends BaseVirtualThread {//... 중략private static final long CARRIER_THREAD = U.objectFieldOffset(VirtualThread.class, \"carrierThread\");    // carrier thread when mounted, accessed by VM    private volatile Thread carrierThread;}주의점  쓰고 버리는게 오히려 이득이다.  커넥션 풀을 사용하는 경우(MySQL 같이)나 IO 최대 개수 제한이 있는 경우(OS 파일) 문제가 될 수 있으니 Bound를 두고 사용하는게 맞을 수 있다.",
        "url": "//2024/05/18/java-series-29-VirtualThread.html"
      }
      ,
    
      "2024-05-18-java-series-28-reactive-html": {
        "title": "[java Series] 28 Reactive",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReactiveReactive데이터 흐름과 전달에 대한 프로그래밍 패러다임이다.기존 명령형 패러다임은 콜을 받아서 당겨오는(Pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(Push) 방식이다.즉, 주변 환경과 상호작용을 하는 것을 주도하는게 아니라 일정 값이 변하면 이벤트를 받아서 동작한다. 일종의 옵저버(Observer) 패턴이다.  대략적으로 보면?      기본 골자는 Stream API와 비슷하다.    Stream API와 같이 끝 맺는 메소드 (subscribe)가 있어야 한다.    퍼블리셔가 이벤트를 발행하면 stream을 타고 subscrbie 소비가 되는 패턴이다.  Flow APIJava 9에는  java.util.concurrent.Flow를 추가했다.리액티브 표준에 따라 발행(Pub)/ 구독(Sub)을 할 수 있도록 되어 있다.  Publisher : 데이터를 발행하는 주체이다.    @FunctionalInterfacepublic static interface Publisher&lt;T&gt; {  public void subscribe(Subscriber&lt;? super T&gt; subscriber);}        Subscriber : 데이터를 소비하는 주체이다.    public static interface Subscriber&lt;T&gt; {  public void onSubscribe(Subscription subscription);  public void onNext(T item);  public void onError(Throwable throwable);  public void onComplete();}        Subscription : 구독 그 자체다. Publisher - Subscriber를 연결한다.    public static interface Subscription {  public void request(long n);  public void cancel();}        Processor : 리액티스 스트림에서 처리하는 단계이다.    public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}      ",
        "url": "//2024/05/18/java-series-28-Reactive.html"
      }
      ,
    
      "2024-05-18-java-series-27-little-html": {
        "title": "[java Series] 27 Little",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자잘한 기록물charType -&gt; integer numberclass Example {    public static void main(String[] args) {         char charNine = '9';         int nine = charNine - '0';         // -&gt; nine;    }}String -&gt; splice?class Example {    public static void main(String[] args) {         String exam = \"adcd\";         StringBuilder builder = new StringBuilder(exam);         builder.deleteCharAt(1); //like Splice    }}",
        "url": "//2024/05/18/java-series-27-Little.html"
      }
      ,
    
      "2024-05-18-java-series-26-set-html": {
        "title": "[java Series] 26 Set",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - SetintersectList의 retainAll은 교집합 구현에 완벽히 사용 불가import java.util.ArrayList;class RetainTest {    @Test    public void case1() {        String first = \"aaabb\";        String second = \"aabbb\";        List&lt;String&gt; firstList = new ArrayList(); // [aa, aa, ab, bb]        List&lt;String&gt; secondList = new ArrayList(); //[aa, ab, bb, bb]        char[] firstChar = first.toCharArray();        for( int i = 1; i &lt; firstChar.length; i ++ )  firstList.add(firstChar[i - 1]+\"\"+firstChar[i]);        char[] secondChar = second.toCharArray();        for( int i = 1; i &lt; secondChar.length; i ++ )  secondList.add(secondChar[i - 1]+\"\"+secondChar[i]);                                firstList.retainAll(secondList);        System.out.println(firstChar); //[aa, aa, ab, bb]                //firstList에 영향이 없다 치고        secondList.remove(firstList);        System.out.println(secondList); //[aa, ab, bb, bb]        /**         * - 결론         * 알던 것과 결과가 굉장히 다르다.          */    }}",
        "url": "//2024/05/18/java-series-26-Set.html"
      }
      ,
    
      "2024-05-18-java-series-24-junit-html": {
        "title": "[java Series] 24 Junit",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JUnitJunitAnnotation|       Annotation       |                                                            Description                                                             ||:———————-:|:———————————————————————————————————————————-:||         @Test          |                                                        메소드가 테스트 메소드임을 나타낸다.                                                        ||   @ParameterizedTest   |                                                        매개변수가 있는 테스트임을 나타낸다.                                                        ||      @ValueSource      |                                         반복 테스트에서 지정한 배열을 파라미터 값으로 순서대로 넘겨준다. (하나의 인수일 경우)                                          ||      @NullSource       |                                                       Null로 값을 전달할 떄  사용한다.                                                        ||      @EmptySource      |                                                        빈 값을 인수로 전달할 때 사용한다.                                                        ||  @NullAndEmptySource   |                                                      Null, Empty 모두 전달할 때 사용                                                       |                                                                    @CsvSource                                                                | 테스트 입력값을 Csv로 구성하여 던질 떄 사용한다.|      @EnumSource       |                                                        열거형의 배열을 테스트 메소드에 전달                                                        ||     @MethodSource      |                                 Arguments로 파라미터를 여러 개 전달할 떄 사용한다. (Arguments.of(value, value….))                                 ||     @RepeatedTest      |                                                      메소드가 반복 테스트 메소드임을 나타낸다.                                                       ||      @DisplayName      |                                                  테스트 클래스 또는 메소드에 대한 사용자 지정 표시 이름                                                   || @DisplayNameGeneration |                                                      테스트 클래스 이름 생성기를 선언한다. *                                                       ||      @BeforeEach       |   @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 전에 실행되는 것을 나타낸다. 테스트 마다 실행 전에 실행된다.  매 테스트마다 초기화해야 하는 경우 사용된다.   ||       @AfterEach       | @Test, @RepeatedTest, @ParameterizedTest, @TestFactor 후에 실행되는 것을 나타낸다.  테스트 마다 실행 후에 실행된다.      매 테스트 후 정리해야 하는 경우 사용된다. ||       @BeforeAll       |                                     @BeforeEach 와 유사하지만 static 메소드여야만 하며  테스트 전에 한 번만 실행된다.                                      ||       @AfterAll        |                                      @AfterEach 와 유사하지만 static 메소드여야만 하며  테스트 후에 한 번만 실행된다.                                      ||        @Nested         |                                                   주석이 달린 클래스가 중첩 테스트 클래스임을 나타낸다.                                                   ||          @Tag          |                                                   클래스, 메소드 수준 테스트 필터링을 위해서 사용한다.                                                   ||       @Disabled        |                                                    테스트 클래스, 메소드를 비활성화할 때 사용한다.                                                     ||        @Timeout        |                                                          테스트 타임아웃을 지정한다.                                                           ||      @ExtendWith       |                                                       확장을 선언적으로 등록할 때 사용한다.                                                        ||   @RegisterExtension   |                                                 필드를 통해 프로그래밍 방식으로 확장을 등록할 떄 사용한다.                                                  ||        @TempDir        |                                             테스트 메소드에서 필드 주입 또는 매개변수 주입을 통해 임시 디렉토리를 제공                                             ||      @TestFactory      |                                                     동적 테스트를 위한 테스트 팩토리임을 나타낸다.                                                     ||     @TestTemplate      |                                                                                                                                    ||    @TestClassOrder     |                                                   @Nested 간 실행 순서를 구성하는 데 사용한다.                                                    ||    @TestMethodOrder    |                             테스트 메소드간 순서를 구성하는 데 사용한다.                                               @                              ||     @TestInstance      |                                              주석이 달린 테스트 클래스의 인스턴스 수명 주기를 구성하는데 사용한다.                                               ||          @Sql              |                                                      sql 파일을 지정하여 Dao 단위 테스트에 미리 구성된 쿼리를 실행한다.                                                                              |class Junit {    @TestFactory    Stream&lt;DynamicTest&gt; testFactory () {        List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        return numbers.stream()                      .forEach( num -&gt; dynamicTest(                              num,                              () -&gt; assertThat(number &lt; 10).isTrue()                      ));    }    @ParameterizedTest    @ValueSource(ints = {1,2,3,4,5,6,7,8,9,10})    public isUnderThen(int number){        assertThat(number &lt; 10).isTrue();    }}Spring Test AnnotationsController Test| Annotation                                                                                                                                                    |                                      Description                                      ||:————————————————————————————————————————————————————–|:————————————————————————————-:|| @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, properties = “spring.profiles.active=[profile]”)                  | SpringBootTest임을 알린다. 이 어노테이션이 붙으면 SpringContext를 실행하고 Component 스캔 등을 한다. (스프링을 켠다.) || @AutoConfigureMockMvc                                                                                                                                         |                                    서블릿 컨테이너를 모킹한다.                                    || @TestPropertySource                                                                                                                                           |     테스트 환경의 Property를 지정할 수 있다. (classpath:로 resource 내부에서 찾는건 덤 -&gt; build에서 찾는다.)     || @ActiveProfiles                                                                                                                                               |                               Active로 둘 Profile를 지정한다.                                |            Object      Description                  @AutowiredMockMvc      테스트용 MVC환경을 만들어 요청, 전송, 응답을 제공하는 클래스              @LocalServerPortint port      현재 mocking 혹은 지정된 포트를 반환한다. (RandomPort의 경우)      //ex)@Test@DisplayName(value = \"ContextLoadTest\")void contextLoads() throws Exception {        System.out.println(\"ContextLoaded\");        //given        String expect = \"junitTest\";        //when        mockMvc.perform(        get(\"/v1/user/test\")        .contentType(MediaType.APPLICATION_JSON)        .accept(MediaType.APPLICATION_JSON)        )        //that        .andExpect(MockMvcResultMatchers.status().isOk())        .andExpect(jsonPath(\"$\",expect).exists());        }ServiceTest| Annotation  |                 Description                  ||:————|:——————————————–:|| @ExtendWith |        단위 테스트에 공통적으로 사용할 확장 기능을 선언한다.        || @Mock       |       Mock 객체를 생성 메소드는 있지만 내부 구현이 없다.        || @Spy        | 모든 기능을 가지고 있다. 다만 Stub을 하면 해당 부분만 Mocking된다. || @InjectMock |  @Mock, @Spy로 생산한 객체를 주입한다.(생성자 주입으로 추정된다.)  |RepositoryTest| Annotation                                                                                                                                          |                         Descpription                         ||:—————————————————————————————————————————————————-|:————————————————————:|| @DataJpaTest(  showSql = true,  properties = {“classpath:application.yml”},  includeFilters = {}) | SpringContext 중 Repository에 관련된 요소들만 테스트하기 위해서 사용하는 어노테이션이다. || @AutoConfigureTestDatabase(connection=””, replace=””)                                                                                               |    TestDB를 구성할 때 유용한 어노테이션이다. 테스트 시 DB를 테스트 DB로 대체할 수 있다.    |",
        "url": "//2024/05/18/java-series-24-Junit.html"
      }
      ,
    
      "2024-05-18-java-series-23-shellcommand-html": {
        "title": "[java Series] 23  shellcommand",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - shellCommand당시 OOM이 나서 여러 옵션을 건들였었는데 이에 대해서 찾아보고 이를 기록한 문서입니다.#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jstat -gcutil -h 20 $pid 2000 10000#!/bin/bashprojectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jhsdb jmap --binaryheap --dumpfile /home/chat/dump.hprof --pid $pid#!/bin/bash#projectName='projectName'pid=`ps -ef | grep $projectName-*.war | grep -v grep | awk '{print $2}'`/home/jdk-11/bin/jcmd $pid GC.class_histogram &gt; histogram.logif [ -z $pid ] then        echo \"No server is running.\" else        kill -9 \"$pid\"        echo \"Shut down the running server.\"fi/home/jdk-11/bin/java \\-XX:+UseParallelOldGC \\-Xms1024m \\-Xmx4096m \\-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=/home/chat/dump/heapdump.hprof \\-verbose:gc \\-jar \\-Dspring.profiles.active=prod \\$projectPath/$projectName-*.war \\&gt; $projectPath/out.log  \\2&gt; $projectPath/exception.log &amp;echo \"The server was successfully run.\"",
        "url": "//2024/05/18/java-series-23-ShellCommand.html"
      }
      ,
    
      "2024-05-18-java-series-22-floatingpoint-html": {
        "title": "[java Series] 22 Floatingpoint",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Floating point issue부동 소수점 관련 문제class FloatingPoint {    @Test    public void fpFailure() {        Assertions.assertEquals(1.2 , 1.1 + 0.1);        //결과는? false        //부동소수점 문제 때문에 그렇다. (특히 이 주변은 다 괜찮은데 얘만 그렇다.)        /**         * Expected :1.2         * Actual   :1.2000000000000002         */        //위와 같은 결과로 나온다.    }        @Test    public void fpSuccess() {        Assertions.assertEquals(BigDecimal.valueOf(1.2), BigDecimal.valueOf(1.1).add(BigDecimal.valueOf(0.1)));        //이러면 성공한다.    }}Java _ BigDecimal 관련 사용 시 유의점연산  ’+’ : BigDecimal.valueOf(x).add(BigDecimal.valueOf(y));  ’-‘ : BigDecimal.valueOf(x).substract(BigDecimal.valueOf(y));  ‘*’ : BigDecimal.valueOf(x).multiply(BigDecimal.valueOf(y));  ’/’ : BigDecimal.valueOf(x).divide(BigDecimal.valueOf(y));  ’%’ : BigDecimal.valueOf(x).remainder(BigDecimal.valueOf(y));  절대값 : BigDecimal.valueOf(x).abs();소수점RoundingMode  UP(BigDecimal.ROUND_UP), : 양수일 때 올림, 음수일 때 내림  DOWN(BigDecimal.ROUND_DOWN), : ROUND_UP과 반대  CEILING(BigDecimal.ROUND_CEILING), : 올림  FLOOR(BigDecimal.ROUND_FLOOR), : 내림  HALF_UP(BigDecimal.ROUND_HALF_UP), : 반올림 (5이상 올림 5미만 버림)  HALF_DOWN(BigDecimal.ROUND_HALF_DOWN), : 반올림 ( 6이상 올림, 6미만 버림)  HALF_EVEN(BigDecimal.ROUND_HALF_EVEN), : 반올림 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP  UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);: 딱 떨어지는 값이 아니면 ArithmeticException사용법BigDecimal(\"0.9999\").setScale(0, RoundingMode.CEILING);MathContext  UNLIMITED = new MathContext(0, RoundingMode.HALF_UP); : unlimit (무제한 정밀 산술)  DECIMAL32 = new MathContext(7, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal32 format, 7 digits ( 7자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL64 = new MathContext(16, RoundingMode.HALF_EVEN); : matching the precision of the IEEE 754-2019 decimal64 format, 16 digits  ( 16자리 정밀도 및 HALF_EVENT의 반올림 모드)  DECIMAL128 = new MathContext(34, RoundingMode.HALF_EVEN);: matching the precision of the IEEE 754-2019 decimal128 format, 34 digits ( 32자리 정밀도 및 HALF_EVENT의 반올림 모드)MethodsBigIntegerclass IntroduceBigInteger {    public void bit () {        BigInteger i = new BigInteger(\"1018\"); // 2진수로 표현하면 : 1111111010(2)        int bitCount = i.bitCount(); // 1의 갯수 : 8        int bitLength = i.bitLength(); // 비트 수 : 10        int getLowestSetBit = i.getLowestSetBit(); // 1        boolean testBit3 = i.testBit(3); // true        BigInteger setBit12 = i.setBit(12); // 우측에서 13번째 비트를 1로 변경 → 1001111111010(2) → 5114        BigInteger flipBit0 = i.flipBit(0); // 1111111011(2) → 1019        BigInteger clearBit3 = i.clearBit(3); // 1111110010(2) → 1010        }           public void bitOperate () {        BigInteger i = new BigInteger(\"17\"); // 2진수 : 10001(2)        BigInteger j = new BigInteger(\"7\"); // 2진수 : 111(2)        BigInteger and = i.and(j); // 10001(2) &amp; 111(2) = 00001(2) → 1(10)        BigInteger or = i.or(j); // 23        BigInteger not = j.not(); // -8        BigInteger xor = i.xor(j); // 22        BigInteger andNot = i.andNot(j); // 16        BigInteger shiftLeft = i.shiftLeft(1); // 34        BigInteger shiftRight = i.shiftRight(1); // 8    }}JsonSerializerBigDecimal to JsonValueclass BigDecimalScale6WithBankersRoundingSerializer  implements JsonSerializer&lt;BigDecimal&gt; {    public static Integer SCALE_SIX = 6;    public static RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;        @Override    public Object serialize( BigDecimal value, JsonGenerator gen,   SerializerProvider serializers ) {        return gen.writeString(value.setScale(SCALE_SIX, BANKERS_ROUNDING_MODE).toString());    }}",
        "url": "//2024/05/18/java-series-22-FloatingPoint.html"
      }
      ,
    
      "2024-05-18-java-series-21-yaml-html": {
        "title": "[java Series] 21 Yaml",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - YAMLYAML(Yet Another Markup Language)기존에 주로 사용되던 포맷인 JSON의 불편함을 해소하기 위해 만들어진 superset이다. (확장자만 바꿔도 JSON -&gt; YAML로 변환된다. )데이터 정의  Key:Value 표기  콤마 표기하지 않음  indent로 계층 구조를 표현  따옴표 (굳이 쓰지 않아도 된다.)  작은 따옴표, 큰 따옴표 -&gt; 이스케이필 문자를 구분해야하면, 큰 따옴표는 escapeSequence, 작은 따옴표는 그대로 문자열로 처리한다.배열 &amp; 리스트  -으로 하위 엘리먼트 표현  객체 배열이 필요하다면 객체 시작에만 -를 사용한다.    students:  - name: Mark major: Math age: 20  - name: Julie major: Arts age: 23  - name: Tommy major: Music age: 25        Boolean : yes/no, true/false를 boolean으로 구문한다. case insensitive다.  변수 선언 : &amp;으로 변수 선언하고 *으로 참조한다.default: &amp;default_school # default_school 라는 변수를 선언하고, 그 내용은 group 과 description 데이터를 지니고 있다   group: '서울대학교'   description: |      서울에 위치하는 대한민국 대학교!student:   - name: '홍길동'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다   - name: '임꺽정'     &lt;&lt;: *default_school # default_school 변수 내용물을 대입한다",
        "url": "//2024/05/18/java-series-21-YAML.html"
      }
      ,
    
      "2024-05-18-java-series-20-stringandtokenizer-html": {
        "title": "[java Series] 20 Stringandtokenizer",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Split vs StringTokenizerSplit vs. StringTokenizer1. Split정규식을 받는 메소드와, 정규식 + 인덱스를 받는 메소드 두 개가 오버로딩되어 있다.class String {    public String[] split(String regex);// 반환을 String 배열로 받는다.// 구분 기호를 문자열이 아닌 정규표현식으로 받는다. (중요)    public String[] split(String regex, int limit);// 문자열을 정규식에 맞춰서 분리하는데 limit만큼 문자열을 자른다.}2. StringTokenizer구분자를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는데 사용한다.// 문자열을 공백 문자를 구분자로 자르기new StringTokenizer(String str)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// 이때 구분자는 토큰으로 간주되지 않음new StringTokenizer(String st, String delim)// 문자열을 매개변수로 지정된 구분자(delim)로 자르기// returnDelims 의 값을 true로하면 구분자도 토큰으로 간주new StringTokenizer(String str, String delim, boolean returnDelims)결론적으로 split vs. StringTokenizer  split 메소드는 String클래스에 속해있는 메소드이고, StringTokenizer는 java.util에 포함되어 있는 클래스이다.  구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.  split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.  split는 빈문자열을 토큰으로 인식하는 반면, StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다.  성능은 split 보다 StringTokenizer 가 좋다.  split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.  그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.",
        "url": "//2024/05/18/java-series-20-StringAndTokenizer.html"
      }
      ,
    
      "2024-05-18-java-series-19-clone-html": {
        "title": "[java Series] 19 Clone",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CloneCloneObject.clone()인스턴스 객체 복제를 위한 메소드, 해당 인스턴스를 복제해서 새로운 인스턴스를 생성해서 그 참조 값을 반환한다. clone() 사용을 위해서 Cloneable을 구현해야한다.Deep vs. ShallowDeep은 값 타입이든, 참조 타입이든 복사하여 원본과 구분되는 결과물을 생성해 내는 것을 의미하며, 얕은 복사는 값이든 참조든 복사하여 원본과 같은 결과물을 만들어내는 것을 의미한다.Deep의 주의사항만일 필드에 참조형이 있다면 아무리 대상을 깊은 복사했어도 필드는 참조를 복사한다. 따라서 필드의 클래스도 따로 처리를 해야한다.",
        "url": "//2024/05/18/java-series-19-Clone.html"
      }
      ,
    
      "2024-05-18-java-series-18-variableargument-html": {
        "title": "[java Series] 18 Variableargument",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 가변인자Variable Argument가변 인수 사용법메서드 파라미터 부분에 타입… 매개변수명 으로 처리하면 사용이 가능하다.가변 인수는 전달 인자를 0개부터 n개까지 넣을수 있다. 그리고 파라미터로 넘겨지는 값들을 모아서 컴파일시 배열로 처리된다. 주의할점은 인자들의 갯수에는 제한이 없지만, 배열 자료형은 매개변수 타입으로 명시된 것에 따라간다는 점이다.만일 매개변수가 가변 인자 외에 다른 매개 변수들도 받는다면, 반드시 가변 인자를 메서드 파라미터 가장 마지막에 위치하도록 정의해야 한다.그리고 매개변수가 넘겨지는 순서는, 인자들이 앞에 있는 파라미터 부터 차례대로 넘겨지고 남은 나머지 인자들이 가변 인자로 넘겨지게 된다.주의점  가변 인자 자체가 성능에 좋지않다. (배열 선언)  가변 인수 자체를 오버로딩하면 컴파일러가 어떤 메소드를 사용해야할지 구분하지 못한다.  배열 타입 매개변수와 혼용하지 않기    public void print( String ... str ) {}public void print( String[] str) {}        제네릭과 혼합하면 신중하게 -&gt; 제네릭은 배열로 실체화 불가하다.  ",
        "url": "//2024/05/18/java-series-18-VariableArgument.html"
      }
      ,
    
      "2024-05-18-java-series-17-generic-html": {
        "title": "[java Series] 17 Generic",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GenericGeneric클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 법을 의미한다.ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();제네릭 타입 매개변수위에서 보다시피, 제네릭은 &lt;&gt; 꺾쇠 괄호 키워드를 사용하는데 이를 다이아몬드 연산자라고 한다. 그리고 이 꺾쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할 수 있다. 이것을 마치 메소드가 매개변수를 받아 사용하는 것과 비슷하여 제네릭의 타입 매개변수(parameter) / 타입 변수 라고 부른다.타입 파라미터 정의이 타입 매개변수는 제네릭을 이용한 클래스나 메소드를 설계할 때 사용된다.예를들어 다음 코드는 제네릭을 감미한 클래스를 정의한 코드이다. 클래스명 옆에  기호로 제네릭을 붙여준 걸 볼 수 있다.그리고 클래스 내부에서 식별자 기호 T 를 클래스 필드와, 메소드의 매개변수의 타입으로 지정되어 있다.class FruitBox&lt;T&gt; {    List&lt;T&gt; fruits = new ArrayList&lt;&gt;();    public void add(T fruit) {        fruits.add(fruit);    }}제네릭 클래스를 만들었으면 이를 인스턴스화 해보자. 마치 파라미터를 지정해서 보내는 것 처럼 생성 코드에서 꺾쇠 괄호 안에 지정해주고 싶은 타입명을 할당해주면,제네릭 클래스 선언문 부분으로 가서 타입 파라미터 T 가 지정된 타입으로 모두 변환되어 클래스의 타입이 지정되게 되는 것이다.타입 파라미터 생략제네릭 객체를 사용하는 문법 형태를 보면 양쪽 두 군데에 꺾쇠 괄호 제네릭 타입을 지정함을 볼 수 있다. 하지만 맨 앞에서 클래스명과 함께 타입을 지정해 주었는데 굳이 생성자까지 제네릭을 지정해 줄 필요가 없다.따라서 jdk 1.7 버전 이후부터,  new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다. 제네릭 나름대로 타입 추론을 해서 생략 된 곳을 넣어주기 때문에 문제가 없는 것이다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;Apple&gt;();// 다음과 같이 new 생성자 부분의 제네릭의 타입 매개변수는 생략할 수 있다.FruitBox&lt;Apple&gt; intBox = new FruitBox&lt;&gt;();복수 타입 파라미터제네릭은 반드시 한개만 사용하라는 법은 없다. 만일 타입 지정이 여러개가 필요할 경우 2개, 3개 얼마든지 만들 수 있다.제네릭 타입의 구분은 꺽쇠 괄호 안에서 쉽표(,)로 하며 &lt;T, U&gt; 와 같은 형식을 통해 복수 타입 파라미터를 지정할 수 있다. 그리고 당연히 클래스 초기화할때 제네릭 타입을 두개를 넘겨주어야 한다.import java.util.ArrayList;import java.util.List;class Apple {}class Banana {}class FruitBox&lt;T, U&gt; {    List&lt;T&gt; apples = new ArrayList&lt;&gt;();    List&lt;U&gt; bananas = new ArrayList&lt;&gt;();    public void add(T apple, U banana) {        apples.add(apple);        bananas.add(banana);    }}public class Main {    public static void main(String[] args) {    \t// 복수 제네릭 타입        FruitBox&lt;Apple, Banana&gt; box = new FruitBox&lt;&gt;();        box.add(new Apple(), new Banana());        box.add(new Apple(), new Banana());    }}중첩 타입 파라미터제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.ArrayList 자체도 하나의 타입으로써 제네릭 타입 파라미터가 될수 있기 때문에 이렇게 중첩 형식으로 사용할 수 있는 것이다.public static void main(String[] args) {    // LinkedList&lt;String&gt;을 원소로서 저장하는 ArrayList    ArrayList&lt;LinkedList&lt;String&gt;&gt; list = new ArrayList&lt;LinkedList&lt;String&gt;&gt;();    LinkedList&lt;String&gt; node1 = new LinkedList&lt;&gt;();    node1.add(\"aa\");    node1.add(\"bb\");    LinkedList&lt;String&gt; node2 = new LinkedList&lt;&gt;();    node2.add(\"11\");    node2.add(\"22\");    list.add(node1);    list.add(node2);    System.out.println(list);}타입 파라미터 기호 네이밍| 타입  |\t설명||:—:|:—–:||  |타입(Type)|||요소(Element), 예를 들어 List|||키(Key), 예를 들어 Map&lt;k, v&gt;|||리턴 값 또는 매핑된 값(Variable)|||숫자(Number)||&lt;S, U, V&gt;|2번째, 3번째, 4번째에 선언된 타입|제네릭 사용 이유, 장점  컴파일 타임에 타입 검사  불필요한 캐스팅을 없앨 수 있음주의 사항  제네릭 타입의 객체는 생성이 불가  static 멤버에 제네릭 타입이 올 수 없음 ( 제네릭 객체 생성 전에 자료 타입이 정해져 있어야 해서 )  제네릭으로 배열을 만들 수 없다.제네릭 범위 한정제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에서 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.예를들어 다음 계산기 클래스가 있다고 하자. 정수, 실수 구분없이 모두 받을 수 있게 하기위해 제네릭으로 클래스를 만들어주었다.하지만 단순히  로 지정하게 되면 숫자에 관련된 래퍼 클래스 뿐만 아니라 String이나 다른 클래스들도 대입이 가능하다는 점이 문제이다.// 숫자만 받아 계산하는 계산기 클래스 모듈class Calculator&lt;T&gt; {    void add(T a, T b) {}    void min(T a, T b) {}    void mul(T a, T b) {}    void div(T a, T b) {}}public class Main {    public static void main(String[] args) {        // 제네릭에 아무 타입이나 모두 할당이 가능        Calculator&lt;Number&gt; cal1 = new Calculator&lt;&gt;();        Calculator&lt;Object&gt; cal2 = new Calculator&lt;&gt;();        Calculator&lt;String&gt; cal3 = new Calculator&lt;&gt;();        Calculator&lt;Main&gt; cal4 = new Calculator&lt;&gt;();    }}개발자의 의도로는 계산기 클래스의 제네릭 타입 파라미터로 Number 자료형만 들어오도록 하고 문자열이나 또 다른 클래스 자료형이 들어오면 안되게 하고 싶다고 한다.그래서 나온 것이 제한된 타입 매개변수 (Bounded Type Parameter) 이다.타입 한정 키워드 extends&lt;T extends [ 제한 타입 ]&gt;인터페이스 타입 한정extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있다.interface Readable {}// 인터페이스를 구현하는 클래스public class Student implements Readable {} // 인터페이스를 Readable를 구현한 클래스만 제네릭 가능public class School &lt;T extends Readable&gt; {}다중 타입 한정만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한하고 싶다면,  &amp; 연산자를 이용하면 된다. 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 된다.단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.interface Readable {}interface Closeable {}class BoxType implements Readable, Closeable {}class Box&lt;T extends Readable &amp; Closeable&gt; {    List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T item) {        list.add(item);    }}재귀적 타입 한정재귀적 타입 한정이란 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 시키는 것을 말한다.실무에선 주로 Comparable 인터페이스와 함께 쓰인다.예를들어 다음과 같이 &lt;E extends Comparable&gt; 제네릭 E의 타입 범위를 Comparable 로 한정한다는 E를 중첩시킨 표현식을 사용할수 있는데, 이 말은 '타입 E는 자기 자신을 서브 타입으로 구현한 Comparable 구현체로 한정' 한다는 뜻이다.class Compare {\t// 외부로 들어온 타입 E는 Comparable&lt;E&gt;를 구현한 E 객체 이어야 한다.    public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; collection) {        if(collection.isEmpty()) throw new IllegalArgumentException(\"컬렉션이 비어 있습니다.\");        E result = null;        for(E e: collection) {            if(result == null) {                result = e;                continue;            }            if(e.compareTo(result) &gt; 0) {                result = e;            }        }        return result;    }}제네릭 형변환캐스팅배열과 같은 일반적인 변수 타입과 달리 지네릭 서브 타입간에는 형변환이 불가능하다. 심지어 대입된 타입이 Object라도 말이다. 자연스럽게 다형성이 적용될 것이라 생각하였지만, 실상 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능한 것이다.와일드 카드      &lt;?&gt; : Unbounded Wildcards (제한 없음)타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다        &lt;? extends 상위타입&gt; : Upper Bounded Wildcards (상위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있다        &lt;? super 하위타입&gt; : Lower Bounded Wildcards (하위 클래스 제한)타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다  자바의 공변성/ 반공변성제네릭의 와일드카드를 배우기 앞서 선수 지식으로 알고 넘어가야할 개념이 있다.조금 난이도 있는 프로그래밍 부분을 학습 하다보면 한번쯤은 들어볼수 있는 공변성(Covariance) / 반공변성(Contravariance) 합쳐서 ‘변성(Variance)’ 이라하는 개념이다.변성은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타태는 지표이다. 그리고 공변성은 서로 다른 타입간에 함께 변할수 있다는 특징을 말한다.이를 객체 지향 개념으로 표현하자면 Liskov 치환 원칙[1]Visit Website에 해당된다.  공변 : S 가 T 의 하위 타입이면,          S[] 는 T[] 의 하위 타입이다.List&lt;S&gt; 는 List&lt;T&gt; 의 하위 타입이다.        반공변 : S 가 T의 하위 타입이면,  T[] 는 S[] 의 하위 타입이다. (공변의 반대)List&lt;T&gt; 는 List&lt;S&gt; 의 하위 타입이다. (공변의 반대)  무공변 / 불공변 : S 와 T 는 서로 관계가 없다.          List&lt;S&gt; 와 List&lt;T&gt; 는 서로 다른 타입이다      제네릭은 공변성이 없다객체 타입은 상하 관계가 있다 그러나 제네릭 타입은 상하관계가 없다. 즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이 불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.제네릭 와일드 카드자바 제네릭을 이용해 프로그래밍 할때 간혹 클래스 정의문을 보다보면 꺾쇠 괄호 ? 물음표 기호가 있는 것을 한번쯤 본 적이 있을 것이다. 이 물음표가 와일드카드이며, 물음표의 의미 답게 어떤 타입이든 될 수 있다는 뜻을 지니고 있다.            와일드카드      네이밍      설명                  &lt;?&gt;      Unbounded wildcards  비한정적 와일드 카드      제한 없음 (모든 타입이 가능)              &lt;? extends U&gt;      Upper Bounded Wildcards 상한 경계 와일드카드      상위 클래스 제한 (U와 그 자손들만 가능)상한이 U라 상한 경계라고 한다.              &lt;? super U&gt;      Lower Bounded Wildcards  하한 경계 와일드카드      하위 클래스 제한 (U와 그 조상들만 가능)  하한이 U라 하한 경계라고 한다.      제네릭의 공변, 반공변자바의 제네릭은 기본적으로 공변, 반공변을 지원하지 않지만, &lt;? extends T&gt; , &lt;? super T&gt; 와일드카드를 이용하면 컴파일러 트릭을 통해 공변, 반공변이 적용되도록 설정 할 수 있다. 둘을 정리하자면 다음과 같다.  상한 경계 와일드카드 &lt;? extends U&gt; : 공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U를 상속받은 하위 클래스 (U와 U의 자손 타입만 가능)상한의 뜻 : 타입의 최고 한도는 U 라는 의미. (최대 U 이하)        하한 경계 와일드카드 &lt;? super U&gt; : 반공변성 적용          타입 매개변수의 범위는 U 클래스이거나, U가 상속한 상위 클래스 (U와 U의 조상 타입만 가능)하한의 뜻 : 타입의 최저 한도는 U 라는 의미. (최소 U 이상)        비경계          타입 매개변수의 범위는 제한이 없다. (모두 가능) &lt; ? extends Object &gt;의 줄임 표현      PECS (Producer-Extends / Consumer-Super)  외부에서 온 데이터를 생산(Producer) 한다면 &lt;? extends T&gt; 를 사용 (하위타입으로 제한)  외부에서 온 데이터를 소비(Consumer) 한다면 &lt;? super T&gt; 를 사용 (상위타입으로 제한). [1] : 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다.",
        "url": "//2024/05/18/java-series-17-Generic.html"
      }
      ,
    
      "2024-05-18-java-series-16-enum-html": {
        "title": "[java Series] 16 Enum",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - EnumerationEnumerationJAVA에서 enum은 interface와 같이 독립된 특수한 클래스로 구분된다. 즉, 일종의 객체이기 때문에 heap에 저장되며,각 enum 상수들은 별개의 메모리 주소 값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.장점  코드가 단순해지며 가독성이 좋아진다  허용 가능한 값들을 제한하여 유형 안전(type safe)을 제공한다.  키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 나타낼 수 있다.  자체 클래스 상수와 달리 switch문에서도 사용할 수 있다  단순 상수와 비교해 IDE의 적극적인 지원을 받을 수 있다 (자동완성, 오타검증, 텍스트 리팩토링 등등)  리팩토링시 변경 범위가 최소화 된다 (enum에서 한번에 관리하기 때문에 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다)  enum은 본질적으로 Thread safe인 싱글톤 객체 이므로 싱글톤 클래스를 생성하는데에도 사용된다메소드|메소드|\t설명\t|리턴 타입||:—–:|:——–:|:———–:||name()|열거 객체의 문자열을 리턴|String||ordinal()|열거 객체의 순번(0부터 시작)을 리턴|int||compareTo()|열거 객체를 비교해서 순번 차이를 리턴|int||valueOf(String name)|문자열을 입력받아서 일치하는 열거 객체를 리턴|enum||values()|모든 열거 객체들을 배열로 리턴|enum[]|java.lang.Enum모든 클래스가 Object 클래스를 자동 상속하는 것 처럼, Enum 클래스도 무조건 java.lang.Enum 이라는 클래스의 상속을 받는다. 그리고 java.lang.Enum 클래스에 정의되어 있는 메소드를 가져와 사용하는 것이다            메소드      내용                  clone()      객체를 복제하기 위한 메소드하지만, 이 메소드는 enum 클래스에서 사용하면 안된다.만약 호출될 경우엔 CloneNotSupportedException 이라는 예외를 발생시키도록 되어있다              finalize()      GC가 발생할 때 처리하기 위한 메소드              hashCode()      int 타입의 해시 코드 값을 리턴하는 메소드              equals()      두 개의 객체가 동일한지를 확인하는 메소드      Enum, Singleton자바에서의 enum 열거 타입은 일종의 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개하게 된다. 하지만 enum은 클래스처럼 이용할수는 있지만 인스턴스화는 할수는 없는데, 실제로 new 키워드로 인스턴스 생성을 하려고 하면 에러가 난다.이러한 제약적인 특징을 가지고 있는 이유는 enum 타입은 고정된 상수들의 집합으로써, 런타임(run-time)이 아닌 컴파일타임(compile-time)에 모든 값을 알고 있어야 하는 규칙이 있기 때문이다. 즉, 다른 패키지나 클래스에서 enum 타입에 접근해서 변수 처럼 동적으로 어떠한 값들을 할당해 주는 행위는 금지된 것이다.이 때문에 enum 객체의 생성자의 접근제어자를 private으로 설정해야 한다. 이렇게 되면 외부에서 접근 가능한 생성자가 없으므로 enum타입은 실제적으로 final 클래스와 다름이 없게 된다.이러한 특성 때문에, enum타입은 싱글톤을 구현하는 하나의 방법으로 사용되기도 한다.",
        "url": "//2024/05/18/java-series-16-Enum.html"
      }
      ,
    
      "2024-05-18-java-series-15-reflection-html": {
        "title": "[java Series] 15. Reflection",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - ReflectionReflectionjava.lang.Class자바 프로그래밍을 할때 우리는 보통 변수나 클래스를 직접 선언하고 만들어 사용하여 왔다. 그런데 어떤 경우에는 애플리케이션 실행 중에서 클래스를 동적으로 불러와 다루어야 할 경우가 생긴다. 즉, 코드를 실행하기전 컴파일 단에서 개발자가 직접 폴더를 뒤져가며 클래스 정의문을 찾아 클래스 정보를 얻는 것이 아닌, 코드 상에서 호출 로직을 통해 클래스 정보를 얻어와 다룸으로써 런타임 단에서 다이나믹하게 클래스를 핸들링 하는 것이다.이때 사용되는 것이 바로 Class 클래스 객체이다.Class 클래스는 java.lang.Class 패키지에 별도로 존재하는 독립형 클래스로서, 자신이 속한 클래스의 모든 멤버 정보를 담고 있기 때문에 런타임 환경에서 동적으로 저장된 클래스나 인터페이스 정보를 가져오는데 사용된다. 여기서 오해하지 말아야 할 것이 클래스 자료형을 말하는게 아니라 클래스 이름이 “Class” 인 클래스를 말하는 것이다.  JVM의 클래스 로더(class loader)는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.먼저 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환하고, 없으면 classpath에 지정된 경로를 따라서 클래스 파일을 찾아 해당 클래스 파일을 읽어서 Class 객체로 변환한다.만일 못 찾으면 우리가 익히아는 ClassNotFoundException 예외를 띄우게 된다.Class 객체 얻기Object.getClass()  모든 클래스의 최상위 클래스인 Object 클래스에서 제공하는 getClass() 메서드를 통해 가져온다.  해당 클래스가 인스턴스화 된 상태 이어야 한다는 제약이 있다.java Class&lt;? extends String&gt; cls = str.getClass();.class 리터럴로 얻기  인스턴스가 존재하지 않고, 컴파일된 클래스 파일만 있다면 리터럴로 Class 객체를 곧바로 얻을 수 있다.  가장 심플하게 Class 객체를 가져오는 방법이다.java  Class&lt;? extends String&gt; cls2 = String.class;Class.forName() 으로 얻기  위의 리터럴 방식과 같이 컴파일된 클래스 파일이 있다면 클래스 이름만으로 Class 객체를 반환 받을 수 있다.  클래스의 도메인을 상세히 적어주어야 한다. 그래서 클래스 파일 경로에 오타가 있으면 에러가 발생할 수 있기 때문에 주의해야한다. (대소문자 실수 등)  만일 Class 객체를 찾지 못한다면 ClassNotFoundException를 발생 시키기 때문에 예외처리가 강제된다.  그러나 다른 두가지 방법보다 forName을 통해 얻게 되면 메모리를 절약하며 동적 로딩 할 수 있기 때문에 가장 성능이 좋다.java Class&lt;?&gt; cls3 = Class.forName(\"java.lang.String\");  Class 클래스 객체를 forName() 메서드를 통해 가져오는 방법을 ‘동적 로딩’이라고 부른다. 보통 다른 클래스 파일을 불러올때는 컴파일 시 JVM의 Method Area에 클래스 파일이 같이 바인딩(binding)이 되지만, forName()으로 .class파일을 불러올 때는 컴파일에 바인딩이 되지않고 런타임때 불러오게 되기 때문에 동적 로딩이라고 부른다.그래서 컴파일 타입에 체크 할 수 없기 때문에 클래스 유무가 확인되지 않아 예외 처리를 해주어야 하는 이유이기도 하다.Class 메소드 종류  String getName(): 클래스의 이름을 리턴한다.  Package getPackage(): 클래스의 패키지 정보를 패키지 클래스 타입으로 리턴한다.  Field[] getFields(): public으로 선언된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.  Field getField(String name): public으로 선언된 변수를 Field 클래스 타입으로 리턴한다.  Field[] getDeclaredFields(): 해당 클래스에서 정의된 변수 목록을 field 클래스 배열 타입으로 리턴한다.  Field getDeclaredField(String name): name과 동일한 이름으로 정의된 변수를 Field 클래스 타입으로 리턴한다.  Method[] getMethods(): public으로 선언된 모든 메소드 목록을 Method 클래스 배열 타입으로 리턴한다. 해당 클래스에서 사용 가능한 상속받은 메소드도 포함된다.  Method getMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 메소드를 Method 클래스 타입으로 리턴한다.  Method[] getDeclaredMethods(): 해당 클래스에서 선언된 모든 메소드 정보를 리턴한다.  Method getDeclaredMethod(String name, Class... parameterTypes): 지정된 이름과 매개변수 타입을 갖는 해당 클래스에서 선언된 메소드를 Method 클래스 타입으로 리턴한다.  Constructor[] getConstructors(): 해당 클래스에 선언된 모든 public 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  Constructor[] getDeclaredConstructors(): 해당 클래스에서 선언된 모든 생성자의 정보를 Constructor 배열 타입으로 리턴한다.  int getModifiers(): 해당 클래스의 접근자(modifier) 정보를 int 타입으로 리턴한다.  String toString(): 해당 클래스 객체를 문자열로 리턴한다.Reflection APIClass 객체를 이용하면 클래스에 대한 모든 정보(클래스의 정의된 멤버의 이름이나 개수 등)를 런타임 단에서 코드 로직으로 얻을 수 있다는 것을 알았다.클래스 정보들을 실행부에서 얻을 수 있는 점은 꽤나 매력적인데, 이러한 정보들을 이용하여 오로지 Class 객체만으로 본 클래스를 인스턴스화 할 수 있고,메서드를 호출 할 수 있는 ..등 보다 동적인 코드를 작성할 수 있게 된다. 이처럼 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메소드, 타입, 변수, …)에 접근할 수 있게 해주는 자바 기법을 Reflection API 라고 부른다.자바 리플렉션(Reflection - 사전적 의미 : 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그램 기법이다.클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍을 가능케 해준다.사용법동적으로 생성자 가져와서 초기화public static void main(String[] args) throws Exception {    // 클래스 객체 가져오기 (forName 메소드 방식)    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 생성자 가져오기 - Person(String name, int age)    Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); // getConstructor 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.    // 가져온 생성자로 인스턴스 만들기    Person person1 = constructor.newInstance(\"홍길동\", 55);    person1.getField(); // 이름 : 홍길동, 나이 : 55}  getConstructor() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만일 어떠한 매개변수 타입을 지정해주지 않으면 기본 생성자가 호출되게 된다.  만약 해당하는 생성자를 찾지 못하면 NoSuchMethodException이 발생된다메소드 가져와서 실행하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // 특정 public 메서드 가져와 실행    // getMethod(\"메서드명\", 매개변수타입들)    Method sum = personClass.getMethod(\"sum\", int.class, int.class);    int result = (int) sum.invoke(new Person(), 10, 20);    System.out.println(\"result = \" + result); // 30    // 특정 static 메서드 가져와 실행    Method staticSum = personClass.getMethod(\"staticSum\", int.class, int.class);    int staticResult = (int) staticSum.invoke(null, 100, 200);    System.out.println(\"staticResult = \" + staticResult); // 300    // 특정 private 메서드 가져와 실행    Method privateSum = personClass.getDeclaredMethod(\"privateSum\", int.class, int.class);    privateSum.setAccessible(true); // private 이기 때문에 외부에서 access 할 수 있도록 설정    int privateResult = (int) privateSum.invoke(new Person(), 1000, 2000);    System.out.println(\"privateResult = \" + privateResult); // 3000}  getMethod() 를 호출할때 인자로 생성자의 매개변수 타입을 바인딩 해주어야 한다.  만약 매개변수가 없는 메소드라면 메소드 명만 입력해주면 된다.  실행은 Method 타입에서 제공하는 invoke()를 호출하여 실행하면 된다.          instance 메소드 - 매개변수로 인스턴스 필요      static 메소드 - 매개변수 필요 없음      private 메소드 - invoke 하기전에 공개화 할 필요있음      동적으로 필드 가져와 조작하기public static void main(String[] args) throws Exception {    Class&lt;Person&gt; personClass = (Class&lt;Person&gt;) Class.forName(\"Person\");    // static 필드를 가져와 조작하고 출력하기    Field height_field = personClass.getField(\"height\");    height_field.set(null, 200);    System.out.println(height_field.get(null)); // 200}  getField() 를 통해 클래스의 필드를 얻을 수 있다.  필드 값 변경은 set() 메서드를 호출하면 된다.  필드는 클래스가 인스턴스가 되어야 Heap 메모리에 적재됨으로 인스턴스가 필요하다.  다만, static 필드라면 Method Area에 이미 적재되어 있으므로 인스턴스가 필요없다.",
        "url": "//2024/05/18/java-series-15.-Reflection.html"
      }
      ,
    
      "2024-05-18-java-series-14-dynamicproxy-html": {
        "title": "[java Series] 14 Dynamicproxy",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 다이나믹 프록시Dynamic Proxy자바 프로그래밍의 디자인 패터중 하나인 프록시 패턴Visit Website은 초기화 지연, 접근 제어, 로깅, 캐싱 등,기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴이다.이 디자인 패턴을 적용하면 개방 폐쇄 원칙(OCP)Visit Website의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 플러스 효과를 얻을 수 있다는 장점이 있다.하지만 프록시 디자인 패턴은 대상 원본 클래스 수만큼 일일히 프록시 클래스를 하나하나 만들어 줘야하는 치명적인 단점이 존재한다. 즉, 프록시 적용 대상 객체가 100개면 프록시 객체도 100개 만들어줘야 한다는 말이다. 따라서 코드량이 많아지게 되고 중복이 발생하여 코드의 복잡도가 증가한다는 한계점이 존재한다.바로 이러한 단점들을 보완하여 컴파일 시점이 아닌 런타임 시점에 프록시 클래스를 만들어주는 방식이 자바 가상 머신(JVM)에서 공식적으로 지원하는 동적 프록시(Dynamic Proxy) 기능이다.동적 프록시는 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의 Reflection APIVisit Website 기법을 응용한 연장선의 개념이다. 프록시 패턴의 기본 흐름은 거의 같고, 프록시를 클래스로 직접만들어서 등록하냐 이미 지원하는 api를 이용하여 동적으로 등록하느냐에 따른 차이만 있을 뿐이다.Dynamic Proxy 구성 요소newProxyInstance() Methodpublic class Proxy implements java.io.Serializable {\t// ...        public static Object newProxyInstance(        ClassLoader loader,  //클래스 로더         Class&lt;?&gt;[] interfaces,  // 타깃의 인터페이스        InvocationHandler h  // 타깃 정보가 포함된 Handler    ) throws IllegalArgumentException {        // ...    }}      ClassLoader loader프록시 클래스를 만들 클래스 로더(Class Loader)Proxy 객체가 구현할 Interface에 Class Loader를 얻어오는 것이 일반적        Class&lt;?&gt;[] interfaces프록시 클래스가 구현하고자 하는 인터페이스 목록 (배열)메서드를 통해 생성 될 Proxy 객체가 구현할 Interface를 정의한다.        InvocationHandler h프록시의 메서드(invoke)가 호출되었을때 실행되는 핸들러 메서드  InvocationHandlerInvocationHandler 인터페이스는 위에서 본 newProxyInstance() 메서드의 3번째 매개변수에 들어갈 핸들러 메서드를 정의하는 함수형 인터페이스이다.이 인터페이스 코드 구성을 보면 내부에 invoke() 라는 추상메서드 하나만 정의되어있는 걸 볼 수 있다.invoke() 메서드는 동적 프록시의 메서드가 호출되었을때, 이를 낚아채어 대신 실행되는 메서드이다. 메서드의 파라미터를 통해 어떤 메서드가 실행되었는지 메서드 정보와 메서드에 전달된 인자까지 알수있다.디자인 패턴으로 프록시를 구성하면 단점이 중복된 메서드 코드 로직이 발생한다는 점인데, 이 invoke() 메서드에 동적으로 등록함으로써 반복된 코드를 줄이게 되는 것이다.public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}  Object proxy : 프록시 객체  Method method : 호출한 메서드 정보  Object[] args : 메서드에 전달된 매개변수 (배열)예시interface AInterface {    String call();    void print();    void run();}class AImpl implements AInterface {    @Override    public String call() {        System.out.println(\"A 호출\");        return \"a\";    }    @Override    public void print() {        System.out.println(\"A print @@@@@@@\");    }    @Override    public void run() {        System.out.println(\"A Running !!!!!!!!!\");    }}public class Client {    public static void main(String[] arguments) {        AInterface proxyA = (AInterface) Proxy.newProxyInstance(                AInterface.class.getClassLoader(),                new Class[]{AInterface.class},                (proxy, method, args) -&gt; { // 람다 함수                    Object target = new AImpl();                    System.out.println(\"TimeProxy 실행\");                    long startTime = System.nanoTime();                    Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행                    long endTime = System.nanoTime();                    long resultTime = endTime - startTime;                    System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);                    return result;                }        );        proxyA.call();        proxyA.print();        proxyA.run();    }}Dynamic Proxy 제약 사항지금까지 동적 프록시 구현 및 응용을 다뤄보았다. 아주 약간의 퍼포먼스를 희생하고 자유롭게 프록시를 다이나믹하게 등록할 수 있지만,여기에 추가로 한가지 제약사항이 존재한다. 동적 프록시에 타켓을 등록할때 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 된다는 점이다.인터페이스를 기반으로 프록시를 동적으로 만들어주기 때문에, 인터페이스가 필수이기 때문이다.즉, 자바에서 newProxyInstance()를 이용해 동적 프록시 객체를 만들때 Class 기반으로는 Proxy 객체를 생성할 수 없다는 말이다. 하지만 클래스의 확장성을 고려할 필요가 없거나 한가지 책임만 분명하게 하는 경우 굳이 인터페이스를 등록해 사용하지 않는 겨우도 있다. 프록시 때문에 굳이 일일히 인터페이스를 구현해야 하는 것도 결국은 디자인 패턴의 한계점의 회귀이다.CGLIB(Code Generator Library)인터페이스가 아닌 클래스를 대상으로 바이트 코드를 조작해서 프록시 생성할 수 있는 라이브러리다.효용성을 입증 받아 스프링에 기본으로 내장돼있다.  스프링 프레임워크에서 Bean을 등록할 때 Spring AOP를 이용하여 등록을 하는데, Bean으로 등록하려는 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 Interface를 구현하고 있지 않으면 CGLIB 라이브러리를 이용한다.CGLIB 프록시CGLIB 에서는 Enhancer 객체로 프록시 객체를 만들며 MethodInterceptor 인터페이스로 프록시 핸들러를 등록한다.// 프록시 핸들러class MyProxyInterceptor implements MethodInterceptor {    private final Object target;    MyProxyInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(            Object o,            Method method,            Object[] args,            MethodProxy methodProxy    ) throws Throwable {        System.out.println(\"TimeProxy 실행\");        long startTime = System.nanoTime();        Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행        long endTime = System.nanoTime();        long resultTime = endTime - startTime;        System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);        return result;    }}// 프록시를 적용할 대상 타켓class Subject {    public void call() {        System.out.println(\"서비스 호출\");    }}public class Client {    public static void main(String[] arguments) {        // 1. 프록시 등록 (CGLIB는 Enhancer를 사용해서 프록시를 등록한다)        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Subject.class); // CGLIB는 구체 클래스를 상속 받아서 프록시를 생성하기 때문에 상혹할 구체 클래스를 지정        enhancer.setCallback(new MyProxyInterceptor(new Subject())); // 프록시 핸들러 할당        // 2. 프록시 생성        Subject proxy = (Subject) enhancer.create(); // setSuperclass() 에서 지정한 클래스를 상속 받아서 프록시가 만들어진다.        // 3. 프록시 호출        proxy.call();    }}람다로?public class Client {    public static void main(String[] arguments) {                Subject proxy = (Subject) Enhancer.create(Subject.class, (MethodInterceptor) (o, method, args, methodProxy) -&gt; {            Subject target = new Subject();            System.out.println(\"TimeProxy 실행\");            long startTime = System.nanoTime();            Object result = method.invoke(target, args); // 파라미터로 전달받은 메서드를 invoke로 실행            long endTime = System.nanoTime();            long resultTime = endTime - startTime;            System.out.println(\"TimeProxy 종료 resultTime = \" + resultTime);            return result;        });                proxy.call();    }}주의사항이렇게 보면 인터페이스 기반일 때는 Dynamic Proxy를 사용하고, 클래스 기반일 때는 CGLIB를 사용하면 되겠지만, 이 라이브러리도 제약사항이 존재한다.우선 CGLIB는 기본적으로 클래스 상속(extends)을 통해 프록시 구현이 되기 때문에, 타겟 클래스가 상속이 불가능할때는 당연히 프록시 등록이 불가능하다. 또한 메서드에 final 키워드가 붙게되면 그 메서드를 오버라이딩하여 사용 할수 없게되어 결과적으로 프록시 메서드 로직이 작동되지 않는다.정리하자면 프록시 대상 객체는 상속에 있어 제한이 있으면 안된다는 것이다.  클래스와 메소드에 final 키워드 적용  추상 클래스(abstract class)  클래스의 생성자를 private화 하여 생성자를 제한할 경우",
        "url": "//2024/05/18/java-series-14-DynamicProxy.html"
      }
      ,
    
      "2024-05-18-java-series-13-serialize-deserialize-html": {
        "title": "[java Series] 13 Serialize_deserialize",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 직렬화 역직렬화Serialize &amp; Deserialize직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes)형태로 연속적인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다. 그 반대 개념인 역직렬화는(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다.이를 시스템적으로 살펴보면, JVM의 힙(heap) 혹은 스택(stack) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여데이터베이스나 파일과 같은 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역질렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.직렬화 사용처  서블릿 세션          단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 만일 세션 데이터를 저장 &amp; 공유가 필요할때 직렬화를 이용한다.      세션 데이터를 데이터베이스에 저장할때      톰캣의 세션 클러스터링Visit Website을 통해 각 서버간에 데이터 공유가 필요할때        캐시          데이터베이스로부터 조회한 객체 데이터를 다른 모듈에서도 필요할때 재차 DB를 조회하는 것이 아닌, 객체를 직렬화하여 메모리나 외부 파일에 저장해 두었다가 역직렬화하여 사용하는 캐시 데이터로서 이용이 가능하다.      물론 자바 직렬화를 이용해서만 캐시를 저장할 수 있는 것은 아니지만 자바 시스템에서 만큼은 구현이 가장 간편하기 때문에 많이 사용된다고 보면 된다.      단, 요즘은 Redis, Memcached 와 같은 캐시 DBVisit Website를 많이 사용하는 편이다.        Remote Method Invocation          자바 RMI는 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.      이 메세지에 객체 데이터를 직렬화하여 송신하는 것이다.      최근에는 소켓을 이용하기 때문에 안쓰이는 기술이다.      직렬화 vs. JSON자바 직렬화의 장점  직렬화는 자바의 고유 기술인 만큼 당연히 자바 시스템에서 개발에 최적화되어 있다.  자바의 광활한 레퍼런스 타입에 대해 제약 없이 외부에 내보낼 수 있다는 것이다.사실 그 외에는 JSON이 훨씬 낫다.직렬화 방법  Serialize 구현Serializable 인터페이스는 아무런 내용도 없는 마커 인터페이스Visit Website 로서, 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준으로 사용된다.  ObjectOutputStream 객체 직렬화직렬화(스트림에 객체를 출력) 에는 ObjectOutputStream을 사용한다.객체가 직렬화될때 오직 객체의 인스턴스 필드값 만을 저장한다. static 필드나 메서드는 직렬화하여 저장하지 않는다직렬화 요소의 제외  transient 키워드    class Customer implements Serializable { int id;  String name;  transient String password; // 직렬화 대상에서 제외 int age;  public Customer(int id, String name, String password, int age) {     this.id = id;     this.name = name;     this.password = password;     this.age = age; }     ...}        readObject / writeObject 재정의직렬화 &amp; 역직렬화할때 호출되는 readObject() 와 writeObject() 는 기본적으로 모든 요소에 대해 자동 직렬화 한다. 그런데 이 메서드들을 직렬화할 클래스에 별도로 재정의 해주면 직렬화를 선택적으로 조작할 수 있게 된다. 이를 커스텀 직렬화 라고도 불리운다.class Customer implements Serializable {    int id; // 고객 아이디    String name; // 고객 닉네임    String password; // 고객 비밀번호    int age; // 고객 나이    public Customer(int id, String name, String password, int age) {        this.id = id;        this.name = name;        this.password = password;        this.age = age;    }    // 직렬화 동작 재정의    private void writeObject(ObjectOutputStream out) throws IOException{        out.writeInt(id);        out.writeObject(name);        out.writeInt(age);    }    // 역직렬화 동작 재정의    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{        this.id = in.readInt();        this.name = (String) in.readObject();        this.age = in.readInt();    }    @Override    public String toString() {        return \"Customer{\" +                \"id=\" + id +                \", password='\" + password + '\\'' +                \", name='\" + name + '\\'' +                \", age=\" + age +                '}';    }}  상속 관계에서 직렬화만약 부모-자식 상속 관계에서 부모 클래스가 Serializable을 구현했다면 자식 클래스는 Serializable을 구현하지 않아도 직렬화가 가능하다. 그러면 반대로 부모 클래스는 Serializable을 구현하지 않고 자식 클래스만 구현했다면 어떤 방식으로 직렬화될까?직렬화할때 부모 클래스의 인스턴스 필드는 무시되고 자식 필드만 직렬화가 된다. 따라서 상위 클래스의 필드까지 직렬화하려면 부모 클래스가 Serializable을 구현하도록 설정하던지,위에서 다뤄본 writeObject / readObject 메서드를 재정의하여 직접 직렬화 코드를 추가 하면 된다.직렬화 버전 관리      SerialVersionUIDSerializable 인터페이스를 구현하는 모든 직렬화된 클래스는 serialVersionUID(이하 SUID) 이라는 고유 식별번호를 부여 받는다. 이 식별 ID는 클래스를 직렬화, 역직렬화 과정에서 동일한 특성을 갖는지 확인하는데 사용된다. 그래서 클래스 내부 구성이 수정될 경우, 기존에 직렬화한 SUID와 현재 클래스의 SUID 버전이 다르기 때문에 이를 인지하고 InvalidClassException 예외가 발생시켜 값 불일치 되는 현상을 미연에 방지한다.단, 직렬화 스펙 상 serialVersionUID 값 명시는 필수가 아니며, 만일 클래스에 SUID 필드를 명시하지 않는다면, 시스템이 런타임에 클래스의 이름, 생성자 등과 같이 클래스의 구조를 이용해 암호 해시함수를 적용해 자동으로 클래스 안에 생성하게 된다.        수동 버전 관리만일 네트워크로 객체를 직렬화하여 전송하거나 협업을 하는 경우 수신자와 송신자 모두 같은 버전의 클래스를 가지고 있어야 할텐데, 만일 클래스가 조금만 변경사항이 있으면 모든 사용자에게 재배포해야 하는 애로사항이 생겨 프로그램을 관리하기 어렵게 만든다.  따라서 직렬화 클래스는 왠만한 상황에선 serialVersionUID 를 직접 명시해주어 클래스 버전을 수동으로 관리하는 것을 권장하는 편이다.SUID를 직접 명시해주면 클래스의 내용이 변경되어도, 클래스의 버전이 시스템이 자동 생성된 값으로 변경되지 않기 때문이다. 이외에도 런타임에 SUID를 생성하는 시간도 많이 잡아먹기 때문에 미리 명시를 강력히 권장되는 바이다.  SerialVersionUID 수동 관리 유의사항  클래스 serialVersionUID를 명시하더라도 절대 만능이 아니다. 위와 같이 단순히 필드 변수 하나 추가하는 정도는 문제가 없겠지만 필드 타입을 변경하는 상황에서는 버전 수동 관리를 하여도 예외를 막을순 없다.직렬화 예외  InvalidClassException  NotSerializableException직렬화의 단점  용량이 크다. (메타 정보를 모두 가지고 있다.)  역직렬화 과정에서 공격당할 위험이 있다.  릴리즈 후 수정이 어렵다.  클래스 캡슐화가 깨진다.  버그와 보안에 취약하다.",
        "url": "//2024/05/18/java-series-13-Serialize_Deserialize.html"
      }
      ,
    
      "2024-05-18-java-series-12-brokensingleton-html": {
        "title": "[java Series] 12 Brokensingleton",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Singleton과 훼손Singleton싱글톤은 기본적으로 단 하나의 유일한 객체를 의미한다.역직렬화에 의한 싱글톤 훼손자바의 직렬화(Serialize)는 JVM의 힙 메모리에 있는 객체 데이터를 바이트 스트림(byte stream) 형태로 바꿔 외부 파일로 내보낼수 있게 하는 기술을 말한다. 반대로 외부로 내보낸 직렬화 데이터를 다시 읽어들여 자바 객체로 재변환하는 것을 역직렬화(Deserialize) 라 한다.직렬화하여 내보낸 외부 파일은 데이터베이스에 저장되기도 하며 네트워크를 통해 전송되기도 한다. 이 직렬화를 적용하기 위해선 클래스에 Serializable 인터페이스를 implements 하면 된다.그런데 만일 어떤 클래스를 직렬화하여 다른 컴퓨터에 전송하려는데, 이 클래스를 싱글톤으로 구성하려고 한다. 하지만 이 싱글톤 클래스는 송신자가 파일을 받고 역직렬화시 깨지게 되어 더이상 싱글톤이 아니게 된다.이러한 현상이 생기는 이유는 역직렬화 자체가 보이지 않은 생성자로서 역할을 수행하기 때문에 인스턴스를 또다시 만들어, 직렬화에 사용한 인스턴스와는 전혀 다른 인스턴스가 되기 때문에 일어나는 것이다. 따라서 클래스에 Serializable을 구현하면 더 이상 이 클래스는 싱글톤이 아니게 되어 메모리 이점을 더이상 얻을수 없게 된다.훼손 대응 방안이러한 싱글톤의 역직렬화의 대응 방안으로 직렬화 관련 메서드인 readResolve() 를 정의하면 된다.readResolve 메서드를 정의하게 되면, 역직렬화 과정에서 readObject를 통해 만들어진 인스턴스 대신 readResolve에서 반환되는 인스턴스를 내가 원하는 것으로 바꿀 수 있기 때문이다. 그리고 기존에 역직렬화를 통해 새로 생성된 객체는 알아서 Garbage CollectorVisit Website의 대상이 된다.class Singleton implements Serializable {    private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    // 역직렬화한 객체는 무시하고 클래스 초기화 때 만들어진 인스턴스를 반환    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}이때 싱글턴 인스턴스의 직렬화 결과에는 아무런 실 데이터를 가질 이유가 없기 때문에, 싱글톤 클래스에 필드 변수들이 있을 경우 모든 인스턴스 필드를 transient로 선언한다. 아무리 readResolve 메서드라도 역직렬화 과정 중간에 역직렬화된 인스턴스의 참조를 훔쳐오는 공격을 행할경우 다른 객체로 바뀔 위험이 있기 때문이다.class Singleton implements Serializable {    // 싱글톤 객체의 필드들을 transient 설정하여 직렬화 제외    transient String str = \"\";    transient ArrayList lists = new ArrayList();    transient Integer[] integers;        private Singleton() {}    private static class SettingsHolder {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SettingsHolder.INSTANCE;    }    private Object readResolve() {        return SettingsHolder.INSTANCE;    }}리플렉션에 의한 싱글톤 훼손자바 리플렉션(Reflection - 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 조작하는 프로그램 기법이다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고 객체를 생성하는 것 또한 가능하게 해준다.이러한 리플렉션 기법은 프레임워크, 라이브러리에서 많이 사용된다. 왜냐하면 프레임워크, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버들을 구성할지 모르는데, 이러한 사용자 클래스들을 기존의 기능과 동적으로 연결 시키기 위하서 이다. 이미 Spring, Lombok 등 많은 프레임워크에서 리플렉션 기능을 사용하고 있다.그런데 문제는 리플렉션을 통해 싱글톤 객체를 생성하게 되면 다른 객체를 반환해 싱글톤이 다시 한번 깨지는 것이다. 클래스 객체를 통해 해당 객체의 생성자를 받아와 newInstance() 메서드를 실행하면 인스턴스를 생성할 수 있게 되는데, 여기서 생성된 인스턴스는 Holder가 가지고 있는 인스턴스와는 전혀 다른 새로운 인스턴스이기 때문이다.",
        "url": "//2024/05/18/java-series-12-BrokenSingleton.html"
      }
      ,
    
      "2024-05-18-java-series-11-heappollution-html": {
        "title": "[java Series] 11 Heappollution",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 힙 오염Heap Pollution힙 오염은 JVM의 Heap 메모리 영역에 저장되어 있는 특정 변수가 불량 데이터를 참조함으로써, 만일 힙에서 데이터를가져오려고 할 때 얘기치 못한 런타임 에러가 발생할 수 있는 오염 상태를 의미한다.힙 오염의 대표 이유는 Generic이다.Generic collection은 이전 버전과의 호환성을 위해서 Compile 때 Generic을 Object으로 변환하거나 제거함으로써 하위 호환을 했다.  제네릭 타입 소거(Erasure)  제네릭은 type-safe하며 실행 시간 오버헤드를 줄이기 위해서 도입된 문법으로, 이전 자바에서 제네릭 타입 파라미터가 없던 탓에 호환성을 위해서제네릭은 컴파일되면 제네릭 타입은 사라졌다. 즉, .class에는 제네릭 정보가 존재하지 않았다.  컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거하기 때문에 잠재적 힙 오염 문제에 빠질 수 있게 됐다.  Reifiable, Non-Reifiable  실체화 타입(Reifiable Type)이란 컴파일 단계에서 타입 소거에 의해 지워지지 않는 타입 정보를 말한다.      int, double, float, byte 등 원시 타입    Number, Integer 등 일반 클래스와 인터페이스 타입    List, ArrayList, Map 등 자체(Raw Type)    List&lt;?&gt;, ArrayList&lt;?&gt; 등 비한정 와일드 카드가 포함된 매개변수화 타입 (와일드 카드 &lt;?&gt; 는 애초에 타입 정보가 명시되지 않았으므로 타입 소거를 해도 별 문제가 없다. 컴파일 타임에 Object로 변환 됨)    비실체화 타입(Non-Reifiable Type) 컴파일 단계에서 타입 소거에 의해서 타입 정보가 제거된 타입을 의미한다. 제네릭 타입 파라미터는 모두 제거된다.      List, List    List, ArrayList    List&lt;? extends Number&gt;, List&lt;? super String&gt;    제네릭 소거 과정  컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 필요한 곳에 형 변환을 넣고 최종적으로 컴파일 코드에 Type Erasure로 제네릭 타입을 제거하게 된다.      제네릭 타입의 경계(bound)를 제거              제네릭  -&gt; T는 Number로 치환                  는 Object로 치환```java// T extends Type -&gt; Type /* 치환 전 */class Box {List list = new ArrayList&lt;&gt;();                    void add(T item) {    list.add(item); }      T getValue(int i) {     return list.get(i); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);} } ```              제네릭 타입을 제거한 후 타입이 일치하지 않는 곳은 형 변환을 추가한다.```java/* 치환 전 */class Box { List list = new ArrayList(); // Object      void add(Number item) {     list.add(item); }}        /* 치환 후 */class Box {    List list = new ArrayList(); // Object  void add(Number item) {    list.add(item);}Number getValue(int i) {    return (Number) list.get(i); // 캐스팅 연산자 추가} } ``` 3. 소거는 똑같이 진행 ```java // T -&gt; Object /* 치환 전 */ public static &lt;T&gt; int count(T[] anArray, T elem) {int cnt = 0;for (T e : anArray)    if (e.equals(elem))        ++cnt;    return cnt; }    /* 치환 후 */public static int count(Object[] anArray, Object elem) {    int cnt = 0;    for (Object e : anArray)        if (e.equals(elem))            ++cnt;        return cnt;}```  Bridge 메소드  컴파일러는 확장된 제네릭 타입에 대해서 타입 소거를 해도 다형성 보존을 위해서 별도의 bridge method를 생성한다.제네릭 힙 오염  원시 타입과 매개변수 타입을 동시에 사용하는 경우  확인되지 않은 형 변환을 수행하는 경우//ClassCastException 발생 예정ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"A\");list1.add(\"B\");Object obj = list1; //상위 타입 Object로 변경ArrayList&lt;Double&gt; list2 = (ArrayList&lt;Double&gt;) obj; //DownCastlist2.add(1.0);list2.add(2.0);System.out.println(list2); // [홍길동, 임꺾정, 1.0, 2.0]for(double n : list2) {    System.out.println(n);}컴파일러는 위의 코드에 대해서 컴파일 에러를 내지 않는다. 이는 제네릭 타입 소거에 의해서 나타나는 문제다.1. 컴파일러는 타입 캐스팅을 검사하지 않는다.-&gt; 컴파일러는 형변환 대상 객체에 대해서 검사하지 않는다. 정확히 말하면 캐스팅 했을 때 대입되는 변수에 저장할 수 있느냐만 검사한다.2. 제네릭 타입이 소거되면 결국 Object-&gt; 컴파일되면서 결국 제네릭은 Object가 된다. 결국 위 예시는 RawType이 되면서 어떤 정보든 저장할 수 있게 되면서 컴파일 에러가 나지 않는다.제네릭 힙 오염 방지책자바에서 Collections 클래스의 checkList() 메소드를 지원한다 해당 객체에 대해서 의도치 않은 타입의 데이터가 들어갔을 때 이를 감지하여 예외를 발생시킨다. https://inpa.tistory.com/entry/JAVA-☕-제네릭-타입-소거-컴파일-과정-알아보기 ",
        "url": "//2024/05/18/java-series-11-HeapPollution.html"
      }
      ,
    
      "2024-05-18-java-series-10-equalsandhashcode-html": {
        "title": "[java Series] 10 Equalsandhashcode",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Equals And Hash CodeEqualsAndHashCodeEquals어떤 참조 변수의 값이 같은지 다른지 동등 비교를 할 때 사용비교할 대상이 객체면 주소 값을 비교한다.override Equals기본적으로 참조형은 주소 값을 비교한다. 아무래 내부 필드가 같아도 엄연히 다른 주소 값이다. 그래서 Java에서는 필드 값을 비교하도록 오버라이드 해서 주소 값 비교를 우회한다.HashCode객체 주소 값을 해싱해서 해시코드를 만든 후 반환한다.(객체의 지문과 같다.)엄밀히 말하면 주소 값으로 만든 고유한 숫자 값이다.override Hashcode만약 Equals만 오버라이드하면 에러를 낸다. java는 equals를 오버라이드하면 당연히 hashcode도 객체의 필드를 다루도록 오버라이드 하도록 한다.왜냐하면 equals()의 결과가 true면 두 객체의 해시코드는 반드시 같아야 한다는 자바의 규칙때문이다.이렇게 강요하는 이유는 hash 값을 사용하는 CollectionFrameWork 사용에 문제가 발생하기 때문이다.ex) setEquals and Hashcode 동작 순서?https://inpa.tistory.com/entry/JAVA-☕-equals-hashCode-메서드-개념-활용-파헤치기1. HashCode는 고유하지 않다.보통 해싱 알고리즘은 서로 다른 주소를 가진 경우 같은 해시코드를 가질 여지가 없다. 64bit(8바이트) 주소값을 hashCode로 이용해서 반환하면4바이트(32bit)로 강제 캐스팅 되기 때문에 값이 겹칠 수도 있다. 즉 서로 다른 객체라도 같은 해시코드를 반환할 수 있다. 2. 해결책@EqualsAndHashCode에서 볼 수 있듯 equals로 두 객체의 진짜 주소를 직접 비교하는 식으로 극복한다.진짜 주소 값이 필요할때?hashcode() 오버라이드 시 비교 대상 객체가 같은지 아닌지를 판별할 수 있다. 그런데, 오버라이드 해버리면 객체 자체의 주소 값(해시코드)가 필요할 때 난감해진다.그래서 identityHashCode()라는 메소드를 제공한다.",
        "url": "//2024/05/18/java-series-10-EqualsAndHashCode.html"
      }
      ,
    
      "2024-05-18-java-series-09-innerclassproblem-html": {
        "title": "[java Series] 09 Innerclassproblem",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - Inner class에서의 문제점Inner Class ProblemInner Class를 선언하면 Inner Class를 static으로 설정하라고 경고한다.이는 Inner Class가 Inner static 보다 메모리를 더 많이 쓰고, 느리고, 바깥 클래스가 GC 대상에서 빠져 메모리 관리에 문제가 될 수 있다.Inner class는 외부 참조를 한다.일반적으로 내부 클래스를 만들기 위해서는 외부 클래스를 초기화 해야한다. 이러한 문제 때문에 inner 클래스는 외부 참조를 갖게 된다. 심지어 내부 클래스가 외부 멤버를사용하지 않아도 숨겨진 외부 참조가 생성된다.public class Outer_Class {    int field = 10;    class Inner_Class {        int inner_field = 20;    }}// Outer_class$Inner_class.class// Outer_class.class// 바이트 코드를 디컴파일하면class Outer_Class$Inner_Class {    int inner_field;        Outer_Class$Inner_Class(Outer_Class this$0) { //생성자로 외부 클래스를 매개 변수로 받아서 초기화        this.this$0 = this$0;        this.inner_field = 20;    }}// 즉 바깥 클래스의 인스턴스와 암묵적으로 연결Inner 클래스의 메모리 누수Inner 클래스가 바깥 클래스를 외부 참조하므로 외부 클래스는 필요가 없고 내부 클래스만 남아있을 경우, 외부 참조로 내부 클래스와연결되어 있기 때문에 메모리에 잔존하고 누수로 이어진다.해결법은 static  static inner는 외부 참조가 없다.  static inner는 메모리 누수가 없다.",
        "url": "//2024/05/18/java-series-09-InnerClassProblem.html"
      }
      ,
    
      "2024-05-18-java-series-08-callby-html": {
        "title": "[java Series] 08 Callby",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - CallByCall By Value vs. Call By Reference프로그래밍을 하다보면 반드시 마주치는 것이 바로 call by value / call by reference 개념이다.함수의 매개변수에서 값을 복사하느냐 주소값을 참조하느냐에 따라 반환 결과가 달라지기 때문에 대부분의 프로그래밍 교육과정에선 중요시 하게 여긴다.자바에서도 역시 call by value 와 call by reference 동작 차이가 존재한다.자바의 데이터형을 알아보면 크게 두가지로 나뉘게 된다.  기본형(primitive type) - Boolean Type(boolean), Numeric Type(short, int, long, float, double, char)  참조형(reference type) - Class Type, Interface Type, Array Type, Enum Type, 기본형을 제외한 모든 것들",
        "url": "//2024/05/18/java-series-08-CallBy.html"
      }
      ,
    
      "2024-05-18-java-series-07-tuning-html": {
        "title": "[java Series] 07 Tuning",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - TuningGC Tuning주의점  GC 옵션은 서비스 특징마다 적정 값이 다르다.  GC 튜닝은 최후의 수단이다. (코드 최적화가 우선이다.)목표  Old로 넘어가는 객체의 수 최소화 하기Old는 Young에서 GC보다 시간이 오래 소요된다. 따라서 Old로 넘어가는 수를 줄이면 Full GC가 줄어든다.이는 Young size를 잘 조절하는 것만으로 Old로 넘어가는 것을 줄이고 이 자체로 튜닝이 된다는 것이다.  Full GC 시간 줄이기Full GC 실행 시간은 Minor GC에 비해 길다. 그러므로 Old 사이즈를 조정하는 것도 방법이다. 그렇다고 너무 줄이면 OutOfMemoryError가 발생하거나 FUll GC가 자주 발생할 수 있다. 반대로 너무 Old를 늘리면 FullGC는 줄지만 실행 시간이 늘어날 수 있다.튜닝 진행1. GC 상황 모니터링# jstat gcutil  명령어로 현재 실행중인 8884번 프로세스에 대해 1초에 한번 씩 총 10번 GC와 관련된 정보를 출력하도록 모니터링jstat -gcutil -t 8844 1000 0            컬럼      설명                  S0      Survivor 영역 0의 사용율(현재 용량에 대한 비율)              S1      Survivor 영역 1의 사용율(현재 용량에 대한 비율)              E      Eden 영역의 사용율 (현재 용량에 대한 비율)              O      Old 영역의 사용율 (현재 용량에 대한 비율)              P      Permanent 영역의 사용율 (현재 용량에 대한 비율)              YGC      Young 세대의 GC 이벤트 수              YGCT      Young 세대의 GC 시간              FGC      Full GC 이벤트 수              FGCT      Full GC 시간              GCT      GC 총 시간      2. 모니터링 결과 분석 후 GC 튜닝 여부 결정  Minor GC 수행시간: YGCT / YGC (0.314 / 19) = 0.016초  Major GC 수행 시간: FGCT / FGC (0.291 / 3) = 0.097초# Minor GC의 처리 시간이 빠르다 (50ms 내외)# Minor GC의 주기가 빈번하지 않다 (10초 내외)# Full GC의 처리 시간이 빠르다 (1초 내외)# Full GC의 주기가 빈번하지 않다 (10분에 1회)3. GC 알고리즘 방식 지정            GC 알고리즘      내용                  Parallel GC      - ‘처리량’이 중요한 시스템에서 주로 사용 - Full GC 수행 시 compaction 작업이 수행되기 때문에 GC 시간 자체는 많이 소요되나 일정한 멈춤 시간을 제공함              CMS GC      - 응답시간이 중용한 시스템에사 주로 사용  - compaction 미수행으로 Stop-The-World 시간은 짧으나 자주 Compaction이 발생하는 시스템의 경우 오히려 Full GC 보다 Compation 시간이 오래 걸릴 수 있음  - 자원 사용량이 증가하는 점도 고려해야 함              G1 GC      - 성능적으로 가장 우수한 GC 방식이나, JDK 7 버전부터 정식 제공되었으며, Java 9 에서 Default GC 방식으로 채택      4. Heap 크기 지정JVM의 힙 크기는 GC 발생 횟수와 수행 시간에 영향을 끼치기 떄문에 옵션을 통해 조절하면 애플리케이션의 성능 향상을 가져올 수 있다. 메모리 크기는 JVM의 시작 크기 -Xms 최대 크기 -Xmx를 말한다.메모리 크기와 GC 발생 횟수, GC 수행 시간 관계는 아래와 같다.  메모리 크기가 크면          GC 발생 횟수가 감소      GC 수행 시간은 길어진다.        메모리 크기가 작으면          GC 발생 횟수는 증가한다.      GC 수행 시간은 짧아진다.                  구분      옵션      설명                  힙(heap) 영역 크기      -Xms      JVM 시작 시 힙 영역 크기              힙(heap) 영역 크기      -Xmx      최대 힙 영역 크기              New 영역의 크기      -XX:NewRatio      New 영역과 Old 영역의 비율              New 영역의 크기      -XX:NewSize      New 영역의 크기              New 영역의 크기      -XX:SurvivorRatio      Eden 영역과 Survivor 영역의 비율      # 이 중에서 중요한 옵션은 -Xms 옵션, -Xmx 옵션, -XX:NewRatio 옵션이다.# 특히 -Xms 옵션과 -Xmx 옵션은 왠만하면 필수로 지정하길 권장되며, 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.# # NewRatio는 New 영역과 Old 영역의 비율이다. # -XX:+NewRatio=1로 지정하면 (New 영역):(Old 영역)의 비율은 1:1이 된다. # 만약 1GB라면 (New 영역):(Old 영역)은 500MB:500MB가 된다. # NewRatio가 2이면 (New 영역):(Old 영역)이 1:2가 된다. # 즉, 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.# 힙 시작 크기 256mb, 힙 최대 크기 2gb# young 영역과 old 영역 비율 1:2 로 설정 (New 영역:Old 영역 = 1:2)# Parallel GC 로 실행java -Xms256m -Xmx2048m -XX:+NewRatio=2 -XX:+UseParallelGC5. 결과 분석분석할 때는 다음의 사항을 중심으로 살펴보는 것이 좋다. 이는 우선 순위 별로 나열되어 있다.  FullGC 수행 시간  MinorGC 수행 시간  Full GC 수행 간격  MinorGC 수행 간격  전체 Full GC 수행 시간  전체 Minor GC 수행 시간  전체 GC 수행 시간  Full GC 수행 횟수  Minor GC 수행 횟수",
        "url": "//2024/05/18/java-series-07-Tuning.html"
      }
      ,
    
      "2024-05-18-java-series-06-gc-algorithm-html": {
        "title": "[java Series] 06 Gc_algorithm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GC Algorithm가비지 컬렉션 알고리즘1. Serial GC  서버의 CPU 코어가 1개일 때 사용하기 위해서 개발된 GC  GC 처리하는 쓰레드가 1개라서 STW가 길다.  MinorGC에서는 Mark-Sweep, MajorGC에서는 Mark-Sweep-Compactjava -XX:+UseSerialGC -jar Application.java2. Parallel GC  Java 8의 Default  Serial GC와 기본 알고리즈은 같지만 Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old는 Single)  Serial GC에 비해서 STW가 줄어java -XX:+UseParallelGC -jar Application.java # -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수3. Parallel Old GC(Parallel Compacting Collector)  Parallel GC를 개선한 버전  Young, Old도 멀티 GC  새로운 GC 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old도 Multi)java -XX:+UseParallelOldGC -jar Application.java# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수4. CMS GC (Concurrent Mark Sweep)  어플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되어 STW를 최대한 줄이기 위래서 고안된 GC  GC 과정이 매우 복잡  GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다.  메모리 파편화 문제  CMS GC는 Java9부터 deprecated, Java14에는 중지됨# deprecated in java9 and finally dropped in java14java -XX:+UseConcMarkSweepGC -jar Application.java5. G1 GC (Garbage First)  GMC GC를 대체하기 위해서 Java 7에서 최초로 release  Java 9+의 디폴트 GC  4GB 이상의 Heap, STW이 0.5 이상이될 때 사용 (Heap이 너무 작으면 미사용 권장)  기존의 GC에서는 HEAP 영역을 물리적으로 고정된 Young/ Old로 나눴지만 G1은 Region을 도입. Eden, Survivor, Old를 고정이 아닌 동적으로 부여  Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 식java -XX:+UseG1GC -jar Application.java6. Shenandoah GC  Java 12에 release  RedHat에서 개발  기존 GMS가 가진 단편과, G1이 가진 pause 이슈를 해결  강력한 Concurrency와 가벼운 GC 로직으로 Heap 사이즈에 영향을 받지 않고 일정한 Pause 시간 소요가 특징java -XX:+UseShenandoahGC -jar Application.java7. ZGC( Z Garbage Collector )  Java 15에 release  대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해서 디자인된 GC  G1의 Region처럼 ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정이지만 ZPage는 2mb 배수로 운영됨  ZGC가 내세우는 최대 장점은 힙 크기가 증가해도 STW가 절대로 10ms를 넘지 않는다.java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java",
        "url": "//2024/05/18/java-series-06-GC_Algorithm.html"
      }
      ,
    
      "2024-05-18-java-series-05-gc-html": {
        "title": "[java Series] 05 Gc",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - GCGC자바의 메모리 관리 방법 중 하나로 JVM의 HEAP 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스(C/C++ 은 수동으로 메모리 할당, 해제를 해야했다.)1. 대상판단 근거로 도달성, 도달능력(Reachability)라는 개념을 적용한다. 객체에 레퍼런스가 있다면 Reachable[1], 객체에 유효한 레퍼런스가 없으면 UnReachable[2]로 구분한다.주로 Heap Area에서 참조하고 있지 않은 객체가 GC 대상이 된다.청소 방식Mark And SweepGC가 동작하는 가장 기초적인 청소 과정.GC 대상이 될 객체를 식별(Mark), 제거(Sweep)하며 객체가 제거되며 파편화된 메모리를 영역 앞에서부터 채워나가는 작업을 수행한다.  Mark : Root Space부터 그래프 순회를 통해서 연결되나 객체를 찾아서 각각 어떤 객체를 참조하고 있는지 마킹  Sweep : Unreachable를 Heap에서 제거한다.  Compact : Heap의 시작 주소를 모아 메모리가 할당된 부분과 아닌 부분으로 압축한다. (GC 종류에 따라 하지 않는 경우도 있음 )GC 동작 과정Heap은 동적으로 레퍼런스 데이터가 저장되는 공간으로 GC 대상이 되는 공간이다. Heap은 아래 2가지를 전제(Weak Generational Hypothesis)로 설계됐다.  대부분 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.  오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.즉, 객체는 대부분 일회성, 메모리에 오랫동안 남을 경우는 드물다는 것이다.   Young          새롭게 객체가 할당되는 영역      대부분 객체가 금방 Unreachalbe이 되므로 Young에 생성됐다 사라짐      Young에 대한 GC를 Minor GC라고 부름        Old          Young에서 Reachable을 유지하면 복사되는 영역      Young보다 크게 할당됨. 크기가 큰 만큼 가비지는 적게 발생      Old에 대한 GC를 Full GC라고 부름        Eden          new를 통해 생성된 위치      정기적 쓰레기 수집 후 살아남으면 Survivor로 보냄        Survivor 0/ 1          최소 1 번 이상의 GC에서 살아남은 객체가 존재하는 영역      Survivor 0, 1 중 하나는 꼭 비어 있다.      MinorGCYoung은 Old에 비해서 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다.  처음 생성된 객체는 Young 영역의 Eden에 위치  Eden이 꽉차면 MinorGC 발생          Obj MarK로 Reachable 탐색      살아 남은 Obj Survivor로 이동      Eden의 unreachable gowp      살아남은 모든 객체 age[3] += 1      Eden이 가득 차면 비어있는 Survivor로 Eden, 기존 Survivor 내용들 이동      옮긴 Survivor 내역들 age += 1      MajorGCOld는 길게 살아남은 메모리들이 존재하는 공간. age 임계 값을 초과해서 이동되는 녀석 가끔 Young에 담을 수 없을 정도로 크면 Old로 보내기도 함그리고 MajorGC는 객체들이 계속 Promotion되어 Old가 부족해지면 발생MinorGC vs. MajorGC            GC Type      MinorGC      MajorGC                  대상      Young      Old              실행 시점      Eden이 꽉 차면      Old가 꽉차면              실행 속도      빠르다      느리다      MajorGC는 old가 꽉 차면 Unreachable을 한꺼번에 삭제하는 MajorGC가 실행된다. Young은 크기가 작기에 빠르지만 Old는 크기에 보통 10배 이상의 시간을 사용한다.또한  STOP-THE-WORLD 가 발생한다. 이 때 Thread가 멈추고 Mark and Sweep을 하므로 일시적으로 멈추기 때문[1] : 객체가 참조되고 있는 상태[2] : 객체가 참조되고 있지 않은 상태 (GC 대상)[3] : Survivor 영역에서 객체가 살아남은 횟수. Object Header에 기록 age가 임계 값에 다다르면 Promotion( Old로 이동 여부를 결정. 기본 임계값은 31)",
        "url": "//2024/05/18/java-series-05-GC.html"
      }
      ,
    
      "2024-05-18-java-series-04-jni-html": {
        "title": "[java Series] 04 Jni",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JNIJNI(Java Native Interface)자바 네이티브 인터페이스는 JVM위에서 실행되고 있는 자바 코드가 네이티브 응용 프로그램(하드웨어, 운영체제 플랫폼에 종속된 프로그램들), C, C++, 어셈블리 같은 다른 언어들로작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크1. 네이티브 메소드Java는 메소드 구현이 네이티브 코드에서 제공될 것임을 나타내는 데 사용되는 네이티브 키워드를 제공한다. 일반적으로 네이티브 실행 프로그램을 만들 때 정적 또는 공유 라이브러리를 사용할 수 있다.2. 예약어  native: 다른 언어에서 사요할 수 있게 해주는 키워드  volatile: Thread safe를 하게 해주는 키워드  strictfp: 자바와 타 플랫폼 간 부동소수점 정밀도를 맞추기 위한 키워드  assert: 인자로 주어진 값이 참인지 거짓인지 판별하는 메소드",
        "url": "//2024/05/18/java-series-04-JNI.html"
      }
      ,
    
      "2024-05-18-java-series-03-memory-html": {
        "title": "[java Series] 03 Memory",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - memoryMemory (Runtime Data Area)  Method(static) 영역  Stack 영역  Heap 영역1. 자바 변수 종류  클래스 변수: 클래스 영역에서 static이 붙는 변수 - 클래스가 메모리에 올라갈 떄  인스턴스 변수: static이 나닌 변수 (참조 없을 경우 gc 대상) - 인스턴스가 생성될 때  지역 변수: 메소드 내에서 선언, 메소드가 끝나면 소멸 - 해당 메소드가 실행될 때  매개 변수: 메소드 호출 시 전달하는 값 - 해당 메소드가 실행될 때2. Method(Static) 영역 ( == Class area, Static area)  JVM이 동작해서 클래스가 로딩될 때 생성      JVM이 읽어들인 클래스와 인터페이스에 대한 정보(멤버 변수, 런타임 상수 풀, 생성자, 메소드 등)와 함께 클래스 변수(static variable)가 저장되는 영역    ↳ Field Information: 멤버 변수의 이름, 데이터 타입, 접근 제어자에 대한 정보    ↳ Method Information: 메소드 이름, 리턴 타입, 매개변수, 접근제어자에 대한 정보    ↳ Type Information: class인지 interface인지 여부 저장, 전체 이름, super의 이름(interface, object인 경우 Heap에서 관리)    Method(Static) 영역에 있는 것은 어느 곳에서나 접근 가능  Method(Static) 영역에 있는 데이터는 프로그램 시작 ~ 종료까지 메모리에 남아 있다.2.1 Runtime Constant Poolstatic 영역에 존재하는 별도 관리 영역 상수 자료형을 저장하여 참조하고 중복을 막는다.3. Stack 영역  메소드 내에서 정의하는 기본 자료형에 해당되는 지역 변수의 데이터 값이 저장되는 공간  메소드가 호출될 때 스택 영역에 스택 프레임[1]이 생기고 그 안에서 메소드를 호출  primitive 타입에 해당되는 지역변수, 매개 변수 데이터 값이 저장됨  메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 사라짐  Stack은 LIFO이며, 스코프 범위를 벗어나면 스택 메모리에서 사라진다.4. Heap[2]  JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 여역  new 연산자로 생성되는 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간  Heap에 있는 오브젝트들을 가리키는 레퍼런스 변수는 stack에 적재  Heap는 Stack과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지. 그러나 Heap에 인스턴스를 참조하지 않는 상황이 되면 GC 대상이 된다.  stack은 쓰레드 개수마다 생성되지만 Heap은 몇 개의 쓰레드가 존재하든 상관 없이 하나의 Heap만 존재한다. https://inpa.tistory.com/entry/JAVA-☕-그림으로-보는-자바-코드의-메모리-영역스택-힙#  https://1-7171771.tistory.com/140  method(static) area? permenent generation?1. Permanent Generation : 생성된 객체들의 정보의 주소 값이 저장된 공간이다. 클래스 로더에 의해 load되는 Class, Method 드엥 대한 Meta 정보가 저장되는 영역 (Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용)  MetaSpace[3]: class의 메타 정보, 메소드의 메타 정보, static object 변수, 상수, JVM, JIT 관련 데이터 등  New/Young          메모리에 객체가 생성되면 Eden에 생성된다.      Eden에 메모리가 가득차면 Eden 데이터가 Survivor1 혹은 Survivor2로 옮겨진다. 1,2 우선 순위는 없다.      Survivor에 있으면 어디에서인가 참조되고 있는 객체들이다. 둘 중 하나가 가득차면 공간이 남아 있는 Survivor로 옮겨진다.      이러한 매커니즘으로 Survivor1 혹은 Survivor2 둘 중 하나는 항상 비워져 있다.      이 과정에서 Minor GC가 발생한다. New/Young에서 발생하는 CG로 Eden 또는 Survior1, Survior2에서 사용되지 않는 객체들을 삭제한다.  Old          Survivor 1, 2를 왔다 갔다하는 동안 살아남은 객체들은 Old로 간다. Old는 Young 보다 크게 할당한다. 이러한 이유로 Old의 GC는 Young보다 드물다.      간혹 Eden -&gt; Old로 넘어가는 경우가 있는데 Survivor에 담을 수 없을 만큼 큰 경우 발생한다.      오랫동안 살아남은 객체?  Minor GC가 발생하면 ageBit를 1씩 늘린다. ageBit이 MaxTenuringThreshold[4]를 초과하면Old로 이동한다. (너무 커서 Eden에서 Old로 바로 이동하기도 한다.)  Old에서는 Major GC(Full Gc)가 일어나며, GC를 진행하는 Thread를 제외하고 이외의 모든 Thread를 멈춘 상태로 GC가 진행된다.이 상태를 stop-the-world라고 한다.  JVM에서 GC를 튜닝하는 이유가 stop-the-world 시간을 단축시키 위함이다.GC 알고리즘 종류  Serial GC : JDK 5,6에서 사용 Minor, Major 모두 싱글 스레드로 실행 -&gt; Stop-The-World가 김.          Mark-Sweep-Compact 알고리즘 사용 (식별하고 지우고 빈공간 정리, 압축)  Parallel GC : Young에서 Minor GC 수행 시 멀티쓰레드 사용(SingleCore CPU라면 Serial로 동작)  Parallel old GC : Old에서 Full GC도 병렬로 처리. Old에서 GC를 처리할 때 Mark-Summary(살아 있는 객체를 식별)-Compaction 사용  CMS(Concurrent Mark &amp; Sweep) GC : Major GC를 최소한으로 하려는데 초점을 둠. MajorGC 수행 시간을 줄기이 위해서 GC의 대상 객체를 최대한 정밀하게 파          Initial Mark : 현재 살아남은 객체를 탐색, GC ROOT에서 참조하는 객체들만 우선적으로 탐색(STW 매우 적음)      Concurrent Mark : Initial Mark에서 탐색한 객체들이 참조하고 있는 객체를 찾아가면 GC 대상인지 판별 (STW 없음)      ReMark : Concurrent Mark 실행 중 새로 생성된 객체나, 참조가 끊어지는 등 변경된 사항이 있는지 다시 한 번 확인 (STW 발생 -&gt; 멀티쓰레딩으로 시간 단축)      Concurrent Sweep : ReMark까지 검증 완료된 GC 대상을 삭제 (STW 없이 진행)        CMS GC는 Compact를 하지 않기 때문에 메모리 단편화를 신경써야 한다. 연속적으로 메모리 할당이 불가능할 정도까지 도달했으면  Compaction을 해야하는데, 이때 다른 GC의 Compaction보다Stop-The-World가 길다.  G1 GC (Garbage First GC)기존 CG 알고리즘으로 큰 메모리에서 효율이 좋지 못해서 개선하기 위해서 등장했다. 기존의 Heap과는 다르게 Region으로 나눠서 관리한다. https://1-7171771.tistory.com/140 Region이라는 논리적인 단위로 메모리를 관히하며, CMS와ㅏ 달리 Compaction을 진행하고 메모리 단편화 문제를 없앰. STW 시간을 예측할 수 있다.  Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간. 이 공간에서 GC가 효율적으로 일어나지 않는다.  Available/Unused : 아직 사용하지 않은, 비어있는 공간Young GC를 수행할 때 STW가 발생, 멀티쓰레드로 극복한다. Young GC는 Regionwnd GC 대상 객체가 가장 많은 Region에서 진행(Eden / Survivor).이 Region에서 살아남은 객체를 다른 Region(Survivor)로 옮기고 빈 Region을 Available/Unused로 돌린다.[1] : 하나의 메소드에 필요한 메모리 덩어리를 묶어서 스택 프레임이라고 한다. 하나의 메소드당 하나의 스택 프레임이 필요하며, 메소드를 호출하기 직전 스택 프레임을 자바 Stack에 생성한 후 메소드를 호출한다.[2] : 자바 코드를 실행할때 따로 -Xms과 -Xmx 옵션을 사용하면 힙 메모리의 초기 사이즈와 최대 사이즈를 조절할 수 있다.[3] : 자바 8부터 변경되었다. 이 영역은 Native 메모리 영역으로 JVM이 아닌 OS에서 관리되도록 변경됐다.[4] :  기본 값 15",
        "url": "//2024/05/18/java-series-03-Memory.html"
      }
      ,
    
      "2024-05-18-java-series-02-jvm-html": {
        "title": "[java Series] 02 Jvm",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - JVMJVMJava Virtual Machine의 줄임말이다.Java는 JVM이라는 가상머신을 거쳐서 OS에 도달한다. 이때 인식하는 것이 자바 바이트코드(Java Bytecode)이다. Java Compiler는 .java를 .class로 변환해준다. 여기서 자바 바이트 코드는 명령어의 크기가 1바이트이다.바이트 코드는 다시 실시간 번역기 또는 JIT(Just-In-Time)[1] 컴파일러에 의해서 바이너리 코드로 변환된다. 이때 변환은 모든 바이트 코드를 변환하는 것이 아니라 실행하기 전에 필요한 부분을 즉석으로 컴파일 하는 방식을 말한다.또한, 자주 쓰이는 코드는 캐싱해서 같은 부분을 반복적으로 번역(interpret)하지 않도록 한다.JVM은 크게 아래와 같이 이뤄져 있다.  클래스 로더(Class Loader)  실행 엔진(Execution Engine)          인터프리터(Interpreter)      JIT 컴파일러(Just-In-Time)      가비지 콜렉터(Garbage collector)        런타임 데이터 영역(Runtime Data Area)1. 클래스 로더JVM 내로 클래스 파일(*.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.2. 실행 엔진클래스를 실행시키는 엔진, 클래스로더가 JVM 내 런타임 데이터 영역에 바이트 코드를 배치시키고 이것은 실행 엔진에 의해서 실행된다. 바이트 코드는 바이너리 코드가 아니다. 그래서 실행 엔진은 바이트 코드를 JVM 내부에서 바이너리 코드로 변환한다.2.1.1. 인터프리터바이트 코드를 명령 단위로 읽어서 실행한다.2.1.2. JIT(HotSpot)인터프리터 방식으로 사용하기 직전 기계어로 변역하고 캐싱하여 이후에는 번역하지 않는 방식으로 동작한다.2.2 가비지 콜렉터[2]더 이상 사용하지 않는 인스턴스를 찾아 메모리에서 삭제한다.2.3 Runtime Data Area3. JDK? JRE?  JDK : Java Development Kit ( JRE + (javac, jdb, javadoc…))  JRE : Java Runtime Environment ( JVM + 자바 클래스 라이브러리)[1] : 크게 나눠서 HotSpot Vm과 같이 메소드(함수) 단위로 JIT하는 방식과 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하여 컴파일할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 추가적으로, 미리 컴파일된 코드를 실행하는게 아니라 런타임에 동적으로 코드를 생성하여 실행하므로 잠재적 보안 문제가 있다. 예를 들어 인텔 스펙터가 JIT에 의존하는 JS 엔진을 가진 브라우저에서만 발생했다.",
        "url": "//2024/05/18/java-series-02-jvm.html"
      }
      ,
    
      "2024-05-18-java-series-01-version-html": {
        "title": "[java Series] 01 Version",
        "tags": "",
        "date": "May 18, 2024",
        "author": "",
        "category": "",
        "content": "from Dictionary - 자바 버전별 정보JDK 1.0  안정화 작업JDK 1.1  이너 클래스, JavaBeans, RMI, Reflection, Calendar 유니코드 지원Javabeans : 자바로 작성된 소프트웨어 컴포넌트\t&gt; 1. 기본 생성자가 반드시 존재해야한다. \t&gt; 2. 모든 속성은 비공개\t&gt; 3. 속성에 접근하고 꺼내올 수 있는 getter, setter 구성\t&gt; 4. Serializable 구현RMI : Remote Method Invocation의 약자로 분산 애플리케이션을 구축하는 데 사용, 한 시스템(JVM)에 상주하는 객체가 다른 JVM에서 실행 중인 객체에 액세스, 호출할 수 있도록 도와주는 메커니즘JDK 1.2  JIT(HotSpot), Collection Framework 등 추가J2SE 1.3  HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가J2SE 1.4assert, 정규표현식, IPv6, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가J2SE 5  Generics 추가  Annotation 추가  동시성 제어 API (Concurrency API) 추가  Enumeration 추가  Auto Boxing/ Unboxing 추가Java SE 7  Diamond Operator ( ‘&lt;&gt;’ ) 추가Java SE 8 (오라클 인수 이후)  Lambda Expression 지원  Method Reference 지원  인터페이스에 default method가 추가  Optional 추가  날짜와 시간 API 추가       //javax.time.Clock   Clock.systemUTC();                    //current time of your system in UTC.    Clock.millis();                        //time in milliseconds from 1/1/1970.        //javax.tme.ZoneId   ZoneId zone = ZoneId.of(“Europe/London”);        //zoneId from a timezone.    Clock clock = Clock.system(zone);            //set the zone of a Clock.        //javax.time.LocalDate   LocalDate date = LocalDate.now();            //current date    String day = date.getDayOfMonth();            //day of the month    String month = date.getMonthValue();            //month    String year = date.getYear();                //year        Stream API 추가  PermGenArea 제거 : java8이전에는 초기 설정시 PermSize, MaxPerSize를 성정해야 했는데 이후 MetaSpace로 변경됐다. MetaSpace는 런타임 시 메모리 요규 사항에 따라 자체 크기를 조정하며, 필요하다면 MaxMetaspaceSize 매개변수를 조정하여 양을 조정할 수 있다.```    Permanent Generation    Permanent Generation은 Class 혹은 Method Code가 저장되는 영역  PermGen은 Heap에 속함  Default로 제한된 크기를 가짐Metaspace  Metaspace는 Java 클래스 로더가 현재까지 로드한 class들의 메타 데이터가 저장되는 공간  JVM에 의해 관리되는 Heap이 아닌 OS 레벨에서 관리되는 Native 메모리 영역에 위치  Default로 제한된 크기를 가지고 있지 않고, 필요한 만큼 늘어남# Java SE 9- 모듈 시스템 jigsaw 등장 (https://www.baeldung.com/project-jigsaw-java-modularity)- A New HTTP Client : 8까지 사용하던 HttpURLConnection을 대체할 새로운 java.net.http 패키지 추가- JsShell : main 메소드 없이 코드를 테스트할 수 있는 대화식 REPL(Read-Eval-Print-Loop) 도구를 제공- Process API 개선 : OS 프로세스 관리 및 컨트롤을 위해 (java.lang.ProcessHandle, java.lang.ProcessHandle.Info)가 추가 됐다.- Try-With-Resource 개선- 다이아몬트 연산자를 익명클래스에서도 사용할 수 있도록 개선됨- Interface Private Method 인터페이스 내에서 private 메소드 사용이 가능해짐- Optional To Stream :  Optional로 Stream을 생성할 수 있게 됐다.         &gt; Stream&lt;Integer&gt; steram = Optional.of(1).stream();# Java SE 10- Local-Variable Type Interface : 로컬 변수 타입 추론 기능이다. 로컬 변수 타입을 var로 선언할 수 있다.```javavar list - new ArrayList&lt;String&gt;();\t//ArrayList&lt;String&gt; 으로 추론var stream = list.stream();\t\t//Stream&lt;String&gt; 으로 추론var numbers = List.of(1, 2, 3, 4, 5);\t//List&lt;Integer&gt; 으로 추론for (var number : numbers){\t\t//Integer 추론\tSystem.out.println(number);}  Garbage Collector Interface : 다양한 GC의 코드 고립도를 향상하는 인터페이스 도입  Thread-Local Handshakes : VM safepoint를 수행할 필요 없이 개별 쓰레드를 stop하고 콜백을 수행할 수 있도록 추가```VM safePoint :: “Stop The World”로 모든 쓰레드를 일시 정지시키는 작업  safepoint를 발생시키는 경우          Garbage collection pauses      Code deoptimization      Flusing code cache      Class redefinition      Biased lock revocation      Various debug operation      - Root Certificates : HTTPS 통신에 쓰이는 root CA 목록을 OracleJdk에서도 가지게 됐다.# Java SE 11- HTTP 클라이언트(JEP 321) : java 9에 포함됐던 HTTP 클라이언트 API를 정식 채택, URLConnection 기반의 HTTP 개발보다 개선된 기능, 명명 규칙을 제공한다. 특히 HTTP 2.0을 지원하여 웹소켓도 포함되어있다.- 새로운 String 메소드 추가|     Method      |                          Description                           ||:---------------:|:--------------------------------------------------------------:||     strip()     |                         문자열 앞, 뒤 공백 제거                         || stripLeading()  |                          문자열 앞의 공백 제거                          || stripTrailing() |                          문자열 뒤의 공백 제거                          ||    isBlank()    | 문자열이 비어있거나 공백만 포함되어있을 경우 true (String.trim().isEmpty()와 결과 같음) ||     lines()     |                     문자열을 라인 단위로 쪼개는 스트림 반환                     ||    repeat(n)    |                   지정된 수 만큼 문자열을 반복하여 붙여서 반환                    |```java trim()은 U+0020이하의 값만 공백으로 인식(tab, CR, LF, 공백) 하지만 유니코드에는 외에 다른 공백을 제공하는데 이를 제거하려면 Character.isWhitespace(int)를 사용해야만 했다.Java SE 11 부터는 strip()을 사용하면 된다.  Lambda 파라미터로 var 사용    (var x, var y) -&gt; x.process(y) =&gt; (x, y) -&gt; x.process(y)      Java SE 12  문법적으로 Switch 문을 확장```java//기존 방식switch (day) {    case MONDAY:    case FRIDAY:    case SUNDAY:        System.out.println(6);        break;    case TUESDAY:        System.out.println(7);        break;    case THURSDAY:    case SATURDAY:        System.out.println(8);        break;    case WEDNESDAY:        System.out.println(9);        break;}//Java SE 12 부터의 방식switch (day) {    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);    case TUESDAY                -&gt; System.out.println(7);    case THURSDAY, SATURDAY     -&gt; System.out.println(8);    case WEDNESDAY              -&gt; System.out.println(9);}- 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선# Java SE 13- Switch 문 개선을 위한 'yield' 예약어 추가```javavar a = switch (day) {    case MONDAY, FRIDAY, SUNDAY:        yield 6;    case TUESDAY:        yield 7;    case THURSDAY, SATURDAY:        yield 8;    case WEDNESDAY:        yield 9;};  textBlock 추가    String str = \"\"\" This is text block\"\"\";      Java SE 14  12, 13에서의 Switch 문이 표준화되었다.      record( preview ) : java로 많은 상용구를 작성하는 수고를 덜어주는 record 클래스 도입```javafinal class Point {  public final int x;  public final int y;    public Point(int x, int y) {      this.x = x;      this.y = y;  }}// state-based implementations of equals, hashCode, toString// nothing else  //레코드 사용record Point(int x, int y) { }```  NullPointerException track: 어떤 부분에서 NPE가 발생헀는지 설명해준다.Java SE 15  textBlock / Multiline Strings가 공식 채택 준비됐습니다.  Sealed Classes ( preview ) 상속 가능한 클래스를 지정할 수 있는 봉인 클래스가 추가된다. 상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해있어야 한다.  EdDSA 암호화 알고리즘 추가  스케일링 가능한 낮은 지연의 가비지 컬렉터 추가(ZGC)[1]Java SE 16  jdk1.8부터 시작된 PermGen 대신 Metaspace를 지원하기 시작  OpenJdk의 버전관리가 git으로 변경되었습니다.  Unix-Domain Socket Channels : Unix 도메인 소켓에 연결할 수 있다.Java SE 17  RandomGenerator : 의사 난수 생성기를 통해서 예측하기 어려운 난수를 생성하는 API가 출시됐다.  M1 정식 지원Java SE 18  UTF-8이 기본 인코딩셋이 되었다.  Simple Web Server: 간편설정, 최소한의 기능으로 바로 사용 가능한 HTTP 파일 서버를 제공한다.  Relection 기능 리팩토링( 메소드 핸들을 이용해서 다시 구현 )  switch-case 패턴 매칭 preview  try-catch-finally deprecated  ( try-with-resources 권장)Java SE 19  VirtualThread, Foreign Function &amp; Memory API, Structured Concurrency, Vector API 등이 preview로 추가Java SE 20  VirtualThread(second preview), ScopedValue(incubated), StructuredConcurrency(SecondIncubate)Java SE 21  StringTemplate(preview)  Sequenced Collections  Generational ZGC  Switch Pattern Matching 정식 출시  Unnamed Patterns and Variables (Preview)  Virtual Thread 정식 출시  Windows 32-bit x86 제거 예정Java SE 22  G1 GC에 Region Pinning 기술을 구현해 지연 시간(latency) 단축  super() 호출 전에 다른 statement 실행을 가능하게함 (프리뷰 기능).  이름없는 변수 및 패턴. 안쓰는 변수 이름을 언더스코어(_)로 표기하는 것을 허용  StructuredConcurrency(secondPreview) : 쓰레드 캔슬, 셧다운에 의한 리스크를 줄이고 Observability 향상, 여러 쓰레드에서 실행되는 관련있는 작업들을 그룹핑하는 기능  ScopedValues(secondPreview) : 같은 쓰레드 내에서의 공유 데이터를 관리하기 위한 컨테이너 오브젝트. ThreadLocal과 비슷하지만 ThreadLocal의 단점을 보완해 더 적은 리소스를 사용하고 더 안전하다고 한다. (특히 VirtualThreads, StructuredConcurrency랑 같이 활용될 때)Java SE 23  2024/06/08 Preview  2024/09 GA[1] ZGC 메소드 핸들 ",
        "url": "//2024/05/18/java-series-01-Version.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
