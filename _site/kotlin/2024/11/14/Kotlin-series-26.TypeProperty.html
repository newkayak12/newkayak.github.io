<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>[kotlin Series] 26.typeproperty | newkayak12.github.io</title>
	<meta name="description"
		content="Type Parameter">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/kotlin/2024/11/14/Kotlin-series-26.TypeProperty.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
		integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

	<script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
		integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
		crossorigin="anonymous"></script>
	

	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'G-4WXFZQCMT3', 'auto');
		ga('send', 'pageview');
	</script>
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">[kotlin Series] 26.typeproperty</h1>
    
    <p class="meta">
      November 14, 2024
      
    </p>

    
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    
  </header>
  <section class="post-content"><h1 id="type-parameter">Type Parameter</h1>

<h2 id="generic">Generic</h2>
<ul>
  <li>제네릭은 선언 해두고 사용할 떄 타입 파라미터를 대신할 타입을 지정해서 사용한다.</li>
  <li>떄로는 java에서도 그렇지만 문맥상 추론이 가능하면 생략하기도 한다. (java <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>)</li>
</ul>

<h2 id="바운드-제약-java의-super--extend">바운드, 제약 (java의 super,  extend)</h2>
<ul>
  <li>전체적인 개념이 java와 유사하다.</li>
  <li>java의 <code class="language-plaintext highlighter-rouge">T extends AbstractClassExample</code>는 kotlin의 <code class="language-plaintext highlighter-rouge">T: AbstractClassExample</code></li>
  <li>java의 super는 kotlin에서 직접적으로 지원하지 않는다.</li>
</ul>

<h2 id="타입-소거">타입 소거</h2>
<ul>
  <li>kotlin도 java와 같이 JVM 언어라 타입 소거가 벌어진다.</li>
  <li>런타임에 제네릭 코드는 parameter type의 차이를 인식할 수 없다.</li>
</ul>

<h2 id="구체화">구체화</h2>
<ul>
  <li>java에서 와일드카드(?) 사용 시 제네릭 타입으로 캐스트하는 것은 허용되나
    <ol>
      <li>캐스트로 덮거나 : 컴파일 이후에 에러가 날 수 있다.</li>
      <li>reflection으로 타입 소거를 우회하거나 : 리플렉션으로 처음에 느리다.</li>
    </ol>
  </li>
  <li>단점이 있다. 그래서 kotlin에서는 파라미터를 구체화하기 위해서 <code class="language-plaintext highlighter-rouge">reified</code>, <code class="language-plaintext highlighter-rouge">inline</code>을 사용해야 한다.
    <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="k">reified</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="nf">isA</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nc">Any</span><span class="p">)</span> <span class="p">=</span> <span class="n">value</span> <span class="k">is</span> <span class="nc">T</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p>reified: more concrete or real</p>
</blockquote>

<h2 id="변성">변성</h2>

<blockquote>
  <h2 id="사전지식">사전지식</h2>

  <p>(이전 자바 공부할 때 적었던 부분을 인용해보자. <sub>java/17.Generic.md</sub>)</p>
  <h3 id="자바의-공변성-반공변성">자바의 공변성/ 반공변성</h3>
  <p>제네릭의 와일드카드를 배우기 앞서 선수 지식으로 알고 넘어가야할 개념이 있다.
조금 난이도 있는 프로그래밍 부분을 학습 하다보면 한번쯤은 들어볼수 있는 공변성(Covariance) / 반공변성(Contravariance) 합쳐서 ‘변성(Variance)’ 이라하는 개념이다.
변성은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지를 나타태는 지표이다. 그리고 공변성은 서로 다른 타입간에 함께 변할수 있다는 특징을 말한다.
이를 객체 지향 개념으로 표현하자면 Liskov 치환 원칙<sup><a href="#liskov">[1]</a></sup>에 해당된다.</p>

  <ul>
    <li><strong>공변</strong> : S 가 T 의 하위 타입이면,
      <blockquote>
        <p>S[] 는 T[] 의 하위 타입이다.
<code class="language-plaintext highlighter-rouge">List&lt;S&gt;</code> 는 <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code> 의 하위 타입이다.</p>
      </blockquote>
    </li>
    <li><strong>반공변</strong> : S 가 T의 하위 타입이면,</li>
  </ul>

  <blockquote>
    <p>T[] 는 S[] 의 하위 타입이다. (공변의 반대)
<code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code> 는 <code class="language-plaintext highlighter-rouge">List&lt;S&gt;</code> 의 하위 타입이다. (공변의 반대)</p>
  </blockquote>

  <ul>
    <li><strong>무공변 / 불공변</strong> : S 와 T 는 서로 관계가 없다.
      <blockquote>
        <p><code class="language-plaintext highlighter-rouge">List&lt;S&gt;</code> 와 <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code> 는 서로 다른 타입이다</p>
      </blockquote>
    </li>
  </ul>

  <h3 id="제네릭은-공변성이-없다">제네릭은 공변성이 없다</h3>
  <p>객체 타입은 상하 관계가 있다 그러나 제네릭 타입은 상하관계가 없다. 즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이 불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.</p>

  <hr />
  <p><a name="liskov"> [1]</a> : 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다.</p>
</blockquote>

<ul>
  <li>kotlin에서도 기본적으로 무공변(invariant)이다.</li>
  <li>불변 컬렉션 같은 타입은 타입 인자 사이의 하위 타입 관계가 그대로 제네릭 타입에도 유지된다.</li>
  <li>이런 타입 간의 하위, 상위 관계가 유지되는 경우를 알기 위해서 검토할 만한 경우의 수를 나열하면 아래와 같다.
    <ol>
      <li>T 타입의 값을 반환하는 연산만 제공하고, T 타입의 값을 입력으로 받는 연산을 제공하지 않는 경우: readOnly : 불변컬렉션 -&gt; 공변이다.
        <ul>
          <li>기초적인 계약인 컬렉션에 넣은 값을 돌려준다는데 있다. 해당 타입은 Any에 대한 능력도 가진다.</li>
          <li>보통 불변 == 공변인 경우가 많으나 성립하지 않을 수도 있다. 반대로 가변 타입을 공변으로 만들 수도 있다. (가변 리스트에 삭제만 가능한 경우)</li>
        </ul>
      </li>
      <li>T 타입의 값을 입력으로 받기만하고 결고 T 타입의 값을 반환하지 않는 제네릭 타입인 소비자: writeOnly: 반공변이다.
        <ul>
          <li>단, 상위 타입이 하위에 대한 공변성은 있다.</li>
        </ul>
      </li>
      <li>둘 다 아닌 경우: 무공변이다.</li>
    </ol>
  </li>
</ul>

<h2 id="선언-지점-변성">선언 지점 변성</h2>
<ul>
  <li>kotlin에서는 이런 변성에 대해서 선언할 수 있다.
    <ol>
      <li>기본으로 <strong>무공변</strong></li>
      <li>제네릭 타입 앞에 <code class="language-plaintext highlighter-rouge">out</code> 키워드를 붙여서 <strong>공변</strong></li>
      <li>제네릭 타입 앞에 <code class="language-plaintext highlighter-rouge">in</code> 키워드로 <strong>반공변</strong></li>
    </ol>
  </li>
</ul>

<h2 id="프로젝션을-사용한-사용-지점-변성">프로젝션을 사용한 사용 지점 변성</h2>
<ul>
  <li>위의 in/out을 붙이는 것을 프로젝션이라고 한다.</li>
  <li>in -&gt; 생산자.</li>
  <li>out -&gt; 소비자.</li>
</ul>

</section>
  

</article>

<!-- Disqus -->


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>이전 글</p>
      <a href="/kotlin/2024/11/13/Kotlin-series-25.SealedClassAndDelegate.html">
        [kotlin Series] 25.sealedclassanddelegate
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>다음 글</p>
      <a href="/kotlin/2024/11/15/Kotlin-series-27.TypeAlias.html">
        [kotlin Series] 27.typealias
      </a>
  </div>
  
</div>



    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
