<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>[wanted Docker Series] 17.scalablearchitecture | newkayak12.github.io</title>
	<meta name="description"
		content="스케일링을 고려한 아키텍쳐">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/docker/wanted/2024/10/17/Wanted-Docker-series-17.ScalableArchitecture.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
		integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

	<script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
		integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
		crossorigin="anonymous"></script>
	

	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'G-4WXFZQCMT3', 'auto');
		ga('send', 'pageview');
	</script>
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">[wanted Docker Series] 17.scalablearchitecture</h1>
    
    <p class="meta">
      October 17, 2024
      
    </p>

    
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    
  </header>
  <section class="post-content"><h1 id="스케일링을-고려한-아키텍쳐">스케일링을 고려한 아키텍쳐</h1>

<h2 id="scaling">Scaling</h2>
<ul>
  <li>성능 저하 없이 더 많은 요청을 처리할 수 있도록 리소스를 확장하는 과정을 의미</li>
  <li>데이터 처리량의 증가에 대비해 확장 가능한 아키텍쳐를 설계하는 것이 중요</li>
  <li>
    <p>클라우드 네이티브의 장점으로 클라우드 네이티브 아키텍쳐는 마이크로 서비스, 컨테이너, 오토스케일링을 통해 자동으로 확장성을 제공한다.</p>

    <ol>
      <li>수직: 스펙업</li>
      <li>수평: 서버 개수 증가</li>
    </ol>
  </li>
</ul>

<h2 id="scaling을-고려한-시스템-아키텍처-설계-원칙">Scaling을 고려한 시스템 아키텍처 설계 원칙</h2>
<ol>
  <li>유연성: 확장 가능성을 고려한 모듈화된 아키텍쳐 설계가 필요하다.</li>
  <li>복원력: 확장 과정에서 장애를 방지하고, 시스템이 자동으로 복구할 수 있도록 설계한다.</li>
  <li>확장 가능한 데이터 관리: 데이터 일관성을 유지하면서 여러 서버 간에 데이터를 효율적으로 분산하는 방법을 고려</li>
</ol>

<h2 id="autoscaling-전략">AutoScaling 전략</h2>
<ol>
  <li>AWS Auto Scaling: EC2 인스턴스나 컨테이너 수를 트래픽 및 리소스 사용량에 따라 자동으로 조정</li>
  <li>Kubernetes HPA(Horizontal Pod Autoscaler):
    <ul>
      <li>HPA는 Kubernetes에서 Pod의 수를 자동으로 조절하는 기능</li>
      <li>클러스터 내에서 리소스 사용량에 따라 Pod의 수를 증가 또는 감소시켜 애플리케이션 성능을 유지
        <blockquote>
          <h3 id="고려-사항">고려 사항</h3>
          <ul>
            <li>임계값 설정: 자원을 확장하는 기준이 되는 메트릭의 임계 값을 적절하게 설정해야 한다.</li>
            <li>트리거: 스케일링 유발 트리거를 설정해야 한다.</li>
            <li>자동화와 모니터링: 자동으로 확장되도록 설정했더라도, 시스템이 예상대로 작동하는지 모니터링이 필요</li>
            <li>비용 관리: 오토스케일링은 편리하지만 과도한 리소스 확장은 비용 문제로 돌아올 수 있다.</li>
            <li>오토스케일링을 통한 비용 최적화 전략
              <ul>
                <li>온디맨드 리소스와 리저브드 인스턴스를 혼합</li>
                <li>자동화 도구로 피크/ 비피크 시간대를 고려한 스케쥴링</li>
              </ul>
            </li>
          </ul>
        </blockquote>
      </li>
    </ul>
  </li>
</ol>

<h2 id="로드밸런싱">로드밸런싱</h2>
<ul>
  <li>대규모 트래픽이 발생할 때 서버 하나가 감당할 수 없는 부하가 생기지 않도록 트래픽을 여러 서버에 분산시켜 성능을 최적화한다.</li>
  <li>여러 서버에 분산해서 안정성, 성능을 유지시키는 중요 기술</li>
  <li>트래픽 집중을 방지하고 장애 시에도 트래픽을 다른 서버로 자동 분산할 수 있다.</li>
</ul>

<h3 id="elbaws-elastic-load-balancer">ELB(AWS Elastic Load Balancer)</h3>
<ul>
  <li>AWS 네트워크 계층에서 동작하는 로드 밸런서</li>
  <li>여러 EC2 인스턴스에 트래픽을 균등하게 분산</li>
  <li>모든 네트워크 트래픽을 분산시키며, 네트워크 레벨에서 작동</li>
</ul>

<h3 id="albapplication-load-balancer">ALB(Application Load Balancer)</h3>
<ul>
  <li>ALB는 애플리케이션 계층에서 동작하는 로드밸런서</li>
  <li>주로 HTTP, HTTPS 트래픽을 처리</li>
  <li>경로기반, 호스트 기반 라우팅으로 특정 트래픽을 특정 애플리케이션으로 정확하게 분배</li>
  <li>Websocket 지원 등 애플리케이션 레벨의 추가 기능을 제공</li>
</ul>

<blockquote>
  <h3 id="elb-vs-alb">ELB vs. ALB</h3>
  <ul>
    <li>ELB는 네트워크 계층에서 모든 트래픽을 분산</li>
    <li>ALB는 애플리케이션 계층에서 HTTP/HTTPS를 주로 처리</li>
  </ul>

  <h3 id="안정성을-유지하는-방법">안정성을 유지하는 방법</h3>
  <ul>
    <li>세션 유지</li>
    <li>성능 모니터링</li>
    <li>다중 리전 로드 밸런식</li>
  </ul>

  <h3 id="네트워크-최적화-트래픽-분산-시-추가-고려-사항">네트워크 최적화, 트래픽 분산 시 추가 고려 사항</h3>
  <ul>
    <li>지리적 분산: CDN 등과 함께 사용</li>
    <li>로드밸런서 상태 체크: 서버 상태를 주기적으로 확인해서 비정상 서버로 트래픽이 라우팅되지 않도록 한다.</li>
  </ul>
</blockquote>

<h2 id="캐싱-전략">캐싱 전략</h2>
<ul>
  <li>캐싱은 데이터, 계산 결과를 미리 저장해 두었다가 나중에 동일한 요청이 들어올 때 빠르게 응답하기 위한 기술</li>
  <li>캐싱 전략을 사용하면 응답속도를 향상시킬 수 있으며, API 응답이나 반복적인 데이터 조회에 유용
    <h3 id="종류">종류</h3>
  </li>
  <li>REDIS</li>
  <li>Memcached</li>
</ul>

<h3 id="인기있는-캐싱-전략-및-데이터-일관성-관리">인기있는 캐싱 전략 및 데이터 일관성 관리</h3>
<ol>
  <li>LRU(Least Recently Used) 전략: 오래 사용하지 않은 데이터를 우선적으로 삭제해서 캐시 공간을 확보</li>
  <li>캐시 무효화: 데이터 변경 시, 캐시된 오래된 데이터를 무효화하고 새로운 데이터로 대체하는 방법</li>
  <li>캐시 계층 설계
    <ul>
      <li>캐시 계층을 설계할 때 만료 정책과 데이터 일관성을 고려해야한다.</li>
      <li>너무 오래된 캐시가 있다면 데이터 불일치 문제가 발생할 수 있따.</li>
      <li>TTL(Time To Live): 유효 기간을 설정해서 일정 기간이 지나면 자동으로 삭제되도록한다.</li>
      <li>다중 계층 캐싱(Multi-layer Caching): 데이터를 효율적으로 저장하고 빠르게 접근하기 위해서 여러 단계의 캐시 시스템을 이용하는 것</li>
    </ul>
  </li>
</ol>

<blockquote>
  <h3 id="로드밸런싱-1">로드밸런싱</h3>
  <ul>
    <li>크기가 작을 때:
      <ul>
        <li>고정 트래픽 분산: 간단한 로드밸런싱으로 충분히 성능을 보장할 수 있다. (ALB, ELB 설정 정도로 충분히 대응 가능)</li>
      </ul>
    </li>
    <li>크기가 커지면:
      <ul>
        <li>지리적 분산, 다중 리전 지원: 트래픽이 많아지면, 로드밸런서가 더 복잡해지고 고급 기능이 필요해진다. (CDN, Anycast 네트워크 활용)</li>
      </ul>
    </li>
  </ul>

  <h3 id="캐싱-전략-1">캐싱 전략</h3>
  <ul>
    <li>크기가 작을 때:
      <ul>
        <li>간단한 캐싱 적용</li>
      </ul>
    </li>
    <li>크기가 커지면
      <ul>
        <li>다중 계층 캐싱 도입: 트래픽이 늘어나면, 다중 계층 캐싱을 통해 성능 극대화한다.</li>
        <li>서버 간의 캐시 분산을 적용하고, 데이터 일관성을 유지하기 위한 복잡한 캐시 전략을 도입</li>
      </ul>
    </li>
  </ul>

  <h3 id="데이터베이스-전략">데이터베이스 전략</h3>
  <ul>
    <li>크기가 짝을 때:
      <ul>
        <li>기본적 사용으로 안정성과 비용 모두 챙김</li>
      </ul>
    </li>
    <li>크기가 커지면
      <ul>
        <li>샤딩이나 분산 데이터베이스로 효율화</li>
      </ul>
    </li>
  </ul>

</blockquote>

<hr />
<h2 id="1-다중-계층-캐싱의-기본-개념">1. 다중 계층 캐싱의 기본 개념</h2>
<ul>
  <li>
    <p>효율 극대화를 위해서 여러 단계로 나눠서 사용할 수 있다.</p>

    <ul>
      <li>L1(첫 번째 계층):
        <ul>
          <li>애플리케이션 내부에서 가장 빠르게 접근할 수 있는 캐시</li>
          <li>주로 메모리 내부에 저장되며, 자주 접근하는 데이터를 여기에 저장</li>
          <li>접근 속도가 매우 빠르지만, 용량이 제한적임</li>
        </ul>
      </li>
      <li>L2(두 번째 계층):
        <ul>
          <li>메모리보다 느리지만, 더 많은 양의 데이터를 저장할 수 있는 외부 캐시 시스템을 의미</li>
          <li>Redis, Memcached 같은 외부 솔루션을 사용해 더 많은 데이터를 저장</li>
          <li>L1보다 느리지만, 훨씬 더 많은 데이터를 저장할 수 있다.</li>
        </ul>
      </li>
      <li>L3(세 번째 계층):
        <ul>
          <li>더 낮은 단계의 캐시, DB나 원번 서버와 같은 위치를 의미</li>
          <li>최후의 데이터 저장소</li>
          <li>L1, L2 캐시에서 찾을 수 없는 데이터를 가져오는 곳</li>
          <li>접근 속도가 가장 느리지만, 데이터를 항상 저장하고 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-다중-캐싱-동작-방식">2. 다중 캐싱 동작 방식</h2>
<ol>
  <li>L1 탐색</li>
  <li>L1에 없으면 L2 탐색</li>
  <li>L2에 없으면 L3 또는 DB 조회</li>
</ol>

<h2 id="3-장점">3. 장점</h2>
<ol>
  <li>성능 향상</li>
  <li>리소스 절약</li>
  <li>확장성</li>
</ol>

<h2 id="4-단점-고려-사항">4. 단점, 고려 사항</h2>
<ol>
  <li>복잡성 증가: 캐시 일관성 고려, 캐시 무효화 전략 설계</li>
  <li>데이터 일관성: 부패된 캐시 데이터는 DB와 싱크가 맞지 않을 수 있다.</li>
</ol>

<hr />
<h2 id="분산-아키텍쳐">분산 아키텍쳐</h2>
<h3 id="1-분산-아키텍쳐">1. 분산 아키텍쳐</h3>
<ul>
  <li>분산 시스템의 정의:
    <ul>
      <li>여러 독립적인 서버 또는 노드가 협력하여 하나의 시스템처럼 작동하는 구조</li>
      <li>대규모 애플리케이션에서 널리 사용된다.</li>
      <li>이를 통해서 더 많은 트래픽을 처리하고, 장애에 대한 내성을 강화할 수 있다.</li>
    </ul>
  </li>
  <li>확장:
    <ul>
      <li>단일 서버는 물리적 한계가 있음</li>
      <li>따라서 여러 서버로 확장하는 것이 필요하며, 트래픽을 유연하게 대응할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="2-데이터-복제-및-분산-처리">2. 데이터 복제 및 분산 처리</h3>
<ul>
  <li>데이터 복제: 데이터를 여러 노드에 복사해서 저장하면 자여스레 부하 분산이 가능하다.</li>
  <li>분산 처리: MapReduce는 대표적 분산 처리 프레임 워크다.</li>
  <li>일관성 문제:
    <ul>
      <li>각 노드 간 싱크가 살짝씩 맞지 않을 수도 있으며, 이를 해결하기 위해서 일관성 모델을 적용한다.</li>
      <li>강한 일관성 : 모든 노드에서 동일한 데이터를 보장</li>
      <li>최종 일관성 : 시간이 지남에 따라 데이터가 동기화됨을 의미</li>
    </ul>
  </li>
</ul>

<h3 id="3-spof-방지-및-고가용성ha-유지">3. SPOF 방지 및 고가용성(HA) 유지</h3>
<ol>
  <li>SPOF: 컴포넌트 하나의 장애가 다른 곳으로 전파되는 것을 방지</li>
  <li>고가용성: 시스템이 지속적으로 사용 가능하도록 복제와 장애 복구 기능을 설계</li>
</ol>

<h3 id="4-분산-트랜잭션-관리">4. 분산 트랜잭션 관리</h3>
<ol>
  <li>2PC(2-PhaseCommit):
    <ul>
      <li>분산 시스템에서 트랜잭션을 안전하게 커밋하는 기법으로, 모든 노드가 트랜잭션 준비가 완료되면 커밋/ 롤백을 결정한다.</li>
      <li>단, 네트워크 지연이 생기면 같이 늦어진다.</li>
    </ul>
  </li>
  <li>SAGA 패턴:
    <ul>
      <li>각 트랜잭션을 작은 단위로 나눠 처리하는 방식</li>
      <li>성공적으로 실행된 트랜잭션 이후에 문제가 발생하면 롤백을 수행</li>
    </ul>
  </li>
</ol>

<h3 id="5-트랜잭션-관리-시-확장성-문제-고려">5. 트랜잭션 관리 시 확장성 문제 고려</h3>
<ol>
  <li>네트워크 분할 문제:
    <ul>
      <li>네트워크 분할 + 장애일 경우 일부가 독립적으로 운영되면서 전체 시스템이 정상적으로 동작할 수 있도록 해야 함</li>
    </ul>
  </li>
  <li>확장성을 고려한 관리 기법:
    <ul>
      <li>비동기 트랜잭션 처리 방식과 같은 확장성 기법을 적용해서 트랜잭션이 독립적 노드에서 처리되도록 설계</li>
    </ul>
  </li>
</ol>

<h2 id="db-확장-전략">DB 확장 전략</h2>
<h3 id="1-수직">1. 수직</h3>
<ol>
  <li>장점
    <ul>
      <li>구조 변경 없이 자원만 추가하면 된다.</li>
      <li>성능 향상이 손쉬움</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>물리적 한계가 있다.</li>
      <li>비용이 급격하게 증가할 수 있다.</li>
    </ul>
  </li>
</ol>

<h3 id="2-수평">2. 수평</h3>
<ul>
  <li>샤딩: 샤드 단위로 분할해서 여러 서버에서 분산 처리하는 방식이다. 샤딩 키를 기준으로 데이터를 나누며 각 샤드는 독립적인 DB처럼 작동한다.
    <ol>
      <li>장점</li>
    </ol>
    <ul>
      <li>여러 서버로 부하 분산</li>
      <li>이론적으로 무한히 확장 가능
        <ol>
          <li>단점</li>
        </ol>
      </li>
      <li>샤딩 키 선택이 매우 중요하다.</li>
      <li>데이터 일관성 유지가 어렵고 복잡하다.</li>
    </ul>
  </li>
</ul>

<h3 id="3-replication">3. Replication</h3>
<ul>
  <li>여러 복제본을 생성하여, 읽기 및 쓰기 작업을 분산하는 방식
    <ol>
      <li>M-S:</li>
    </ol>
    <ul>
      <li>Master는 쓰기, Slave는 읽기</li>
      <li>읽기 성능이 중요한 시스템에 적합
        <ol>
          <li>M-M</li>
        </ol>
      </li>
      <li>여러 Master가 쓰기 작업을 하며, 데이터 동기화가 필요하다.</li>
      <li>글로벌 서비스나 대규모 시스템에서 주로 사용</li>
    </ul>
  </li>
</ul>

</section>
  

</article>

<!-- Disqus -->


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>이전 글</p>
      <a href="/docker/wanted/2024/10/16/Wanted-Docker-series-16.OptimizeWebServer.html">
        [wanted Docker Series] 16.optimizewebserver
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>다음 글</p>
      <a href="/docker/wanted/2024/10/27/Docker-series-18.ServiceMesh.html">
        [docker Series] 18.servicemesh
      </a>
  </div>
  
</div>



    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
