<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>[wanted Docker Series] 14.designcloudnative | newkayak12.github.io</title>
	<meta name="description"
		content="클라우드 네이티브 설계  클라우드에서 최적화된 애플리케이션을 설계, 배포, 운영하는 방식  마이크로서비스, 컨테이너 오토스케일링, 분산 시스템을 중심으로 하며, 애플리케이션을 독립적으로 배포하고 관리">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/docker/wanted/2024/10/14/Wanted-Docker-series-14.DesignCloudNative.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
		integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

	<script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
		integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
		crossorigin="anonymous"></script>
	

	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'G-4WXFZQCMT3', 'auto');
		ga('send', 'pageview');
	</script>
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">[wanted Docker Series] 14.designcloudnative</h1>
    
    <p class="meta">
      October 14, 2024
      
    </p>

    
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    
  </header>
  <section class="post-content"><h1 id="클라우드-네이티브-설계">클라우드 네이티브 설계</h1>
<ul>
  <li>클라우드에서 최적화된 애플리케이션을 설계, 배포, 운영하는 방식</li>
  <li>마이크로서비스, 컨테이너 오토스케일링, 분산 시스템을 중심으로 하며, 애플리케이션을 독립적으로 배포하고 관리</li>
</ul>

<blockquote>
  <p>vs. monolithic</p>
  <ul>
    <li>모놀리식은 모든 기능이 하나의 코드베이스로 구성.</li>
    <li>모든 기능이 함께 배포되고 관리됨</li>
    <li>
      <p>초기에는 간단하지만 시간이 지나고 기능이 늘면 확장성과 유지보수 측면에서 어려움이 생김</p>
    </li>
    <li>클라우드 네이티브는 각 기능을 독립적인 마이크로서비스로 구성</li>
    <li>확장성과 유지보수를 용이하게 한다.</li>
    <li>The Twelve-Factor App은 확장 가능하고 유지 보수성이 높은 애플리케이션을 개발하기 위한 표준이자 원칙이 된다.</li>
    <li>12요소는 각기 독립적인 모듈로, 애플리케이션이 다양한 클라우드 환경과 하이브리드 환경에서 일관되게 동작하게 하고, 관리할 수 있도록 돕는 설계 원칙이다.</li>
  </ul>
</blockquote>

<h2 id="12-factor-app"><a href="https://12factor.net">12 Factor App</a></h2>
<ol>
  <li>codebase
    <ul>
      <li>하나의 코드베이스를 가져야하며, 이 코드베이스는 버전 관리 시스템에 의해서 추적되어야 한다.</li>
      <li>하나의 코드베이스를 기반으로 다양한 환경(dev, stage, prod)을 지원할 수 있다.</li>
      <li>모든 환경은 동일한 코드베이스에서 파생된다.( 다른 버전의 코드를 사용하지 않는다. )</li>
      <li>동일한 코드베이스로부터 빌드된 여러 배포가 존재할 수 있다.</li>
    </ul>
  </li>
  <li>dependencies(Explicitly Declare Dependencies)
    <ul>
      <li>애플리케이션이 의존하는 모든 라이브러리, 패키지를 명시적으로 선언해야 한다.</li>
      <li>이를 통해 일관된 빌드를 보장하고, 종속성 관련 문제를 최소화한다.</li>
      <li>모든 의존성은 완벽히 관리되고 동일한 패키지를 사용하도록 보장된다.</li>
    </ul>
  </li>
  <li>config(Store Config in the Environment)
    <ul>
      <li>설정정보는 코드 베이스가 아닌 환경 변수나 외부 설정 파일로 분리해야 한다.</li>
      <li>이는 다양한 환경에서 일관되게 동작할 수 있도록 한다.</li>
      <li>설정 정보가 코드에 포함되지 않아서 보안 문제도 해결할 수 있다.</li>
    </ul>
  </li>
  <li>backing services(Treat Backing Services as Attached Resources)
    <ul>
      <li>DB, MessageQueue, Cache 같은 외부 서비스는 백엔드 리소스로 취급된다. (연결된 자원)</li>
      <li>애플리케이션은 이들 서비스와 독립적으로 실행되어야 한다.</li>
      <li>백엔드 서비스의 위치나 구성 변경 시에도 애플리케이션의 코드에 수정이 필요하지 않도록 해야 한다.</li>
      <li>이 접근법은 애플리케이션이 어느 환경에서도 일관되게 동작할 수 있도록 보장한다.</li>
    </ul>
  </li>
  <li>build release run(Strictly Separate Build and Run Stages)
    <ul>
      <li>애플리케이션은 build, release, run 단계를 명확히 구분해야 한다.</li>
      <li>빌드 단계에서는 코드를 컴파일하고, 릴리즈 단계에서는 빌드된 아티팩트와 설정 정보를 결합하며, 실행 단계에서는 해당 릴리즈 버전을 실행한다.</li>
      <li>CI/CD를 통해서 빌드하고, 결과물을 환경 설정과 결합하여 릴리즈 버전을 생성한다.</li>
      <li>그리고 배포하여 실행한다.
        <ul>
          <li>코드와 설정 정보 분리 이유는 동일한 코드베이스가 다양한 환경에서 설정만 변경하여 사용할 수 있도록 하기 위함이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>processes
    <ul>
      <li>애플리케이션은 상태를 가지고 있지 않아야 한다.</li>
      <li>만약 상태를 가져야 한다면 db같은 backing service에 저장되어야 한다.</li>
    </ul>
  </li>
  <li>port binding(Export Services via Port Binding)
    <ul>
      <li>애플리케이션이 특정 포트를 통해 외부와 통신할 수 있도록 하는 것이다.</li>
      <li>외부와의 통신을 위해서 포트 바인딩을 통해서 서비스를 제공해야 한다.</li>
      <li>이를 통해서 애플리케이션은 웹 서비스와 같은 외부 프로세스에 의존하지 않고 자체적으로 HTTP 트래픽을 처리할 수 있다.</li>
      <li>웹서버를 이용할 수도 있고, 로드밸런서도 쓸 수 있다.</li>
      <li>애플리케이션이 포트에 직결해서 서비스 할 수 있다면 더 유연하다.</li>
      <li>애플리케이션이 외부에 의존 없이 포트 바인딩으로 자체적으로 서비스 제공하면 애플리케이션의 독립성과 확작성을 높인다.</li>
    </ul>
  </li>
  <li>concurrency(Scale Out via the Process Model)
    <ul>
      <li>애플리케이션은 프로세스 기반으로 동시성을 처리해야 한다.</li>
      <li>여러 프로세스나 인스턴스를 통해서 확장성을 제공한다.</li>
      <li>이는 수평 확장을 통해서 더 많은 트래픽을 처리할 수 있게 한다.
        <ul>
          <li>동시성: 여러 작업이 동시에 처리될 수 있도록 프로세스를 병렬로 실행하는 것</li>
        </ul>
      </li>
      <li>애플리케이션은 프로세스 모델을 통해서 동시성을 제공한다.</li>
      <li>프로세스 간 상태 공유 없이 독립적으로 동작할 수 있어야 한다.</li>
    </ul>
  </li>
  <li>disposability
    <ul>
      <li>프로세스는 언제든 처분될 수 있으며, 이는 언제든지 실행되거나 종료될 수 있음을 의미한다.</li>
      <li>프로세스의 시작 시간은 최소화되어야 한다.</li>
      <li>짧은 시작시간은 릴리즈, 스케일 업에 유연성을 부여한다.</li>
      <li>종료는 우아하게 되어야 한다.</li>
      <li>또한 고장 발생시 갑작스런 종료에 견고해야 한다.</li>
    </ul>
  </li>
  <li>dev/prod parity
    <ul>
      <li>최대한 dev/stage/prod 간 차이가 크지 않아야 한다.</li>
    </ul>
    <ul>
      <li>시간적 차이: 개발 단계에서 배포 전까지 기간이 반드시 존재한다.</li>
      <li>인원적 차이: 개발은 개발자가, 배포는 엔지니어가 한다.</li>
      <li>도구적 차이: 각 단계에서 사용하는 도구가 다르다.
        - 즉 이 차이들을 줄이려면 주기적으로 지속적으로 배포해야 한다.
        - 또한 인원 차이를 문서화등 명시적으로 작성하는 것으로 극복해야 한다.
        - 마지막으로 개발, 배포 간 차이를 줄여야 한다.</li>
    </ul>
  </li>
  <li>logs(Treat Logs as Event Stream)
    <ul>
      <li>애플리케이션에서 발생하는 모든 로그는 이벤트 스트림으로 처리되야 한다.</li>
      <li>별도의 로그 처리 시스템에서 중앙화 하여 관리할 수 있다.</li>
      <li>로그는 단순 출력이 아니라, 애플리케이션의 상태를 모니터링하고 문제를 디버깅하는 중요한 데이터 소스다.
        <ul>
          <li>EventStream: 애플리케이션에서 발생하는 이벤트를 시간 순서대로 처리하는 방식이다. 이를 통해서 실시간 데이터 분석, 모니터링이 가능하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>admin processes(Run Admin/Management Tasks as One-off Process)
    <ul>
      <li>DB 마이그레이션이나 백업 같은 관리자 작업은 애플리케이션의 코드와 별도로 독립적인 프로세스로 관리되어야 한다.</li>
      <li>이러한 작업은 운영 중인 애플리케이션과 분리되며, 애플리케이션에 영향을 미치지 않도록 처리한다.</li>
      <li>관리 작업은 독립적 프로세스로 실행되어야 한다.</li>
      <li>이 작업은 애플리케이션에 영향을 미치지 않아야 한다.</li>
    </ul>
  </li>
</ol>

<h2 id="1-cap">1. CAP</h2>
<ul>
  <li>CAP 이론은 Consistency, Availability, Partition Tolerance 중 두 가지를 선택해야 한다는 이론이다.</li>
  <li>이 세가지 요소는 서로 상충되기에, 한 시스템에서 세 가지를 동시에 완벽하기 어렵다.</li>
  <li>아키텍쳐 설계 단계에서 뭘 더 중점을 둘지를 정해야 한다.</li>
</ul>

<ol>
  <li>Consistency
    <ul>
      <li>일관성은 분산 시스템에서 모든 노드가 동일한 데이터 상태를 유지하는 것을 의미한다.</li>
      <li>한 노드에서 데이터를 업데이트하면, 그 업데이트는 다른 모든 노드에 즉시 반영되어야 한다.</li>
      <li>장/단점
        <ul>
          <li>장점: 데이터 신뢰성, 정확성이 높아진다.</li>
          <li>단점: 모든 데이터를 즉시 동기화해야 해서, 네트워크 지연이나 장애 발생 시 가용성이 떨어진다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Availability
    <ul>
      <li>가용성을 장애가 발생하거나 네트워크가 분리되더라도 모든 요청에 대해서 응답할 수 있는 능력을 의미한다.</li>
      <li>이는 분산 시스템의 중요한 목표 중 하나다.</li>
      <li>사용자 요청을 무조건적으로 처리해주는 것을 보장한다.</li>
      <li>장/단점
        <ul>
          <li>장점: 사용자 경험이 지속적으로 유지, 시스템 가동 중단을 최소화할 수 있다.</li>
          <li>단점: 노드 간에 일관성이 일시적으로 깨질 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Partition Tolerance
    <ul>
      <li>파티션 허용성은 네트워크 분할이 발생했을 때도 시스템이 정상적으로 동작할 수 있는 능력을 의미한다.</li>
      <li>분산 시스템에서 네트워크 연결이 끊기거나, 일부 노드가 다른 노드와 연결되지 못하는 상황을 의미한다.</li>
      <li>이런 경우에도 시스템은 가능한 한 정상적으로 작동해야 한다.</li>
      <li>장/단점
        <ul>
          <li>장점: 네트워크 분리 시에도 서비스가 계속 제공될 수 있다.</li>
          <li>단점: 일관성과 가용성 중 하나를 포기해야 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="/assets/img/cap.png" alt="cap.png" /></p>

<ul>
  <li>일관성 우선: 데이터 정확성이 중요한 경우 선택. 가용성과 파티션 허용성을 어느정도 희생</li>
  <li>가용성 우선: 대규모 트래픽을 처리해야 하는 경우 선택.</li>
  <li>파티션 우선: 글로벌 서비스를 제공하는 클라우드 환경에서 선택</li>
</ul>

<h2 id="2-데이터-복구-장애-복구">2. 데이터 복구, 장애 복구</h2>
<ul>
  <li>분산 시스템에서 데이터를 여러 노드로 복제하여 시스템의 고가용성을 보장하는 것이 중요하다.</li>
  <li>데이터 복제는 한 노드에서 데이터를 변경했을 때, 그 변경 사항이 다른 노드에서도 복사되는 것을 의미한다.</li>
  <li>이를 통해서 장애가 발생해도 데이터를 잃지 않고 시스템을 빠르게 복구할 수 있다.</li>
</ul>

<ol>
  <li>데이터 복제의 중요성
    <ul>
      <li>고가용성 보장: 하나의 노드에 장애가 발생하더라도 다른 노드에 동일 데이터가 있어서 서비스 중단이 없다.</li>
      <li>데이터 손실 방지: 실시간으로 데이터를 여러 노드에 복제함으로써, 시스템 장애나 데이터센터의 물리적 손상에서도 데이터 복구가 가능</li>
    </ul>
  </li>
  <li>복제 방법
    <ul>
      <li>동기 복제: 데이터 변경할 떄, 모든 노드가 데이터 변경 사항을 즉시 반영한다. 이는 데이터 일관성을 보장하지만, 지연 시간이 길어질 수 있다.</li>
      <li>비동기 복제: 데이터 변경 후, 일정 시간이 지난 후에 데이터를 복제한다. 짧은 시간 일관성이 떨어질 수 있지만, 시스템 성능과 가용성이 높아진다.</li>
    </ul>
  </li>
  <li>장애 복구 전략
    <ul>
      <li>자동 복구(Self-healing): 클라우드 네이티브 시스템은 장애가 발생하면 자동으로 복구될 수 있도록 설계되어야 한다.</li>
      <li>백업, 복원: 중요 데이터는 정기적으로 백업하고, 장애 발생 시 이를 통해서 복원해야 한다. 데이터 손실을 최소화 하기 위해서 여러 데이터 센터에서 복제된 백업을 보유하는 것이 좋다.</li>
    </ul>
  </li>
</ol>

<h2 id="3-네트워크-레이턴시">3. 네트워크 레이턴시</h2>
<ul>
  <li>분산 시스템에서 성능을 저하시키는 요소 중 하나</li>
  <li>노드 간 이동하는데 걸리는 시간을 의미한다.</li>
  <li>latency가 길어지면 응답 시간이 길어져 사용자 경험에 악영향을 미친다.</li>
  <li>따라서 통신을 최적화해야 한다.</li>
</ul>

<ol>
  <li>레이턴시 발생 원인
    <ul>
      <li>지리적 거리: 사용자 - 서버 간 물리적 거리가 멀면 느려질 수 있다.</li>
      <li>네트워크 혼잡: 네트워크가 많은 트래픽을 처리해야 하면 느려질 수 있다.</li>
      <li>잘못된 라우팅: 네트워크 내에서 잘못된 경로로 전송하면 추가적 레이턴시가 발생할 수 있다.</li>
    </ul>
  </li>
  <li>최적화
    <ul>
      <li>CDN 사용: 지리적으로 가까운 서버에서 받을 수 있도록 한다.</li>
      <li>DNS 최적화: 라우팅을 최적화 하여 사용자가 가까운 서버에 연결되도록 한다.</li>
      <li>오토스케일링 및 로드 밸런싱: 트래픽이 많으면 자동으로 서버를 추가하고, 트래픽을 분배해서 네트워크 혼잡을 방지한다.</li>
      <li>서비스 간 통신 최적화:
        <ol>
          <li>서비스 메시: 서비스 메시를 사용해서 마이크로서비스 간 통신을 효율적으로 관리할 수 있다. 서비스 메시를 통해서 통신 경로를 최적화하고, 성능을 모니터링할 수 있다.</li>
          <li>RPC: 원격 노드 간의 통신을 최적화하는 방법이다. 서비스 간 빠른 데이터 전송을 가능하게 한다. gRPC는 RPC를 개선하여, 데이터 전송 속도를 높였다.</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h2 id="4-servicemesh-api-gateway">4. ServiceMesh/ API gateway</h2>
<h3 id="41-서비스-메시">4.1. 서비스 메시</h3>
<ul>
  <li>분산 시스템에서 마이크로 서비스 간의 통신을 최적화하는 구조다.</li>
  <li>여러 개의 마이크로 서비스가 통신할 때, 서비스 메시가 각 서비스 간의 트래픽을 라우팅하고, 보안 및 모니터링을 담당한다.</li>
  <li>주요 기능
    <ol>
      <li>트래픽 관리: 서비스 간의 통신 경로를 최적화 하고, 필요한 경우 트래픽을 제한하거나 우선순위를 설정</li>
      <li>보안: 서비스 메시를 통해서 마이크로서비스 간의 통신을 암호화하고, 인증 및 권한 부여 기능을 통해 보안을 강화</li>
      <li>모니터링 및 로깅: 서비스 메시가 모든 서비스 간의 트래픽을 감시하고, 성능을 모니터링한다. 또한, 로깅 기능을 통해 문제가 발생한 서비스의 통신 기록을 분석할 수 있다.</li>
    </ol>
  </li>
</ul>

<h3 id="42-api-gateway">4.2. API gateway</h3>
<ul>
  <li>외부 클라이언트가 여러 마이크로서비스에 접근할 수 있도록 라우팅을 제공하는 진입점 역할을 한다.</li>
  <li>클라우드 네이티브에서는 중요한 역할을 하며, 서비스 메시와 사용되기도 한다.</li>
  <li>주요 기능
    <ol>
      <li>트래픽 라우팅: API 게이트웨이는 클라이언트 요청을 적절한 마이크로서비스로 라우팅하여 각 서비스가 개별적으로 처리할 수 있도록 한다.</li>
      <li>보안: 보안, 인가, 데이터 검증 등의 기능을 제공하여, 외부 클라이언트 - 내부 마이크로서비스 간의 보안을 강화한다.</li>
      <li>로드밸런싱: 여러 마이크로서비스 간 트래픽을 분산하여, 특정 서비스에 과부화가 걸리지 않도록 조정한다.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <h1 id="api-설계와-버저닝">API 설계와 버저닝</h1>
  <ul>
    <li>마이크로 서비스 간 통신을 관리하고 데이터를 주고받는 중요한 요소</li>
    <li>서비스 간 연결성을 보장</li>
    <li>클라우드 네이티브에서는 여러 마이크로서비스가 독립적으로 배포되고 관리되기에 각 서비스가 다른 서비스와 통신할 수 있도록 API 설계, 버저닝이 중요</li>
    <li>잘 설계된 API는 확장성, 유지보수성 그리고 서비스 간 안정적 통신을 보장</li>
  </ul>

  <h2 id="a-api-설계-원칙">a. API 설계 원칙</h2>
  <h3 id="1-restful">1. RESTful</h3>
  <ul>
    <li>REST(REpresentational State Transfer)</li>
    <li>인터넷 사이 상호 운용성을 제공하는 방법
      <h4 id="11-어떻게-정보를-공유할-것인가">1.1. 어떻게 정보를 공유할 것인가?</h4>
    </li>
    <li>장점:
      <ul>
        <li>표준화되니 방식으로 설계되어, 다양한 클라이언트에서 사용 가능함</li>
        <li>무상태성으로 인해 서버 확장성이 높다.</li>
        <li>직관적인 설계를 통해 자원에 대한 접근을 쉽게 이해할 수 있다.</li>
      </ul>
    </li>
    <li>단점
      <ul>
        <li>대규모 요청에서 불필요한 데이터 전송이 발생할 수 있다</li>
        <li>요청한 데이터 외에도 많은 자원 정보를 보내기 때문에 대역폭이 낭비될
          <h3 id="graphql">GraphQL</h3>
        </li>
      </ul>
    </li>
    <li>facebook이 개발한 쿼리 언어, 클라이언트가 단일 엔드포인트롤 통해서 필요한 데이터만 요청할 수 있다.</li>
    <li>불필요한 정보 송수신을 줄일 수 있다.</li>
    <li>장점
      <ul>
        <li>클라이언트가 필요한 데이터만 요청할 수 있어 효율적이다.</li>
        <li>하나의 엔드포인트에서 다양한 자원에 접근이 가능하다.</li>
        <li>API 변경 시에도 클라이언트와의 호환성을 유지할 수 있다.</li>
      </ul>
    </li>
    <li>단점
      <ul>
        <li>복잡한 쿼리 로직이 많다면 서버 부하가 생길 수 있다.</li>
        <li>GraphQL 스키마를 정의하고 유지관리하는데 추가적인 작업이 필요하다.
          <h3 id="grpc">gRPC</h3>
        </li>
      </ul>
    </li>
    <li>구글에서 개발한 RemoteProcedureCall 프레임워크</li>
    <li>고성능 통신을 위해서 프로토콜 버퍼를 사용해서 데이터를 직렬화 하고 비동기 통신을 지원한다.</li>
    <li>마이크로서비스 간의 저지연, 고성능 통신을 위해서 사용된다.</li>
    <li>HTTP/2 프로토콜 기반으로 작동한다.</li>
    <li>장점
      <ul>
        <li>프로토콜 버퍼를 사용한 데이터 직렬화로 매우 빠른 데이터 전송이 가능</li>
        <li>HTTP/2 기반으로 다중 요청 및 스트리밍을 지원해서 네트워크 효율이 뛰어남</li>
        <li>언어에 구애받지 않음</li>
      </ul>
    </li>
    <li>단점
      <ul>
        <li>RESTful에 비해 상대적으로 복잡</li>
        <li>브라우저에서 직접적으로 사용하기 어려움(프록시 서버가 필요)</li>
      </ul>
    </li>
  </ul>

  <h2 id="b-버전-관리-전략">b. 버전 관리 전략</h2>
  <ul>
    <li>여러 버전으로 존재해야 할 수도 있다.</li>
    <li>기능이 추가되면서 기존 명세는 유지해야할 수도 있다.</li>
    <li>이 경우 버전 관리가 중요하다.</li>
    <li>URI, Header, Parameter 세 가지 종류가 있다.
      <ol>
        <li>URI: /v1/users
          <ul>
            <li>장점:
              <ul>
                <li>클라이언트가 명확하게 버전을 선택할 수 있다.</li>
                <li>URL에 버전을 포함해서 쉽게 관리할 수 있다.</li>
              </ul>
            </li>
            <li>단점
              <ul>
                <li>여러 버전 API를 유지 관리해야해서 복잡할 수 있다.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Header: API-Version: v1
          <ul>
            <li>장점:
              <ul>
                <li>URI를 변경하지 않고도 버전관리를 할 수 있다.</li>
                <li>클라이언트가 헤더를 통해서 유연하게 API를 선택할 수 있다.</li>
              </ul>
            </li>
            <li>단점
              <ul>
                <li>클라이언트에 요청 헤더를 추가해야한다.</li>
                <li>URI에 버전 명시가 없어서 가시성이 떨어진다.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Parameter: ~?version=v1 // ~;version=1
          <ul>
            <li>장점:
              <ul>
                <li>클라이언트가 요청 파라미터로 버전을 쉽게 설정할 수 있다.</li>
                <li>버전이 API 경로와는 별개로 관리되기 때문에 URI 설계에 영향을 주지 않는다.</li>
              </ul>
            </li>
            <li>단점:
              <ul>
                <li>URL이 복잡해질 수 있다. 파라미터를 일일이 관리해야 한다.</li>
                <li>쿼리 또는 경로 파라미터가 없는 케이스를 처리해야 한다.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>
</section>
  

</article>

<!-- Disqus -->


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>이전 글</p>
      <a href="/docker/wanted/2024/10/13/Wanted-Docker-series-13.OperateAndDeploy.html">
        [wanted Docker Series] 13.operateanddeploy
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>다음 글</p>
      <a href="/docker/wanted/2024/10/15/Wanted-Docker-series-15.DeployAndLogging.html">
        [wanted Docker Series] 15.deployandlogging
      </a>
  </div>
  
</div>



    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
