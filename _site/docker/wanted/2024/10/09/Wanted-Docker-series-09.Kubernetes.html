<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>[wanted Docker Series] 09.kubernetes | newkayak12.github.io</title>
	<meta name="description"
		content="K8s">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/docker/wanted/2024/10/09/Wanted-Docker-series-09.Kubernetes.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="newkayak12.github.io"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
		integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

	<script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
		integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
		crossorigin="anonymous"></script>
	

	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'G-4WXFZQCMT3', 'auto');
		ga('send', 'pageview');
	</script>
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.jpeg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">newkayak12.github.io</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:newkayak12@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/newkayak12" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>































            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">[wanted Docker Series] 09.kubernetes</h1>
    
    <p class="meta">
      October 9, 2024
      
    </p>

    
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    
  </header>
  <section class="post-content"><h1 id="k8s">K8s</h1>

<blockquote>
  <p><a href="https://training.linuxfoundation.org/certification/certified-kubernetes-administrator-cka/">CKA(Certified Kubernetes Administrator)</a></p>
  <h2 id="기본-이해">기본 이해</h2>
</blockquote>

<ul>
  <li>현대 개발에서 필수 도구
    <ul>
      <li>CloudkNative 황경에서 표준 컨테이너 오케스레이션 도구가 되었음</li>
      <li>MSA에서 필수 기술로 자리자븜</li>
    </ul>
  </li>
  <li>배포 및 관리 자동화
    <ul>
      <li>자동화된 배포, 스케일링, 롤백을 지원</li>
      <li>무중단 배포, 롤백 업데이트 같은 기능을 활용할 수 있다.</li>
      <li>이를 통해서 배포 효율성을 높일 수 있다.</li>
    </ul>
  </li>
  <li>최적화
    <ul>
      <li>리소스 할당과 자동 확장을 제공한다.</li>
      <li>모니터링을 통해서 성능을 개선할 수 있다.</li>
    </ul>
  </li>
  <li>MSA
    <ul>
      <li>K8s는 컨테이너화된 마이크로 서비스를 쉽게 배포하고 관리하는데 최저고하</li>
      <li>마이크로서비스 간의 통신, 장애 발생 시 복구, 각 서비스의 독립적 배포되는 방식을 이해해야 이를 감안하여 개발할 수 있음</li>
    </ul>
  </li>
  <li>CI/CD 통합
    <ul>
      <li>K8s는 많은 CI/CD 도구와 통합되어 있음</li>
    </ul>
  </li>
  <li>CloudNative 이해
    <ul>
      <li>클라우드 서비스 제공업체에서 제공하는 많은 관리형 서비스가 있음(EKS, GKS)</li>
    </ul>
  </li>
  <li>DevOps와 개발자 간 협업
    <ul>
      <li>어떻게 배포되고 관리되는지에 대해서 알고 이해하는게 원활한 협업에 도움이 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="dockercompose를-쓰면">DockerCompose를 쓰면?</h2>
<ul>
  <li>k8s는 여러 대의 물리 서버를 운영하는 것을 전제로 한다.</li>
  <li>dockercompose으로 여러 번의 command를 사용해야한다.</li>
  <li>모니터링에도 한계가 있다.</li>
  <li>k8s는 오케스트레이션 도구다.</li>
</ul>

<h2 id="desiredstate를-유지">DesiredState를 유지</h2>
<ul>
  <li>Desired State는 사용자가 원하는 애플리케이션의 상태를 의미한다.</li>
  <li>Pod, Container가 3개 실행되어 있어야 한다고 설정했다면 오케스트레이션 시스템은 항상 그 상태를 유지하려고 한다.</li>
</ul>

<h2 id="동작-방식">동작 방식</h2>
<ol>
  <li>원하는 상태(DesiredState) 설정:
    <ul>
      <li>몇 개의 컨테이너가 실행되어야 하는지, 어떤 버전의 애플리케이션이 배포되어야 하는 지 설정</li>
    </ul>
  </li>
  <li>현재 상태(CurrentState) 모니터링:
    <ul>
      <li>오케이스트레이션 시스템은 CurrentState를 모니터링한다.</li>
      <li>만약 컨테이너가 중단되거나 장애가 발생하면 이를 감지</li>
    </ul>
  </li>
  <li>원하는 상태와 현재 상태 비교:
    <ul>
      <li>원하는 상태, 현재 상태를 비교한다.</li>
      <li>지속적으로 원하는 상태로 맞추기 위해서 작동한다.</li>
    </ul>
  </li>
  <li>자동 복구 및 조정(Self-healing):
    <ul>
      <li>자체 복구라고 하며 이 기능으로 항상 가용한 상태를 유지하게 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="desired-condition을-유지하려는-결과적으로">desired condition을 유지하려는 결과적으로</h2>
<ol>
  <li>자동화된 관리: 도커 오케스트레이션 도구는 컨테이너 배포, 관리 및 확장을 자동화하여, 수동 작업의 필요성을 줄여준다.</li>
  <li>확장성 : 오케스트레이션 도구를 사용하면 컨테이너를 쉽게 스케일 아웃할 수 있다.</li>
  <li>부하분산: 여러 컨테이너와 서버에 걸쳐 트래픽과 부하를 자동으로 분산시키는 기능을 제공</li>
  <li>서비스 발견과 네트워킹: 오케스트레이션 도구는 컨테이너 간의 네트워킹과 서비스 발견을 관리한다.</li>
  <li>상태 관리와 self-healing: 시스템이 정의한 상태를 유지하도록 설정할 수 있으며, 문제가 발생했을 때 오케스트레이션 도구가 자동으로 문제를 해결하고자 시도한다.</li>
</ol>

<h2 id="주요-도커-오케스트레이션-도구">주요 도커 오케스트레이션 도구</h2>
<ul>
  <li>Kubernetes</li>
  <li>DockerSwarm</li>
  <li>ApacheMesos</li>
</ul>

<h2 id="구성요소">구성요소</h2>
<blockquote>
  <p>논리적 단위로 그룹화한다. =&gt; Pod</p>
  <ul>
    <li>k8s에서 ‘논리적 단위로 그룹화한다.’는 말은 컨테이너들을 효과적으로 관리하고 조정하기 위해서, 관련 컨테이너들을 하나의 그룹로 묶는 것을 의미</li>
    <li>k8s에서 생성 및 관리되는 가장 작은 단위</li>
  </ul>
</blockquote>

<ol>
  <li>공유 리소스와 통신:
    <ul>
      <li>Pod 안에 있는 컨테이너들은 network namespace, storage를 공유할 수 있다.</li>
      <li>컨테이너들이 서로 통신을 용이하게 하며, 필요한 데이터를 서로 접근할 수 있게 해준다.</li>
    </ul>
  </li>
  <li>컨테이너 조정
    <ul>
      <li>Pod를 사용하면 여러 컨테이너들을 한 그룹으로 관리할 수 있다.</li>
      <li>배포, 스케일링 및 관리를 간소화한다.</li>
    </ul>
  </li>
  <li>서비스 디스커버리
    <ul>
      <li>Pod는 하나의 Logical 호스트로 취급됨으로써, 하나의 IP 주소와 Port 범위를 가진다.</li>
      <li>네트워크를 통한 서비스 발견과 라우팅을 단순화함</li>
    </ul>
  </li>
  <li>부하 분산과 자동 복구
    <ul>
      <li>Pod를 여러 노드에 걸쳐 자동으로 배포할 수 있다.</li>
      <li>Pod가 실패할 경우 자동으로 복구</li>
    </ul>
  </li>
</ol>

<h2 id="주요-구조">주요 구조</h2>
<ul>
  <li>Node는 Pod를 실행하는 물리적 또는 가상의 서버</li>
  <li>Pod는 k8s의 기본 배포 단위로 하나 이상의 컨테이너로 구성될 수 있다.</li>
  <li>pod내 컨테이너들은 공유된 리소스 정보를 가지며, 네트워크, 스토리지 측면에서 밀접하게 연관되어 작동</li>
</ul>

<h3 id="masternode">MasterNode</h3>
<ul>
  <li>k8s 클러스터의 제어 허브로서 클러스터 관리 및 조정을 담당</li>
  <li>kubectl을 설치하고 마스터 노드의 초기 설정 후 마스터 노드를 조정하여, 직접 워커 노드를 관리하는 일은 없음</li>
</ul>

<h3 id="controlplane을-통해서-워커-노드를-관리하는-핵심-컴포넌트">ControlPlane을 통해서 워커 노드를 관리하는 핵심 컴포넌트</h3>
<ul>
  <li>ControlPlane과 WorkerNode로 구성된다.</li>
  <li>중앙 제어 시스템으로 클러스터의 상태를 유지하고, 리소스를 배치하며, 전반적인 작업을 관리하는 역할을 한다.</li>
  <li>ControlPlane은 여러 핵심 컴포넌트들로 구성되어 있으며, 이들 간의 상호 작용을 통해서 Kuberentes 클러스터를 관리</li>
</ul>

<p><img src="/assets/img/k8s.png" alt="k8s.png" /></p>

<h4 id="1-api-서버kube-apiserver">1. API 서버(kube-apiserver)</h4>
<ul>
  <li>API 서버는 k8s클러스터와의 모든 통신 중심 엔드포인트</li>
  <li>클러스터 내부 및 외부의 모든 구성 요소가 API 서버를 통해서 상호작용</li>
  <li>CRUD 작업이 모두 이곳에서 처리된다.</li>
  <li>k8s의 REST API를 제공하고 외부 요청을 받아 k8s 클러스터에 명령을 전달</li>
  <li>주요 역할
    <ul>
      <li>명령어 처리 : kubectl 명령어를 사용해서 클러스터에 명령을 내릴 떄, 이 요청은 모두 API 서버에서 처리</li>
      <li>보안 관리 : 인증(Authentication), 인가(Authorization)를 통해, 사용자가 클러스테 접근하고 리소스에 대한 작업을 수행할 수 있는지 확인함</li>
      <li>클러스터 내부 통신 : k8s 내부 컴포넌트들 간의 통신도 API 서버를 통해서 이뤄진다. 클러스터 내부 통신의 일관성을 보장</li>
      <li>유효성 검사 및 전달 : 리소스 정의 파일(YAML, JSON)을 받으면 유효성 검사하고, 이에 따라 클러스터에 작업을 전달한다.</li>
    </ul>
  </li>
</ul>

<h4 id="2-컨트롤-매니저kube-controller-manager">2. 컨트롤 매니저(kube-controller-manager)</h4>
<ul>
  <li>k8s 클러스터에서 여러 컨트롤러들을 실행하여 클러스터의 상태를 <code class="language-plaintext highlighter-rouge">원하는 상태(DesiredState)</code>로 유지하는 역할을 수행한다.</li>
  <li>컨트롤러는 각기 다른 k8s 리소스를 관리하는 백그라운드 프로세스로, 리소스가 설정된 대로 실행되는지 모니터링하고 이를 유지하는 역할을 담당</li>
  <li>주요 역할
    <ul>
      <li>ReplicationController: Pod가 설정된 수만큼 실행 중인지 확인하고, 부족한 경우 새로운 Pod를 생성하거나, 초과할 경우 삭제</li>
      <li>EndpointController: 서비스와 Pod 간의 연결을 관리하며, 클러스터 내 서비스 디스커버리 및 로드 밸런싱을 관리</li>
      <li>NameSpaceController: 네임스페이스를 생성 및 삭제하는 작업을 관리한다.</li>
      <li>NodeContoller: 클러스터의 노드 상태를 모니터링하며, 장애가 발생한 노드를 감지하고 이를 처리한다.</li>
      <li>자원관리 : 클러스터의 리소스 상태가 정의한대로 유지되도록 보장함</li>
    </ul>
  </li>
</ul>

<h4 id="3-스케쥴러kube-scheduler">3. 스케쥴러(kube-scheduler)</h4>
<ul>
  <li>스케쥴러는 새롭게 생성된 Pod를 적절한 workerNode에 배치하는 역할을 담당</li>
  <li>k8s는 Pod가 클러스터 내의 노드에서 실행되도록 해야하므로, 스케쥴러는 Pod가 요구하는 리소스와 각 노드 상태를 고려하여 배치함</li>
  <li>주요 역할
    <ul>
      <li>Pod 배치 결정</li>
      <li>노드 리소스 고려: CPU, 메모리, 네트워크, 디스크 용량 등을 종합적으로 고려</li>
      <li>애플리케이션 요구 사항 반영: Pod가 특정 zone이나  region에서 실행되어야 하는 경우 이를 반영</li>
    </ul>
  </li>
</ul>

<h4 id="4-클라우드-컨트롤러-매니저cloud-controller-manager">4. 클라우드 컨트롤러 매니저(Cloud Controller Manager)</h4>
<ul>
  <li>클라우드 컨트롤러 매니저는 kubernetes 클라우드 서비스 제공 업체 간의 통합을 담당하는 컴포넌트다.</li>
  <li>클러스터가 클라우드 환경에서 실행될 떄, 클라우드 리소스와 kubernetes 리소스 간의 상호 작용을 관리한다.</li>
  <li>주요 역할
    <ul>
      <li>클라우드 리소스 관리: kubernetes 클러스터 간 연결을 관리하며, 클라우드에서 제공하는 서비스</li>
      <li>클라우드 이벤트 처리: 클라우드에서 발생한느 이벤트를 Kubernetes에 전달하고, 이를 기반으로 클러스 상태를 업데이트</li>
      <li>클라우 기반 기능: 클라우드 환경에서 실행되는 kubernetes 클러스터가 클러스터 제공자의 네트워킹 및 스토리지와 같은 기능을 효과적으로 사용할 수 있도록 지원</li>
    </ul>
  </li>
</ul>

<h4 id="5-etcd">5. etcd</h4>
<ul>
  <li>etcd는 kubernetes의 key-value 저장소로, 클러스터 내 모든 상태와 메타데이터를 저장하는 역할을 한다.</li>
  <li>이 데이터는 클러스터의 싱글 소스 오브 트루스(Single Source of Truth)로 작동한다.</li>
  <li>주요 역할
    <ul>
      <li>클러스터 상태 저장 : etcd는 클러스터의 모든 상태 정보를 저장한다. Pod, Node, Service, 설정 정보를 포함한다.</li>
      <li>트랜잭션 처리 : etcd는 강력한 일관성을 보장하는 트랜잭션 기반의 데이터 저장소다. 모든 클러스터의 상태 변경은 etcd에 안전하게 기록된다.</li>
      <li>데이터 복제 및 고가용성: etcd는 데이터 복제 및 고가용성을 지원하여, 클러스터의 장애 발생 시에도 데이터 손실을 방지한다. 다수의 etcd 인스턴스를 통해 데이터를 분산 저장하고, 하나의 etcd 인스턴스가 실패해도 다른 이스턴스가 데이터를 제공</li>
    </ul>
  </li>
</ul>

<h3 id="worker-nodes">Worker Nodes</h3>
<ul>
  <li>워커 노드들은 실제로 애플리케이션 컨테이너가 실행되느 서버다.</li>
  <li>각 워커노드는 아래와 같은 컴포넌트를 포함
    <ul>
      <li>kubelet: 각 노드에서 실행되는 에이전트로, 마스터 노드의 지시를 받아 컨테이너가 Pod 내에서 올바르게 실행되도록 관리한다. 실행 중인 Pod의 상태를 정기적으로 모니터링해서 kube-scheduler에 통지</li>
      <li>kube-proxy: 네트워크 프록시 및 로드 밸런서 역할을 하는 컴포넌트, 노드의 네트워크 규칙을 관리하고, 연결 및 트래픽 라우팅을 처리</li>
      <li>컨테이너 런타임 : 컨테이너를 실행하기 위한 환경을 제공한다. (Docker, containerd, CRI-O 등)</li>
    </ul>
  </li>
  <li>추가 구성 요소
    <ul>
      <li>네트워크 : Pod 간 통신을 위해서 자체 네트워킹 모델을 제공한다. 각 Pod는 고유한 IP 주소를 가지며, Pod 간에는 플랫 네트워크에서 서로 통신할 수 있다.</li>
      <li>스토리지 : k8s는 볼륨을 사용하여 데이터를 저장한다. 로컬스토리지, 네트워크 스토리지(NFS, iSCSI 등)</li>
    </ul>
  </li>
</ul>

<h3 id="pod의-구성요소와-특징">Pod의 구성요소와 특징</h3>
<ol>
  <li>컨테이너
    <ul>
      <li>Pod하나 이상의 컨테이너를 포함할 수 있다. 이 컨테이너들은 동일한 UTS(UnixTimeSharing) 네임스페이스를 공유하며, 필요한 경우 IPC(Inter-process Communication)을 통해서 통신</li>
      <li>각 Pod는 주요 애플리케이션 컨테이너, 추가적 사이드카 컨테이너를 포함할 수 있다.</li>
      <li>사이드카 컨테이너는 로깅, 모니터링, 네트워크 프록시 등의 보조 기능을 제공한다.</li>
    </ul>
  </li>
  <li>공유 네트워크
    <ul>
      <li>모든 컨테이너는 동일한 IP주소와 포트 공간을 공유한다.</li>
      <li>이는 외부에서 접근할 때 마치 하나의 엔티티처럼 보이게 하고, 컨테이너 간의 통신을 로컬 호스트를 통해 가능하게 함</li>
    </ul>
  </li>
  <li>공유 스토리지 볼륨
    <ul>
      <li>Pod는 하나 이상의 볼륨을 정의할 수 있다. 이 볼륨은 Pod내 컨테이너들 사이에 공유되어 파일 시스템을 통한 공유를 용이하게 한다.</li>
      <li>k8s는 다양한 유형의 볼륨을 지원하며, 이는 Pod가 스토리지에 종속되지 않고, 어떤 노드든 동일하게 작동할 수 있도록 한다.</li>
    </ul>
  </li>
  <li>생명주기와 관리
    <ul>
      <li>Pod 불변성을 가지며, 한 번 생성되면 그 내부의 컨테이너를 변경할 수 없다.</li>
      <li>컨테이너 업데이트를 위해서는 Pod를 새로 지우고 생성하는 방식으로 처리</li>
      <li>Pod는 일반적으로 replication을 통해서 고가용성을 보장받는다.</li>
      <li>쿠버네티스는 Pod의 상태를 모니터링하고, 실패한 Pod를 자동으로 대체하는 복제 컨트롤러와 ReplicaSet을 사용하여 관리</li>
    </ul>
  </li>
</ol>

<h3 id="pod의-replication">Pod의 Replication</h3>
<ul>
  <li>k8s는 Pod 상태를 지속적으로 모니터링하고 replication을 관리하기 위해서 ReplicaSet과 같은 컨트롤러를 사용한다.</li>
  <li>현재 상태(CurrentState)와 원하는 상태(DesiredState)를 비교하여 문제가 생기면 새로운 Pod를 자동으로 생성하거나 대체한다.</li>
  <li>현재 상태 모니터링은 컨트롤 플레인(ControlPlane)에 속한 컨트롤러 매니저가 수행한다.</li>
  <li>이 상태를 바탕으로 현재 상태를 결정한다. Pod의 실행 여부, 리소스 사용량, 상태 등이 포함된다.</li>
</ul>

<h3 id="replicaset복제-컨트롤러의-동작">ReplicaSet/복제 컨트롤러의 동작</h3>
<ul>
  <li>ReplicaSet이나 복제 컨트롤러는 Pod의 수를 관리하며, 원하는 개수만큼 Pod가 항상 실행되도록 보장
    <ul>
      <li>Pod 장애 탐지</li>
      <li>Pod 복제 및 대체</li>
    </ul>
  </li>
  <li>ReplicaSet은 클러스터에서 지정된 Pod 개수를 보장하기 위해서 필요한 경우 새로운 Pod를 자동으로 생성하고, 장애 발생 시 이를 대체</li>
</ul>

<h3 id="pod의-상태를-복제하는-방법">Pod의 상태를 복제하는 방법</h3>
<ul>
  <li>장애 Pod를 감지한 후, 해당 Pod가 사용하던 컨테이너 이미지, 환경 변수, 네트워크 성정 등 모든 설정 정보를 기반으로 새로운 Pod를 생성</li>
  <li>이 과정에서는 Pod는 template을 사용하여, 원래 Pod와 동일한 설정으로 새로운 Pod를 복제</li>
  <li>Pod 템플릿 Deployment 또는 ReplicaSet에 정의되어 있으며, Pod를 생성할 때 사용되는 모든 설정 정보가 포함되어 있다.</li>
</ul>

<h3 id="self-healing">Self-Healing</h3>
<ul>
  <li>쿠버티스의 self-healing 기능은 Pod의 상태를 지속적으로 체크하며, 장애가 발생했을 때 자동으로 복구한다.</li>
  <li>Pod가 정상적으로 실행되지 않거나 충돌이 발생하면, k8s는 이를 감지하고 새로운 Pod를 동일한 설정으로 생성해서 자동 복구를 수행</li>
  <li>이를 통해 무중단 서비스가 가능하고, 높은 가용성을 유지할 수 있다.</li>
</ul>

<h3 id="node-pod">Node, Pod</h3>
<ul>
  <li>노드 내 Pod는 독립적인 실행 환경을 제공받으며 노드의 리소스를 할당받아 사용</li>
</ul>

<h3 id="k8s-특징">k8s 특징</h3>
<ol>
  <li>Self-Healing : 실패한 컨테이너는 다시 시작하고 컨테이너를 교체하며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지는 않는다.</li>
  <li>Auto-Scaling
    <ul>
      <li>HorizontalPodAutoscaler(HPA) : CPU 등의 메트릭을 바탕으로 Pod 인스턴스 수를 자동으로 스케일아웃</li>
      <li>ClusterAutoScaler: k8s의 클러스ㅓ 오토스케일러는 클러스터 내에서 노드의 수를 동적으로 조정하여 Pod의 수요에 따라 클러스터의 리소스를 최적화하는 역할을 함. 클러스터 크기를 자동으로 확장하거나 축소하는 과정이 포함된다.</li>
    </ul>
  </li>
</ol>
</section>
  

</article>

<!-- Disqus -->


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>이전 글</p>
      <a href="/docker/wanted/2024/10/08/Wanted-Docker-series-08.HighAvailbility.html">
        [wanted Docker Series] 08.highavailbility
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>다음 글</p>
      <a href="/docker/wanted/2024/10/10/Wanted-Docker-series-10.KubernetesResources.html">
        [wanted Docker Series] 10.kubernetesresources
      </a>
  </div>
  
</div>



    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
