<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>newkayak12.github.io</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>https://github.com/newkayak12/newkayak12.github.io/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Sun, 16 Jun 2024 13:43:32 +0900</pubDate>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/16/Effective-java-series-63.Exception.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/16/Effective-java-series-63.Exception.html</guid>
        <description>&lt;h1 id=&quot;되도록-표준-예외를-사용하자--추상화-수준에-맞는-예외를-던지자-예외-상세-메시지에-실패-관련-정보를-담자&quot;&gt;되도록 표준 예외를 사용하자 &amp;amp; 추상화 수준에 맞는 예외를 던지자&amp;amp; 예외 상세 메시지에 실패 관련 정보를 담자.&lt;/h1&gt;

&lt;h2 id=&quot;되도록-표준-예외를-사용하자&quot;&gt;되도록 표준 예외를 사용하자&lt;/h2&gt;

&lt;p&gt;표준 예외를 재사용하면 얻는게 많다. 이미 프로그래머들에게 익숙한 예외를 사용하기 떄문이다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IllegalStateException&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt; 등이 있다.&lt;/p&gt;

&lt;h2 id=&quot;추상화-수준에-맞는-예외를-던지자&quot;&gt;추상화 수준에 맞는 예외를 던지자&lt;/h2&gt;

&lt;p&gt;수행하려는 일과 관련이 없어 보이는 예외가 나오면 당황스러울 것이다. 저수준 예외를 처리하지 않고 바깥으로 전파하면 일어나는 일 이다.
이는 내부 구현을 외부로 노출시키는 일이다. 또한 내부 구현과 사용을 결합시키게 되는 일이 된다. 따라서 다음 릴리즈에서 바꾸면
다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수 있다.&lt;/p&gt;

&lt;p&gt;차라리 이 때는 예외를 번역해서 던지자 예외 번역이란 저수준 예외를 받아서 고수준 예외로 다시 던지는 것을 의미한다.
예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exceptionChaining)를 사용하는게 좋다.&lt;/p&gt;

&lt;p&gt;예외 연쇄란 문제의 근본 원인 저수준 예외를 고수준 예외에 실어보내는 것이다. 무턱대로 예외를 전파하는 것보다 좋은 방법이지만 그렇다고 남용하면 안된다.&lt;/p&gt;

&lt;h2 id=&quot;예외-상세-메시지에-실패-관련-정보를-담자&quot;&gt;예외 상세 메시지에 실패 관련 정보를 담자.&lt;/h2&gt;

&lt;p&gt;예외는 stack trace를 자동 캡쳐 출력한다. 예외 분석을 위한 초석이 된다. 관련 데이터를 모두 담아야 하지만 꼭 장황할 필요는 없다. 문제를 분석하는 사람은 
소스코드도 함께 보기 때문이다.&lt;/p&gt;

&lt;p&gt;예외를 최종 클라이언트에게 보여줄 메시지로 생각하면 안 된다. 최종 사용자에게는 훨씬 더 의미있는 메시지가 중요하다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/16/Effective-java-series-62.CheckedUncheckedException.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/16/Effective-java-series-62.CheckedUncheckedException.html</guid>
        <description>&lt;h1 id=&quot;복구할-수-있는-상황에는-검사-예외를-프로그래밍-오류에는-런타임-예외를&quot;&gt;복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를&lt;/h1&gt;

&lt;p&gt;호출하는 쪽에서 복구하리라 여겨지면 checkedException 을 던져서 구현자에게 회복을 요구할 수 있다. uncheckedException은 런타임/ 에러 가 있다. 
프로그래밍 오류는 runtimeException을 사용하면 된다. 대부분은 전제조건을 만족하지 못했을 때 사용한다. 에러는 JVM이 자원부족, 불변식 깨짐 등 더 이상 수행을
계속할 수 없는 상황을 의미한다. 따라서 에러는 직접 구현할 일이 거의 없다. 대부분의 상황에서 개발자들은 uncheckedException으로 runtimeException을
서브클래싱할 가능성이 높다.&lt;/p&gt;

&lt;p&gt;여기서 고민이 될거다. checkedException을 자주 사용하느게 좋은가? 검사 예외는 문제를 처리하게 해서 안정성을 높이게끔 해준다. 그런데 이 오류들이 쌓이면
피곤해진다. 다 처리해야하기 때문이다. 이를 회피하기 가장 쉬운 방법은 옵셔널을 반환하는 것이다. 차라리 빈 옵셔널을 반환하는게 좋다. 
물론 이 방법도 왜 예외가 발생한지 모르기 때문에 구체적 예외 타입 등을 알 수 없다.&lt;/p&gt;

&lt;p&gt;결론적으로 최대한 코드 내부에서 처리하되 옵셔널/ 에러 던지기를 잘 조절해서 던지는게 좋다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/16/Effective-java-series-61.ConsiderException.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/16/Effective-java-series-61.ConsiderException.html</guid>
        <description>&lt;h1 id=&quot;예외는-진짜-예외에만-사용하자&quot;&gt;예외는 진짜 예외에만 사용하자&lt;/h1&gt;

&lt;p&gt;예를 들어 for-loop을 exception으로 종료한다고 해보자. 나중에 보면 정상 종료를 위한 exception을 낸건지 진짜 에러인지 구분이 안 갈거다. 또한 
예외는 예외 상황에 쓸 용도로 설계됐으므로 JVM에서 최적화 대상이 아니다. 코드를 try-catch 블록 안에 넣으면 JVM이 할 수 있는 최적화가 제한된다.
이런 패널티를 받으면서 굳이 exception으로 비즈니스 로직을 사용해야 하는지는 의문이다.&lt;/p&gt;

&lt;p&gt;예외는 그냥 예외로만 사용하는 게 좋다. 제어 흐름용으로 사용하는 건 넌센스다. 그럼 exception 없이 제어하려면 어떻게 하면 될까? 단순하다. 상태 검사 로직을
넣으면 된다. 그것도 애매하면 옵셔널을 사용할 수도 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;외부 동기화 없이 멀티쓰레드를 사용한다면, 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.&lt;/li&gt;
  &lt;li&gt;성능이 중요한 상황에서 메소드가 상태 의존적 메소드 작업 일부를 중복 수행하면 옵셔널, 특정 값을 사용&lt;/li&gt;
  &lt;li&gt;이외에는 상태 검사가 나을 수 있다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 16 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-60.Optimize.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-60.Optimize.html</guid>
        <description>&lt;h1 id=&quot;최적화는-신중히--컨벤션을-따르자&quot;&gt;최적화는 신중히 &amp;amp; 컨벤션을 따르자.&lt;/h1&gt;

&lt;h2 id=&quot;최적화는-신중히&quot;&gt;최적화는 신중히&lt;/h2&gt;

&lt;p&gt;성능 떄문에 견고한 구조를 희생하지는 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라. 고민 해볼만한 문구다. 이 말은 완성하기 전에는 성능을 무시하라는 말이 아니다.
구현상 문제는 여러 변 다듬어 최적화할 수 있지만 이키텍쳐는 수정하기가 어렵다. 따라서 설계부터 탄탄해야한다는 의미와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;성능을 제한하는 설계를 피하라.&lt;/li&gt;
  &lt;li&gt;API 설계시 성능에 주는 영향을 고려하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 정도를 고민해보면 될 것 같다. 보통 잘 설계하면 성능이 잘 나온다. 그러니 이미 망친 설계에서 좋은 성능을 위해 노력하는 건 앞 뒤가 맞지 않는다.
만약 해야만 한다면 프로파일링 도구에 도움을 받는 것도 좋다.&lt;/p&gt;

&lt;h2 id=&quot;컨벤션을-따르자&quot;&gt;컨벤션을 따르자.&lt;/h2&gt;

&lt;p&gt;자바는 컨벤션이 잘 정립됐다. 그리고 언어 명세에도 기술되어 있다. 이 규칙들은 특별한 이유가 없는 한 반드시 따라야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;역도메인을 패키지 이름으로 하는 것&lt;/li&gt;
  &lt;li&gt;각 요소는 8자 이하의 짧은 단어로 축약 (utilities 보다는 utils)&lt;/li&gt;
  &lt;li&gt;클래스, 인터페이스 일므은 하나 이상의 단어 조합으로, upper camel case&lt;/li&gt;
  &lt;li&gt;메소드 필드명은 lower camel case&lt;/li&gt;
  &lt;li&gt;상수는 upper case&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그외 get, set으로 시작하는 형태는 javaBeans 명세에 뿌리를 두고 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-59.Native.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-59.Native.html</guid>
        <description>&lt;h1 id=&quot;네이티브-메소드는-신중히-사용하라&quot;&gt;네이티브 메소드는 신중히 사용하라&lt;/h1&gt;

&lt;p&gt;자바 네이티브 인터페이스( Java Native Interface, JNI )는 자바 프로그램이 네이티브 메소드를 호출하는 기술이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;레지스트리 같은 플랫폼 특화 기능을 사용한다.&lt;/li&gt;
  &lt;li&gt;네이티브 코드로 작성된 기존 라이브러리를 사용한다.&lt;/li&gt;
  &lt;li&gt;성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;플랫폼 특화 기능을 활용하려면 네이티브 메소드를 사용해야 한다. 자바가 성숙해지면서 점차 네이티브 메소드를 사용할 일이 줄어든다. 그 예시가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process api&lt;/code&gt;다.
그러나 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다. 이미 자바가 성숙됐다.&lt;/p&gt;

&lt;p&gt;또한 네이티브 메소드에는 심각한 단점이 있다. 네이티브 언어가 안전하지 않으므로 네이티브 메소드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다.
뿐만 아니라 CG 관장 영역이 아니므로 메모리를 자동으로 회수하거나 추적조차 불가하다. 마지막으로 네이티브 - 자바 간 접착 코드(glueCode)가 필요한데 번거로운 작업이다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-58.UseInterfaceAsType.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-58.UseInterfaceAsType.html</guid>
        <description>&lt;h1 id=&quot;객체는-인터페이스를-사용해서-참조하자--리플렉션&quot;&gt;객체는 인터페이스를 사용해서 참조하자. &amp;amp; 리플렉션?&lt;/h1&gt;

&lt;h2 id=&quot;객체는-인터페이스를-사용해서-참조하자&quot;&gt;객체는 인터페이스를 사용해서 참조하자.&lt;/h2&gt;

&lt;p&gt;인터페이스를 구현하고 인터페이스를 타입으로 사용할 수 있다. 이렇게 인터페이스를 타입으로 사용하면 매개변수로서, 반환 값으로서, 변수, 필드로서 유연성을 갖게 된다.
단, 인터페이스 규약 이외 기능을 제공하고, 코드가 이에 기대서 작동한다면 일관성이 무너져 코드가 실패할 가능성이 있다. 그럴 경우 해당 기능을 인터페이스에 
기입하여, 필수 구현 항목으로 지정하는 것이 나을 수 있다.&lt;/p&gt;

&lt;p&gt;물론 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다. 혹은 클래스 기반으로 작성됐다면 어쩔 수 없다. 마지막으로 특정 클래스에 국한되어 특별한 기능을
제공한다면 인터페이스 타입을 포기할 수밖에 없다. 적합한 인터페이스가 없다면 클래스 계층 구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하는게 좋다.&lt;/p&gt;

&lt;h2 id=&quot;리플렉션&quot;&gt;리플렉션?&lt;/h2&gt;

&lt;p&gt;리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.&lt;/li&gt;
  &lt;li&gt;리플렉션을 이용하면 코드가 지저분하고 장황해진다.&lt;/li&gt;
  &lt;li&gt;성능이 떨어진다. (처음에만 느리다고들 한다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;물론 리플렉션을 아주 제한된 형태로만 사용해야 장점만 취할 수 있다. 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해서 사용하자.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-57.BoxingIsHeavy.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-57.BoxingIsHeavy.html</guid>
        <description>&lt;h1 id=&quot;박싱은-무겁다-기본-타입을-사용하자--충족되는-타입이-있다면-문자열은-피하자&quot;&gt;박싱은 무겁다. 기본 타입을 사용하자. &amp;amp; 충족되는 타입이 있다면 문자열은 피하자.&lt;/h1&gt;

&lt;h2 id=&quot;박싱은-무겁다-기본-타입을-사용하자&quot;&gt;박싱은 무겁다. 기본 타입을 사용하자.&lt;/h2&gt;

&lt;p&gt;기본 타입과 박싱된 타입의 차이는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;기본 타입은 값만 가지고 있으나 박싱 타입은 식별성을 갖는다.&lt;/li&gt;
  &lt;li&gt;기본 타입은 언제나 유효하지만 박싱 타입을 null을 가질 수 있다.&lt;/li&gt;
  &lt;li&gt;기본 타입이 박싱 타입보다 시간, 메모리 사용면에서 더 효율적이다.&lt;/li&gt;
  &lt;li&gt;기본 타입은 동등 연산자로 비교가 가능하지만 박싱은 기본타입으로 바꿔서 비교해야 한다. ( 기본/ 박싱을 비교하면 자동으로 박싱이 풀린다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 이유로 식별성을 갖거나 제네릭으로 사용하거나 null을 식별값으로 가져야만 한다면 사용을 고려해봄직 하다. 마지막으로 리플렉션을 통해 메소드를 호출할 때도 박싱된 타입을
사용해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;충족되는-타입이-있다면-문자열은-피하자&quot;&gt;충족되는 타입이 있다면 문자열은 피하자.&lt;/h2&gt;

&lt;p&gt;문자열은 문자열이다. 다른 값을 표현하기 위한 수단으로는 부적합하다. 또한 혼합 타입을 대신하기에도 적절하지 않다. 정말 해당 타입인지, 값이 맞는지 파싱하고 검증하고
굉장히 손이 많이 간다. 당연히 오류 가능성도 커진다.&lt;/p&gt;

&lt;h1 id=&quot;문자열-연결----은-피하자&quot;&gt;문자열 연결 (“” + “”) 은 피하자.&lt;/h1&gt;

&lt;p&gt;문자열 역시 + 연산자로 합칠 수 있다. 굉장히 편리하다. 문자열은 값 타입이 아니다. 문자열 연결을 본격적으로 사용하면 성능 저하를 면치 못할 것이다. 문자열 연결 
연산자로 n개를 이으면 n^2에 비례햔다. 앞서 말한 듯 값 타입이 아니라 양 쪽 내용을 복사해서 새롭게 만들어야 한다. 차라리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuffer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;를 사용하자.&lt;/p&gt;

&lt;p&gt;추가로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringTokenizer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String.split()&lt;/code&gt;으로 문자열을 분할할 수도 있다. 이는 상황에 따라 속도가 다른데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringTokenizer&lt;/code&gt;가 빠른 경우는&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Delimiter가 하나라면 Tokenizer&lt;/li&gt;
  &lt;li&gt;Delimiter가 ascii 값이라면&lt;/li&gt;
  &lt;li&gt;순회하는게 아니라면&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;의 경우가 있다. 보통 tokenizer가 빠르다. split이 내부에서 정규 표현식을 사용해서 처리하기 떄문이다. 그러나&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Delimiter가 여러 개면 내부에서 여러 번 스캐닝 작업을 한다.&lt;/li&gt;
  &lt;li&gt;유니코드라면 색인이 느리다.&lt;/li&gt;
  &lt;li&gt;hasMoreToken, nextToken을 호출하면 그 때마다 풀 스캔을 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;는 특징으로 tokenizer가 빠를 때도 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-56.FloatingPoint.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-56.FloatingPoint.html</guid>
        <description>&lt;h1 id=&quot;부동-소수점-이슈&quot;&gt;부동 소수점 이슈&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://newkayak12.github.io/java/2024/05/18/java-series-22-FloatingPoint.html&quot;&gt;blog&lt;/a&gt;에서 다룬 바와 같이 부동소수 계산에는 정밀도가 
떨어진다는 문제가 있다. 그래서 소수점이 있는 금융 계산에 치명적이다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt;을 사용해야 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-55.EnhancedFor.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-55.EnhancedFor.html</guid>
        <description>&lt;h1 id=&quot;for-each&quot;&gt;For-Each&lt;/h1&gt;

&lt;p&gt;for가 while보다 낫지만 그래도 너무 지저분하다. for-each(enhanced for statement)을 쓰면 인덱스를 위한 변수와 이를 증감 시키는 코드를 작성하지 않아도
해당 반복자의 요소를 모두 순회할 수 있다.&lt;/p&gt;

&lt;p&gt;단, 몇 가지 상황에서 사용하지 못할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파괴적 필터링(destructive filtering) : 컬렉션/배열을 순회하면서 선택 원소를 제거한다면 인덱스의 변화가 생길 수 있다.&lt;/li&gt;
  &lt;li&gt;변형(transforming) : 리스트/배열에 인덱스로 접근해서 요소를 수행해야 한다면 인덱스가 필요해서 사용하지 못할 수 있다.&lt;/li&gt;
  &lt;li&gt;병렬 반복 : 여러 컬렉션/배열을 병렬로 순회해야 한다면 인덱스로 조절하는게 쉬울 수도 있다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-54.LocalVariable.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-54.LocalVariable.html</guid>
        <description>&lt;h1 id=&quot;지역변수-범위-최소화&quot;&gt;지역변수 범위 최소화&lt;/h1&gt;

&lt;p&gt;지역 변수 범위를 줄이는 기법은 ‘가장 처음에 쓸 때 선언하기’가 있다. 그러나 미리 선언하면 코드가 어수선해지 쉽상이다. 또한 너무 고민 없이 선언하면 변수가 쓰이는
범위보다 너무 앞서 선언하게 되거나, 다 쓴 뒤에도 살아있게 될 수 있다. 또한, 지역변수는 대부분 선언과 동시에 초기화를 해야하는데 초기화 정보가 모자라도 선언을 하는
일을 맞닥뜨리게 될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;while-vs-for&quot;&gt;while vs for&lt;/h2&gt;
&lt;p&gt;for가 낫다. while은 안에서 사용하는 변수를 바깥에서 선언해야할 때가 있다. 그러면 그 이름의 변수를 다른 의미로 아래에서 또 사용해야 한다면?
실수하기 쉽다. for는 for 블록에서 선언하므로 크게 문제가 되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{...}&lt;/span&gt;


&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{...}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//이러면 안돌고 지나간다.&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메소드를-잘게-쪼개기&quot;&gt;메소드를 잘게 쪼개기&lt;/h2&gt;
&lt;p&gt;메소드를 기능 단위로 단일 책임을 지우면 그게 최고다. 또한 이러면 메소드 단위가 작아져 지역 범위를 최소화할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-53.Optional.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-53.Optional.html</guid>
        <description>&lt;h1 id=&quot;옵셔널-반환은-신중히&quot;&gt;옵셔널 반환은 신중히&lt;/h1&gt;

&lt;p&gt;옵셔널이 나오기 전, 예외를 던지거나 null을 반환하거나 했다. 그러나 이는 에외를 예외답게 사용하지 않는다는 점과 stackTrace 캡쳐에 리소스가 크게 든다는 점
NPE에 시달려야 한다는 점 불편한 점이 많았다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt;은 자바 8에 추가 됐다. Optional은 원소 1개를 최대로 가지는 불변 컬렉션이다. Optional에서는 null이면 에러를 던질 수도, 기본 값을 할당할 수도 있다.
NPE에서 비교적 자유로워진다. 예외검사와 NullCheck를 모두 겸할 수 있다. 굉장히 편리하지만 무조건 좋은건 아니다.&lt;/p&gt;

&lt;p&gt;Collection, Stream, Array 같은 컨테이너 타입은 Optional로 감싸면 원타입도 무거운데 optional로 감싸서 리소스가 너무 많이 든다. 박싱 타입도 같은 이유로
지양하면 좋다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalInt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalLong&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalDouble&lt;/code&gt;을 제공한다. 기본 타입으로 말이다. 또한 Optional를 컬렉션 키로 하는 것도 지양하자.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-52.IfNullReturnArray.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-52.IfNullReturnArray.html</guid>
        <description>&lt;h1 id=&quot;null-대신-빈-컬렉션이나-배열을-반환하자&quot;&gt;null 대신 빈 컬렉션이나 배열을 반환하자&lt;/h1&gt;

&lt;p&gt;컨테이너(배열, 컬렉션)이 비었을 때 선택지는 null, 빈 컨테이너 둘 중 하나다. null을 값으로 생각하면 null을 리턴할 수도 있다. 그러나 NPE 등 고려할 것들이
많아진다. 혹자는 빈 컨테이너 생성도 리소스라고 할지 모른다. 그러나 오히려 방어 로직이 훨씬 골치아픈 일이 될 수도 있다. 결론적으로 말하면 그렇고 하나씩 따져보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;빈 컨테이너 생성? 성능에 큰 영향이 가지 않는다. : 이 정도 리소스 할당은 전혀 문제가 되지 않는 정도의 컴퓨팅 성능을 보인다.&lt;/li&gt;
  &lt;li&gt;빈 컨테이너를 그냥 반환하면 된다. : 빈 컨테이너를 확인하고 null을 반환하는 것보다 훨씬 간편하고 의미적으로도 맞다.&lt;/li&gt;
  &lt;li&gt;정말로 신경쓰이면 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptyList()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptyMap()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptySet()&lt;/code&gt;을 반환하는 방법이 있다. 배열도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new int[0]&lt;/code&gt;을 반환하면 된다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-51.ReallyUseVarArgs.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-51.ReallyUseVarArgs.html</guid>
        <description>&lt;h1 id=&quot;가변인수는-신중히&quot;&gt;가변인수는 신중히&lt;/h1&gt;

&lt;p&gt;가변 인수를 호출하면 인수 개수와 길이가 같은 배열을 만들도 배열에 저장해서 가변인수 메소드에 건낸다. 인수 개수는 런타임에 알 수 있다. 이런 불확실성은 왠지 모르게
불편해지는 부분이다. 더군다나 인수가 1개 이상 필요한데, 가변 인수를 안 넘기면? 원소가 0인 배열이 만들어지고 이를 위한 방어 로직을 짜야한다.&lt;/p&gt;

&lt;p&gt;이 경우 꼭 필요한 원소는 파라미터로 선언하고 그 다음부터 가변인수로 만들면?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//이거 대신&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//이렇게 바꾸면?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;성능적으로 보면? 권장하지 않는다. 이 비용은 감당하기 싫으면서 유연성이 필요하다면?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;스프링에 있는 Jooq가 이런식으로 구현해놓은 경우가 있다. 이러면 마지막 케이스는 정말 극소수가 될거다. 자연스레 비용이 준다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-50.ConsiderOverload.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-50.ConsiderOverload.html</guid>
        <description>&lt;h1 id=&quot;다중-정의는-신중히&quot;&gt;다중 정의는 신중히&lt;/h1&gt;

&lt;p&gt;다중 정의된 메소드는 컴파일 타임에 정해진다. 그런데! 매개변수가 일전의 다중 정의 매개변수들을 모두 포함할 수 있는 
다중정의라면? 해당 메소드 외는 호출될 가능성이 없다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 파라미터가 Collection&amp;lt;?&amp;gt;인 메소드만 열심히 호출된다. 다중정의한 메소드는 객체 런타임 타입은 중요하지 않다. 오로지 컴파일 타임에,
오직 매개변수의 컴파일 타입에 의해 결정된다. 다중 정의는 혼동을 일으킬 여지가 있는 방식이다. 안전하게 하려면 매개변수 수가 같은 다중정의는 지양하는 것이 좋다.
더구나 가변인수를 사용하는 메소드는 아예 꿈도 꾸지 않는게 좋다. 차라리 이름을 다르게 짓는게 낫다.&lt;/p&gt;

&lt;p&gt;가장 좋은 방법은 위의 여지가 없는 아예 명확히 구분되는 형식으로 다중정의하는 것이 최고다. 다중 정의의 실효성이야 확실하니 말이다.
예를 들어&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;의 경우에서 remove는 (Object o), (int index)가 있다. 여기서&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;던지면&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;둘&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;중&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;어떤걸&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;실행할까&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boxing된&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다중 정의의 최상의 결과는 언제 어떤 메소드가 불리는지는 모르는데 아주 명확히 잘 작동하는 경우다. 신경 쓸 게 없는 경우말이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-49.MethodSignature.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-49.MethodSignature.html</guid>
        <description>&lt;h1 id=&quot;메소드-시그니처를-신중히-설계하자&quot;&gt;메소드 시그니처를 신중히 설계하자.&lt;/h1&gt;

&lt;p&gt;고민할 점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메소드 이름을 신중히 짓자.&lt;/li&gt;
  &lt;li&gt;편의 메소드를 너무 많이 만들지 말자.&lt;/li&gt;
  &lt;li&gt;매개변수는 구성을 고민하자. 매개변수는 최대 4개 정도가 좋다. 특히 같은 타입이 연달아 나오면 문제가 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3번은 아래와 같은 기술로 헤쳐나갈 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메소드를 쪼개거나&lt;/li&gt;
  &lt;li&gt;매개변수를 묶는 컨테이너 클래스를 만들거나&lt;/li&gt;
  &lt;li&gt;1 + 2의 빌더 패턴을 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여담으로 매개변수 타입은 클래스보다 인터페이스가 나을 수 있다. 그러면 유연성이 올라간다. 또한 단순 boolean 보다는 직관성을 위해서 Enum 두 개가 나을 수도 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
