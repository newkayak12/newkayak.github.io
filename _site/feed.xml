<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>newkayak12.github.io</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Sun, 27 Oct 2024 17:33:13 +0900</pubDate>
    
      <item>
        <title>[docker Series] 18.servicemesh</title>
        <link>/docker/wanted/2024/10/27/Docker-series-18.ServiceMesh.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/27/Docker-series-18.ServiceMesh.html</guid>
        <description>&lt;h1 id=&quot;servicemesh&quot;&gt;ServiceMesh&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Mesh, 서비스들이 서로 그물처럼 엮여 있다는 의미다.&lt;/li&gt;
  &lt;li&gt;MSA를 적용한 시스템의 내부 통신이 Mesh Network의 형태를 띠는 것에 빗대어 명명됐다.&lt;/li&gt;
  &lt;li&gt;Istio처럼 애플리케이션의 다양한 부분들이 서로 데이터를 공유하는 방식을 제어하는 방법&lt;/li&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Istio가 서비스 메시를 구현할 수 있는 대표적 오픈소스 솔루션이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터와 일관성을 공유하며 서로 통신할 수 있도록 지원하는 사전 구성된 애플리케이션 서비스&lt;/li&gt;
  &lt;li&gt;애플리케이션에 구축된 전용 인프라 계층이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쉽게 설정하고 배포할 수 있도록 설계된 서비스 메시는 MicroService에서 새로운 서비스를 쉽게 발견하고 관리할 수 있게 되어 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;k8s에선 서비스 메시는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sideCar&lt;/code&gt;를 이용한 확장 가능한 네트워크 프록시 모듈로 구현된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/img/mesh.png&quot; alt=&quot;mesh.png&quot; /&gt;
&lt;a href=&quot;https://www.tibco.com/ko/reference-center/what-is-a-service-mesh&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MSA에서는 시간이 지나고 크기가 커지면 서비스 간 통신 복잡성이 급격하게 증가한다.&lt;/li&gt;
  &lt;li&gt;마이크로서비스의 설정, 관리, 통신 방식에 대한 제어가 필요하며, 마이크로서비스마다 추가되어야 할 공통 기능이 증가한다.&lt;/li&gt;
  &lt;li&gt;이러한 관리 포인트 증가에 대한 문제를 해결하기 위한 방법 중 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceMesh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;사이드카-패턴&quot;&gt;사이드카 패턴&lt;/h2&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/img/sideCar.png&quot; alt=&quot;sideCar.png&quot; /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;pod 내 애플리케이션 컨테이너와 독립적으로 동작하는 컨테이너&lt;/li&gt;
    &lt;li&gt;애플리케이션을 도와주는 역할을 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사이드카 프록시를 모아서 메시 네트워크를 형성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-기능&quot;&gt;주요 기능&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ServiceDiscovery
    &lt;ul&gt;
      &lt;li&gt;검색 계층을 통한 서비스 검색&lt;/li&gt;
      &lt;li&gt;서비스 이름만으로 다른 서비스가 참조 가능(DNS를 통해서)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LoadBalancing
    &lt;ul&gt;
      &lt;li&gt;Replication 설정에서 복제본으로 부하 분산&lt;/li&gt;
      &lt;li&gt;RR(RoundRobin), WRR(Weighted Round Robin), LRR(Least Round Robin) 등과 같은 세밀한 부하 분산 기능 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RequestRouting
    &lt;ul&gt;
      &lt;li&gt;정교한 라우팅 지원&lt;/li&gt;
      &lt;li&gt;A/B, Canary 등 구현할 때 정교한 라우팅 활용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HealthCheck/RetryPolicy
    &lt;ul&gt;
      &lt;li&gt;일시적 과부화, 네트워크 일시 단절 등으로 장애가 전파되는 것 방지&lt;/li&gt;
      &lt;li&gt;주기적인 HealthCheck로 서비스 가용성 및 애플리케이션 성능 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CircuitBreaker
    &lt;ul&gt;
      &lt;li&gt;복잡한 통신 시나리오에 대한 내결함성 시나리오 처리 기능&lt;/li&gt;
      &lt;li&gt;서비스 간 호출 시 단계적 호출 시나리오에서 발생 가능한 오류에 대해서 차단할 수 있는 기능 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TLS
    &lt;ul&gt;
      &lt;li&gt;암호화를 한 번에 관리해서 서비스 복잡도를 낮출 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Observability
    &lt;ul&gt;
      &lt;li&gt;서비스 개수가 늘어남에 따라 각 서비스에서 발생하는 각종 지표들을 수집하고 분석할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;장점&quot;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;비즈니스, 내부 네트워크 컴포넌트를 분리해서 애플리케이션이 본연의 역할에 집중할 수 있도록 할 수 있다.&lt;/li&gt;
  &lt;li&gt;애플리케이션 외부에 구현하여 재사용 가능&lt;/li&gt;
  &lt;li&gt;마이크로 서비스의 런타임에 대한 복잡성 이슈를 해결할 수 있다.&lt;/li&gt;
  &lt;li&gt;애플리케이션 개발 시 미들웨어 종속성 제거&lt;/li&gt;
  &lt;li&gt;분산된 기능 관리를 중앙 집중화할 수 있다.&lt;/li&gt;
  &lt;li&gt;Proxy를 이용해서 인프라 복잡성 감소
    &lt;h2 id=&quot;단점&quot;&gt;단점&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;사이드카를 달아야 해서 인스턴스 수의 증가&lt;/li&gt;
  &lt;li&gt;서비스 통신 간 네트워크 홉이 증가해서 지연 시간이 생김&lt;/li&gt;
  &lt;li&gt;Proxy에 대한 디버깅 및 관리 이슈가 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vsgateway&quot;&gt;vs.Gateway&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;적용되는 위치가 다르다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;API Gateway는 중앙 집중식 제어 영역으로 외부에서 들어오는 트래픽 제어를 담당한다.&lt;/li&gt;
      &lt;li&gt;Service Mesh는 애플리케이션 기능을 인프라 계층에 의해서 관리되는 MicroService로 분리하는 방법이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;아키텍쳐가 다르다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;API Gateway는 SPOF(Single Point of Failure)를 생성한다.&lt;/li&gt;
      &lt;li&gt;Service Mesh는 SPOF를 생성하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패턴이 다르다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;API Gateway는 일반적으로 Gateway proxy pattern`을 사용&lt;/li&gt;
      &lt;li&gt;호출자는 구현 내용을 알 필요 없이 Gateway에 집중한다.&lt;/li&gt;
      &lt;li&gt;Service Mesh는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sidecar proxy pattern&lt;/code&gt;을 사용&lt;/li&gt;
      &lt;li&gt;호출자 코드는 Provider의 주소를 찾는 방법, failover와 관련된 코드 등에 대한 내용이 들어간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;주요 항목&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Service Mesh&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;API Gateway&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;목적&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MSA로 이식성을 개선하도록 설계&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;내/외부 액세스를 위한 API 호출까지도 라우팅 할 수 있도록 설계&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;복잡성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서비스 확장에 따른 복잡성 가중&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;하나의 엔드포인트로 API를 확장하여 서비스들을 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기술 성숙도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 신기술&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 성숙&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Sun, 27 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 17.scalablearchitecture</title>
        <link>/docker/wanted/2024/10/17/Wanted-Docker-series-17.ScalableArchitecture.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/17/Wanted-Docker-series-17.ScalableArchitecture.html</guid>
        <description>&lt;h1 id=&quot;스케일링을-고려한-아키텍쳐&quot;&gt;스케일링을 고려한 아키텍쳐&lt;/h1&gt;

&lt;h2 id=&quot;scaling&quot;&gt;Scaling&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;성능 저하 없이 더 많은 요청을 처리할 수 있도록 리소스를 확장하는 과정을 의미&lt;/li&gt;
  &lt;li&gt;데이터 처리량의 증가에 대비해 확장 가능한 아키텍쳐를 설계하는 것이 중요&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클라우드 네이티브의 장점으로 클라우드 네이티브 아키텍쳐는 마이크로 서비스, 컨테이너, 오토스케일링을 통해 자동으로 확장성을 제공한다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;수직: 스펙업&lt;/li&gt;
      &lt;li&gt;수평: 서버 개수 증가&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scaling을-고려한-시스템-아키텍처-설계-원칙&quot;&gt;Scaling을 고려한 시스템 아키텍처 설계 원칙&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;유연성: 확장 가능성을 고려한 모듈화된 아키텍쳐 설계가 필요하다.&lt;/li&gt;
  &lt;li&gt;복원력: 확장 과정에서 장애를 방지하고, 시스템이 자동으로 복구할 수 있도록 설계한다.&lt;/li&gt;
  &lt;li&gt;확장 가능한 데이터 관리: 데이터 일관성을 유지하면서 여러 서버 간에 데이터를 효율적으로 분산하는 방법을 고려&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;autoscaling-전략&quot;&gt;AutoScaling 전략&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;AWS Auto Scaling: EC2 인스턴스나 컨테이너 수를 트래픽 및 리소스 사용량에 따라 자동으로 조정&lt;/li&gt;
  &lt;li&gt;Kubernetes HPA(Horizontal Pod Autoscaler):
    &lt;ul&gt;
      &lt;li&gt;HPA는 Kubernetes에서 Pod의 수를 자동으로 조절하는 기능&lt;/li&gt;
      &lt;li&gt;클러스터 내에서 리소스 사용량에 따라 Pod의 수를 증가 또는 감소시켜 애플리케이션 성능을 유지
        &lt;blockquote&gt;
          &lt;h3 id=&quot;고려-사항&quot;&gt;고려 사항&lt;/h3&gt;
          &lt;ul&gt;
            &lt;li&gt;임계값 설정: 자원을 확장하는 기준이 되는 메트릭의 임계 값을 적절하게 설정해야 한다.&lt;/li&gt;
            &lt;li&gt;트리거: 스케일링 유발 트리거를 설정해야 한다.&lt;/li&gt;
            &lt;li&gt;자동화와 모니터링: 자동으로 확장되도록 설정했더라도, 시스템이 예상대로 작동하는지 모니터링이 필요&lt;/li&gt;
            &lt;li&gt;비용 관리: 오토스케일링은 편리하지만 과도한 리소스 확장은 비용 문제로 돌아올 수 있다.&lt;/li&gt;
            &lt;li&gt;오토스케일링을 통한 비용 최적화 전략
              &lt;ul&gt;
                &lt;li&gt;온디맨드 리소스와 리저브드 인스턴스를 혼합&lt;/li&gt;
                &lt;li&gt;자동화 도구로 피크/ 비피크 시간대를 고려한 스케쥴링&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;로드밸런싱&quot;&gt;로드밸런싱&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;대규모 트래픽이 발생할 때 서버 하나가 감당할 수 없는 부하가 생기지 않도록 트래픽을 여러 서버에 분산시켜 성능을 최적화한다.&lt;/li&gt;
  &lt;li&gt;여러 서버에 분산해서 안정성, 성능을 유지시키는 중요 기술&lt;/li&gt;
  &lt;li&gt;트래픽 집중을 방지하고 장애 시에도 트래픽을 다른 서버로 자동 분산할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;elbaws-elastic-load-balancer&quot;&gt;ELB(AWS Elastic Load Balancer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AWS 네트워크 계층에서 동작하는 로드 밸런서&lt;/li&gt;
  &lt;li&gt;여러 EC2 인스턴스에 트래픽을 균등하게 분산&lt;/li&gt;
  &lt;li&gt;모든 네트워크 트래픽을 분산시키며, 네트워크 레벨에서 작동&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;albapplication-load-balancer&quot;&gt;ALB(Application Load Balancer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ALB는 애플리케이션 계층에서 동작하는 로드밸런서&lt;/li&gt;
  &lt;li&gt;주로 HTTP, HTTPS 트래픽을 처리&lt;/li&gt;
  &lt;li&gt;경로기반, 호스트 기반 라우팅으로 특정 트래픽을 특정 애플리케이션으로 정확하게 분배&lt;/li&gt;
  &lt;li&gt;Websocket 지원 등 애플리케이션 레벨의 추가 기능을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;elb-vs-alb&quot;&gt;ELB vs. ALB&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;ELB는 네트워크 계층에서 모든 트래픽을 분산&lt;/li&gt;
    &lt;li&gt;ALB는 애플리케이션 계층에서 HTTP/HTTPS를 주로 처리&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;안정성을-유지하는-방법&quot;&gt;안정성을 유지하는 방법&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;세션 유지&lt;/li&gt;
    &lt;li&gt;성능 모니터링&lt;/li&gt;
    &lt;li&gt;다중 리전 로드 밸런식&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;네트워크-최적화-트래픽-분산-시-추가-고려-사항&quot;&gt;네트워크 최적화, 트래픽 분산 시 추가 고려 사항&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;지리적 분산: CDN 등과 함께 사용&lt;/li&gt;
    &lt;li&gt;로드밸런서 상태 체크: 서버 상태를 주기적으로 확인해서 비정상 서버로 트래픽이 라우팅되지 않도록 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;캐싱-전략&quot;&gt;캐싱 전략&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐싱은 데이터, 계산 결과를 미리 저장해 두었다가 나중에 동일한 요청이 들어올 때 빠르게 응답하기 위한 기술&lt;/li&gt;
  &lt;li&gt;캐싱 전략을 사용하면 응답속도를 향상시킬 수 있으며, API 응답이나 반복적인 데이터 조회에 유용
    &lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;REDIS&lt;/li&gt;
  &lt;li&gt;Memcached&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인기있는-캐싱-전략-및-데이터-일관성-관리&quot;&gt;인기있는 캐싱 전략 및 데이터 일관성 관리&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;LRU(Least Recently Used) 전략: 오래 사용하지 않은 데이터를 우선적으로 삭제해서 캐시 공간을 확보&lt;/li&gt;
  &lt;li&gt;캐시 무효화: 데이터 변경 시, 캐시된 오래된 데이터를 무효화하고 새로운 데이터로 대체하는 방법&lt;/li&gt;
  &lt;li&gt;캐시 계층 설계
    &lt;ul&gt;
      &lt;li&gt;캐시 계층을 설계할 때 만료 정책과 데이터 일관성을 고려해야한다.&lt;/li&gt;
      &lt;li&gt;너무 오래된 캐시가 있다면 데이터 불일치 문제가 발생할 수 있따.&lt;/li&gt;
      &lt;li&gt;TTL(Time To Live): 유효 기간을 설정해서 일정 기간이 지나면 자동으로 삭제되도록한다.&lt;/li&gt;
      &lt;li&gt;다중 계층 캐싱(Multi-layer Caching): 데이터를 효율적으로 저장하고 빠르게 접근하기 위해서 여러 단계의 캐시 시스템을 이용하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;로드밸런싱-1&quot;&gt;로드밸런싱&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;크기가 작을 때:
      &lt;ul&gt;
        &lt;li&gt;고정 트래픽 분산: 간단한 로드밸런싱으로 충분히 성능을 보장할 수 있다. (ALB, ELB 설정 정도로 충분히 대응 가능)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;크기가 커지면:
      &lt;ul&gt;
        &lt;li&gt;지리적 분산, 다중 리전 지원: 트래픽이 많아지면, 로드밸런서가 더 복잡해지고 고급 기능이 필요해진다. (CDN, Anycast 네트워크 활용)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;캐싱-전략-1&quot;&gt;캐싱 전략&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;크기가 작을 때:
      &lt;ul&gt;
        &lt;li&gt;간단한 캐싱 적용&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;크기가 커지면
      &lt;ul&gt;
        &lt;li&gt;다중 계층 캐싱 도입: 트래픽이 늘어나면, 다중 계층 캐싱을 통해 성능 극대화한다.&lt;/li&gt;
        &lt;li&gt;서버 간의 캐시 분산을 적용하고, 데이터 일관성을 유지하기 위한 복잡한 캐시 전략을 도입&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;데이터베이스-전략&quot;&gt;데이터베이스 전략&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;크기가 짝을 때:
      &lt;ul&gt;
        &lt;li&gt;기본적 사용으로 안정성과 비용 모두 챙김&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;크기가 커지면
      &lt;ul&gt;
        &lt;li&gt;샤딩이나 분산 데이터베이스로 효율화&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;1-다중-계층-캐싱의-기본-개념&quot;&gt;1. 다중 계층 캐싱의 기본 개념&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;효율 극대화를 위해서 여러 단계로 나눠서 사용할 수 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;L1(첫 번째 계층):
        &lt;ul&gt;
          &lt;li&gt;애플리케이션 내부에서 가장 빠르게 접근할 수 있는 캐시&lt;/li&gt;
          &lt;li&gt;주로 메모리 내부에 저장되며, 자주 접근하는 데이터를 여기에 저장&lt;/li&gt;
          &lt;li&gt;접근 속도가 매우 빠르지만, 용량이 제한적임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;L2(두 번째 계층):
        &lt;ul&gt;
          &lt;li&gt;메모리보다 느리지만, 더 많은 양의 데이터를 저장할 수 있는 외부 캐시 시스템을 의미&lt;/li&gt;
          &lt;li&gt;Redis, Memcached 같은 외부 솔루션을 사용해 더 많은 데이터를 저장&lt;/li&gt;
          &lt;li&gt;L1보다 느리지만, 훨씬 더 많은 데이터를 저장할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;L3(세 번째 계층):
        &lt;ul&gt;
          &lt;li&gt;더 낮은 단계의 캐시, DB나 원번 서버와 같은 위치를 의미&lt;/li&gt;
          &lt;li&gt;최후의 데이터 저장소&lt;/li&gt;
          &lt;li&gt;L1, L2 캐시에서 찾을 수 없는 데이터를 가져오는 곳&lt;/li&gt;
          &lt;li&gt;접근 속도가 가장 느리지만, 데이터를 항상 저장하고 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-다중-캐싱-동작-방식&quot;&gt;2. 다중 캐싱 동작 방식&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;L1 탐색&lt;/li&gt;
  &lt;li&gt;L1에 없으면 L2 탐색&lt;/li&gt;
  &lt;li&gt;L2에 없으면 L3 또는 DB 조회&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-장점&quot;&gt;3. 장점&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;성능 향상&lt;/li&gt;
  &lt;li&gt;리소스 절약&lt;/li&gt;
  &lt;li&gt;확장성&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-단점-고려-사항&quot;&gt;4. 단점, 고려 사항&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;복잡성 증가: 캐시 일관성 고려, 캐시 무효화 전략 설계&lt;/li&gt;
  &lt;li&gt;데이터 일관성: 부패된 캐시 데이터는 DB와 싱크가 맞지 않을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;분산-아키텍쳐&quot;&gt;분산 아키텍쳐&lt;/h2&gt;
&lt;h3 id=&quot;1-분산-아키텍쳐&quot;&gt;1. 분산 아키텍쳐&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;분산 시스템의 정의:
    &lt;ul&gt;
      &lt;li&gt;여러 독립적인 서버 또는 노드가 협력하여 하나의 시스템처럼 작동하는 구조&lt;/li&gt;
      &lt;li&gt;대규모 애플리케이션에서 널리 사용된다.&lt;/li&gt;
      &lt;li&gt;이를 통해서 더 많은 트래픽을 처리하고, 장애에 대한 내성을 강화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장:
    &lt;ul&gt;
      &lt;li&gt;단일 서버는 물리적 한계가 있음&lt;/li&gt;
      &lt;li&gt;따라서 여러 서버로 확장하는 것이 필요하며, 트래픽을 유연하게 대응할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-데이터-복제-및-분산-처리&quot;&gt;2. 데이터 복제 및 분산 처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 복제: 데이터를 여러 노드에 복사해서 저장하면 자여스레 부하 분산이 가능하다.&lt;/li&gt;
  &lt;li&gt;분산 처리: MapReduce는 대표적 분산 처리 프레임 워크다.&lt;/li&gt;
  &lt;li&gt;일관성 문제:
    &lt;ul&gt;
      &lt;li&gt;각 노드 간 싱크가 살짝씩 맞지 않을 수도 있으며, 이를 해결하기 위해서 일관성 모델을 적용한다.&lt;/li&gt;
      &lt;li&gt;강한 일관성 : 모든 노드에서 동일한 데이터를 보장&lt;/li&gt;
      &lt;li&gt;최종 일관성 : 시간이 지남에 따라 데이터가 동기화됨을 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-spof-방지-및-고가용성ha-유지&quot;&gt;3. SPOF 방지 및 고가용성(HA) 유지&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;SPOF: 컴포넌트 하나의 장애가 다른 곳으로 전파되는 것을 방지&lt;/li&gt;
  &lt;li&gt;고가용성: 시스템이 지속적으로 사용 가능하도록 복제와 장애 복구 기능을 설계&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-분산-트랜잭션-관리&quot;&gt;4. 분산 트랜잭션 관리&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;2PC(2-PhaseCommit):
    &lt;ul&gt;
      &lt;li&gt;분산 시스템에서 트랜잭션을 안전하게 커밋하는 기법으로, 모든 노드가 트랜잭션 준비가 완료되면 커밋/ 롤백을 결정한다.&lt;/li&gt;
      &lt;li&gt;단, 네트워크 지연이 생기면 같이 늦어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SAGA 패턴:
    &lt;ul&gt;
      &lt;li&gt;각 트랜잭션을 작은 단위로 나눠 처리하는 방식&lt;/li&gt;
      &lt;li&gt;성공적으로 실행된 트랜잭션 이후에 문제가 발생하면 롤백을 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-트랜잭션-관리-시-확장성-문제-고려&quot;&gt;5. 트랜잭션 관리 시 확장성 문제 고려&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;네트워크 분할 문제:
    &lt;ul&gt;
      &lt;li&gt;네트워크 분할 + 장애일 경우 일부가 독립적으로 운영되면서 전체 시스템이 정상적으로 동작할 수 있도록 해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장성을 고려한 관리 기법:
    &lt;ul&gt;
      &lt;li&gt;비동기 트랜잭션 처리 방식과 같은 확장성 기법을 적용해서 트랜잭션이 독립적 노드에서 처리되도록 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;db-확장-전략&quot;&gt;DB 확장 전략&lt;/h2&gt;
&lt;h3 id=&quot;1-수직&quot;&gt;1. 수직&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;구조 변경 없이 자원만 추가하면 된다.&lt;/li&gt;
      &lt;li&gt;성능 향상이 손쉬움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;물리적 한계가 있다.&lt;/li&gt;
      &lt;li&gt;비용이 급격하게 증가할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-수평&quot;&gt;2. 수평&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;샤딩: 샤드 단위로 분할해서 여러 서버에서 분산 처리하는 방식이다. 샤딩 키를 기준으로 데이터를 나누며 각 샤드는 독립적인 DB처럼 작동한다.
    &lt;ol&gt;
      &lt;li&gt;장점&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 서버로 부하 분산&lt;/li&gt;
      &lt;li&gt;이론적으로 무한히 확장 가능
        &lt;ol&gt;
          &lt;li&gt;단점&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;샤딩 키 선택이 매우 중요하다.&lt;/li&gt;
      &lt;li&gt;데이터 일관성 유지가 어렵고 복잡하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-replication&quot;&gt;3. Replication&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 복제본을 생성하여, 읽기 및 쓰기 작업을 분산하는 방식
    &lt;ol&gt;
      &lt;li&gt;M-S:&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;Master는 쓰기, Slave는 읽기&lt;/li&gt;
      &lt;li&gt;읽기 성능이 중요한 시스템에 적합
        &lt;ol&gt;
          &lt;li&gt;M-M&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;여러 Master가 쓰기 작업을 하며, 데이터 동기화가 필요하다.&lt;/li&gt;
      &lt;li&gt;글로벌 서비스나 대규모 시스템에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 17 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 16.optimizewebserver</title>
        <link>/docker/wanted/2024/10/16/Wanted-Docker-series-16.OptimizeWebServer.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/16/Wanted-Docker-series-16.OptimizeWebServer.html</guid>
        <description>&lt;h1 id=&quot;웹서버-성능-최적화&quot;&gt;웹서버 성능 최적화&lt;/h1&gt;

&lt;h2 id=&quot;클라우드-환경에서-고려해야-하는-웹서버-성능-최적화를-위한-모니터링-전략&quot;&gt;클라우드 환경에서 고려해야 하는 웹서버 성능 최적화를 위한 모니터링 전략&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;빠른 응답 시간&lt;/li&gt;
  &lt;li&gt;높은 가용성: 웹서버의 다운타임을 최소화&lt;/li&gt;
  &lt;li&gt;확장성: 트래픽 증가에 따라 서버 자원을 유연하게 확장할 수 있도록 함&lt;/li&gt;
  &lt;li&gt;효율적인 자원 사용: 서버 자원을 최적화하여 비용을 절감하고 성능을 극대화&lt;/li&gt;
  &lt;li&gt;안정성: 웹서버가 안정적으로 동작하여 사용자가 신뢰할 수 있도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;성능-최적화를-위해서-고려할-요소들&quot;&gt;성능 최적화를 위해서 고려할 요소들&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어&lt;/li&gt;
  &lt;li&gt;네트워크
    &lt;ul&gt;
      &lt;li&gt;대역폭: 네트워크에서 데이터를 전송할 수 있는 최대 용량&lt;/li&gt;
      &lt;li&gt;트래픽: 네트워크를 통해서 주고 받는 데이터의 양을 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 최적화&lt;/li&gt;
  &lt;li&gt;DB 최적화&lt;/li&gt;
  &lt;li&gt;캐싱
    &lt;ul&gt;
      &lt;li&gt;Redis: Ram에 저장하며 매우 빠른 속도로 읽고 쓸 수 있다. 문자열, 해시, 리스트, 셋, 정렬된 셋 등의 데이터를 저장할 수 있다.&lt;/li&gt;
      &lt;li&gt;Memcached: DB에서 자주 요청되는 데이터를 메모리에 저장해서 빠르게 접근할 수 있게 해주는 시스템&lt;/li&gt;
      &lt;li&gt;비교
        &lt;ul&gt;
          &lt;li&gt;Redis가 더 다양한 데이터 구조와 기능을 제공, 데이터 영속성과 고 가용성을 지원&lt;/li&gt;
          &lt;li&gt;Memcached는 간단한 키-값 형태의 데이터 캐싱에 특화되어 있고, 매우 높은 성능을 제공&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로드밸런싱: 여러 서버에 트래픽을 분산시켜 서버 과부하를 방지하고 성능을 최적화&lt;/li&gt;
  &lt;li&gt;CDN: 전세계에 분산된 서버 네트워크를 통해서 콘텐츠를 사용자에게 빠르게 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모니터링에-고려해야할-요소&quot;&gt;모니터링에 고려해야할 요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CPU 사용률&lt;/li&gt;
  &lt;li&gt;메모리 사용률&lt;/li&gt;
  &lt;li&gt;디스크 I/O&lt;/li&gt;
  &lt;li&gt;네트워크 트래픽&lt;/li&gt;
  &lt;li&gt;응답시간&lt;/li&gt;
  &lt;li&gt;에러 로그&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클라우드-환경에서-성능-최적화&quot;&gt;클라우드 환경에서 성능 최적화&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;오토스케일링&lt;/li&gt;
  &lt;li&gt;인프라 최적화&lt;/li&gt;
  &lt;li&gt;컨테이너화&lt;/li&gt;
  &lt;li&gt;DB 최적화&lt;/li&gt;
  &lt;li&gt;캐싱 전략&lt;/li&gt;
  &lt;li&gt;최신 기술 사용&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 16 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 15.deployandlogging</title>
        <link>/docker/wanted/2024/10/15/Wanted-Docker-series-15.DeployAndLogging.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/15/Wanted-Docker-series-15.DeployAndLogging.html</guid>
        <description>&lt;h1 id=&quot;데이터-스토리지-무중단-배포-로깅-모니터링&quot;&gt;데이터 스토리지, 무중단 배포, 로깅 모니터링&lt;/h1&gt;

&lt;h2 id=&quot;1-데이터-스토리지&quot;&gt;1. 데이터 스토리지&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;클라우드 환경에서 데이터를 효율적으로 저장하고 확장하는 것은 애플리케이션 성능과 안정성을 보장하는 핵심&lt;/li&gt;
  &lt;li&gt;DB, 파일 스토리지로 데이터의 일관성, 확장성을 보장&lt;/li&gt;
  &lt;li&gt;다양한 데이터 스토리지에 맞춰 확장성 전략을 세우고 관리해서 클라우드 네이티브 환경에 최적의 아키텍쳐를 구축할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;11-클라우드-환경에서-데이터-스토리지&quot;&gt;1.1. 클라우드 환경에서 데이터 스토리지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클라우드 환경에서 대규모 트래픽과 데이터를 처리할 수 있도록 설계됨&lt;/li&gt;
  &lt;li&gt;데이터를 안전하게 저장하고, 필요 시 쉽게 확장할 수 있는 방법을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-종류&quot;&gt;1.2. 종류&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;RDBMS&lt;/li&gt;
  &lt;li&gt;NoSQL&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-분산-데이터-시스템&quot;&gt;1.3. 분산 데이터 시스템&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클라우드 환경에서 분산 데이터 시스템은 필수다.&lt;/li&gt;
  &lt;li&gt;대규모 트래픽 처리에 유연하다.&lt;/li&gt;
  &lt;li&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cassandra&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-데이터-확장성&quot;&gt;2. 데이터 확장성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;대규모 데이터를 처리할 때 필수적으로 고려해야 할 요소.&lt;/li&gt;
  &lt;li&gt;수평, 수직이 있음
    &lt;h3 id=&quot;21-수평-vs-수직&quot;&gt;2.1. 수평 vs. 수직&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;수직(VerticalScaling): 서버 사양 업그레이드&lt;/li&gt;
  &lt;li&gt;수평(HorizontalScaling): 여러 서버로 데이터를 분산 처리하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-샤딩-vs-파티셔닝-ɑ&quot;&gt;2.2. 샤딩 vs. 파티셔닝 (+ɑ)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;샤딩, 파티셔닝 모두 확장하고 성능을 위해서 나누는 방식이지만 차이가 있다.
    &lt;ol&gt;
      &lt;li&gt;샤딩:&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터를 여러 DB에 분산해서 저장하는 방식이다.&lt;/li&gt;
      &lt;li&gt;수평 확장을 통해서 대규모 데이터를 처리하거나 트래픽 분산에 사용&lt;/li&gt;
      &lt;li&gt;독립된 데이터베이스 서버에 저장된다.&lt;/li&gt;
      &lt;li&gt;샤딩된 데이터는 어떤 샤드에 저장됐는지 알기 위해서 샤딩키를 사용한다.&lt;/li&gt;
      &lt;li&gt;수평 확장&lt;/li&gt;
      &lt;li&gt;각 샤드는 독립적&lt;/li&gt;
      &lt;li&gt;서버 장애시 해당 샤드에만 영향
        &lt;ol&gt;
          &lt;li&gt;파티셔닝&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;파티셔닝은 하나의 데이터베이스에서 논리적으로 나누는 방법&lt;/li&gt;
      &lt;li&gt;데이터를 여러 파티션으로 나눠 읽기, 쓰기 성능을 최적화&lt;/li&gt;
      &lt;li&gt;동일한 데이터베이스 인스턴스에 안에서 유지&lt;/li&gt;
      &lt;li&gt;수직 확장에 가까운 개념&lt;/li&gt;
      &lt;li&gt;논리적으로 분리한다.
        &lt;ol&gt;
          &lt;li&gt;캐싱&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;자주 사용하는 데이터를 메모리에 저장&lt;/li&gt;
      &lt;li&gt;Redis, Memcached가 있다.
        &lt;h2 id=&quot;3-데이터-관리-전략&quot;&gt;3. 데이터 관리 전략&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라우드 환경에서 데이터 관리는 확장성, 성능을 유지하면서 데이터 안정성, 일관성을 확보하는 것이 핵심
    &lt;h3 id=&quot;31-데이터-동기화-및-복제-전략&quot;&gt;3.1. 데이터 동기화 및 복제 전략&lt;/h3&gt;
    &lt;ol&gt;
      &lt;li&gt;Master-Slave: DB간 주-종으로 쓰기-읽기를 분할&lt;/li&gt;
      &lt;li&gt;Multi-Master Replication: 여러 마스터 노드에서 동시에 기록하고 동기화하여 높은 가용성과 성능을 제공
        &lt;h3 id=&quot;32-데이터-분석&quot;&gt;3.2. 데이터 분석&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;클라우드 환경에서 데이털르 수집하고 분석하는 작업은 대규모 데이터를 빠르게 처리하는 데 중요(Redshift, BigQuery)
    &lt;h3 id=&quot;33-데이터-보안-및-규정-준수&quot;&gt;3.3. 데이터 보안 및 규정 준수&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;암호화: 클라우드 환경에서 데이터를 저장할 때 암호화는 필수, 데이터의 기밀성과 무결성을 보장하여 공격에 보호&lt;/li&gt;
  &lt;li&gt;액세스 제어: IAM(Identity and Access Management)을 통해서 클라우드 리소스에 대한 접근 권한을 관리&lt;/li&gt;
  &lt;li&gt;규정 준수: GDPR, HIPAA 같은 규제 요구 사항을 준수하여 데이터를 처리
    &lt;h2 id=&quot;4-무중단-배포-및-devops&quot;&gt;4. 무중단 배포 및 DevOps&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 기술이 아닌 팀 간 협업과 책임 공유를 중심으로 한 문화다.&lt;/li&gt;
  &lt;li&gt;DevOps 문화에서는 팀이 각자 역할에만 국한되지 않고, 공동 목표를 함께 노력한다.&lt;/li&gt;
  &lt;li&gt;단순 개발을 넘어서 운영팀과 협력하여 서비스 안정성과 성능 최적화에 참여
    &lt;h2 id=&quot;5-로깅과-모니터링의-중요성&quot;&gt;5. 로깅과 모니터링의 중요성&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;운영에서 중요한 역할을 한다.&lt;/li&gt;
  &lt;li&gt;로깅은 시스템에서 발생하는 모든 이벤트를 기록&lt;/li&gt;
  &lt;li&gt;모니터링은 시스템 성능을 실시간으로 추적하고 감시하는 프로세스&lt;/li&gt;
  &lt;li&gt;클라우드 네이티브는 항상 여러 개의 노드, 컨테이너, 마이크로 서비스에 걸쳐 실행된다.&lt;/li&gt;
  &lt;li&gt;이로 인해 발생하는 데이터의 흐름, 리소스 사용, 네트워크 트래픽 등을 실시간으로 파악할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;중요성&quot;&gt;중요성?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;실시간 문제 감시 및 해결
    &lt;ul&gt;
      &lt;li&gt;운영 중 발생할 수 있는 문제 감시&lt;/li&gt;
      &lt;li&gt;조기 경고로 신속하게 대응할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능 최적화
    &lt;ul&gt;
      &lt;li&gt;성능 모니터링으로 병목, 비효율점을 찾아서 최적화할 수 있다.&lt;/li&gt;
      &lt;li&gt;지속적으로 높은 성능을 유지할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안 강화
    &lt;ul&gt;
      &lt;li&gt;모든 시스템 로깅&lt;/li&gt;
      &lt;li&gt;보안침해를 빠르게 탐지할 수 있다.&lt;/li&gt;
      &lt;li&gt;보안 사고 시 로깅 데이터로 추적할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;규정 준수 및 감사
    &lt;ul&gt;
      &lt;li&gt;산업 분야에서 법적 규제 및 컴플라이언스 요구사항을 준수하기 위해서 시스템 활동을 철저히 기록하고 관리해야 한다.&lt;/li&gt;
      &lt;li&gt;모든 활동을 기록하고 아카이빙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 가용성 및 안정성 유지
    &lt;ul&gt;
      &lt;li&gt;클라우드 네이티브에서 여러 개의 서버, 컨테이너, 네트워크를 포함한 복잡한 분산 시스템이 운영된다.&lt;/li&gt;
      &lt;li&gt;각 요소의 가용성을 보장하는 것이 중요하다.&lt;/li&gt;
      &lt;li&gt;로깅, 모니터링으로 실시간으로 확인하고 장애 발생 시 자동 복구하거나 재배치하는 등의 조치를 취할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;클라우드-네이티브에서&quot;&gt;클라우드 네이티브에서?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;동적 확장 및 자원 관리
    &lt;ul&gt;
      &lt;li&gt;로깅은 각 확장, 축수에 대한 기록을 남기고 이를 기반으로 자원 관리 최적화를 도울 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 분산 시스템에서의 통합 관리
    &lt;ul&gt;
      &lt;li&gt;모니터링 시스템으로 사용 상태를 감시해서 오토스케일링을 트리거할 수 있다. 리소스 낭비를 막고 적절한 자원을 추가할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 수준 협약(SLA) 유지
    &lt;ul&gt;
      &lt;li&gt;클라우드에서 운영되는 시스템은 일정 수준의 가용성, 응답 시간을 보장해야하는데 로깅과 모니터링을 통해서 이를 준수하는지 확인할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실시간 분석, 피드백 루프
    &lt;ul&gt;
      &lt;li&gt;실시간 데이터를 생성하고 이를 분석해서 시스템 개선, 성능 최적화를 위한 피드백을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 15 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 14.designcloudnative</title>
        <link>/docker/wanted/2024/10/14/Wanted-Docker-series-14.DesignCloudNative.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/14/Wanted-Docker-series-14.DesignCloudNative.html</guid>
        <description>&lt;h1 id=&quot;클라우드-네이티브-설계&quot;&gt;클라우드 네이티브 설계&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;클라우드에서 최적화된 애플리케이션을 설계, 배포, 운영하는 방식&lt;/li&gt;
  &lt;li&gt;마이크로서비스, 컨테이너 오토스케일링, 분산 시스템을 중심으로 하며, 애플리케이션을 독립적으로 배포하고 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;vs. monolithic&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;모놀리식은 모든 기능이 하나의 코드베이스로 구성.&lt;/li&gt;
    &lt;li&gt;모든 기능이 함께 배포되고 관리됨&lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;초기에는 간단하지만 시간이 지나고 기능이 늘면 확장성과 유지보수 측면에서 어려움이 생김&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;클라우드 네이티브는 각 기능을 독립적인 마이크로서비스로 구성&lt;/li&gt;
    &lt;li&gt;확장성과 유지보수를 용이하게 한다.&lt;/li&gt;
    &lt;li&gt;The Twelve-Factor App은 확장 가능하고 유지 보수성이 높은 애플리케이션을 개발하기 위한 표준이자 원칙이 된다.&lt;/li&gt;
    &lt;li&gt;12요소는 각기 독립적인 모듈로, 애플리케이션이 다양한 클라우드 환경과 하이브리드 환경에서 일관되게 동작하게 하고, 관리할 수 있도록 돕는 설계 원칙이다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;12-factor-app&quot;&gt;&lt;a href=&quot;https://12factor.net&quot;&gt;12 Factor App&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;codebase
    &lt;ul&gt;
      &lt;li&gt;하나의 코드베이스를 가져야하며, 이 코드베이스는 버전 관리 시스템에 의해서 추적되어야 한다.&lt;/li&gt;
      &lt;li&gt;하나의 코드베이스를 기반으로 다양한 환경(dev, stage, prod)을 지원할 수 있다.&lt;/li&gt;
      &lt;li&gt;모든 환경은 동일한 코드베이스에서 파생된다.( 다른 버전의 코드를 사용하지 않는다. )&lt;/li&gt;
      &lt;li&gt;동일한 코드베이스로부터 빌드된 여러 배포가 존재할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dependencies(Explicitly Declare Dependencies)
    &lt;ul&gt;
      &lt;li&gt;애플리케이션이 의존하는 모든 라이브러리, 패키지를 명시적으로 선언해야 한다.&lt;/li&gt;
      &lt;li&gt;이를 통해 일관된 빌드를 보장하고, 종속성 관련 문제를 최소화한다.&lt;/li&gt;
      &lt;li&gt;모든 의존성은 완벽히 관리되고 동일한 패키지를 사용하도록 보장된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;config(Store Config in the Environment)
    &lt;ul&gt;
      &lt;li&gt;설정정보는 코드 베이스가 아닌 환경 변수나 외부 설정 파일로 분리해야 한다.&lt;/li&gt;
      &lt;li&gt;이는 다양한 환경에서 일관되게 동작할 수 있도록 한다.&lt;/li&gt;
      &lt;li&gt;설정 정보가 코드에 포함되지 않아서 보안 문제도 해결할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;backing services(Treat Backing Services as Attached Resources)
    &lt;ul&gt;
      &lt;li&gt;DB, MessageQueue, Cache 같은 외부 서비스는 백엔드 리소스로 취급된다. (연결된 자원)&lt;/li&gt;
      &lt;li&gt;애플리케이션은 이들 서비스와 독립적으로 실행되어야 한다.&lt;/li&gt;
      &lt;li&gt;백엔드 서비스의 위치나 구성 변경 시에도 애플리케이션의 코드에 수정이 필요하지 않도록 해야 한다.&lt;/li&gt;
      &lt;li&gt;이 접근법은 애플리케이션이 어느 환경에서도 일관되게 동작할 수 있도록 보장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;build release run(Strictly Separate Build and Run Stages)
    &lt;ul&gt;
      &lt;li&gt;애플리케이션은 build, release, run 단계를 명확히 구분해야 한다.&lt;/li&gt;
      &lt;li&gt;빌드 단계에서는 코드를 컴파일하고, 릴리즈 단계에서는 빌드된 아티팩트와 설정 정보를 결합하며, 실행 단계에서는 해당 릴리즈 버전을 실행한다.&lt;/li&gt;
      &lt;li&gt;CI/CD를 통해서 빌드하고, 결과물을 환경 설정과 결합하여 릴리즈 버전을 생성한다.&lt;/li&gt;
      &lt;li&gt;그리고 배포하여 실행한다.
        &lt;ul&gt;
          &lt;li&gt;코드와 설정 정보 분리 이유는 동일한 코드베이스가 다양한 환경에서 설정만 변경하여 사용할 수 있도록 하기 위함이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;processes
    &lt;ul&gt;
      &lt;li&gt;애플리케이션은 상태를 가지고 있지 않아야 한다.&lt;/li&gt;
      &lt;li&gt;만약 상태를 가져야 한다면 db같은 backing service에 저장되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;port binding(Export Services via Port Binding)
    &lt;ul&gt;
      &lt;li&gt;애플리케이션이 특정 포트를 통해 외부와 통신할 수 있도록 하는 것이다.&lt;/li&gt;
      &lt;li&gt;외부와의 통신을 위해서 포트 바인딩을 통해서 서비스를 제공해야 한다.&lt;/li&gt;
      &lt;li&gt;이를 통해서 애플리케이션은 웹 서비스와 같은 외부 프로세스에 의존하지 않고 자체적으로 HTTP 트래픽을 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;웹서버를 이용할 수도 있고, 로드밸런서도 쓸 수 있다.&lt;/li&gt;
      &lt;li&gt;애플리케이션이 포트에 직결해서 서비스 할 수 있다면 더 유연하다.&lt;/li&gt;
      &lt;li&gt;애플리케이션이 외부에 의존 없이 포트 바인딩으로 자체적으로 서비스 제공하면 애플리케이션의 독립성과 확작성을 높인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;concurrency(Scale Out via the Process Model)
    &lt;ul&gt;
      &lt;li&gt;애플리케이션은 프로세스 기반으로 동시성을 처리해야 한다.&lt;/li&gt;
      &lt;li&gt;여러 프로세스나 인스턴스를 통해서 확장성을 제공한다.&lt;/li&gt;
      &lt;li&gt;이는 수평 확장을 통해서 더 많은 트래픽을 처리할 수 있게 한다.
        &lt;ul&gt;
          &lt;li&gt;동시성: 여러 작업이 동시에 처리될 수 있도록 프로세스를 병렬로 실행하는 것&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;애플리케이션은 프로세스 모델을 통해서 동시성을 제공한다.&lt;/li&gt;
      &lt;li&gt;프로세스 간 상태 공유 없이 독립적으로 동작할 수 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;disposability
    &lt;ul&gt;
      &lt;li&gt;프로세스는 언제든 처분될 수 있으며, 이는 언제든지 실행되거나 종료될 수 있음을 의미한다.&lt;/li&gt;
      &lt;li&gt;프로세스의 시작 시간은 최소화되어야 한다.&lt;/li&gt;
      &lt;li&gt;짧은 시작시간은 릴리즈, 스케일 업에 유연성을 부여한다.&lt;/li&gt;
      &lt;li&gt;종료는 우아하게 되어야 한다.&lt;/li&gt;
      &lt;li&gt;또한 고장 발생시 갑작스런 종료에 견고해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dev/prod parity
    &lt;ul&gt;
      &lt;li&gt;최대한 dev/stage/prod 간 차이가 크지 않아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;시간적 차이: 개발 단계에서 배포 전까지 기간이 반드시 존재한다.&lt;/li&gt;
      &lt;li&gt;인원적 차이: 개발은 개발자가, 배포는 엔지니어가 한다.&lt;/li&gt;
      &lt;li&gt;도구적 차이: 각 단계에서 사용하는 도구가 다르다.
        - 즉 이 차이들을 줄이려면 주기적으로 지속적으로 배포해야 한다.
        - 또한 인원 차이를 문서화등 명시적으로 작성하는 것으로 극복해야 한다.
        - 마지막으로 개발, 배포 간 차이를 줄여야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;logs(Treat Logs as Event Stream)
    &lt;ul&gt;
      &lt;li&gt;애플리케이션에서 발생하는 모든 로그는 이벤트 스트림으로 처리되야 한다.&lt;/li&gt;
      &lt;li&gt;별도의 로그 처리 시스템에서 중앙화 하여 관리할 수 있다.&lt;/li&gt;
      &lt;li&gt;로그는 단순 출력이 아니라, 애플리케이션의 상태를 모니터링하고 문제를 디버깅하는 중요한 데이터 소스다.
        &lt;ul&gt;
          &lt;li&gt;EventStream: 애플리케이션에서 발생하는 이벤트를 시간 순서대로 처리하는 방식이다. 이를 통해서 실시간 데이터 분석, 모니터링이 가능하다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;admin processes(Run Admin/Management Tasks as One-off Process)
    &lt;ul&gt;
      &lt;li&gt;DB 마이그레이션이나 백업 같은 관리자 작업은 애플리케이션의 코드와 별도로 독립적인 프로세스로 관리되어야 한다.&lt;/li&gt;
      &lt;li&gt;이러한 작업은 운영 중인 애플리케이션과 분리되며, 애플리케이션에 영향을 미치지 않도록 처리한다.&lt;/li&gt;
      &lt;li&gt;관리 작업은 독립적 프로세스로 실행되어야 한다.&lt;/li&gt;
      &lt;li&gt;이 작업은 애플리케이션에 영향을 미치지 않아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-cap&quot;&gt;1. CAP&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CAP 이론은 Consistency, Availability, Partition Tolerance 중 두 가지를 선택해야 한다는 이론이다.&lt;/li&gt;
  &lt;li&gt;이 세가지 요소는 서로 상충되기에, 한 시스템에서 세 가지를 동시에 완벽하기 어렵다.&lt;/li&gt;
  &lt;li&gt;아키텍쳐 설계 단계에서 뭘 더 중점을 둘지를 정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Consistency
    &lt;ul&gt;
      &lt;li&gt;일관성은 분산 시스템에서 모든 노드가 동일한 데이터 상태를 유지하는 것을 의미한다.&lt;/li&gt;
      &lt;li&gt;한 노드에서 데이터를 업데이트하면, 그 업데이트는 다른 모든 노드에 즉시 반영되어야 한다.&lt;/li&gt;
      &lt;li&gt;장/단점
        &lt;ul&gt;
          &lt;li&gt;장점: 데이터 신뢰성, 정확성이 높아진다.&lt;/li&gt;
          &lt;li&gt;단점: 모든 데이터를 즉시 동기화해야 해서, 네트워크 지연이나 장애 발생 시 가용성이 떨어진다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Availability
    &lt;ul&gt;
      &lt;li&gt;가용성을 장애가 발생하거나 네트워크가 분리되더라도 모든 요청에 대해서 응답할 수 있는 능력을 의미한다.&lt;/li&gt;
      &lt;li&gt;이는 분산 시스템의 중요한 목표 중 하나다.&lt;/li&gt;
      &lt;li&gt;사용자 요청을 무조건적으로 처리해주는 것을 보장한다.&lt;/li&gt;
      &lt;li&gt;장/단점
        &lt;ul&gt;
          &lt;li&gt;장점: 사용자 경험이 지속적으로 유지, 시스템 가동 중단을 최소화할 수 있다.&lt;/li&gt;
          &lt;li&gt;단점: 노드 간에 일관성이 일시적으로 깨질 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partition Tolerance
    &lt;ul&gt;
      &lt;li&gt;파티션 허용성은 네트워크 분할이 발생했을 때도 시스템이 정상적으로 동작할 수 있는 능력을 의미한다.&lt;/li&gt;
      &lt;li&gt;분산 시스템에서 네트워크 연결이 끊기거나, 일부 노드가 다른 노드와 연결되지 못하는 상황을 의미한다.&lt;/li&gt;
      &lt;li&gt;이런 경우에도 시스템은 가능한 한 정상적으로 작동해야 한다.&lt;/li&gt;
      &lt;li&gt;장/단점
        &lt;ul&gt;
          &lt;li&gt;장점: 네트워크 분리 시에도 서비스가 계속 제공될 수 있다.&lt;/li&gt;
          &lt;li&gt;단점: 일관성과 가용성 중 하나를 포기해야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cap.png&quot; alt=&quot;cap.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일관성 우선: 데이터 정확성이 중요한 경우 선택. 가용성과 파티션 허용성을 어느정도 희생&lt;/li&gt;
  &lt;li&gt;가용성 우선: 대규모 트래픽을 처리해야 하는 경우 선택.&lt;/li&gt;
  &lt;li&gt;파티션 우선: 글로벌 서비스를 제공하는 클라우드 환경에서 선택&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-데이터-복구-장애-복구&quot;&gt;2. 데이터 복구, 장애 복구&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;분산 시스템에서 데이터를 여러 노드로 복제하여 시스템의 고가용성을 보장하는 것이 중요하다.&lt;/li&gt;
  &lt;li&gt;데이터 복제는 한 노드에서 데이터를 변경했을 때, 그 변경 사항이 다른 노드에서도 복사되는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;이를 통해서 장애가 발생해도 데이터를 잃지 않고 시스템을 빠르게 복구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 복제의 중요성
    &lt;ul&gt;
      &lt;li&gt;고가용성 보장: 하나의 노드에 장애가 발생하더라도 다른 노드에 동일 데이터가 있어서 서비스 중단이 없다.&lt;/li&gt;
      &lt;li&gt;데이터 손실 방지: 실시간으로 데이터를 여러 노드에 복제함으로써, 시스템 장애나 데이터센터의 물리적 손상에서도 데이터 복구가 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복제 방법
    &lt;ul&gt;
      &lt;li&gt;동기 복제: 데이터 변경할 떄, 모든 노드가 데이터 변경 사항을 즉시 반영한다. 이는 데이터 일관성을 보장하지만, 지연 시간이 길어질 수 있다.&lt;/li&gt;
      &lt;li&gt;비동기 복제: 데이터 변경 후, 일정 시간이 지난 후에 데이터를 복제한다. 짧은 시간 일관성이 떨어질 수 있지만, 시스템 성능과 가용성이 높아진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장애 복구 전략
    &lt;ul&gt;
      &lt;li&gt;자동 복구(Self-healing): 클라우드 네이티브 시스템은 장애가 발생하면 자동으로 복구될 수 있도록 설계되어야 한다.&lt;/li&gt;
      &lt;li&gt;백업, 복원: 중요 데이터는 정기적으로 백업하고, 장애 발생 시 이를 통해서 복원해야 한다. 데이터 손실을 최소화 하기 위해서 여러 데이터 센터에서 복제된 백업을 보유하는 것이 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-네트워크-레이턴시&quot;&gt;3. 네트워크 레이턴시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;분산 시스템에서 성능을 저하시키는 요소 중 하나&lt;/li&gt;
  &lt;li&gt;노드 간 이동하는데 걸리는 시간을 의미한다.&lt;/li&gt;
  &lt;li&gt;latency가 길어지면 응답 시간이 길어져 사용자 경험에 악영향을 미친다.&lt;/li&gt;
  &lt;li&gt;따라서 통신을 최적화해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;레이턴시 발생 원인
    &lt;ul&gt;
      &lt;li&gt;지리적 거리: 사용자 - 서버 간 물리적 거리가 멀면 느려질 수 있다.&lt;/li&gt;
      &lt;li&gt;네트워크 혼잡: 네트워크가 많은 트래픽을 처리해야 하면 느려질 수 있다.&lt;/li&gt;
      &lt;li&gt;잘못된 라우팅: 네트워크 내에서 잘못된 경로로 전송하면 추가적 레이턴시가 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화
    &lt;ul&gt;
      &lt;li&gt;CDN 사용: 지리적으로 가까운 서버에서 받을 수 있도록 한다.&lt;/li&gt;
      &lt;li&gt;DNS 최적화: 라우팅을 최적화 하여 사용자가 가까운 서버에 연결되도록 한다.&lt;/li&gt;
      &lt;li&gt;오토스케일링 및 로드 밸런싱: 트래픽이 많으면 자동으로 서버를 추가하고, 트래픽을 분배해서 네트워크 혼잡을 방지한다.&lt;/li&gt;
      &lt;li&gt;서비스 간 통신 최적화:
        &lt;ol&gt;
          &lt;li&gt;서비스 메시: 서비스 메시를 사용해서 마이크로서비스 간 통신을 효율적으로 관리할 수 있다. 서비스 메시를 통해서 통신 경로를 최적화하고, 성능을 모니터링할 수 있다.&lt;/li&gt;
          &lt;li&gt;RPC: 원격 노드 간의 통신을 최적화하는 방법이다. 서비스 간 빠른 데이터 전송을 가능하게 한다. gRPC는 RPC를 개선하여, 데이터 전송 속도를 높였다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-servicemesh-api-gateway&quot;&gt;4. ServiceMesh/ API gateway&lt;/h2&gt;
&lt;h3 id=&quot;41-서비스-메시&quot;&gt;4.1. 서비스 메시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;분산 시스템에서 마이크로 서비스 간의 통신을 최적화하는 구조다.&lt;/li&gt;
  &lt;li&gt;여러 개의 마이크로 서비스가 통신할 때, 서비스 메시가 각 서비스 간의 트래픽을 라우팅하고, 보안 및 모니터링을 담당한다.&lt;/li&gt;
  &lt;li&gt;주요 기능
    &lt;ol&gt;
      &lt;li&gt;트래픽 관리: 서비스 간의 통신 경로를 최적화 하고, 필요한 경우 트래픽을 제한하거나 우선순위를 설정&lt;/li&gt;
      &lt;li&gt;보안: 서비스 메시를 통해서 마이크로서비스 간의 통신을 암호화하고, 인증 및 권한 부여 기능을 통해 보안을 강화&lt;/li&gt;
      &lt;li&gt;모니터링 및 로깅: 서비스 메시가 모든 서비스 간의 트래픽을 감시하고, 성능을 모니터링한다. 또한, 로깅 기능을 통해 문제가 발생한 서비스의 통신 기록을 분석할 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42-api-gateway&quot;&gt;4.2. API gateway&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;외부 클라이언트가 여러 마이크로서비스에 접근할 수 있도록 라우팅을 제공하는 진입점 역할을 한다.&lt;/li&gt;
  &lt;li&gt;클라우드 네이티브에서는 중요한 역할을 하며, 서비스 메시와 사용되기도 한다.&lt;/li&gt;
  &lt;li&gt;주요 기능
    &lt;ol&gt;
      &lt;li&gt;트래픽 라우팅: API 게이트웨이는 클라이언트 요청을 적절한 마이크로서비스로 라우팅하여 각 서비스가 개별적으로 처리할 수 있도록 한다.&lt;/li&gt;
      &lt;li&gt;보안: 보안, 인가, 데이터 검증 등의 기능을 제공하여, 외부 클라이언트 - 내부 마이크로서비스 간의 보안을 강화한다.&lt;/li&gt;
      &lt;li&gt;로드밸런싱: 여러 마이크로서비스 간 트래픽을 분산하여, 특정 서비스에 과부화가 걸리지 않도록 조정한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h1 id=&quot;api-설계와-버저닝&quot;&gt;API 설계와 버저닝&lt;/h1&gt;
  &lt;ul&gt;
    &lt;li&gt;마이크로 서비스 간 통신을 관리하고 데이터를 주고받는 중요한 요소&lt;/li&gt;
    &lt;li&gt;서비스 간 연결성을 보장&lt;/li&gt;
    &lt;li&gt;클라우드 네이티브에서는 여러 마이크로서비스가 독립적으로 배포되고 관리되기에 각 서비스가 다른 서비스와 통신할 수 있도록 API 설계, 버저닝이 중요&lt;/li&gt;
    &lt;li&gt;잘 설계된 API는 확장성, 유지보수성 그리고 서비스 간 안정적 통신을 보장&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h2 id=&quot;a-api-설계-원칙&quot;&gt;a. API 설계 원칙&lt;/h2&gt;
  &lt;h3 id=&quot;1-restful&quot;&gt;1. RESTful&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;REST(REpresentational State Transfer)&lt;/li&gt;
    &lt;li&gt;인터넷 사이 상호 운용성을 제공하는 방법
      &lt;h4 id=&quot;11-어떻게-정보를-공유할-것인가&quot;&gt;1.1. 어떻게 정보를 공유할 것인가?&lt;/h4&gt;
    &lt;/li&gt;
    &lt;li&gt;장점:
      &lt;ul&gt;
        &lt;li&gt;표준화되니 방식으로 설계되어, 다양한 클라이언트에서 사용 가능함&lt;/li&gt;
        &lt;li&gt;무상태성으로 인해 서버 확장성이 높다.&lt;/li&gt;
        &lt;li&gt;직관적인 설계를 통해 자원에 대한 접근을 쉽게 이해할 수 있다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;단점
      &lt;ul&gt;
        &lt;li&gt;대규모 요청에서 불필요한 데이터 전송이 발생할 수 있다&lt;/li&gt;
        &lt;li&gt;요청한 데이터 외에도 많은 자원 정보를 보내기 때문에 대역폭이 낭비될
          &lt;h3 id=&quot;graphql&quot;&gt;GraphQL&lt;/h3&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;facebook이 개발한 쿼리 언어, 클라이언트가 단일 엔드포인트롤 통해서 필요한 데이터만 요청할 수 있다.&lt;/li&gt;
    &lt;li&gt;불필요한 정보 송수신을 줄일 수 있다.&lt;/li&gt;
    &lt;li&gt;장점
      &lt;ul&gt;
        &lt;li&gt;클라이언트가 필요한 데이터만 요청할 수 있어 효율적이다.&lt;/li&gt;
        &lt;li&gt;하나의 엔드포인트에서 다양한 자원에 접근이 가능하다.&lt;/li&gt;
        &lt;li&gt;API 변경 시에도 클라이언트와의 호환성을 유지할 수 있다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;단점
      &lt;ul&gt;
        &lt;li&gt;복잡한 쿼리 로직이 많다면 서버 부하가 생길 수 있다.&lt;/li&gt;
        &lt;li&gt;GraphQL 스키마를 정의하고 유지관리하는데 추가적인 작업이 필요하다.
          &lt;h3 id=&quot;grpc&quot;&gt;gRPC&lt;/h3&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;구글에서 개발한 RemoteProcedureCall 프레임워크&lt;/li&gt;
    &lt;li&gt;고성능 통신을 위해서 프로토콜 버퍼를 사용해서 데이터를 직렬화 하고 비동기 통신을 지원한다.&lt;/li&gt;
    &lt;li&gt;마이크로서비스 간의 저지연, 고성능 통신을 위해서 사용된다.&lt;/li&gt;
    &lt;li&gt;HTTP/2 프로토콜 기반으로 작동한다.&lt;/li&gt;
    &lt;li&gt;장점
      &lt;ul&gt;
        &lt;li&gt;프로토콜 버퍼를 사용한 데이터 직렬화로 매우 빠른 데이터 전송이 가능&lt;/li&gt;
        &lt;li&gt;HTTP/2 기반으로 다중 요청 및 스트리밍을 지원해서 네트워크 효율이 뛰어남&lt;/li&gt;
        &lt;li&gt;언어에 구애받지 않음&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;단점
      &lt;ul&gt;
        &lt;li&gt;RESTful에 비해 상대적으로 복잡&lt;/li&gt;
        &lt;li&gt;브라우저에서 직접적으로 사용하기 어려움(프록시 서버가 필요)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;h2 id=&quot;b-버전-관리-전략&quot;&gt;b. 버전 관리 전략&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li&gt;여러 버전으로 존재해야 할 수도 있다.&lt;/li&gt;
    &lt;li&gt;기능이 추가되면서 기존 명세는 유지해야할 수도 있다.&lt;/li&gt;
    &lt;li&gt;이 경우 버전 관리가 중요하다.&lt;/li&gt;
    &lt;li&gt;URI, Header, Parameter 세 가지 종류가 있다.
      &lt;ol&gt;
        &lt;li&gt;URI: /v1/users
          &lt;ul&gt;
            &lt;li&gt;장점:
              &lt;ul&gt;
                &lt;li&gt;클라이언트가 명확하게 버전을 선택할 수 있다.&lt;/li&gt;
                &lt;li&gt;URL에 버전을 포함해서 쉽게 관리할 수 있다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
            &lt;li&gt;단점
              &lt;ul&gt;
                &lt;li&gt;여러 버전 API를 유지 관리해야해서 복잡할 수 있다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Header: API-Version: v1
          &lt;ul&gt;
            &lt;li&gt;장점:
              &lt;ul&gt;
                &lt;li&gt;URI를 변경하지 않고도 버전관리를 할 수 있다.&lt;/li&gt;
                &lt;li&gt;클라이언트가 헤더를 통해서 유연하게 API를 선택할 수 있다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
            &lt;li&gt;단점
              &lt;ul&gt;
                &lt;li&gt;클라이언트에 요청 헤더를 추가해야한다.&lt;/li&gt;
                &lt;li&gt;URI에 버전 명시가 없어서 가시성이 떨어진다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Parameter: ~?version=v1 // ~;version=1
          &lt;ul&gt;
            &lt;li&gt;장점:
              &lt;ul&gt;
                &lt;li&gt;클라이언트가 요청 파라미터로 버전을 쉽게 설정할 수 있다.&lt;/li&gt;
                &lt;li&gt;버전이 API 경로와는 별개로 관리되기 때문에 URI 설계에 영향을 주지 않는다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
            &lt;li&gt;단점:
              &lt;ul&gt;
                &lt;li&gt;URL이 복잡해질 수 있다. 파라미터를 일일이 관리해야 한다.&lt;/li&gt;
                &lt;li&gt;쿼리 또는 경로 파라미터가 없는 케이스를 처리해야 한다.&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 14 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 13.operateanddeploy</title>
        <link>/docker/wanted/2024/10/13/Wanted-Docker-series-13.OperateAndDeploy.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/13/Wanted-Docker-series-13.OperateAndDeploy.html</guid>
        <description>&lt;h1 id=&quot;클라우드-컴퓨팅과-서버-운영-및-배포&quot;&gt;클라우드 컴퓨팅과 서버 운영 및 배포&lt;/h1&gt;

&lt;h2 id=&quot;클라우드-컴퓨팅&quot;&gt;클라우드 컴퓨팅&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;탄력성&lt;/li&gt;
  &lt;li&gt;확장성&lt;/li&gt;
  &lt;li&gt;고가용성&lt;/li&gt;
  &lt;li&gt;비용 효율성&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클라우드-컴퓨팅-정의-및-개념&quot;&gt;클라우드 컴퓨팅 정의 및 개념&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;NIST가 정의한 클라우드 컴퓨팅
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-145.pdf&quot;&gt;NIST가 정의한 클라우드 컴퓨팅 특징&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;On-demand self-service: 사용자가 필요할 떄마다 언제든지 컴퓨팅 자원을 제공받을 수 있다.&lt;/li&gt;
  &lt;li&gt;Broad network access: 네트워크를 통해 다양한 장치에서 클라우드 서비스에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;Resource pooling: 여러 사용자 간에 컴퓨팅 자원을 동적으로 할당하여 효율적으로 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;Rapid elasticity: 필요한 자원을 신속하게 확장하거나 축소할 수 있다.&lt;/li&gt;
  &lt;li&gt;Measured service: 사용한 자원에 대해 측정하고, 이에 따라 요금을 부과한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;클라우드 컴퓨팅을 정의하는 5가지 주요 원칙
    &lt;ol&gt;
      &lt;li&gt;PooledComputingResources:
        &lt;ul&gt;
          &lt;li&gt;여러 사용자가 컴퓨팅 자원을 공유하며, 필요에 따라 자원이 동적으로 할당된다.&lt;/li&gt;
          &lt;li&gt;한 데이터 센터에서 여러 가상머신이 운영된다.&lt;/li&gt;
          &lt;li&gt;자원의 풀링을 통해 클라우드 서비스 제공자는 높은 자원 활용률을 달성하고 비용을 절감하며, 사용자의 다양한 요구를 충족시킬 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Virtualization of compute resources:
        &lt;ul&gt;
          &lt;li&gt;물리적인 자원을 가상화하여 여러 가상 컴퓨터로 분할한다.&lt;/li&gt;
          &lt;li&gt;한 서버에서 여러 개의 가상 서버가 동작하며 각각 다른 서비스를 제공한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Elasticity as resources demands grow and shrink:
        &lt;ul&gt;
          &lt;li&gt;자원의 수요에 따라 컴퓨팅 자원을 신속하게 확장하거나 축소할 수 있다.&lt;/li&gt;
          &lt;li&gt;트래픽이 급증할 떄 서버를 자동으로 추가하고 트래픽이 줄어들면 서버를 줄인다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Automation of new resources deployment:
        &lt;ul&gt;
          &lt;li&gt;새로운 컴퓨팅 자원을 자동으로 배포하고 관리한다.&lt;/li&gt;
          &lt;li&gt;새로운 애플리케이션 배포 시 자동으로 서버를 설정하고 네트워크를 구성한다.&lt;/li&gt;
          &lt;li&gt;자동화 도구는 인프라 관리의 복잡성을 줄이고, 배포 시간과 오류를 최소화하여 운영 효율을 높인다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Metered billing that charges only for what you use
        &lt;ul&gt;
          &lt;li&gt;사용한 자원에 대해 정확하게 측정하고, 이에 따라 요금을 부과한다.&lt;/li&gt;
          &lt;li&gt;사용한 컴퓨팅 시간, 데이터 저장소, 네트워크 대역폭 등에 따라 요금을 부과한다.&lt;/li&gt;
          &lt;li&gt;사용자는 실제로 사용한 만큼만 비용을 지불하고, 불필요한 비용을 절감할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;클라우드 컴퓨팅의 발전과 배경
    &lt;ul&gt;
      &lt;li&gt;발전 배경
        &lt;ul&gt;
          &lt;li&gt;1990: 초기 데이터센터 등장, 자체적으로 서버를 구축&lt;/li&gt;
          &lt;li&gt;2000 초반: 가상화 기술이 발전하면서 하나의 물리적 서버에서 여러 가상 서버를 운영할 수 있게 됨&lt;/li&gt;
          &lt;li&gt;2000 중반: AWS, GCP, AZURE 등의 클라우드 서비스 제공자들이 등장&lt;/li&gt;
          &lt;li&gt;2010: 클라우드 컴퓨팅이 주요 IT 인프라로 자리잡으면서 다양하 서비스와 기술이 개발됨&lt;/li&gt;
          &lt;li&gt;2020: 기업들은 단일 클라우드 제공자에 의존하지 않고, 여러 클라우드 제공자를 사용하는 멀티 클라우드 전략을 채택&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;현재 널리 적용되는 이유
        &lt;ol&gt;
          &lt;li&gt;유연성
            &lt;ul&gt;
              &lt;li&gt;필요할 때마다 자원을 확장하거나 축소할 수 있어 비즈니스 요구에 빠르게 대응 가능함&lt;/li&gt;
              &lt;li&gt;다양한 옵션으로 자원을 유연하게 관리&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;비용절감
            &lt;ul&gt;
              &lt;li&gt;초기 자본 투자 없이 사용한 만큼만 요금을 지불&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;글로벌 접근성
            &lt;ul&gt;
              &lt;li&gt;전 세계 어디서나 클라우드 서비스에 접근 가능함&lt;/li&gt;
              &lt;li&gt;글로벌 데이터 센터 네트워크를 통해 낮은 지여 시간과 높은 가용성을 제공함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;보안 및 규정 준수
            &lt;ul&gt;
              &lt;li&gt;클라우드 서비스 제공자는 고도하된 보안 및 규정 준수 서비스를 제공함&lt;/li&gt;
              &lt;li&gt;데이터 암호화, 접근 제어, 규정 준수 보고서 제공 등 다양한 보안 기능 제공을 통해서 데이터 보호&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;클라우드-환경에서-서버-운영-및-배포의-주요-단계&quot;&gt;클라우드 환경에서 서버 운영 및 배포의 주요 단계&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;계획 및 요구사항 수집: 프로젝트 목표 정의, 필요한 리소스와 서비스, 보안 요구사항 파악&lt;/li&gt;
  &lt;li&gt;아키텍쳐 설계: 클라우드 서비스 및 리소스를 활용해서 시스템 아키텍쳐 설계&lt;/li&gt;
  &lt;li&gt;인프라 구축: 설계된 아키텍쳐를 바탕으로 클라우드 리소스를 프로비저닝함
    &lt;ul&gt;
      &lt;li&gt;클라우드 리소스 생성&lt;/li&gt;
      &lt;li&gt;네트워크 구성&lt;/li&gt;
      &lt;li&gt;스토리지 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;애플리케이션 배포: 서버에 애플리케이션을 설치하고, 필요한 설정을 수행
    &lt;ul&gt;
      &lt;li&gt;애플리케이션 코드 배포&lt;/li&gt;
      &lt;li&gt;애플리케이션 설정 및 환경 변수 구성&lt;/li&gt;
      &lt;li&gt;의존성 설치 및 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안 설정: 클라우드 인프라와 애플리케이션의 보안을 강화함
    &lt;ul&gt;
      &lt;li&gt;IAM 정책 설정 및 역할 부여&lt;/li&gt;
      &lt;li&gt;네트워크 보안 그룹 및 ACL 구성&lt;/li&gt;
      &lt;li&gt;데이터 암호화 설정&lt;/li&gt;
      &lt;li&gt;보안 모니터링 및 로그 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모니터링 및 로깅: 서버 및 애플리케이션의 상태를 모니터링하고 로그를 수집하여 문제를 감지함
    &lt;ul&gt;
      &lt;li&gt;모니터링 도구 설정(cloudWatch, grafana)&lt;/li&gt;
      &lt;li&gt;알림 및 경고 설정(cloudWatch Alarms, SNS)&lt;/li&gt;
      &lt;li&gt;로그 수집 및 분석(cloudWatch Logs, ELK)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능 최적화: 시스템 성능을 분석하고, 필요한 최적화를 수행
    &lt;ul&gt;
      &lt;li&gt;애플리케이션 성능 프로파이링 및 분석&lt;/li&gt;
      &lt;li&gt;리소스 스케일링&lt;/li&gt;
      &lt;li&gt;데이터베이스 최적화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;백업 및 복구: 데이터를 주기적으로 백업하고, 복구 계획을 수립
    &lt;ul&gt;
      &lt;li&gt;백업 정책 설정&lt;/li&gt;
      &lt;li&gt;백업 데이터 검증 및 복구 테스트&lt;/li&gt;
      &lt;li&gt;재해 복구 계획 수립 및 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;업데이트 및 유지보수: 시스템 및 애플리케이션을 정기적으로 업데이트하고, 유지보수 작업 수행
    &lt;ul&gt;
      &lt;li&gt;시스템 및 애플리케이션 업데이트&lt;/li&gt;
      &lt;li&gt;보안 패치 적용&lt;/li&gt;
      &lt;li&gt;유지보수 작업 및 문제 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비용관리: 클라우드 리소스 사용량 모니터하고, 비용을 최적화함
    &lt;ul&gt;
      &lt;li&gt;비용 추적 및 분석&lt;/li&gt;
      &lt;li&gt;비용 절감 전략 수립&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라우드 컴퓨팅과 연관된 주요 개념&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;컨테이너(Container)
      &lt;ul&gt;
        &lt;li&gt;컨테이너 애플리케이션과 그 종속성을 하나의 패키지로 묶어 어디서나 일관되게 실행할 수 있도록 하는 가상화 기술&lt;/li&gt;
        &lt;li&gt;클라우드와의 연관성:
          &lt;ol&gt;
            &lt;li&gt;이식성: 컨테이너는 특정 클라우드 제공자에 종속되지 않고 다양한 클라우드 환경에서 동일하게 동작함&lt;/li&gt;
            &lt;li&gt;확장성: 컨테이너는 경량화되어 있어 빠르게 배포하고 확장할 수 있다. 클라우드 환경에서는 k8s와 같은 오케스트레이션 도구를 사용&lt;/li&gt;
            &lt;li&gt;효율성: 컨테이너는 가상 머신보다 자원을 효율적으로 사용&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;온프레미스(On-premise)
      &lt;ul&gt;
        &lt;li&gt;자체적으로 소유하고 운영하는 데이터 센터에서 애플리케이션을 실행하는 환경&lt;/li&gt;
        &lt;li&gt;클라우드와의 연관성:
          &lt;ol&gt;
            &lt;li&gt;비교: 온프레미스는 초기 자본 투자와 유지 관리 비용이 높으나, 클라우드는 사용한 만큼만 비용을 지불&lt;/li&gt;
            &lt;li&gt;하이브리드 클라우드: 온프레미스랑 클라우드를 결합하여 하이브리드 클라우드를 구축&lt;/li&gt;
            &lt;li&gt;데이터 주권 및 규제 준수: 온프레미스 환경은 데이터 주권 및 규제 준수 요건을 충족하는데 유리하다.&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;스케일링(Scaling)
      &lt;ul&gt;
        &lt;li&gt;스케일링은 시스템의 처리 능력을 증가시키거나 감소하는 과정&lt;/li&gt;
        &lt;li&gt;클라우드와 연관성
          &lt;ol&gt;
            &lt;li&gt;수평: 서버, 인스턴스를 추가하여 처리 능력을 확장하는 방식&lt;/li&gt;
            &lt;li&gt;수직: 기존 서버나 인스턴스의 자원을 업그레이드하는 방식&lt;/li&gt;
            &lt;li&gt;자동: 자동 스케일링을 클라우드 서비스 제공자가 제공하며, 트래픽 변화에 따라 자원을 자동으로 조정&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;가상화(Virtualization)
      &lt;ul&gt;
        &lt;li&gt;물리적인 하드웨어 자원을 소프트웨어적으로 분리하여 여러 개의 가상 환경을 생성하는 기술&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;가상머신(VirtualMachine)
      &lt;ul&gt;
        &lt;li&gt;가상화 기술을 통해서 생성된 독립적인 운영 환경이다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;가상화와 가상 머신
      &lt;ul&gt;
        &lt;li&gt;가상화 기술: 가상 머신을 생성하고 관리하는데 생성(VMWare, Hyper-V, KVM)&lt;/li&gt;
        &lt;li&gt;장점
          &lt;ul&gt;
            &lt;li&gt;자원 활용도&lt;/li&gt;
            &lt;li&gt;유연성&lt;/li&gt;
            &lt;li&gt;격리성&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;가상머신과 클라우드의 연관성
          &lt;ul&gt;
            &lt;li&gt;클라우드의 핵심 기술: 가상화는 클라우드의 핵심이다. 클라우드 제공자는 가상화 기술로 물리적 서버를 논리적으로 나눠서 제공&lt;/li&gt;
            &lt;li&gt;유연한 자원 관리: 클라우드 환경에서는 가상 머신을 필요에 따라 쉽게 생성, 삭제, 이동할 수 있다. 이는 기업이 변화하는 비즈니스 요구에 빠르게 대응할 수 있도록 도와준다.&lt;/li&gt;
            &lt;li&gt;비용 효율성: 가상화는 자원을 효율적을으로 사용하므로 비용을 절감할 수 있다.&lt;/li&gt;
            &lt;li&gt;고가용성: 클라우드 환경에서는 가상 머신을 여러 데이터 센터에 분산해서 고가용성을 제공한다. 예를 들어 여러 가용 영역(AZ)에 걸쳐 인스턴스를 배치하여 하나의 AZ에 문제가 발생했을 경우 서비스를 유지할 수 있다.&lt;/li&gt;
            &lt;li&gt;복원력: 클라우드 환경에서는 데이터 백업 및 복구가 용이하다. 가상머신의 스냅샷을 통해서 데이터를 백업하고 필요 시 복원할 수 있다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IaaS: 인프라 제공, 유연성 높음, 설정과 관리가 필요&lt;/li&gt;
  &lt;li&gt;PaaS: 개발 환경 제공, 개발 편의성 높음, 플랫폼 제한 가능성&lt;/li&gt;
  &lt;li&gt;SaaS: 소프트웨어 제공, 사용자 편의성 높음, 커스터마이징 제한적&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;1-iaas&quot;&gt;1. IaaS&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;IaaS는 가상화된 컴퓨팅 자원을 제공하는 서비스 모델&lt;/li&gt;
    &lt;li&gt;사용자는 인프라 자원을 인터넷을 통해서 제공받는다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;2-paas&quot;&gt;2. PaaS&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;애플리케이션 개발 및 실행 환경을 제공하는 모델&lt;/li&gt;
    &lt;li&gt;개발자는 인프라 관리 없이 애플리케이션 개발, 테스트, 배포에 집중할 숭 ㅣㅆ다.
      &lt;ul&gt;
        &lt;li&gt;Aws ElasticBeanstalk&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;3-saas&quot;&gt;3. SaaS&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;인터넷을 통해 소프트웨어 애플리케이션을 제공하는 모델&lt;/li&gt;
    &lt;li&gt;설치 없이 브라우저를 통해 애플리케이션을 사용할 수 있다.&lt;/li&gt;
  &lt;/ul&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;publicCloud: 여러 사용자가 공유, 비용 효율적&lt;/li&gt;
  &lt;li&gt;privateCloud: 특정 조직 전용, 보안 및 규정 준수 용이&lt;/li&gt;
  &lt;li&gt;hybridCloud: 공개 + 사설 겹합, 유연성 및 통합성이 높다.&lt;/li&gt;
  &lt;li&gt;multicloud: 여러 클라우드 사용, 리스크 분산 및 최적화 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;1-public&quot;&gt;1. Public&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;공개 클라우드는 여러 사용자가 공유하는 물리적 서버에서 가상화된 자원을 제공하는 클라우드 모델임&lt;/li&gt;
    &lt;li&gt;서비스 제공자가 인프라를 소유하고, 사용자는 인터넷을 통해 자원을 이용
      &lt;h3 id=&quot;2-private&quot;&gt;2. Private&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;사설 클라우드는 특정 조직을 위해 전용으로 제공되는 클라우드를 결합한 모델이다.&lt;/li&gt;
    &lt;li&gt;워크로드를 유연하게 이동시키고, 데이터와 애플리케이션을 통합할 수 있다.
      &lt;h3 id=&quot;3-hybrid&quot;&gt;3. Hybrid&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;공개 클라우드와 사설 클라우드를 결합한 모델&lt;/li&gt;
    &lt;li&gt;워크로드를 유연하게 이동시키고, 데이터와 애플리케이션을 통합할 수 있다.
      &lt;h3 id=&quot;4-멀티-클라우드&quot;&gt;4. 멀티 클라우드&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;여러 클라우드 서비스 제공자의 인프라와 서비스를 함께 사용하는 모델&lt;/li&gt;
    &lt;li&gt;단일 제공자에 종속되지 않으면서 각 클라우드의 강점을 활용할 수 있다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;클라우드-컴퓨팅의-이점-및-고려사항&quot;&gt;클라우드 컴퓨팅의 이점 및 고려사항&lt;/h2&gt;
&lt;h3 id=&quot;이점&quot;&gt;이점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;반응성 증가: 필요에 따라 자원을 신속하게 할당, 해제 가능&lt;/li&gt;
  &lt;li&gt;비용 절감: 초기 인프라 구축 비용을 줄이고 사용한 만큼만 비용을 지불&lt;/li&gt;
  &lt;li&gt;유연성: 다양한 OS, 언어, 도구를 지원&lt;/li&gt;
  &lt;li&gt;확장성: 필요에 따라 컴퓨팅 자원을 확장하거나 축소할 수 있다.&lt;/li&gt;
  &lt;li&gt;가용성, 안정성: 높은 가용성, 안정성을 제공하여, 시스템이 항상 접근 가능하고 중단 없이 운영될 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;고려-사항&quot;&gt;고려 사항&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;보안: 애플리케이션의 보안을 위해서 다양한 보안 조치와 정책을 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;데이터 관리: 클라우드 환경에서 데이터 저장, 백업, 복구 등을 효과적으로 관리&lt;/li&gt;
  &lt;li&gt;규제준수: 각종 법적 규제와 산업 표준을 준수하기 위해 필요한 조치를 취해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;위험과-과제&quot;&gt;위험과 과제&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;신뢰 경계 중복으로 인한 취약성 증가: 클라우드 환경에서는 여러 사용자가 동일한 인프라를 공유하므로, 신뢰 경게가 중복될 수 있다.&lt;/li&gt;
  &lt;li&gt;공유된 보안 책임으로 인한 취약성 증가: 클라우드 제공자와 사용자가 보안을 공동으로 책임지므로, 책임 분담이 명확하지 않을 수 있다.&lt;/li&gt;
  &lt;li&gt;사이버 위협에 대한 노출 증가: 인터넷을 통해 접근 가능하므로, 사이버 공격에 노출될 수 있다.&lt;/li&gt;
  &lt;li&gt;운영 관리 통제의 감소: 클라우드 제공자가 인프라를 관리하므로, 사용자가 직접적인 운영 관리를 수행하기 어려움 (클라우드 제공자의 SLA(서비스 수준 협약)을 명확히 한다.)&lt;/li&gt;
  &lt;li&gt;클라우드 제공자 간의 제한된 이동성: 클라우드 제공자 간의 상호 운용성이 부족하여, 한 제공자에서 다른 제공자로 이동이 어려움&lt;/li&gt;
  &lt;li&gt;다중 지역 규제 및 법적 문제: 클라우드 서비스를 여러 지역에서 사용할 경우, 각 지역의 법적 규제와 준수 요구 사하잉 달라진다.&lt;/li&gt;
  &lt;li&gt;비용 초과: 사용량이 예측을 초과할 경우, 높은 발생이 발생할 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;serverless&quot;&gt;Serverless&lt;/h2&gt;
&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;서버 관리를 신경 쓸 필요가 없음&lt;/li&gt;
  &lt;li&gt;자동 스케일링&lt;/li&gt;
  &lt;li&gt;사용한 만큼만 비용 지불&lt;/li&gt;
  &lt;li&gt;주요 서비스
    &lt;ul&gt;
      &lt;li&gt;AWS Lambda&lt;/li&gt;
      &lt;li&gt;Azure Functions&lt;/li&gt;
      &lt;li&gt;GCP Functions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;서버 관리 불필요&lt;/li&gt;
  &lt;li&gt;자동 확장성&lt;/li&gt;
  &lt;li&gt;비용 효율성&lt;/li&gt;
  &lt;li&gt;빠른 개발 및 배포&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;ColdStart&lt;/li&gt;
  &lt;li&gt;상태 저장이 어려움&lt;/li&gt;
  &lt;li&gt;제한된 제어: 서버, 네트워크에 대한 세부 설정, 제어가 어렵기에 맞춤형 시스템에는 적합하지 않음&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 13 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 12.architecture</title>
        <link>/docker/wanted/2024/10/12/Wanted-Docker-series-12.Architecture.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/12/Wanted-Docker-series-12.Architecture.html</guid>
        <description>&lt;h1 id=&quot;아키텍쳐&quot;&gt;아키텍쳐&lt;/h1&gt;

&lt;h2 id=&quot;고려사항&quot;&gt;고려사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 수가 얼마나 되는가?&lt;/li&gt;
  &lt;li&gt;얼마나 성장할 것인가?&lt;/li&gt;
  &lt;li&gt;기술 스택이 무엇인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-전&quot;&gt;설계 전&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;시스템에서 전반적으로 달성해야 할 목표와 가능 범위 확인&lt;/li&gt;
  &lt;li&gt;전체 설계의 개략적 청사진 마련&lt;/li&gt;
  &lt;li&gt;상세 설계에서 집중해야 할 영역들 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목표-설정&quot;&gt;목표 설정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 아키텍쳐 설계는 명확한 목표를 설정하는 것이 중요하다.&lt;/li&gt;
  &lt;li&gt;잘못된 목표를 설정하면 시스템 성능, 보안, 확장성에 큰 영향을 준다.&lt;/li&gt;
  &lt;li&gt;서비스 소준 목표(SLO): 서비스가 충족해야 할 성능, 가용성, 응답 시간 등의 구체적 기준을 정의&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SLA  -&amp;gt; the agreement you make with your clients or users
SLOs -&amp;gt; the objectives your team must hit to meet that agreement
SLIs -&amp;gt; the real numbers on your performance&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;안정성-확장성-신뢰성을-고려한-아케텍쳐-설계&quot;&gt;안정성, 확장성, 신뢰성을 고려한 아케텍쳐 설계&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안정성
    &lt;ul&gt;
      &lt;li&gt;장시간동안 중단 없이 동작할 수 있도록 보장하는 것이 목표다.&lt;/li&gt;
      &lt;li&gt;이를 위해서 장애를 감지하고 복구하는 기능이 있어야 한다.&lt;/li&gt;
      &lt;li&gt;회복력 있는 아키텍쳐(Self-Healing이 가능한)로 안정성을 도모한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장성
    &lt;ul&gt;
      &lt;li&gt;더 많은 사용자를 수용하거나 데이터 처리량을 증가시킬 수 있도록 설계되어야 함&lt;/li&gt;
      &lt;li&gt;수직 vs. 수평 -&amp;gt; ScaleUp vs. ScaleOut
        &lt;ol&gt;
          &lt;li&gt;유연한 리소스 확장
            &lt;ul&gt;
              &lt;li&gt;수평 확장은 상대적으로 저렴한 서버나 인스턴스를 여러 대 추가하여 성능을 높일 수 있기에 비용 대비 성능 효율성이 높다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;비용 효율성
            &lt;ul&gt;
              &lt;li&gt;수직 확장은 자체 Spec을 올려서 성능을 향상시키는 방식이다. 고사양으로 가면 갈수록 단가가 높아진다.&lt;/li&gt;
              &lt;li&gt;수평 확장은 클라우드 특성인 탄력성을 극대화할 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;고가용성
            &lt;ul&gt;
              &lt;li&gt;수평 확장을 사용하면 여러 대의 서버에 트래픽을 분산할 수 있다.(고가용성)&lt;/li&gt;
              &lt;li&gt;로드밸런서를 통해 트래픽을 여러 서버로 분산시키고 하나가 장애가 발생해도 자동 복구와 장애 서버 대체가 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;무중단 서비스 운영
            &lt;ul&gt;
              &lt;li&gt;수평 확장은 시스템을 확장하면서도 무중단 배포가 가능하게 해줌(blue-green/ canary)&lt;/li&gt;
              &lt;li&gt;수직 확장에는 서버 업그레이드나 재시작 시 서비스가 중단될 수 있다.&lt;/li&gt;
              &lt;li&gt;수평 확장은 서버 교체가 유연하다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;클라우드 네이티브 애플리케이션에 적합
            &lt;ul&gt;
              &lt;li&gt;클라우드 네이티브 애플리케이션은 분산 시스템을 기반으로 설계되기에 수평확장이 더 자연스럽고 효율적이다.&lt;/li&gt;
              &lt;li&gt;마이크로 서비스 아키텍쳐를 사용해서 각 서비스가 독립적으로 확장될 수 있다.&lt;/li&gt;
              &lt;li&gt;각 서비스가 컨테이너화되어 있고, 이러한 컨테이너를 여러 대 실행해서 부하 분산을 시킬 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;성능 병목 해결
            &lt;ul&gt;
              &lt;li&gt;수직 확장은 물리적 자원의 한계에 도달할 수 있다.&lt;/li&gt;
              &lt;li&gt;수평 확장은 병목이 발생하는 구간에만 추가 리소스를 투입할 수 있어서 각 구성요소가 필요에 따라 확장할 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;글로벌 확장에 유리
            &lt;ul&gt;
              &lt;li&gt;수평 확장은 글로벌 서비스가 적합&lt;/li&gt;
              &lt;li&gt;CDN과 결합하면 더 좋다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;시스템의 데이터 무결성, 일관성을 유지하는 것이 목표다.&lt;/li&gt;
      &lt;li&gt;데이터 복제, 분산 DB는 데이터 손실 방지를 보장한다.&lt;/li&gt;
      &lt;li&gt;장애 복구전략: 장애 발생 시 데이터 손실을 방지하기 위한 복구 계획이 필수적이다.&lt;/li&gt;
      &lt;li&gt;지리적 복제: 데이터를다른 리전에 복제할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클라우드-기반-시스템-설계-시-고려-사항&quot;&gt;클라우드 기반 시스템 설계 시 고려 사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자동화: 리소스 프로비저닝, 스케일링, 모니터링을 자동화하여 사람이 개입하지 않고도 원활히 운영될 수 있음&lt;/li&gt;
  &lt;li&gt;보안: 클라우드 시스템에서는 데이터 암호화, 접근 제어와 같은 보안 조치가 필수. 민감한 데이터 처리 시, 규정 준수도 중요&lt;/li&gt;
  &lt;li&gt;비용 관리: 클라우드 리소스는 사용량에 따라 비용이 발생하므로, 불필요한 자원 낭비를 줄이고 최적의 성능을 제공하면서도 비용을 최소화하는 아키텍쳐 설계가 중요&lt;/li&gt;
  &lt;li&gt;트래픽 관리: 로드 밸런싱, 오토스케일링을 통해서 클라우드 트래픽 증가에 대비해야 하며, 이를 통해 시스템 성능을 유지하고 트래픽 급증에도 서비스가 안정적으로 운영될 수 있도록 해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-아키텍쳐-유형&quot;&gt;시스템 아키텍쳐 유형&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/System-Architectures1.png&quot; alt=&quot;System-Architectures1.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Integrated
    &lt;ul&gt;
      &lt;li&gt;FitForPurpose(규모 확장에 적합): 통합형 시스템은 특정 목적을 당성하기 위해 설계된 아키텍쳐. 모든 요소가 서로 통합되어 작동하며, 각 워크로드에 맞게 개별적으로 조정됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributed
    &lt;ul&gt;
      &lt;li&gt;FitForScale(규모 확장에 적합): 분산형 아키텍쳐는 여러 서버와 자원들이 문산위어 운영됨으로써 수평확장이 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pooled
    &lt;ul&gt;
      &lt;li&gt;FitForEfficiency(효율에 적합): 풀링 아키텍쳐는 여러 자원을 하나의 풀로 모아 효율적으로 자원을 공유하고 관리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Converged
    &lt;ul&gt;
      &lt;li&gt;FitForAgility(유연성에 적합): 융합형 아키텍쳐는 다양한 IT 자원을 통합하여, 필요에 따라 쉽게 자원을 추가하거나 제거할 수 있는 유연한 구조다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;더-나은-아키텍쳐-설계&quot;&gt;더 나은 아키텍쳐 설계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;더 나은 아키텍쳐는 상황에 맞는 유연성을 기반으로 시스템 안정성과 확장성을 동시에 고려해야 한다.&lt;/li&gt;
  &lt;li&gt;초기 단계에서 과도한 리소스 투자는 피하고, 필요할 때 필요한 만큼만 확장하는 전략을 통해 효율적인 운영을 가능하게 함&lt;/li&gt;
  &lt;li&gt;오버 엔지니어링, 언더 엔지니어링을 피하고, 적절한 엔지니어링을 통해서 서비스 성장을 뒷받침하는 것이 중요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-서비스-운영-방식에-적합한-더-나은-아키텍쳐&quot;&gt;1. 서비스 운영 방식에 적합한 더 나은 아키텍쳐&lt;/h3&gt;

&lt;h4 id=&quot;개발자-관점의-필수-요소&quot;&gt;개발자 관점의 필수 요소&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;단순히 복잡하고 최신 기술 도입이 아니라, 실제 서비스 운영 환경에 맞춰서 효율적인 솔루션을 제공하는 아키텍쳐&lt;/li&gt;
  &lt;li&gt;최선의 성능과 기능을 위해 복잡한 아키텍쳐를 선호할 수 있지만, 서비스의 실질적 요구와 비용, 유지보수성 등을 고려한 아키텍처 선택이 중요&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;오버엔지니어링-언더엔지니어링&quot;&gt;오버엔지니어링, 언더엔지니어링&lt;/h4&gt;
  &lt;ul&gt;
    &lt;li&gt;오버엔지니어링(over-engineering) : 서비스 요구 사항에 비해 지나치게 복잡한 시스템을 설계하는 것을 의미한다. (유지보수 비용을 증가시키고 비효율성을 초래할 수 있다.)&lt;/li&gt;
    &lt;li&gt;언더엔지니어링(under-engineering) : 서비스 확장 가능성을 충분히 고려하지 않고 최소한의 아키텍쳐만을 설계하는 경우 (확장될 때 발 빠르게 대응하지 못함)&lt;/li&gt;
  &lt;/ul&gt;

&lt;/blockquote&gt;

&lt;h4 id=&quot;사용자-관점의-병목-방지&quot;&gt;사용자 관점의 병목 방지&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;더 나은 아키텍쳐는 사용자 경험을 최우선으로 하여 bottleneck을 최소화하는 데 중점을 둔다.&lt;/li&gt;
  &lt;li&gt;서비스 성장에 따라 문제가 발생할 수 있는 부분을 예측하고, 이를 대비한 설계를 통해 병목을 방지하는 것&lt;/li&gt;
  &lt;li&gt;네트워크 트래픽 분산, 데이터베이스 최적화, 캐싱 전략등을 통해 성능 극대화하면서도 복잡해지지 않도록 해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-일반적인-케이스에서-고려할-점&quot;&gt;2. 일반적인 케이스에서 고려할 점&lt;/h3&gt;

&lt;h4 id=&quot;엔지니어링-관점에서&quot;&gt;엔지니어링 관점에서&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;안정적인 서비스를 운영하기 위해서 기본적으로 로드 밸런서, 캐싱, DB 복제 등을 통해 시스템 안정성을 확보해야 한다.&lt;/li&gt;
  &lt;li&gt;성능 모니터링 도구와 자동화된 테스트 환경을 구축하여 실시간으로 성능을 추적하고, 장애나 성능 저하가 발생할 경우 즉각적으로 대응할 수 있는 시스템을 갖추는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;유연한-아키텍처의-필요성&quot;&gt;유연한 아키텍처의 필요성&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;더 나운 아키텍쳐는 유연성이 핵심이다.&lt;/li&gt;
  &lt;li&gt;모든 서비스가 복잡한 클러스터링이나 오토스케일링을 필요로 하지는 않으며, 서비스의 성장 단계와 요구사항에 따라 필요한 리소스를 점진적으로 추가하는 방식이 가장 효율적&lt;/li&gt;
  &lt;li&gt;초기 단계에서는 간단하게, 서비스 확장되거나 트래픽이 증가할 때 점진적으로 인프라를 확장하는 방식이 비용 효율적&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;초기-단계에서&quot;&gt;초기 단계에서&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;과도한 오토스케일링, 클러스터링은 솔직히 필요 없음&lt;/li&gt;
  &lt;li&gt;서비스 안정화 이후 리소스를 추가하는 방식으로 확장하는 것이 합리적&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;h2 id=&quot;sloservice-level-objective-측정-방법&quot;&gt;SLO(Service Level Objective) 측정 방법&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li&gt;SLO는 서비스 성능과 가용성 등 운영 목표를 정략적으로 측정하는 기준이다.&lt;/li&gt;
    &lt;li&gt;따라서 정확하게 측정하는 방법이 중요하다.&lt;/li&gt;
    &lt;li&gt;SLO를 측정하기 위해서는 서비스가 정의한 목표에 대한 데이터를 지속적으로 수집하고 분석해야 한다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;slo-측정-프로세스&quot;&gt;SLO 측정 프로세스&lt;/h3&gt;
  &lt;ol&gt;
    &lt;li&gt;측정할 SLO 항목 정의
      &lt;ul&gt;
        &lt;li&gt;서비스에 중요한 성능 지표를 정의&lt;/li&gt;
        &lt;li&gt;SLO는 가용성, 응답시간, 오류율 드의 항목으로 나눌 수 있다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;메튜릭 수집 도구 사용
      &lt;ul&gt;
        &lt;li&gt;SLO 측정을 위해서 성능 데이터를 자동으로 수집하고 저장하는 도구가 필요하다. 일반적으로 모니터링 도구나 애플리케이션 성능 관리(APM) 도구를 사용&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;SLO 성능 데이터 분석
      &lt;ul&gt;
        &lt;li&gt;수집된 데이터를 기반으로, 정의된 SLO 기준에 맞춰 서비스가 목표를 달성하고 있는지 분석&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;SLO 성과 대시보드 구축
      &lt;ul&gt;
        &lt;li&gt;Grafana, Kibana 같은 시각화 도구를 사용하여 SLO 성과를 모니터링하는 대시보드를 구축한다.&lt;/li&gt;
        &lt;li&gt;실시간으로 SLO 목표 달성 여부를 확인하고, 이상 발생시 신속하게 대응할 수 있다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;경고 설정 및 자동화
      &lt;ul&gt;
        &lt;li&gt;SLO 준수하지 못할 경우 알림을 받을 수 있는 경고 시스템을 설정&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;주기적인 SLO 리뷰 및 조정
      &lt;ul&gt;
        &lt;li&gt;서비스가 발전하거나 사용자 요구가 변화할 경우, SLO도 주기적으로 리뷰하고 조정해야 한다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;클라우드-시스템에서-보안-및-규정-준수&quot;&gt;클라우드 시스템에서 보안 및 규정 준수&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;데이터 보호&lt;/li&gt;
  &lt;li&gt;규정 준수: 각국의 규정은 데이터 보호와 보안에 대한 강력한 요구사항을 규정한다. 클라우드 사용 기업은 GDPR, HIPAA 등을 준수해야 한다.&lt;/li&gt;
  &lt;li&gt;서비스의 신뢰성: 보안 사고는 기업의 신뢰성을 손상시킬 수 있다. 신뢰성의 문제다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 12 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 11.manifest</title>
        <link>/docker/wanted/2024/10/11/Wanted-Docker-series-11.Manifest.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/11/Wanted-Docker-series-11.Manifest.html</guid>
        <description>&lt;h1 id=&quot;manifest&quot;&gt;Manifest&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;k8s 리소스를 정의하는 템플릿 역할을 한다. 이를 통해 개발자는 어떻게 배포되고 실행되어야 하는지 지시할 수 있다.&lt;/li&gt;
  &lt;li&gt;Pod, Deployment, Service, ConfigMap 등 다양한 리소스를 YAML 형식으로 정의하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl apply&lt;/code&gt;로 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#apiVersion (v1: 기본적인 리소스, apps/v1: Deployement와 같은 리소스)&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#resourceKind (Pod, Deployment, Service, ConfigMap)&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#resourceName (리소스 고유 이름)&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# (리소스에 추가적인 정보 제공)&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#detail (어떻게 동작해야 하는지를 정의)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-configmap&quot;&gt;참고) ConfigMap&lt;/h2&gt;
&lt;h3 id=&quot;1-특징&quot;&gt;1. 특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;설정과 코드의 분리&lt;/li&gt;
  &lt;li&gt;Key-Value 쌍으로 구성&lt;/li&gt;
  &lt;li&gt;다양한 용도로 사용&lt;/li&gt;
  &lt;li&gt;리소스 경량성&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-사용-이유&quot;&gt;2. 사용 이유&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;유연한 환경 설정 관리:
    &lt;ul&gt;
      &lt;li&gt;환경설정을 하드코딩하지 않고 ConfigMap을 통해서 전달&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;환경에 따른 설정 분리:
    &lt;ul&gt;
      &lt;li&gt;개발, 테스트 프로덕션 환경에서 각각 다른 설정을 적용할 때 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;애플리케이션의 유지보수성 향상
    &lt;ul&gt;
      &lt;li&gt;코드와 설증을 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 설정 관리
    &lt;ul&gt;
      &lt;li&gt;여러 Pod나 Deployment에서 동일한 설정을 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;configmap-vs-secret&quot;&gt;ConfigMap vs. Secret&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;configMap: 일반적인 설정 데이터&lt;/li&gt;
  &lt;li&gt;secret: 민감한 데이터&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 11 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 10.kubernetesresources</title>
        <link>/docker/wanted/2024/10/10/Wanted-Docker-series-10.KubernetesResources.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/10/Wanted-Docker-series-10.KubernetesResources.html</guid>
        <description>&lt;h1 id=&quot;resources&quot;&gt;Resources&lt;/h1&gt;

&lt;h2 id=&quot;pod-service-deployment-replicaset&quot;&gt;Pod, Service, Deployment, ReplicaSet&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Pod: 컨테이너의 실행 단위, 가장 작은 배포 단위&lt;/li&gt;
  &lt;li&gt;ReplicaSet: 틀정 개수의 Pod가 항상 실행되도록 보장&lt;/li&gt;
  &lt;li&gt;Deployment: Pod와 ReplicaSet을 관리하며, 애플리케이션 상태를 정의하고, 무중단 업데이트, 롤백 등의 기능을 제공&lt;/li&gt;
  &lt;li&gt;Service: Pod의 네트워크 접근을 관리하고, 로드 밸런싱 및 고정된 네트워크 엔드포인트를 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pod&quot;&gt;Pod&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;배포되고 관리되는 가장 작은 단위, 컨테이너들의 논리적 그룹&lt;/li&gt;
  &lt;li&gt;주요 특징:
    &lt;ul&gt;
      &lt;li&gt;단일 컨테이너 또는 여러 컨테이너로 구성될 수 있다.&lt;/li&gt;
      &lt;li&gt;Pod 내 모든 컨테이너는 같은 네트워크 IP 주소를 공유한다.&lt;/li&gt;
      &lt;li&gt;짧은 생명 주기를 가지며, Pod 자체는 불안정하고 휘발성임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추가 사항 : 주 컨테이너, 사이드카 컨테이너가 하나의 Pod로 묶이는 경우가 많음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service&quot;&gt;Service&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/service.png&quot; alt=&quot;service.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스는 Pod들의 네트워크 접근을 관리&lt;/li&gt;
  &lt;li&gt;Pod의 수명에 의한 가변성을 추상화&lt;/li&gt;
  &lt;li&gt;Pod가 생성되거나 종료되더라도 항상 고정된 네트워크 접근을 제공하며, Pod에 대한 네트워크 요청을 로드밸런식하여 효율적으로 관리함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;주요-특징&quot;&gt;주요 특징&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;고정된 IP 주소와 DNS 이름 제공
    &lt;ul&gt;
      &lt;li&gt;k8s Pod는 생성될 때마다 새로운 IP를 할당 받음&lt;/li&gt;
      &lt;li&gt;서비스는 이런 Pod의 특성과 달리 고정된 IP, DNS를 제공하며 일관된 네트워크 접근을 가능하게 한다.&lt;/li&gt;
      &lt;li&gt;DNS 기반 서비스 디스커버리를 사용하며, 고정된 DNS 이름을 통해 다른 서비스를 접근할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라벨 셀렉터
    &lt;ul&gt;
      &lt;li&gt;서비스틑 라벨 셀렉터를 사용하여, 특정 레이블을 가진 Pod들을 자동으로 찾고 이를 백엔드로 연결&lt;/li&gt;
      &lt;li&gt;Label은 Pod와 같은 k8s 리소스를 태그를 추가해서 관리하는 방식이다.&lt;/li&gt;
      &lt;li&gt;서비스는 이 라벨을 기준으로 Pod를 그룹화하고, 트래픽을 해당 그룹에 전달한다.&lt;/li&gt;
      &lt;li&gt;애플리케이션 업데이트 시에도 서비스는 새로운 Pod로 자동으로 트래픽을 라우팅할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클러스터 내부 및 외부 서비스
    &lt;ul&gt;
      &lt;li&gt;클러스터 내부 또는 외부 네트워크에서 접근 가능하도록 설정할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;ClusterIP : 클러스터 내부에서만 접근 가능한 IP&lt;/li&gt;
          &lt;li&gt;NodePort : 각 노드의 고정도니 포트를 열어서 외부에서 노드 IP와 포트를 통해서 직접 접근 가능하게 한다.&lt;/li&gt;
          &lt;li&gt;LoadBalancer : 클라우드 제공자의 로드밸런서를 자동으로 설정하여 외부 클라이언트가 서비스에 접근할 수 있도록 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로드 밸런싱
    &lt;ul&gt;
      &lt;li&gt;서비스는 Pod의 네트워크 요청을 로드밸런싱하여 트래픽을 효율적으로 분산한다.&lt;/li&gt;
      &lt;li&gt;동일한 서비스를 제공하는 여러 Pod로 트래픽이 균등하게 분배되어 과도한 부하가 걸리는 것을 방지&lt;/li&gt;
      &lt;li&gt;외부 로드밸런서와 k8s의 내부 로드밸런서가 협력하여 트래픽으 ㄹ최저고하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;서비스-타입&quot;&gt;서비스 타입&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;ClusterIP
    &lt;ul&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;기본 서비스 타입: 기본적으로 설정되는 서비스 타입으로 외부에서 접근할 수 없고 클러스터 내부의 다른 Pod이 서비스에 연결할 수 있도록 설정한다.&lt;/li&gt;
          &lt;li&gt;내부 통신에 최적화 : 애플리케이션 간 내부 통신을 위해서 설계됐다.&lt;/li&gt;
          &lt;li&gt;DNS 이름 제공 : ClusterIP는 서비스의 고정된 IP 주소와 DNS 이름을 제공한다. Pod가 클러스터 내에서 서비스를 발견하고 통신할 수 있도록 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NodePort
    &lt;ul&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;고정된 포트 사용 : 30000 ~ 32767&lt;/li&gt;
          &lt;li&gt;클래스터 내 모든 노드에서 접근 가능 : 모든 노드에서 동일한 포트가 열리며, 외부 클라이언트는 클러스터의 어떤 노드 IP를 통해서도 해당 포트로 접근이 가능&lt;/li&gt;
          &lt;li&gt;ClusterIP 서비스와 연결: NodePort는 내부적으로 ClusterIP를 생성하며, 외부에서 온 트래픽은 ClusterIP를 통해서 전파된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LoadBalancer
    &lt;ul&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;외부 트래픽 노출: LoadBalancer는 외부에서 애플리케이션에 접근할 수 있도록 클라우드에서 관리되는 로드 밸런서를 생성한다. PublicIP를 제공하며, 외부 클라이언트가 서비스에 접속할 수 있게 한다.&lt;/li&gt;
          &lt;li&gt;트래픽 분산: 여러 노드의 Pod로 분산하여 애플리케이션의 부하를 효율적으로 처리&lt;/li&gt;
          &lt;li&gt;NodePort, ClusterIP와 연동 : LoadBalancer는 NordPort 및 ClusterIP를 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;deployment&quot;&gt;Deployment&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Pod와 ReplicaSet을 관리하는 상위 개념으로, 애플리케이션의 상태를 정의하고 무중단 배포, 업데이트, 롤백 등의 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;지속적 배포를 위해서 사용되며, k8s 클러스터에서 애플리케이션의 버전 관리와 확장을 자동화한다.&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;Deployment를 통해 Pod와 ReplicaSet을 정의할 수 있다.&lt;/li&gt;
      &lt;li&gt;Deployment에서 Pod의 template을 정의하고 Pod가 몇 개의 복제본으로 실행될지 설정할 수 있다.&lt;/li&gt;
      &lt;li&gt;RollingUpdate를 통해서 점진적으로 업데이트 할 수 있다.&lt;/li&gt;
      &lt;li&gt;Rollback을 할 수 있다.&lt;/li&gt;
      &lt;li&gt;자동 확장을 설정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;replicaset&quot;&gt;ReplicaSet&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 개수의 Pod가 항상 실행 중임을 보장하는 k8s 리소스&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;실행할 Pod의 수를 설정할 수 있으며, ReplicaSet은 이 설정을 기반으로 Pod의 수를 자동으로 조정&lt;/li&gt;
      &lt;li&gt;Pod가 실패하거나 종료되면 ReplicaSet이 이를 감지하고, 새로운 Pod를 생성하여 DesiredState를 유지&lt;/li&gt;
      &lt;li&gt;Deployment에 의해 자동으로 생성되며, 사용자가 직접 ReplicaSet을 생성할 필요는 거의 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관계성&quot;&gt;관계성&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Deployment는 사용자가 애플리케이션의 상태를 정의하는 리소스 ReplicaSet을 생성하며 복제된 Pod가 항상 정의된 수만큼 실행되도록 보장&lt;/li&gt;
  &lt;li&gt;ReplicaSet: 복제된 Pod가 항상 정의된 수만큼 실행되도록 보장&lt;/li&gt;
  &lt;li&gt;Pod: 컨테이너의 실행 단위&lt;/li&gt;
  &lt;li&gt;Service: Pod들이 동적으로 변동되더라도, 고정된 네트워크 엔드 포인트를 제공&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 09.kubernetes</title>
        <link>/docker/wanted/2024/10/09/Wanted-Docker-series-09.Kubernetes.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/09/Wanted-Docker-series-09.Kubernetes.html</guid>
        <description>&lt;h1 id=&quot;k8s&quot;&gt;K8s&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://training.linuxfoundation.org/certification/certified-kubernetes-administrator-cka/&quot;&gt;CKA(Certified Kubernetes Administrator)&lt;/a&gt;&lt;/p&gt;
  &lt;h2 id=&quot;기본-이해&quot;&gt;기본 이해&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;현대 개발에서 필수 도구
    &lt;ul&gt;
      &lt;li&gt;CloudkNative 황경에서 표준 컨테이너 오케스레이션 도구가 되었음&lt;/li&gt;
      &lt;li&gt;MSA에서 필수 기술로 자리자븜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;배포 및 관리 자동화
    &lt;ul&gt;
      &lt;li&gt;자동화된 배포, 스케일링, 롤백을 지원&lt;/li&gt;
      &lt;li&gt;무중단 배포, 롤백 업데이트 같은 기능을 활용할 수 있다.&lt;/li&gt;
      &lt;li&gt;이를 통해서 배포 효율성을 높일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화
    &lt;ul&gt;
      &lt;li&gt;리소스 할당과 자동 확장을 제공한다.&lt;/li&gt;
      &lt;li&gt;모니터링을 통해서 성능을 개선할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MSA
    &lt;ul&gt;
      &lt;li&gt;K8s는 컨테이너화된 마이크로 서비스를 쉽게 배포하고 관리하는데 최저고하&lt;/li&gt;
      &lt;li&gt;마이크로서비스 간의 통신, 장애 발생 시 복구, 각 서비스의 독립적 배포되는 방식을 이해해야 이를 감안하여 개발할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CI/CD 통합
    &lt;ul&gt;
      &lt;li&gt;K8s는 많은 CI/CD 도구와 통합되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudNative 이해
    &lt;ul&gt;
      &lt;li&gt;클라우드 서비스 제공업체에서 제공하는 많은 관리형 서비스가 있음(EKS, GKS)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DevOps와 개발자 간 협업
    &lt;ul&gt;
      &lt;li&gt;어떻게 배포되고 관리되는지에 대해서 알고 이해하는게 원활한 협업에 도움이 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dockercompose를-쓰면&quot;&gt;DockerCompose를 쓰면?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;k8s는 여러 대의 물리 서버를 운영하는 것을 전제로 한다.&lt;/li&gt;
  &lt;li&gt;dockercompose으로 여러 번의 command를 사용해야한다.&lt;/li&gt;
  &lt;li&gt;모니터링에도 한계가 있다.&lt;/li&gt;
  &lt;li&gt;k8s는 오케스트레이션 도구다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;desiredstate를-유지&quot;&gt;DesiredState를 유지&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Desired State는 사용자가 원하는 애플리케이션의 상태를 의미한다.&lt;/li&gt;
  &lt;li&gt;Pod, Container가 3개 실행되어 있어야 한다고 설정했다면 오케스트레이션 시스템은 항상 그 상태를 유지하려고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;동작-방식&quot;&gt;동작 방식&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;원하는 상태(DesiredState) 설정:
    &lt;ul&gt;
      &lt;li&gt;몇 개의 컨테이너가 실행되어야 하는지, 어떤 버전의 애플리케이션이 배포되어야 하는 지 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현재 상태(CurrentState) 모니터링:
    &lt;ul&gt;
      &lt;li&gt;오케이스트레이션 시스템은 CurrentState를 모니터링한다.&lt;/li&gt;
      &lt;li&gt;만약 컨테이너가 중단되거나 장애가 발생하면 이를 감지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원하는 상태와 현재 상태 비교:
    &lt;ul&gt;
      &lt;li&gt;원하는 상태, 현재 상태를 비교한다.&lt;/li&gt;
      &lt;li&gt;지속적으로 원하는 상태로 맞추기 위해서 작동한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자동 복구 및 조정(Self-healing):
    &lt;ul&gt;
      &lt;li&gt;자체 복구라고 하며 이 기능으로 항상 가용한 상태를 유지하게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;desired-condition을-유지하려는-결과적으로&quot;&gt;desired condition을 유지하려는 결과적으로&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자동화된 관리: 도커 오케스트레이션 도구는 컨테이너 배포, 관리 및 확장을 자동화하여, 수동 작업의 필요성을 줄여준다.&lt;/li&gt;
  &lt;li&gt;확장성 : 오케스트레이션 도구를 사용하면 컨테이너를 쉽게 스케일 아웃할 수 있다.&lt;/li&gt;
  &lt;li&gt;부하분산: 여러 컨테이너와 서버에 걸쳐 트래픽과 부하를 자동으로 분산시키는 기능을 제공&lt;/li&gt;
  &lt;li&gt;서비스 발견과 네트워킹: 오케스트레이션 도구는 컨테이너 간의 네트워킹과 서비스 발견을 관리한다.&lt;/li&gt;
  &lt;li&gt;상태 관리와 self-healing: 시스템이 정의한 상태를 유지하도록 설정할 수 있으며, 문제가 발생했을 때 오케스트레이션 도구가 자동으로 문제를 해결하고자 시도한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;주요-도커-오케스트레이션-도구&quot;&gt;주요 도커 오케스트레이션 도구&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Kubernetes&lt;/li&gt;
  &lt;li&gt;DockerSwarm&lt;/li&gt;
  &lt;li&gt;ApacheMesos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구성요소&quot;&gt;구성요소&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;논리적 단위로 그룹화한다. =&amp;gt; Pod&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;k8s에서 ‘논리적 단위로 그룹화한다.’는 말은 컨테이너들을 효과적으로 관리하고 조정하기 위해서, 관련 컨테이너들을 하나의 그룹로 묶는 것을 의미&lt;/li&gt;
    &lt;li&gt;k8s에서 생성 및 관리되는 가장 작은 단위&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;공유 리소스와 통신:
    &lt;ul&gt;
      &lt;li&gt;Pod 안에 있는 컨테이너들은 network namespace, storage를 공유할 수 있다.&lt;/li&gt;
      &lt;li&gt;컨테이너들이 서로 통신을 용이하게 하며, 필요한 데이터를 서로 접근할 수 있게 해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너 조정
    &lt;ul&gt;
      &lt;li&gt;Pod를 사용하면 여러 컨테이너들을 한 그룹으로 관리할 수 있다.&lt;/li&gt;
      &lt;li&gt;배포, 스케일링 및 관리를 간소화한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 디스커버리
    &lt;ul&gt;
      &lt;li&gt;Pod는 하나의 Logical 호스트로 취급됨으로써, 하나의 IP 주소와 Port 범위를 가진다.&lt;/li&gt;
      &lt;li&gt;네트워크를 통한 서비스 발견과 라우팅을 단순화함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부하 분산과 자동 복구
    &lt;ul&gt;
      &lt;li&gt;Pod를 여러 노드에 걸쳐 자동으로 배포할 수 있다.&lt;/li&gt;
      &lt;li&gt;Pod가 실패할 경우 자동으로 복구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;주요-구조&quot;&gt;주요 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Node는 Pod를 실행하는 물리적 또는 가상의 서버&lt;/li&gt;
  &lt;li&gt;Pod는 k8s의 기본 배포 단위로 하나 이상의 컨테이너로 구성될 수 있다.&lt;/li&gt;
  &lt;li&gt;pod내 컨테이너들은 공유된 리소스 정보를 가지며, 네트워크, 스토리지 측면에서 밀접하게 연관되어 작동&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;masternode&quot;&gt;MasterNode&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;k8s 클러스터의 제어 허브로서 클러스터 관리 및 조정을 담당&lt;/li&gt;
  &lt;li&gt;kubectl을 설치하고 마스터 노드의 초기 설정 후 마스터 노드를 조정하여, 직접 워커 노드를 관리하는 일은 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;controlplane을-통해서-워커-노드를-관리하는-핵심-컴포넌트&quot;&gt;ControlPlane을 통해서 워커 노드를 관리하는 핵심 컴포넌트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ControlPlane과 WorkerNode로 구성된다.&lt;/li&gt;
  &lt;li&gt;중앙 제어 시스템으로 클러스터의 상태를 유지하고, 리소스를 배치하며, 전반적인 작업을 관리하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;ControlPlane은 여러 핵심 컴포넌트들로 구성되어 있으며, 이들 간의 상호 작용을 통해서 Kuberentes 클러스터를 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/k8s.png&quot; alt=&quot;k8s.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-api-서버kube-apiserver&quot;&gt;1. API 서버(kube-apiserver)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;API 서버는 k8s클러스터와의 모든 통신 중심 엔드포인트&lt;/li&gt;
  &lt;li&gt;클러스터 내부 및 외부의 모든 구성 요소가 API 서버를 통해서 상호작용&lt;/li&gt;
  &lt;li&gt;CRUD 작업이 모두 이곳에서 처리된다.&lt;/li&gt;
  &lt;li&gt;k8s의 REST API를 제공하고 외부 요청을 받아 k8s 클러스터에 명령을 전달&lt;/li&gt;
  &lt;li&gt;주요 역할
    &lt;ul&gt;
      &lt;li&gt;명령어 처리 : kubectl 명령어를 사용해서 클러스터에 명령을 내릴 떄, 이 요청은 모두 API 서버에서 처리&lt;/li&gt;
      &lt;li&gt;보안 관리 : 인증(Authentication), 인가(Authorization)를 통해, 사용자가 클러스테 접근하고 리소스에 대한 작업을 수행할 수 있는지 확인함&lt;/li&gt;
      &lt;li&gt;클러스터 내부 통신 : k8s 내부 컴포넌트들 간의 통신도 API 서버를 통해서 이뤄진다. 클러스터 내부 통신의 일관성을 보장&lt;/li&gt;
      &lt;li&gt;유효성 검사 및 전달 : 리소스 정의 파일(YAML, JSON)을 받으면 유효성 검사하고, 이에 따라 클러스터에 작업을 전달한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-컨트롤-매니저kube-controller-manager&quot;&gt;2. 컨트롤 매니저(kube-controller-manager)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;k8s 클러스터에서 여러 컨트롤러들을 실행하여 클러스터의 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원하는 상태(DesiredState)&lt;/code&gt;로 유지하는 역할을 수행한다.&lt;/li&gt;
  &lt;li&gt;컨트롤러는 각기 다른 k8s 리소스를 관리하는 백그라운드 프로세스로, 리소스가 설정된 대로 실행되는지 모니터링하고 이를 유지하는 역할을 담당&lt;/li&gt;
  &lt;li&gt;주요 역할
    &lt;ul&gt;
      &lt;li&gt;ReplicationController: Pod가 설정된 수만큼 실행 중인지 확인하고, 부족한 경우 새로운 Pod를 생성하거나, 초과할 경우 삭제&lt;/li&gt;
      &lt;li&gt;EndpointController: 서비스와 Pod 간의 연결을 관리하며, 클러스터 내 서비스 디스커버리 및 로드 밸런싱을 관리&lt;/li&gt;
      &lt;li&gt;NameSpaceController: 네임스페이스를 생성 및 삭제하는 작업을 관리한다.&lt;/li&gt;
      &lt;li&gt;NodeContoller: 클러스터의 노드 상태를 모니터링하며, 장애가 발생한 노드를 감지하고 이를 처리한다.&lt;/li&gt;
      &lt;li&gt;자원관리 : 클러스터의 리소스 상태가 정의한대로 유지되도록 보장함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-스케쥴러kube-scheduler&quot;&gt;3. 스케쥴러(kube-scheduler)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;스케쥴러는 새롭게 생성된 Pod를 적절한 workerNode에 배치하는 역할을 담당&lt;/li&gt;
  &lt;li&gt;k8s는 Pod가 클러스터 내의 노드에서 실행되도록 해야하므로, 스케쥴러는 Pod가 요구하는 리소스와 각 노드 상태를 고려하여 배치함&lt;/li&gt;
  &lt;li&gt;주요 역할
    &lt;ul&gt;
      &lt;li&gt;Pod 배치 결정&lt;/li&gt;
      &lt;li&gt;노드 리소스 고려: CPU, 메모리, 네트워크, 디스크 용량 등을 종합적으로 고려&lt;/li&gt;
      &lt;li&gt;애플리케이션 요구 사항 반영: Pod가 특정 zone이나  region에서 실행되어야 하는 경우 이를 반영&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-클라우드-컨트롤러-매니저cloud-controller-manager&quot;&gt;4. 클라우드 컨트롤러 매니저(Cloud Controller Manager)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;클라우드 컨트롤러 매니저는 kubernetes 클라우드 서비스 제공 업체 간의 통합을 담당하는 컴포넌트다.&lt;/li&gt;
  &lt;li&gt;클러스터가 클라우드 환경에서 실행될 떄, 클라우드 리소스와 kubernetes 리소스 간의 상호 작용을 관리한다.&lt;/li&gt;
  &lt;li&gt;주요 역할
    &lt;ul&gt;
      &lt;li&gt;클라우드 리소스 관리: kubernetes 클러스터 간 연결을 관리하며, 클라우드에서 제공하는 서비스&lt;/li&gt;
      &lt;li&gt;클라우드 이벤트 처리: 클라우드에서 발생한느 이벤트를 Kubernetes에 전달하고, 이를 기반으로 클러스 상태를 업데이트&lt;/li&gt;
      &lt;li&gt;클라우 기반 기능: 클라우드 환경에서 실행되는 kubernetes 클러스터가 클러스터 제공자의 네트워킹 및 스토리지와 같은 기능을 효과적으로 사용할 수 있도록 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;5-etcd&quot;&gt;5. etcd&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;etcd는 kubernetes의 key-value 저장소로, 클러스터 내 모든 상태와 메타데이터를 저장하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;이 데이터는 클러스터의 싱글 소스 오브 트루스(Single Source of Truth)로 작동한다.&lt;/li&gt;
  &lt;li&gt;주요 역할
    &lt;ul&gt;
      &lt;li&gt;클러스터 상태 저장 : etcd는 클러스터의 모든 상태 정보를 저장한다. Pod, Node, Service, 설정 정보를 포함한다.&lt;/li&gt;
      &lt;li&gt;트랜잭션 처리 : etcd는 강력한 일관성을 보장하는 트랜잭션 기반의 데이터 저장소다. 모든 클러스터의 상태 변경은 etcd에 안전하게 기록된다.&lt;/li&gt;
      &lt;li&gt;데이터 복제 및 고가용성: etcd는 데이터 복제 및 고가용성을 지원하여, 클러스터의 장애 발생 시에도 데이터 손실을 방지한다. 다수의 etcd 인스턴스를 통해 데이터를 분산 저장하고, 하나의 etcd 인스턴스가 실패해도 다른 이스턴스가 데이터를 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;worker-nodes&quot;&gt;Worker Nodes&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;워커 노드들은 실제로 애플리케이션 컨테이너가 실행되느 서버다.&lt;/li&gt;
  &lt;li&gt;각 워커노드는 아래와 같은 컴포넌트를 포함
    &lt;ul&gt;
      &lt;li&gt;kubelet: 각 노드에서 실행되는 에이전트로, 마스터 노드의 지시를 받아 컨테이너가 Pod 내에서 올바르게 실행되도록 관리한다. 실행 중인 Pod의 상태를 정기적으로 모니터링해서 kube-scheduler에 통지&lt;/li&gt;
      &lt;li&gt;kube-proxy: 네트워크 프록시 및 로드 밸런서 역할을 하는 컴포넌트, 노드의 네트워크 규칙을 관리하고, 연결 및 트래픽 라우팅을 처리&lt;/li&gt;
      &lt;li&gt;컨테이너 런타임 : 컨테이너를 실행하기 위한 환경을 제공한다. (Docker, containerd, CRI-O 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추가 구성 요소
    &lt;ul&gt;
      &lt;li&gt;네트워크 : Pod 간 통신을 위해서 자체 네트워킹 모델을 제공한다. 각 Pod는 고유한 IP 주소를 가지며, Pod 간에는 플랫 네트워크에서 서로 통신할 수 있다.&lt;/li&gt;
      &lt;li&gt;스토리지 : k8s는 볼륨을 사용하여 데이터를 저장한다. 로컬스토리지, 네트워크 스토리지(NFS, iSCSI 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pod의-구성요소와-특징&quot;&gt;Pod의 구성요소와 특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;컨테이너
    &lt;ul&gt;
      &lt;li&gt;Pod하나 이상의 컨테이너를 포함할 수 있다. 이 컨테이너들은 동일한 UTS(UnixTimeSharing) 네임스페이스를 공유하며, 필요한 경우 IPC(Inter-process Communication)을 통해서 통신&lt;/li&gt;
      &lt;li&gt;각 Pod는 주요 애플리케이션 컨테이너, 추가적 사이드카 컨테이너를 포함할 수 있다.&lt;/li&gt;
      &lt;li&gt;사이드카 컨테이너는 로깅, 모니터링, 네트워크 프록시 등의 보조 기능을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 네트워크
    &lt;ul&gt;
      &lt;li&gt;모든 컨테이너는 동일한 IP주소와 포트 공간을 공유한다.&lt;/li&gt;
      &lt;li&gt;이는 외부에서 접근할 때 마치 하나의 엔티티처럼 보이게 하고, 컨테이너 간의 통신을 로컬 호스트를 통해 가능하게 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 스토리지 볼륨
    &lt;ul&gt;
      &lt;li&gt;Pod는 하나 이상의 볼륨을 정의할 수 있다. 이 볼륨은 Pod내 컨테이너들 사이에 공유되어 파일 시스템을 통한 공유를 용이하게 한다.&lt;/li&gt;
      &lt;li&gt;k8s는 다양한 유형의 볼륨을 지원하며, 이는 Pod가 스토리지에 종속되지 않고, 어떤 노드든 동일하게 작동할 수 있도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;생명주기와 관리
    &lt;ul&gt;
      &lt;li&gt;Pod 불변성을 가지며, 한 번 생성되면 그 내부의 컨테이너를 변경할 수 없다.&lt;/li&gt;
      &lt;li&gt;컨테이너 업데이트를 위해서는 Pod를 새로 지우고 생성하는 방식으로 처리&lt;/li&gt;
      &lt;li&gt;Pod는 일반적으로 replication을 통해서 고가용성을 보장받는다.&lt;/li&gt;
      &lt;li&gt;쿠버네티스는 Pod의 상태를 모니터링하고, 실패한 Pod를 자동으로 대체하는 복제 컨트롤러와 ReplicaSet을 사용하여 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pod의-replication&quot;&gt;Pod의 Replication&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;k8s는 Pod 상태를 지속적으로 모니터링하고 replication을 관리하기 위해서 ReplicaSet과 같은 컨트롤러를 사용한다.&lt;/li&gt;
  &lt;li&gt;현재 상태(CurrentState)와 원하는 상태(DesiredState)를 비교하여 문제가 생기면 새로운 Pod를 자동으로 생성하거나 대체한다.&lt;/li&gt;
  &lt;li&gt;현재 상태 모니터링은 컨트롤 플레인(ControlPlane)에 속한 컨트롤러 매니저가 수행한다.&lt;/li&gt;
  &lt;li&gt;이 상태를 바탕으로 현재 상태를 결정한다. Pod의 실행 여부, 리소스 사용량, 상태 등이 포함된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;replicaset복제-컨트롤러의-동작&quot;&gt;ReplicaSet/복제 컨트롤러의 동작&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ReplicaSet이나 복제 컨트롤러는 Pod의 수를 관리하며, 원하는 개수만큼 Pod가 항상 실행되도록 보장
    &lt;ul&gt;
      &lt;li&gt;Pod 장애 탐지&lt;/li&gt;
      &lt;li&gt;Pod 복제 및 대체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ReplicaSet은 클러스터에서 지정된 Pod 개수를 보장하기 위해서 필요한 경우 새로운 Pod를 자동으로 생성하고, 장애 발생 시 이를 대체&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pod의-상태를-복제하는-방법&quot;&gt;Pod의 상태를 복제하는 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;장애 Pod를 감지한 후, 해당 Pod가 사용하던 컨테이너 이미지, 환경 변수, 네트워크 성정 등 모든 설정 정보를 기반으로 새로운 Pod를 생성&lt;/li&gt;
  &lt;li&gt;이 과정에서는 Pod는 template을 사용하여, 원래 Pod와 동일한 설정으로 새로운 Pod를 복제&lt;/li&gt;
  &lt;li&gt;Pod 템플릿 Deployment 또는 ReplicaSet에 정의되어 있으며, Pod를 생성할 때 사용되는 모든 설정 정보가 포함되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;self-healing&quot;&gt;Self-Healing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;쿠버티스의 self-healing 기능은 Pod의 상태를 지속적으로 체크하며, 장애가 발생했을 때 자동으로 복구한다.&lt;/li&gt;
  &lt;li&gt;Pod가 정상적으로 실행되지 않거나 충돌이 발생하면, k8s는 이를 감지하고 새로운 Pod를 동일한 설정으로 생성해서 자동 복구를 수행&lt;/li&gt;
  &lt;li&gt;이를 통해 무중단 서비스가 가능하고, 높은 가용성을 유지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;node-pod&quot;&gt;Node, Pod&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;노드 내 Pod는 독립적인 실행 환경을 제공받으며 노드의 리소스를 할당받아 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;k8s-특징&quot;&gt;k8s 특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Self-Healing : 실패한 컨테이너는 다시 시작하고 컨테이너를 교체하며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지는 않는다.&lt;/li&gt;
  &lt;li&gt;Auto-Scaling
    &lt;ul&gt;
      &lt;li&gt;HorizontalPodAutoscaler(HPA) : CPU 등의 메트릭을 바탕으로 Pod 인스턴스 수를 자동으로 스케일아웃&lt;/li&gt;
      &lt;li&gt;ClusterAutoScaler: k8s의 클러스ㅓ 오토스케일러는 클러스터 내에서 노드의 수를 동적으로 조정하여 Pod의 수요에 따라 클러스터의 리소스를 최적화하는 역할을 함. 클러스터 크기를 자동으로 확장하거나 축소하는 과정이 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 09 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 08.highavailbility</title>
        <link>/docker/wanted/2024/10/08/Wanted-Docker-series-08.HighAvailbility.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/08/Wanted-Docker-series-08.HighAvailbility.html</guid>
        <description>&lt;h1 id=&quot;high-availability&quot;&gt;High availability&lt;/h1&gt;

&lt;h2 id=&quot;왜&quot;&gt;왜?&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;사용자가 늘어서 운영이 어려워 지고&lt;/li&gt;
  &lt;li&gt;성능 유지는 필요하다.
    &lt;ul&gt;
      &lt;li&gt;서버는 동시 요청 처리 한계가 명확하다.&lt;/li&gt;
      &lt;li&gt;서버를 scale out하거나 scale up으로 사용자 경험을 유지할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버 한계 극복 위해서 고려할 요소
    &lt;ul&gt;
      &lt;li&gt;가용성&lt;/li&gt;
      &lt;li&gt;부하 분산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scaleout으로 서버 수 증가, -&amp;gt; 컨테이너 수 증가&lt;/li&gt;
  &lt;li&gt;컨테이너의 효율적 관리 =&amp;gt; 오케이스트레이션 기술 대두&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;한계에서부터-생각하기---가용성&quot;&gt;한계에서부터 생각하기 -&amp;gt; 가용성&lt;/h2&gt;
&lt;h3 id=&quot;1-가용성-향상&quot;&gt;1. 가용성 향상&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단일 서버는 단일 장애점이다.&lt;/li&gt;
  &lt;li&gt;가용성은 지표다. 메트릭스로 측정해서 표현할 수 있다.&lt;/li&gt;
  &lt;li&gt;서버에서 가용성은 서버 또는 네트워크 시스템이 계획된 운영 시간 동안 얼마나 안정적으로 접근이 가능하고, 정상적으로 기능하는지에 대한 지표&lt;/li&gt;
  &lt;li&gt;기본적으로, 가용성은 시스템이 사용자의 요구를 충족시키며, 요청된 서비스를 제공할 수 있는 능력을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-가용성의-중요-요소&quot;&gt;2. 가용성의 중요 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연속성과 신뢰성: 예상치 못한 중단 없이 지속적으로 작동하고, 예정된 유지 관리 외에 다운타임이 회소화 되어야 함&lt;/li&gt;
  &lt;li&gt;복구력: 장애 후 얼마나 빠르게 정상으로 돌아오는지도 중요&lt;/li&gt;
  &lt;li&gt;확장성: 사용자 수나 데이터량 증가 등, 시스템에 대한 요구가 변화할 때 이를 수용하고 성능을 유지할 수 있는 능력&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;가용성을 높이는 방법&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;하드웨어 중복&lt;/li&gt;
    &lt;li&gt;로드밸런싱&lt;/li&gt;
    &lt;li&gt;failover 시스템&lt;/li&gt;
    &lt;li&gt;정기적인 백업 및 복구 테스트 (ChaosMonkey같은 툴로)&lt;/li&gt;
    &lt;li&gt;분산 아키텍쳐&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3-주요-가용성-지표&quot;&gt;3. 주요 가용성 지표&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가동 시간(Uptime) : 중단 없이 가동된 시간의 비율을 의미 (99.9% 가동시간이 보장되면 연간 8.76시간의 다운타임을 가질 수 있다.)&lt;/li&gt;
  &lt;li&gt;장애 복구 시간(Recovery Time Objective, RTO) : 얼마나 빨리 복구할 수 있는지를 의미한다. (장애 후 서비스가 다시 정상적으로 운영되는데 걸리는 시간)&lt;/li&gt;
  &lt;li&gt;데이터 손실 허용 시간(Recovery Point Objective, RPO) : 시스템 장애 발생시 데이터 손실을 허용할 수 있는 최대 시간을 의미 ( 복구 시점, 장애 시점 사이의 손실된 데이터를 기준으로 한다.)&lt;/li&gt;
  &lt;li&gt;무중단 운영(Failover): 장애가 발생하면 자동으로 대체 서버나 복제 서버로 전환되어 서비스 중단 없이 운영이 계속되는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;고갸용성&quot;&gt;고갸용성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최대한 오랫동안 중단 없이 운영되도록 보장되는 아키텍쳐&lt;/li&gt;
  &lt;li&gt;복제 서버, 백업 서버, 이중화 시스템, 로드 밸런싱 등의 기술로 서비스 중단 없이 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-복제-서버-replication-servers&quot;&gt;1. 복제 서버 (Replication Servers)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;역할: 복제 서버를 통해서 실시간 데이터 복제를 실행 -&amp;gt; 메인에서 처리된 모든 데이터를 동시에 다른 서버에 복제하여, 장애가 발생해도 복제 서버에서 동일한 데이터를 가지고 서비스를 지속&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;master-slave&quot;&gt;Master-Slave&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;작동 방식
    &lt;ul&gt;
      &lt;li&gt;Master에서 모든 데이터 변경 작업이 이뤄지고 Slave에서 읽기 전용 작업만 수행&lt;/li&gt;
      &lt;li&gt;복제는 단방향, Slave는 주 서버의 데이터를 따라간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;차이점
    &lt;ul&gt;
      &lt;li&gt;Slave는 읽기 전용, 쓰기는 주로 Master에서&lt;/li&gt;
      &lt;li&gt;비동기 복제가 일반적이지만, 동기 복제로도 설정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;master-master&quot;&gt;Master-Master&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;작동 방식
    &lt;ul&gt;
      &lt;li&gt;여러 서버가 동시에 읽기, 쓰기를 수행&lt;/li&gt;
      &lt;li&gt;서버 간 서로의 데이터를 실시간으로 동기화한다.&lt;/li&gt;
      &lt;li&gt;데이터 충돌 방지를 위해서 충돌 관리 메커니즘이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;차이점
    &lt;ul&gt;
      &lt;li&gt;모든 서버가 동등한 역할을 하며, 읽기와 쓰기를 모두 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;데이터의 동기화 복잡성이 커지고, 데이터 충돌이 발생할 수 있다.&lt;/li&gt;
      &lt;li&gt;보통 동기 또는 반동기 복제 형식으로 동작하며 모든 서버 간 일관성 유지가 어렵다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;실시간-동기활르-통한-복제-서버-구현&quot;&gt;실시간 동기활르 통한 복제 서버 구현&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;동기식 복제(Synchronous)
    &lt;ul&gt;
      &lt;li&gt;동기식 복제는 Primary에서 오는 모든 데이터를 Seconary에 동시에 반영하는 방식이다&lt;/li&gt;
      &lt;li&gt;주 서버는 복제 서버가 변경 사항을 완전히 저장할 때까지 작업을 완료하지 않는다.&lt;/li&gt;
      &lt;li&gt;일관성 보장 측면에서는 좋지만 지역 시간이 발생할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;작동 방식&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;트랜잭션이 발생하면 변경하고 복제 서버로 전송&lt;/li&gt;
    &lt;li&gt;복제서버가 수신하고 적용되었다고 주 서버로 알림&lt;/li&gt;
    &lt;li&gt;주 서버는 수신 이후 트랜잭션을 완료&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;높은 데이터 일관성이 보장된다.&lt;/li&gt;
      &lt;li&gt;주, 복제 서버 간 높은 싱크로율이 유지된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;지연 시간이 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;비동기식 복제(Asynchronous)
    &lt;ul&gt;
      &lt;li&gt;주 서버가 데이터 변경을 수행한 후, 즉시 다음 작업을 진행하고 복제 서버는 별도의 시간에 변경 사항을 적용한다.&lt;/li&gt;
      &lt;li&gt;주 서버는 상태를 기다리지 않기에 처리 속도는 빠르지만 일시적으로 데이터 불일치가 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;작동 방식&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;주 서버에서 트랜잭션이 발생하면 즉시 변경 사항을 기록하고 트랜잭션을 완료&lt;/li&gt;
    &lt;li&gt;변경된 데이터를 복제 서버로 전송하면 주 서버는 복제 서버 응답을 기다리징 낳음&lt;/li&gt;
    &lt;li&gt;복제서버는 전송된 데이터를 나중에 적용하여 동기화를 완료&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;성능이 뛰어나도 빠른 처리 속도를 유지&lt;/li&gt;
      &lt;li&gt;복제 서버가 원거리에 있을 때도 큰 성능 저하가 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;일시적으로 데이터 불일치가 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;스트리밍 복제
    &lt;ul&gt;
      &lt;li&gt;주 서버에서 로그 파일을 실시간으로 스트리밍하여 복제 서버에 데이터를 전송하는 방식&lt;/li&gt;
      &lt;li&gt;비동기식과 비슷하지만 데이터 전송이 보다 실시간에 가까움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;작동 방식&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;주 서버는 데이터 변경 시 변경된 데이터의 로그 파일을 생성
      &lt;ul&gt;
        &lt;li&gt;트랜잭션 데이터를 WAL(Write-Ahead Logging)파일로 기록&lt;/li&gt;
        &lt;li&gt;WAL은 데이터가 디스크에 쓰이기 전에 로그 파일에 먼저 기록되는 방식&lt;/li&gt;
        &lt;li&gt;데이터 일관성을 유지하는 데 중요한 역할을 한다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;로그 파일은 스트리밍 방식으로 실시간 복제(Replica) 서버로 전송
      &lt;ul&gt;
        &lt;li&gt;WAL Sender는 실시간으로 WAL 파일을 서버로 스트리밍&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;복제 서버는 이 로그를 즉시 적용하거나 일정 시간 후에 적용하여 데이터 일관성을 맞춤
      &lt;ul&gt;
        &lt;li&gt;Replica 서버는 WAL Receiver를 통해서 WAL 파일을 수신하고 재생하여 Primary와 동기화&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Replica 서버는 읽기 전용 상태로 클라이언트 요청에 대응&lt;/li&gt;
    &lt;li&gt;필요 시 FailOver를 통해서 Primary역할을 할 수도 있다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;지연이 적고, 데이터가 실시간에 가깝게 동기화&lt;/li&gt;
      &lt;li&gt;동기식, 비동기식의 장점을 결합한 방식&lt;/li&gt;
      &lt;li&gt;데이터 일관성 유지와 성능을 적절히 균형 있게 관리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;완벽한 동기식 복제처럼 즉각적인 데이터 일관성을 보장하지는 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-백업-서버&quot;&gt;2. 백업 서버&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비상시에만 사용되는 서버&lt;/li&gt;
  &lt;li&gt;메인서버, 복제 서버에 심각한 장애가 발생할 경우 데이터 복구 및 서비스 복원을 위해서 사용&lt;/li&gt;
  &lt;li&gt;보통 원격지에 위치하며, 데이터 복구 및 재해 복구 전략( DisasterRecover, DR )의 핵심점 역할을 담당&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-이중화&quot;&gt;3. 이중화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이중화 메커니즘을 통해 장애 발생 시 자동으로 다른 서버로 전환하는 기능을 제공&lt;/li&gt;
  &lt;li&gt;한 서버가 다운되면 다른 서버가 즉시 이어 받아 중단 없는 서비스를 제공&lt;/li&gt;
  &lt;li&gt;이중화 시스템은 자동 전환을 통해 서비스 중단을 최소화하고, 연속적인 서비스 가용성을 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-1-로드-밸런싱&quot;&gt;4-1. 로드 밸런싱&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;고가용성 아키텍쳐는 로드 밸런서를 통해 여러 서버 간의 트래픽을 분산하여, 서버 과부하를 방지하고 최적 성능을 유지&lt;/li&gt;
  &lt;li&gt;많은 사용자가 동시에 접속해도 안정성을 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;자동으로 서버 상태를 감시하고, 트래픽을 가장 적절한 서버로 분배해서 시스템의 가용성을 보장&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-부하-분산&quot;&gt;4-2. 부하 분산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서버를 추가하면 네트워크 트래픽과 데이터 처리 부하를 여러 서버에 분산시켜 각 서버의 부하를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;각 서버의 안정성을 제고하고, 전체 시스템의 효율성이 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;부하&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;부하는 일반적으로 서버, 네트워크가 처리해야하는 데이터의 양, 요청 수 또는 동시 사용자 수등으로 인해 발생하는 작업량이나 스트레스르 의미&lt;/li&gt;
    &lt;li&gt;부하의 주요 유형
      &lt;ul&gt;
        &lt;li&gt;CPU&lt;/li&gt;
        &lt;li&gt;Memory&lt;/li&gt;
        &lt;li&gt;DISK I/O&lt;/li&gt;
        &lt;li&gt;Network&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;부하가 서버에 미치는 영향
      &lt;ul&gt;
        &lt;li&gt;응답 시간 증가&lt;/li&gt;
        &lt;li&gt;시스템 다운&lt;/li&gt;
        &lt;li&gt;리소스 경합&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;관리 방법
      &lt;ul&gt;
        &lt;li&gt;부하 분산(LoadBalancing)&lt;/li&gt;
        &lt;li&gt;Scaling&lt;/li&gt;
        &lt;li&gt;Caching&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-재난-복구&quot;&gt;5. 재난 복구&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 지역에 서버를 분산시켜 두면 자연재해나 기타 여러 상황에서 서비스의 연속성을 보장할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-데이터-처리-능력-증가&quot;&gt;6. 데이터 처리 능력 증가&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 증가에 따른 처리 요구 증가&lt;/li&gt;
  &lt;li&gt;DB, Server, ApplicationServer를 증설하여 처리 능력을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-확장성&quot;&gt;7. 확장성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 확장성이 높아야 유연하게 대응하 룻 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과적으로&quot;&gt;결과적으로&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Scaling으로 귀결된다. 적당히 늘리고 투자해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;유연성과 확장성: 서버나 리소스의 필요에 따라 추가하거 제거할 수 있다.&lt;/li&gt;
  &lt;li&gt;비용 효율성: 고성능 서버 하나보다 일반 성능 여러 개가 비용이 저럼&lt;/li&gt;
  &lt;li&gt;고갸용성: 한 노드가 실패하더라도 중단 없이 다른 노드가 작업을 수행&lt;/li&gt;
  &lt;li&gt;부하 분산: 트래픽이나 작업 부하를 여러 서버에 분산&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;서버 수가 늘어나고 도커 컨테이너 수도 증가&lt;/li&gt;
  &lt;li&gt;컨테이너들을 효과적으로 관리하고 조정하는데 어려움이 있음&lt;/li&gt;
  &lt;li&gt;도커 오케스트레이션 기술의 대두&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;가용성&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Pod의 가용성을 보장하기 위해서 self-healing을 제공&lt;/li&gt;
    &lt;li&gt;Pod하나가 장애로 종료되면 k8s는 즉시 새 pod를 생성&lt;/li&gt;
    &lt;li&gt;autoScaling, self-healing을 통해서 장애 발생시 자동 복구&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pod의 가용성을 보장하기 위해서 selfHealing, autoScaling을 사용한다.&lt;/li&gt;
  &lt;li&gt;이를 통해 자동으로 복구하고 Pod의 개수를 동적으로 조절한다.&lt;/li&gt;
  &lt;li&gt;무중단 서비스를 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pod&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;가장 작은 단위의 컴퓨팅 리소스이다.&lt;/li&gt;
    &lt;li&gt;애플리케이션의 인스턴스로 볼 수 있다.&lt;/li&gt;
    &lt;li&gt;K8s는 Pod를 통해서 애플리케이션의 실행 환경을 추상화, 컨테이너 간의 네트워크와 스토리지 관리&lt;/li&gt;
    &lt;li&gt;Pod는 일시적이며, 언제든 중단될 수 있으므로 이 경우 새로운 Pod를 아예 새로 띄운다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Self-Healing
    &lt;ul&gt;
      &lt;li&gt;자체 복구는 K8s의 중요 기능 중 하나다.&lt;/li&gt;
      &lt;li&gt;장애로 인한 종료, 비정상적 상태에 복구하는 메커니즘&lt;/li&gt;
      &lt;li&gt;클러스터 상태를 지속적으로 모니터링하거나, Pod를 탐지하고 이를 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AutoScaling
    &lt;ul&gt;
      &lt;li&gt;트래픽, 부하 변동에 따라서 자동으로 Pod 개수를 늘리거나 줄임&lt;/li&gt;
      &lt;li&gt;HPA(Horizontal Pod Autoscaler)를 이용해서 CPU나 메모리에 따라 Pod 수를 조절&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가용성 보장
    &lt;ul&gt;
      &lt;li&gt;가용성은 Pod의 지속적인 샐행을 보장하는 것과 관련이 있음&lt;/li&gt;
      &lt;li&gt;Pod가 종료되거나 장애가 발생시 복구 메커니즘으로 항상 실행 가능한 상태를 유지&lt;/li&gt;
      &lt;li&gt;ReplicaSet, Deployment는 애플리케이션의 desiredState(원하는 상태)를 정의하고 이를 맞추려고 조정함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;테스트와 측정&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;모니터링 도구 : Datadog, NewRelic, Prometheus&lt;/li&gt;
    &lt;li&gt;Uptime모니터링 서비스: UptimeRobot, Pingdom&lt;/li&gt;
    &lt;li&gt;부하 테스트: JMeter, Gatling, LoadRunner&lt;/li&gt;
    &lt;li&gt;장애 조치 테스트 : 재난 복구 시나리오&lt;/li&gt;
    &lt;li&gt;카오스 엔지니어링: Netflix의 ChaosMonkey&lt;/li&gt;
    &lt;li&gt;번치마킹 : 성능 벤치마킹 또느 이전과 비교가 용이&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;성능 지표&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;Throughput: 시간 내 일머나 만흥 작업을 처리할 수 있느닞&lt;/li&gt;
    &lt;li&gt;responseTime: 요청 처리에 걸리는 시간을 의미&lt;/li&gt;
    &lt;li&gt;Latency : 지연시간을 의미하며, 요쳥을 처리하기 위해서 걸리는 시간(효율성)&lt;/li&gt;
    &lt;li&gt;Concurrency: 동시에 처리할 수 있는 요청의 수&lt;/li&gt;
    &lt;li&gt;Scalability: 추가적인 하드웨어나 리소스를 투입할 때 얼마나 성능향상이 있는지를 의미&lt;/li&gt;
    &lt;li&gt;CPU, Memory 사용률&lt;/li&gt;
    &lt;li&gt;에러율 : 시스템이 처리 중 발생한느 오류 비율&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 08 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 07.dockercompose</title>
        <link>/docker/wanted/2024/10/07/Wanted-Docker-series-07.DockerCompose.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/07/Wanted-Docker-series-07.DockerCompose.html</guid>
        <description>&lt;h1 id=&quot;dockercompose&quot;&gt;DockerCompose&lt;/h1&gt;

&lt;h2 id=&quot;1-필요성&quot;&gt;1. 필요성&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;여러 컨테이너 정의 및 실행
    &lt;ul&gt;
      &lt;li&gt;DockerCompose는 여러 컨테이너를 정의하고 실행하기 위한 도구다.&lt;/li&gt;
      &lt;li&gt;복잡한 애플리케이션은 여러 서비스로 구성되며, 각 서비스는 독립적인 컨테이너로 실행된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 애플리케이션 구성
    &lt;ul&gt;
      &lt;li&gt;단일 Dockerfile로는 복잡한 애플리케이션을 구성하기에 어려움이 있다.&lt;/li&gt;
      &lt;li&gt;컨테이너 간 상호작용이 필요한 경우 더욱 문제가 된다.&lt;/li&gt;
      &lt;li&gt;컨테이너의 설정과 실행 순서, 의존성을 관리하는 것이 어렵다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일관된 환경 유지
    &lt;ul&gt;
      &lt;li&gt;개발, 테스트, 배포 환경에서 일관된 컨테이너 설정을 유지하기에 용이하다.&lt;/li&gt;
      &lt;li&gt;DockerCompose로 모든 동일한 환경에서 동일한 설정으로 컨테이너를 실행할 수 있어서 환경 불일치에서 오는 문제를 최소화 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-복잡한-애플리케이션에서-dockercompose&quot;&gt;2. 복잡한 애플리케이션에서 DockerCompose&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;다중 컨테이너 정의
    &lt;ul&gt;
      &lt;li&gt;복잡한 애플리케이션은 보통 여러 서비스로 구성되고 각 서비스는 독립된 컨테이너로 실행됨&lt;/li&gt;
      &lt;li&gt;DockerCompose는 이러한 서비스를 정의하고 의존성 관리에 효율적&lt;/li&gt;
      &lt;li&gt;환경 변수 관리 : 환경변수, 네트워크 설정, 볼륨 마운트 등의 설정을 명시적으로 YAML에 정의하여 일관된 환경을 제공&lt;/li&gt;
      &lt;li&gt;네트워크 구성 : 자동으로 네트워크 구성하여, 서비스 간의 통신을 지원한다.&lt;/li&gt;
      &lt;li&gt;배포 자동화: 단일 명령으로 모든 서비스를 실행할 수 있어, 배포를 자동화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 애플리케이션 구성
    &lt;ul&gt;
      &lt;li&gt;DockerCompose는 여러 서비스를 정의하고 실행할 때 모든 설정를 YAML 하나에 담아 관리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;환경 설정 관리
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env&lt;/code&gt;를 사용하여 환경 변수를 관리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크 구성
    &lt;ul&gt;
      &lt;li&gt;DockerCompose는 프로젝트에 대해서 독립된 네트워크를 자동으로 생성하여, 서비스 간의 통신을 지원한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 간 의존성 관리
    &lt;ul&gt;
      &lt;li&gt;DockerCompose는 서비스 간의 의존성을 관리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 지속성 관리
    &lt;ul&gt;
      &lt;li&gt;볼륨을 사용하여 데이터의 지속성을 관리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 환경 지원
    &lt;ul&gt;
      &lt;li&gt;DockerCompose는 여러 개의 환경을 지원할 수 있다. (개발, 테스트, 프로덕션 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로컬 개발 환경 구성
    &lt;ul&gt;
      &lt;li&gt;여러 서비스를 동시에 실행해야 하는 경우 편리하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일관된 테스트 환경 제공
    &lt;ul&gt;
      &lt;li&gt;통합테스트, end-to-end 테스트를 위한 환경을 쉽게 구성할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dockercompose의-기본-네트워크-동작-방식&quot;&gt;DockerCompose의 기본 네트워크 동작 방식&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자동 네트워크 생성: DockerCompose에서 별도 네트워크 정의가 없다면, 각 Compose 프로젝트에 대해서 기본 네트워크를 자동으로 생성한다.(bridge)&lt;/li&gt;
  &lt;li&gt;DNS 기반 통신 : DockerCompose는 서비스를 생성할 떄, 각 서비스를 DNS로 자동 등록한다.
```yaml
services:
  app: ~
  mongodb:
 ~&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#이 경우 app, monggodb가 DNS
```&lt;/p&gt;

&lt;h2 id=&quot;환경에-따른-yaml&quot;&gt;환경에 따른 YAML&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.dev.yml&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.stage.yml&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.prod.yml&lt;/code&gt;와 같이 분리&lt;/li&gt;
  &lt;li&gt;.env를 통해서 분리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env.dev&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env.prod&lt;/code&gt;  -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose --env-file .env.dev up -d&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 07 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 06.githubaction</title>
        <link>/docker/wanted/2024/10/06/Wanted-Docker-series-06.GithubAction.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/06/Wanted-Docker-series-06.GithubAction.html</guid>
        <description>&lt;h1 id=&quot;githubaction&quot;&gt;GithubAction&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;repository의 이벤트에 반응하여 자동화된 워크 플로우를 실행하는 시스템&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.github/workflows&lt;/code&gt;내 yaml로 정의된다.&lt;/li&gt;
  &lt;li&gt;jobs, steps, actions 등을 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;workflow는 이벤트 발생 시 지정된 환경에서 컨테이너 또는 가상 머신 위에서 실행된다.&lt;/li&gt;
  &lt;li&gt;job은 서로 독립, 병렬로 실행될 수 있다.&lt;/li&gt;
  &lt;li&gt;build, test, deploy 등의 작업 수행이 가능해진다.&lt;/li&gt;
  &lt;li&gt;workflow는 githubAction에서 실행되는 자동화 프로세스를 정의하는 단위다. 각 작업은 독립적으로 실행되며, 여러 개의 단계로 구성될 수 있다.&lt;/li&gt;
  &lt;li&gt;step은 각 작업 내에서 순차적으로 실행되며, 성공적으로 완료되어야 작업이 성공적으로 완료된다.
    &lt;ul&gt;
      &lt;li&gt;작업 간: 각각 작업은 독립적인 가상 머신 또는 컨테이너에서 실행되며, 서로 격리되어 있다.&lt;/li&gt;
      &lt;li&gt;단계 간: 동일한 작업 내의 단계는 같은 환경을 공유하므로, 각 단계가 별도의 컨테이너에서 실행되는 것은 아니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Action은 Marketplace에서 가져오거나 직접 작성한 재사용 가능한 코드 조각이다.&lt;/li&gt;
  &lt;li&gt;이를 재활용하여 배포 등과 같은 다양한 작업을 자동화할 수 있다.&lt;/li&gt;
  &lt;li&gt;Secrets는 레포지토리의 중요한 데이터를 안전하게 저장하고 관리하는데 사용한다.&lt;/li&gt;
  &lt;li&gt;API Token, SSH 키, 암호 등과 같이 민감한 정보를 포함할 수 있다.&lt;/li&gt;
  &lt;li&gt;Secrets는 보안을 유지하기 위해서 암호화되어 저장되며, 워크플로우 실행 중에서 필요할 때만 복호화되어 사용된다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 05.cloudcontainerservice</title>
        <link>/docker/wanted/2024/10/05/Wanted-Docker-series-05.CloudContainerService.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/05/Wanted-Docker-series-05.CloudContainerService.html</guid>
        <description>&lt;h1 id=&quot;cloud-container-service&quot;&gt;Cloud Container Service&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;모던 웹 환경에서 환경 불일치, 리소스 비효율성, 배포 복잡성 등의 문제를 해결하기 위해서 도입됐다.&lt;/li&gt;
  &lt;li&gt;컨테이너화된 애플리케이션은 일관성 있고 이식성이 뛰어나며, 리소스를 효율적으로 사용하여 배포를 높일 수 있다.&lt;/li&gt;
  &lt;li&gt;Docker는 MSA, CI/CD를 지원하면서, 웹 개발에서 필수적인 도구로 자리잡았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;개발환경과 운영 환경의 일관성
    &lt;ul&gt;
      &lt;li&gt;로컬, 운영에서 환경 불일치로 로컬에서 되던 것이 운영에서 안되는 경우가 있었음&lt;/li&gt;
      &lt;li&gt;Docker로 모든 라이브러리, 종속성을 하나의 컨테이너로 묶어서 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이식성
    &lt;ul&gt;
      &lt;li&gt;전통적 애플리 케이션 방식은 OS에 의존적이거나 특정 서버 구성에 종속적인 경우가 많았음&lt;/li&gt;
      &lt;li&gt;Docker로 특정 운영체제에 독립되어 영향을 거의 받지 않도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;효율적 리소스 관리
    &lt;ul&gt;
      &lt;li&gt;VM 마다 OS를 올려서 오버헤드 발생&lt;/li&gt;
      &lt;li&gt;Docker는 OS 수준 격리된 경량 컨테이너를 실행하므로 전체를 가상화하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빠르고 일관된 배포 및 스케일링
    &lt;ul&gt;
      &lt;li&gt;점차 CI/CD 파이프라인을 통해 애플리케이션을 자주 업데이트하고 배포해야하는데, 전통적인 방식으로는 어려웠다.&lt;/li&gt;
      &lt;li&gt;Docker는 컨테이너 이미지를 기반으로 애플리케이션을 일관되게 배포할 수 있어, 다양한 배포 환경에서 빠르고 안정적으로 배포할 수 있음&lt;/li&gt;
      &lt;li&gt;Kubernetes 같은 컨테이너 오케이스테이션 도구 도입으로 스케일링도 자동화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마이크로서비스 아케텍쳐 지원
    &lt;ul&gt;
      &lt;li&gt;요즘 트렌드는 대규모 애플리 케이션을 작고 독립적인 서비스로 나눠 관리하는 방식이 됐다.&lt;/li&gt;
      &lt;li&gt;개발, 배포가 더 유연하고 빠르게 이뤄질 수 있다.&lt;/li&gt;
      &lt;li&gt;Docker는 각각 마이크로 서비스를 독립적인 컨테이너로 실행할 수 있어서 서로 격리된 환경에서 실행되는 동시에 관리도 간편해진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발자/ 운영팀 간의 협업 개선
    &lt;ul&gt;
      &lt;li&gt;서로 다른 환경에서 작업하는 개발자와 운영팀 간의 불일치나 배포 실패나 성능 저하로 이뤄질 수 있다.&lt;/li&gt;
      &lt;li&gt;Docker 개발환경과 운영 환경 간의 일관성을 제공하기에 환경 불일치를 막을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cicd&quot;&gt;CI/CD&lt;/h2&gt;

&lt;h3 id=&quot;ci지속적-통합&quot;&gt;CI(지속적 통합)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발자들이 작업한 코드를 주기적으로 공유 레포지토리에 병합함으로써 코드의 통합을 자동화하는 과정이다.&lt;/li&gt;
  &lt;li&gt;모든 변경 사항은 자동 빌드 및 테스트를 거쳐 master로 통합된다.&lt;/li&gt;
  &lt;li&gt;코드 충돌을 최소화하면서 소프트웨어의 품질을 유지하고, 배포 준비 상태를 지속적으로 유지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cdcontinuous-delivery---지속적-전달&quot;&gt;CD(Continuous Delivery) - 지속적 전달&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CI 과정을 한 단계 발전시켜, 코드 변경사항이 자동으로 빌드 및 테스트를 거쳐 실제 운영환경에 배포될 준비가 된다.&lt;/li&gt;
  &lt;li&gt;배포 과정을 완전히 자동화하지 않고 실제 배포는 수동으로 트리거할 수 있는 옵션을 둔다.&lt;/li&gt;
  &lt;li&gt;신속하게 배포할 준비를 할 수 있으며, 비즈니스 요구에 따라서 배포 시점을 선택할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cdcontinuous-deployment---지속적-배포&quot;&gt;CD(Continuous Deployment) - 지속적 배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 변경사항이 자동 테스트를 통과하면 즉시 프로덕션에 배포된다.&lt;/li&gt;
  &lt;li&gt;배포 과정을 단축시켜 빠르게 가치를 전달할 수 있도록 함&lt;/li&gt;
  &lt;li&gt;지속적 배포로, 릴리즈 과정이 자동화되어, 사람 개입 없이도 신속하게 배포된다.&lt;/li&gt;
  &lt;li&gt;CI/CD 파이프라인의 도입은 개발 프로세스의 자동화, 코드 통합, 테스트, 배포 과정을 효율성을 극대화하여 코드 품질의 지속적 개선, 개발 주기의 단축, 사용자 만족으로 이어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;결론적으로-왜-필요하게-됐는가&quot;&gt;결론적으로 왜 필요하게 됐는가?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CI/CD 구축은 기능 개발에 시간과 노력을 더 투자하기보다느 전체 개발 과정의 효율성과 안정성을 향상시키는 데 기여한다.&lt;/li&gt;
  &lt;li&gt;이를 통해서 개발자는 코드 품질을 유지하고, 더 빠르게 새로운 기능을 릴리즈하며, 배포 과정에서 발생하는 문제를 미연에 방지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 05 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[wanted Docker Series] 04.dockernetwork</title>
        <link>/docker/wanted/2024/10/04/Wanted-Docker-series-04.DockerNetwork.html</link>
        <guid isPermaLink="true">/docker/wanted/2024/10/04/Wanted-Docker-series-04.DockerNetwork.html</guid>
        <description>&lt;h1 id=&quot;docker-network&quot;&gt;Docker Network&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컨테이너 간 통신을 가능하게 한다.&lt;/li&gt;
  &lt;li&gt;브릿지, 호스트, 오버레이 등의 종류가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기본-개념&quot;&gt;기본 개념&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컨테이너 간 서로 통신하고 외부 네트워크와 연결될 수 있도록 네트워크 환경을 구성하는 기술&lt;/li&gt;
  &lt;li&gt;각 컨테이너는 고유한 네트워크 네임스페이스를 가지고, 격리됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;격리와 보안
    &lt;ul&gt;
      &lt;li&gt;네트워크 네임스페이스로 컨테이너 간 네트워크 분리&lt;/li&gt;
      &lt;li&gt;독립된 네트워크 환경 구성으로 서로 영향을 미치지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유연한 구성
    &lt;ul&gt;
      &lt;li&gt;다양한 네트우커 브릿지로 네트워크를 유연하게 구성할 수 있다.&lt;/li&gt;
      &lt;li&gt;컨테이너 간 통신, 외부 네트워크와의 통신, 다중 호스트 간의 통신을 손쉽게 설정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장성
    &lt;ul&gt;
      &lt;li&gt;도커 네트워킹을 통해 컨테이너 기반 애플리케이션의 네트워크를 쉽게 확장할 수 있다.&lt;/li&gt;
      &lt;li&gt;오버레이 네트워크를 사용하면 다중 호스트 간의 통신을 지원하여 클러스터 환경에서도 유연하게 네트워크 확장이 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;네트워크-특징&quot;&gt;네트워크 특징&lt;/h2&gt;
&lt;h3 id=&quot;브릿지&quot;&gt;브릿지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;브릿지 네트워크는 기본 네트워크 드라이브다. 호스트 내의 컨테이너 간 통신을 지원&lt;/li&gt;
  &lt;li&gt;가상의 브리지 인터페이스를 통해 각 컨테이너를 연결하여, 동일한 네트워크 세그먼트에 있는 것처럼 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;격리된 환경&lt;/li&gt;
      &lt;li&gt;간편한 설정: 기본 설정으로 자동 생성&lt;/li&gt;
      &lt;li&gt;내부 통신 지원: 브리지 네트워크에 연결된 컨테이너 간에는 IP주소를 통해서 서로 통신할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;브리지 네트워크에 연결된 컨테이너 간에는 IP 주소를 통해서 서로 통신할 수 있다.&lt;/li&gt;
          &lt;li&gt;각 컨테이너는 브리지 네트워크에 의해서 가상의 스위치에 연결된 것처럼 동작
            &lt;ul&gt;
              &lt;li&gt;스위치는 컴퓨터 네트워크에서 여러 장치를 연결하여 데이터 패킷을 전달하는 장치다. 스위치는 네트워크 세그먼트 내의 장치들이 서로 데이터를 주고받을 수 있도록 도와준다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;브리지 네트워크에서 가상 스위치는 실제 물리적인 스위치와 같은 역할을 하여, 컨테이너 간의 데이터를 전달하고 통신을 가능하게 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;인터페이스 설명
    &lt;ol&gt;
      &lt;li&gt;eth0: 컨테이너 내부에서 eth0는 외부 네트워크와 통신을 위한 가상 네트워크 인터페이스다. 이는 컨테이너가 브리지 네트워크를 통해서 외부와 통신할 수 있도록한다. eth0는 컨테이너 내에서 기본 네트워크 인터페이스로 사용된다.&lt;/li&gt;
      &lt;li&gt;docker0: 호스트 시스템에서 기본 브리지 네트워크 인터페이스다. 이는 호스트와 모든 브리지 네트워크에 연결된 컨테이너 간의 통신을 가능하게 한다. 모든 브리지 네트워크에 연결된 컨테이너는 docker0를 통해서 서로 통신할 수 있다.&lt;/li&gt;
      &lt;li&gt;veth: virtual ethernet pair로 작동한다. 하나의 인터페이스는 컨테이너 내에 존재하고, 다른 하나는 호스트 시스템에 존재한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;호스트-네트워크&quot;&gt;호스트 네트워크&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;호스트 네트워크 모드에서는 컨테이너가 호스트의 네트워크 스택을 공유&lt;/li&gt;
  &lt;li&gt;컨테이너가 호스트의 IP주소를 직접 사용하며, 네트워크 인터페이스를 그대로 사용한다. 컨테이너가 호스트의 네트워크 환경을 그대로 사용하게 하여, 네트워크 성능을 극대화할 수 있지만, 격리도는 낮아짐&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;고성능: 네트워크 스택을 공유하기 때문에 네트워크 오버헤드가 줄어들어 성능이 향상&lt;/li&gt;
      &lt;li&gt;제한된 격리: 컨테이너가 호스트 네트워크를 공유하므로, 격리도가 떨어짐 (보안 문제)&lt;/li&gt;
      &lt;li&gt;단일 호스트 환경에서 유용: 단일 호스트 내에서 네트워크 성능을 극대화하고자 할 때 유용하다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;오버레이-네트워크&quot;&gt;오버레이 네트워크&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;오버레이 네트워크는 다중 호스트 간의 네트워크를 구성하여, 클러스터 환경에서 컨테이너 간 통신을 지원한다.&lt;/li&gt;
  &lt;li&gt;가상 네트워크를 통해서 물리적으로 분산된 노드를 연결
    &lt;ol&gt;
      &lt;li&gt;특징&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;클러스터 환경 지원: 다중 호스트 간 통신을 지원하여, kubernetes와 같은 오케스트레이션 도구와 함계 사용됨&lt;/li&gt;
      &lt;li&gt;확장성 : 네트워크를 쉽게 확장할 수 있어 대규모 애플리케이션 배포에 적합함&lt;/li&gt;
      &lt;li&gt;보안: 네트워크 오버레이를 통해 트래픽을 암호화하여 보안을 강화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 04 Oct 2024 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
