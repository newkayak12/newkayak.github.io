<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>newkayak12.github.io</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Thu, 23 May 2024 21:13:11 +0900</pubDate>
    
      <item>
        <title>[others Series] Transaction</title>
        <link>/2024/05/23/Others-series-Transaction.html</link>
        <guid isPermaLink="true">/2024/05/23/Others-series-Transaction.html</guid>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post
categories: [OTHERS]
—&lt;/p&gt;

&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/Transaction.md&quot;&gt;Dictionary - Transaction&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;

&lt;p&gt;격리 수준은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERIALIZABLE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE_READ&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_COMMITTED&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_UNCOMMITTED&lt;/code&gt;가 있으며, 왼쪽으로 가면 갈수록 격리성이 강해지며, 
오른쪽으로 가면 갈수록 동시성이 강해진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE_READ&lt;/code&gt;는 팬텀리드, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_COMMITTED&lt;/code&gt;는 팬텀리드, 반복 가능하지 않은 조회가 발생하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_UNCOMMITTED&lt;/code&gt;는 팬텀 리드, 반복 가능하지 않은
조회, 더티 리드가 발생할 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;격리-수준에-따라-발생하는-현상&quot;&gt;격리 수준에 따라 발생하는 현상&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;팬텀 리드 (Phantom read) : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.&lt;/li&gt;
  &lt;li&gt;반복 가능하지 않은 조회 (Non-repeatable read) : 한 트랜잭션 내의 같은 행이 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킨다.&lt;/li&gt;
  &lt;li&gt;더티 리드 (dirty read) : 반복 가능하지 않은 조회와 유사하며, 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아직 커밋되지 않은&lt;/code&gt; 행의 데이터를 읽을 수 있을 때 발생&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;격리-수준&quot;&gt;격리 수준&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Serializable : 트랜잭션을 순차적으로 진행시키는 것을 의미한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.&lt;/li&gt;
  &lt;li&gt;Repeatable_read : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만, 새로운 행을 추가하는 것을 막아주지는 않는다.&lt;/li&gt;
  &lt;li&gt;Read_committed : 기본 값이다. read_uncommitted와 다르게 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수는 있다.&lt;/li&gt;
  &lt;li&gt;read_uncommitted : 가장 낮은 격리 수준으로 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Semaphoreandmutex</title>
        <link>/2024/05/23/Others-series-SemaphoreAndMutex.html</link>
        <guid isPermaLink="true">/2024/05/23/Others-series-SemaphoreAndMutex.html</guid>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post
categories: [OTHERS]
—&lt;/p&gt;

&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/SemaphoreAndMutex.md&quot;&gt;Dictionary - Semaphore vs. Mutex&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;mutex&quot;&gt;Mutex&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로한 상호배제 기법&lt;/code&gt;
프로세스, 쓰레가 공유 자원을 lock()을 통해 잠금을 설정하고 사용한 뒤 unlock()으로 잠금 해제하는 객체 객체다.&lt;/p&gt;

&lt;h1 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Signaling mechanism. 현재 공유 자원에 접근할 수 있는 쓰레드, 프로세스 수를 나타내는 값을 둬서 상호배제를 이루는 기법&lt;/code&gt;
일반화된 뮤텍스, 간단한 정수 값과 두 가지 함수 wait 및 signal로 공유 자원에 대한 접근을 처리한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;은 자신의 차례가 올 때까지 기다리는 함수이며,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal()&lt;/code&gt;은 다음 프로세스로 순서를 넘겨주는 함수다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 세마포어
0, 1의 두 가지 값만 가질 수 있는 세마포어. 구현의 유사성으로 뮤텍스는 바이너리 세마포어라고 할 수 있지만 엄밀히 말하면 뮤텍스는 잠금 기반으로 상호 배제가 일어나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잠금 메커니즘&lt;/code&gt;이고, 세마포어는
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신호를 기반으로&lt;/code&gt; 상호 배제를 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신호 메커니즘이다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카운팅 세마포어
여러 개의 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는 데 사용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;monitor&quot;&gt;Monitor&lt;/h1&gt;
&lt;p&gt;모니터는 둘 이상의 쓰레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다.&lt;/p&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Processandserviceanddaemon</title>
        <link>/2024/05/23/Others-series-ProcessAndServiceAndDaemon.html</link>
        <guid isPermaLink="true">/2024/05/23/Others-series-ProcessAndServiceAndDaemon.html</guid>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post
categories: [OTHERS]
—&lt;/p&gt;

&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/ProcessAndServiceAndDaemon.md&quot;&gt;Dictionary - Process vs. Service vs. Daemon&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;process-vs-service-vs-daemon&quot;&gt;Process vs. Service vs. Daemon&lt;/h1&gt;

&lt;h2 id=&quot;process&quot;&gt;Process&lt;/h2&gt;
&lt;p&gt;프로세스는 메모리에 적재되어 CPU에 의해 실행되는 컴퓨터 프로그램을 지칭한다. 각 프로세스는 고유한 프로세스 ID(PID)를 가지며, 운영체제는 프로세스 간의 자원 공유를 관리한다.
예를 들어, 웹 브라우저를 실행하는 경우 브라우저라는 프로그램은 하나의 프로세스로 실행되는 것이다. 그리고 프로세스는 눈에 보이는 프로세스(foreground process)와
눈에 보이지 않은 프로세스(background process)로 구분된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;foreground&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;background&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자와 상호작용하는 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스는 사용자와 상호작용하지 않고 시스템에서 실행되는 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최소화를 하더라도 눈에 보이는 프로세스를 포그라운드 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;눈에 보이지 않지만 뒤에서 일을 하고 있는 프로세스를 백그라운드 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터넷, 카카오톡, 메모장, 그림판 등 눈에 보이는 프로그램&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;백신 프로그램, 그래픽 드라이버, 마이크 드라이버 등 눈에 보이지 않는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;p&gt;서비스는 백그라운드에서 실행되는 응용 프로그램이다. 윈도우 서비스는 일반적으로 사용자 인터페이스를 필요로 하지 않는 작업(네트워크 서비스, 데이터베이스 서버, 백업 서비스) 등을 수행한다.
이러한 서비스들은 시스템이 부팅될 때 자동으로 시작되며, 사용자가 로그인하지 않은 상태에서도 계속해서 실행된다.
이렇게만 보면 데몬과 서비스의 차이가 잘 와닿지 않을 것인데, 윈도우 OS에서는 백그라운드에서 실행되는 응용 프로그램을 service 라 부르고 유닉스(리눅스) OS에서는 daemon 이라고 불린다고 보면 된다.&lt;/p&gt;

&lt;h2 id=&quot;daemon&quot;&gt;Daemon&lt;/h2&gt;
&lt;p&gt;데몬은 백그라운드에서 실행되는 프로그램으로, 사용자가 직접적으로 제어하지 않고 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다. 사용자의 요청을 기다리고 있다가
요청이 발생하면 이에 적절히 대응하는 리스너와 같은 역할을 한다. 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응 할 수 있도록 대기중인 프로세스를 말한다.&lt;/p&gt;

&lt;p&gt;예시)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;서비스 명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;데몬 명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux 슈퍼데몬&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xinetd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux 내 여러 서비스를 한번에 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;File Transfer Protocol&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;vsftpd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;File을 전송하는 서비스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Secure Shell Service&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sshd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;암호화 원격 작업이 가능한 서비스&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;service-vs-daemon&quot;&gt;Service vs. Daemon&lt;/h2&gt;

&lt;p&gt;Daemon 과 Service는 비슷한 개념이지만, 운영 체제 차이점 있다고 했다. 그외에도 사용처에도 차이가 있는데, 데몬은 일반적으로 서버에서 주로 사용되고, 서비스는 다른 프로그램이나 서비스를 지원하기 위해 실행된다.
데몬은 시스템에서 독립적으로 실행되고, 서비스는 시스템의 상태를 모니터링하고, 백그라운드에서 실행되는 애플리케이션을 제어하고, 작업을 수행하는 등의 역할 지원하는데 초점이 맞춰져 있다는 뜻이다.&lt;/p&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Os</title>
        <link>/others/2024/05/23/Others-series-OS.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-OS.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/OS.md&quot;&gt;Dictionary - OS&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;os&quot;&gt;OS&lt;/h1&gt;
&lt;p&gt;운영체제의 역할&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU 스케쥴링 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다.&lt;/li&gt;
  &lt;li&gt;메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지 관리한다.&lt;/li&gt;
  &lt;li&gt;디스크 파일 관리 : 디스크 파일을 어떤 방법으로 보관할지 관리한다.&lt;/li&gt;
  &lt;li&gt;I/O 디바이스 관리 : I/O 디바이스들과 컴퓨터 간의 데이터를 주고 받는 것을 관리한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/os.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시스템 호출(systemCall)이란 운영체제가 커널에 접근한기 위한 인터페이스이며, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다.&lt;/p&gt;

&lt;h1 id=&quot;컴퓨터의-요소&quot;&gt;컴퓨터의 요소&lt;/h1&gt;
&lt;p&gt;컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이뤄져 있다.&lt;/p&gt;

&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;CU(ControlUnit) : 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다.&lt;/li&gt;
  &lt;li&gt;레지스터 : 매우 빠른 임시기억 장치&lt;/li&gt;
  &lt;li&gt;산술논리연산장치 : 덧셈, 뺄셈 같은 두 숫자의 산술연산, 배타적 논리합, 곱 등같은 논리 연산을 계산하는 디지털 회로&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dma&quot;&gt;DMA&lt;/h2&gt;
&lt;p&gt;I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU에만  너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며, CPU의 일을 부담하는 역할을 한다.&lt;/p&gt;

&lt;h2 id=&quot;메모리&quot;&gt;메모리&lt;/h2&gt;
&lt;p&gt;메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음&lt;/li&gt;
  &lt;li&gt;캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음, L3도 있다.&lt;/li&gt;
  &lt;li&gt;주기억장치 : RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량이 보통&lt;/li&gt;
  &lt;li&gt;보조기억장치 : HDD, SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량 많음&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;
&lt;p&gt;캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목을 줄이기 위해서 사용하는 메모리를 말한다. 이를 통해 
데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;지역성의-원리&quot;&gt;지역성의 원리&lt;/h3&gt;
&lt;p&gt;자주 사용하는 데이터를 기반으로 설정해야 한다. 자주 사용하는 데이터에 대한 근거가 무엇일까? 시간 지역성(temporal locality), 공간 지역성(spatiaal locality)가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;시간 지역성
최근 사용한 데이터에 다시 접근하려는 특성을 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공간 지역성
최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스-히트&quot;&gt;캐시 미스, 히트&lt;/h3&gt;
&lt;p&gt;원하는 데이터를 찾는 것을 캐시 히트 반대를 캐시 미스라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-관리&quot;&gt;메모리 관리&lt;/h3&gt;
&lt;p&gt;가상 메모리는 메모리 관리 기법의 하나로 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;스와핑&quot;&gt;스와핑&lt;/h3&gt;
&lt;p&gt;가상 메모리에 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다. 이때 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 
HDD의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-폴트&quot;&gt;페이지 폴트&lt;/h3&gt;
&lt;p&gt;프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우 발생한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 없다면 트랩이 발생해서 운영체제에 알리게 된다.&lt;/li&gt;
  &lt;li&gt;OS는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.&lt;/li&gt;
  &lt;li&gt;해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체(스와핑)&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 갱신시킨 후 해당 명령을 다시 시&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;쓰레싱&quot;&gt;쓰레싱&lt;/h3&gt;
&lt;p&gt;Thrashing은 메모리의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터의 성능 저하를 초래한다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h3&gt;
&lt;p&gt;시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;연속 할당 : 메모리에 ‘연속적으로’ 공간을 할당하는 것을 의미
    &lt;ul&gt;
      &lt;li&gt;고정 분할 방식(fixed partition allocation) : 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어 있기 때문에 융통성이 없다. 또한 내부 단편화가 발생한다.&lt;/li&gt;
      &lt;li&gt;가변 불할 방식(variable partition allocation) : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 없지만 외부 단편화가 있을 수 있다. (최초 적합, 최적 적합, 최악 적합이 있다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;First Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Best Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Worst Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스의 크기와 가장 많이 차이가 나는 홀에 할당&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;

  &lt;p&gt;내부 단편화(Internal Fragmentation) : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
외부 단편화(External Fragmentation) : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 경우 
홀 (hole) : 할당할 수 있는 비어 있는 메모리 공간&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;불연속 할당
현대 OS가 쓰는 방법, 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것, 페이징 말고 세그맨테이션, 페이지드 세그멘테이션이 있다.
    &lt;ul&gt;
      &lt;li&gt;Paging : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다. 홀의 크긱가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.&lt;/li&gt;
      &lt;li&gt;Segmentation : 페이지가 아닌 의미 단위인 세그먼트로 나누는 방식이다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이뤄지는데, 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수도 있다. 이는 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않는 단점이 있다.&lt;/li&gt;
      &lt;li&gt;Paged Segmentation : 세그먼트로 나누는데, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;페이지 교체 알고리즘
offline : 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다. 
FIFO(First In First Out) : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미한다. 
LRU(Least Recently Used) : 참조가 가장 오래된 페이지를 바꾼다. 
NUR(Not Used Recently) : LRU에서 발, clock 알고리즘, 시계 방향으로 돌며 참조하면 1, 아니면 0. 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘
LFU(Least Frequently Used) : 가장 참조 횟수가 적은 페이지를 교체한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;프로세스-상태&quot;&gt;프로세스 상태&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/process.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;New : 프로세스 생성 상태, fork(), exec() 함수로 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;fork() : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수 (주소 공간만 복사)&lt;/li&gt;
  &lt;li&gt;exec() : 새롭게 프로세스를 생성하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ready : 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기, CPU 소유권이 넘어오기를 기다림
Ready Suspend : 메모리 부족으로 일시 중단된 상태&lt;/p&gt;

&lt;p&gt;Blocked : 어떤 이벤크가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다. 
Blocked Suspend : 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태&lt;/p&gt;

&lt;p&gt;Terminated : 메모리와 CPU 소유권을 모두 놓고 가는 상태부모가 자식 프로세스를 강제로 비자발적 종료로 종료되는 것도 있다. 자식 프로세스가 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process kill로 프로세스를 종료할 때 발&lt;/p&gt;

&lt;h2 id=&quot;컨텍스트-스위칭&quot;&gt;컨텍스트 스위칭&lt;/h2&gt;
&lt;p&gt;PCB를 기반으로 프로세스 상태를 저장하고 로드시키는 과정, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;PCB ( Process Control Block ) : 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 프로세스 제어 블록이라고도 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;쓰레드-멀티-쓰레딩&quot;&gt;쓰레드, 멀티 쓰레딩&lt;/h2&gt;
&lt;p&gt;쓰레드 : 프로셋의 실행 가능한 가장 작은 단위
멀티쓰레드 : 프로세스 내 여러 개의 쓰레드, 멀티 쓰레드로 처리하는 기법 쓰레드끼리 자원을 공유하기 때문에 효율성이 높음&lt;/p&gt;

&lt;h2 id=&quot;공유-자원&quot;&gt;공유 자원&lt;/h2&gt;
&lt;p&gt;shared resource는  시스템 안에서 각 프로세스, 쓰레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원이나 변수를 의미한다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을
경쟁 상태(race condition)이라고 한다.  동시 접근 시 타이밍, 순서 등이 결과에 영향을 준다.&lt;/p&gt;

&lt;h2 id=&quot;임계-영역&quot;&gt;임계 영역&lt;/h2&gt;
&lt;p&gt;둘 이상의 프로세스, 쓰레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 말한다. 임계영역을 해결하는 방법은 뮤텍스, 세마포어, 모니터 세 가지가 있다. 
모두 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;상호 배제(mutual exclusion)
한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.&lt;/p&gt;

  &lt;p&gt;한정 대기(bounded waiting)
특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하면 안 된다.&lt;/p&gt;

  &lt;p&gt;융통성(progress)
만약 어떠한 프로세스도 임계 영역을 사용하지 않으면 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며, 이 때 프로세스끼리 서로 방해하지 않는다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;SemaphoreAndMutex.md&quot;&gt;세마포어, 뮤텍스, 모니터&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착-상태deadlock의-원인&quot;&gt;교착 상태(Deadlock)의 원인&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가&lt;/li&gt;
  &lt;li&gt;점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태&lt;/li&gt;
  &lt;li&gt;비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다.&lt;/li&gt;
  &lt;li&gt;환형 대기 : 프로세스A는 프로세스B의 자원을 요구하고, 프로세스B는 A의 자원을 요고하는 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자원 할당 시 조건이 설림하지 않도록 설계&lt;/li&gt;
  &lt;li&gt;교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;은행원 알고리즘&lt;/code&gt;을 쓴다.&lt;/li&gt;
  &lt;li&gt;교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.&lt;/li&gt;
  &lt;li&gt;거의 일어나지 않지만 처리하는데 비용이 크다. 그래서 사용자에게 판단을 위임한다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Network</title>
        <link>/others/2024/05/23/Others-series-Network.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Network.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/Network.md&quot;&gt;Dictionary - Network&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;network&quot;&gt;Network&lt;/h1&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;LAN : Local Area Network&lt;/li&gt;
  &lt;li&gt;MAN : Metropolitan Area Network&lt;/li&gt;
  &lt;li&gt;WAN : Wide Area Network&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tcpip-4계층---osi-7계층&quot;&gt;TCP/IP 4계층 - OSI 7계층&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/layer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcpip-4계층&quot;&gt;TCP/IP 4계층&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;L4 (애플리케이션 계층) : FTP/ HTTP/ SSH/ SMTP/ DNS -&amp;gt; 프로토콜 계층&lt;/li&gt;
  &lt;li&gt;L3 (전송 계층): TCP/ UDP/ QUIC -&amp;gt; 송,수신자를 연결하는 계층&lt;/li&gt;
  &lt;li&gt;L2 (인터넷 계층) : IP/ ARP/ ICMP -&amp;gt; 네트워크 패킷을 IP주소로 지정된 목적지로 전송하기 위해서 사용하는 계층&lt;/li&gt;
  &lt;li&gt;L1 (링크 계층) : ethernet -&amp;gt; 전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달하며 장치 간의 신호를 주고 받는 규칙을 정하는 계층&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;osi-7&quot;&gt;OSI 7&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;L7 (응용 계층) : HTTP/ FTP/ SMTP/ POP3/ IMAP/ Telnet과 같은 프로토콜이 있다. -&amp;gt; 응용 서비스를 수행 (L7 스위치)&lt;/li&gt;
  &lt;li&gt;L6 (표현 계층) : 코드 간의 번역을 담당하며, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 덜어준다. -&amp;gt; MIME 인코딩, 암호화 같은 동작을 수행 (압축, 포장, 암호화)&lt;/li&gt;
  &lt;li&gt;L5 (세션 계층) : 데이터가 통신하기 위한 노리적 연결을 한다. -&amp;gt; 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 (duplex, half-duplex, full-duplex), TCP/IP 세션을 만들고 없애는 책임을 가진다.&lt;/li&gt;
  &lt;li&gt;L4 (전송 계층) : 통신을 활성화 하기 위한 계층 단대단 오류제어 및 흐름 제어(UDP/TCP) -&amp;gt; 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있으며 연결 기반이다. (이는 전송계층이 패킷들의 전송이 유효한지 확인하고 실패한 패킷들을 다시 전송한다는 것이다.)&lt;/li&gt;
  &lt;li&gt;L3 (네트워크 계층) : 라우팅이 가장 중요한 기능이다. -&amp;gt; IP주소 부여, 라우팅 (라우터, L3 스위치)&lt;/li&gt;
  &lt;li&gt;L2 (데이터 링크 계층) : 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보 전달을 수행할 수 있도록 도와주는 역할을 한다. -&amp;gt; mac을 가지고 통신한다. 이 계층에서 전송되는 단위를 프레임이라고 한다. (L2 스위치, 브리지)&lt;/li&gt;
  &lt;li&gt;L1 (물리 계층) : 전기적, 기계적 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송한다. -&amp;gt; 단순 전기적 신호를 변환해서 주고 받는다. ( NIC, 리피터, AP)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Multiprocessandmultithread</title>
        <link>/others/2024/05/23/Others-series-MultiProcessAndMultiThread.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-MultiProcessAndMultiThread.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/MultiProcessAndMultiThread.md&quot;&gt;Dictionary - MultiProcess vs. MultiThread&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;multiprocess-vs-multithread&quot;&gt;MultiProcess vs. MultiThread&lt;/h1&gt;

&lt;h2 id=&quot;multiprocess&quot;&gt;MultiProcess&lt;/h2&gt;
&lt;p&gt;멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다. 보통 하나의 프로그램 실행에 대해 하나의 프로세스가 메모리에 생성되지만, 부가적인 기능을 위해 여러개의 프로세스를 생성하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/multiProcess.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 프로세스 내부를 보면, 하나의 부모 프로세스가 여러 개의 자식 프로세스를 생성함으로서 다중 프로세스를 구성하는 구조이다.
한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성할 수 있는데, 다른 프로세스를 생성하는 프로세스를 부모 프로세스(Parent Process)라 하고,
다른 프로세스에 의해 생성된 프로세스를 자식 프로세스(Child Process)라 한다.&lt;/p&gt;

&lt;p&gt;부모 프로세스와 자식 프로세스는 각각 고유한 PID(Process ID)를 가지고 있다. 부모 프로세스는 자식 프로세스의 PID를 알고 있으며, 이를 통해 자식 프로세스를 제어할 수 있다. 또한, 자식 프로세스는 부모 프로세스의 PID와 PPID(Parent Process ID)를 알고 있어, 이를 통해 부모 프로세스와의 통신이 가능하다.
ex) 브라우저 탭&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;h4 id=&quot;1-프로그램-안정성&quot;&gt;1. 프로그램 안정성&lt;/h4&gt;
&lt;p&gt;독립적 메모리 공간을 가져서 한 프로세스가 비정상 종료되도 다른 프로세스에 영향을 주지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;2-병렬성&quot;&gt;2. 병렬성&lt;/h4&gt;
&lt;h4 id=&quot;3-시스템-확장성&quot;&gt;3. 시스템 확장성&lt;/h4&gt;
&lt;p&gt;멀티 프로세스는 각 프로세스가 독립적이므로, 새로운 기능이나 모듈을 추가하거나 수정할때 다른 프로세스에 영향을 주지 않는다. 그래서 시스템의 규모를 쉽게 확장할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;h4 id=&quot;1-context-switching-overhead&quot;&gt;1. Context Switching OverHead&lt;/h4&gt;
&lt;p&gt;멀티태스킹을 구성하는데 핵심 기술인 컨텍스트 스위칭(context switching) 과정에서 성능 저하가 올 수 있다&lt;/p&gt;
&lt;h4 id=&quot;2-자원-공유-비효율성&quot;&gt;2. 자원 공유 비효율성&lt;/h4&gt;
&lt;p&gt;멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 결과적으로 메모리 사용량이 증가하게 된다.
만일 각 프로세스간에 자원 공유가 필요할 경우 프로세스 사이의 어렵고 복잡한 통신 기법인 IPC(Inter-Process Commnuication)을 사용하여야 한다.&lt;/p&gt;

&lt;h2 id=&quot;multithread&quot;&gt;MultiThread&lt;/h2&gt;
&lt;p&gt;스레드는 하나의 프로세스 내에 있는 실행 흐름이다. 그리고 멀티 스레드는 하나의 프로세스 안에 여러개의 스레드가 있는 것을 말한다. 따라서 하나의 프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능해진다.
멀티 프로세스는 웹 브라우저에서의 여러 탭이나 여러 창이라고 말했었다. 대신 멀티 스레드는 웹 브라우저의 단일 탭 또는 창 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리하고 처리하는데 사용된다고 보면된다.&lt;/p&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;
&lt;h4 id=&quot;1-쓰레드가-프로세스보다-저렴함&quot;&gt;1. 쓰레드가 프로세스보다 저렴함&lt;/h4&gt;
&lt;h4 id=&quot;2-공유-메모리에-따른-자원-효율성&quot;&gt;2. 공유 메모리에 따른 자원 효율성&lt;/h4&gt;
&lt;h4 id=&quot;3-context-switching-비용-감소-비용이-상대적으로-낮다&quot;&gt;3. Context Switching 비용 감소 (비용이 상대적으로 낮다.)&lt;/h4&gt;
&lt;h4 id=&quot;4-응답-시간-단축&quot;&gt;4. 응답 시간 단축&lt;/h4&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;
&lt;h4 id=&quot;1-안정성&quot;&gt;1. 안정성&lt;/h4&gt;
&lt;h4 id=&quot;2-공유-메모리-동기화로-인한-성능-저하&quot;&gt;2. 공유 메모리 동기화로 인한 성능 저하&lt;/h4&gt;
&lt;h4 id=&quot;3-데드락&quot;&gt;3. 데드락&lt;/h4&gt;
&lt;h4 id=&quot;4-context-switch-overhead-1&quot;&gt;4. Context Switch Overhead &lt;sup&gt;&lt;a href=&quot;#contextSwitchOverhead&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;h4 id=&quot;5-디버깅이-어려움&quot;&gt;5. 디버깅이 어려움&lt;/h4&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;contextSwitchOverhead&quot;&gt;[1]&lt;/a&gt; : 
running상태가 끝난 프로세스는 PC, SP, 레지스터, Base Register, limit Register 등 많은 내용들을 PCB에 저장을 해야하는 것이고, 이후 Dispatcher는 ready queue에서 running상태로 올릴 프로세스의 PCB에서 또다시 많은 내용을 복원해야 하는 것이다. 즉, context switching을 위해 context를 저장하고 context를 restore하는 것인데 이러한 일을 하는 데에는 부담이 발생할 수밖에 없을 것이다.
이렇게 Context Switch(문맥 교환)에 의해 Dispatcher에 발생하게 되는 부담을 “Context Switching Overhead(문맥교환 오버헤드)”라고 한다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Encryption</title>
        <link>/others/2024/05/23/Others-series-Encryption.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Encryption.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/Encryption.md&quot;&gt;Dictionary - Encrypt&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;암호화&quot;&gt;암호화&lt;/h1&gt;

&lt;h2 id=&quot;단방향-hash&quot;&gt;단방향 (Hash)&lt;/h2&gt;
&lt;h3 id=&quot;1-종류&quot;&gt;1. 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MD5 (Message-Digest algorithm 5)&lt;/li&gt;
  &lt;li&gt;SHA-1&lt;/li&gt;
  &lt;li&gt;SHA-2(SHA-256)
    &lt;h3 id=&quot;2-장점&quot;&gt;2. 장점&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;빠른 속도
    &lt;h3 id=&quot;3-단점&quot;&gt;3. 단점&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;RainbowTable : 동일한 메시지는 동일한 다이제스트를 갖는다. (BruteForce)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;양방향&quot;&gt;양방향&lt;/h2&gt;
&lt;h3 id=&quot;대칭키비공개키&quot;&gt;대칭키(비공개키)&lt;/h3&gt;
&lt;h4 id=&quot;1-종류-1&quot;&gt;1. 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;DES&lt;/li&gt;
  &lt;li&gt;3DES&lt;/li&gt;
  &lt;li&gt;AES&lt;/li&gt;
  &lt;li&gt;SEED&lt;/li&gt;
  &lt;li&gt;ARIA&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-특징&quot;&gt;2. 특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;암/복호화에 서로 동일한 키가 상용되는 암호화 방식 (그래서 비공개)
    &lt;h4 id=&quot;3-장점&quot;&gt;3. 장점&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;속도가 빠름
    &lt;h4 id=&quot;4-단점&quot;&gt;4. 단점&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;키가 탈취되면 문제가 생김&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비대칭키공개키&quot;&gt;비대칭키(공개키)&lt;/h3&gt;
&lt;h4 id=&quot;1-종류-2&quot;&gt;1. 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;RSA&lt;/li&gt;
  &lt;li&gt;DSA&lt;/li&gt;
  &lt;li&gt;ECC
    &lt;h4 id=&quot;2-특징-1&quot;&gt;2. 특징&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;암/복호화에 서로 다른 키가 사용된다.
    &lt;h4 id=&quot;3-장점-1&quot;&gt;3. 장점&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;키가 탈취되도 문제가 적다.
    &lt;h4 id=&quot;4-단점-1&quot;&gt;4. 단점&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;느리다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Cpuschedule</title>
        <link>/others/2024/05/23/Others-series-CpuSchedule.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-CpuSchedule.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/CpuSchedule.md&quot;&gt;Dictionary - CPU scheduling&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;cpu-스케쥴링-알고리즘&quot;&gt;CPU 스케쥴링 알고리즘&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cpuSchedule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-비선점non-preemptive&quot;&gt;1. 비선점(non-preemptive)&lt;/h2&gt;
&lt;p&gt;프로세스가 스스로 CPU 소유권을 포기하는 방식. 강제로 프로세스를 중지하지 않는다. 따라서 컨텍스트 스위칭으로 인한 부하가 적다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FCFS(First Come, First Served) : 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘 -&amp;gt; ready Queue에서 오래 기다리는 현상(Convoy effect)가 발생하는 단점이 있다.&lt;/li&gt;
  &lt;li&gt;SJF(Shortest Job First) : 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘 -&amp;gt; 긴 시간을 가진 프로세스가 실행되지 않는 현상(Starvation)이 일어나며, 평균 대기 시간이 가장 짧다.&lt;/li&gt;
  &lt;li&gt;우선 순위 : SJF는 긴 시간 프로세스가 무한정 밀릴 수 있다. 우선 순위는 ‘우선 순위를 높이는 방법(aging)’을 사용해서 이를 보완했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-선점preemptive&quot;&gt;2. 선점(preemptive)&lt;/h2&gt;
&lt;p&gt;현대 OS 작동 방식으로 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 다른 프로세스에 CPU 소유권을 할당하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라운드 로빈(Round Robin) : 각 프로세스는 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 ready Queue의 뒤로 가는 알고리즘&lt;/li&gt;
  &lt;li&gt;SRF(Shortest Remaining Time First) : SJF는 중간 실행 시간이 더 짧은 작업이 들어오면 기존 작업을 수행하고 넘어가는데, SRF는 더 짧은 작업이 생기면 중간에 종료하고 더 짧은 것을 먼저 수행하는 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;다단계 큐 : 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Compiletranspileinterpreter</title>
        <link>/others/2024/05/23/Others-series-CompileTranspileInterpreter.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-CompileTranspileInterpreter.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/CompileTranspileInterpreter.md&quot;&gt;Dictionary - Compile vs. Transpile vs. Interpreter&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;compile-vs-transpile-vs-interpreter&quot;&gt;Compile vs. Transpile vs. Interpreter&lt;/h1&gt;
&lt;h2 id=&quot;compile&quot;&gt;Compile&lt;/h2&gt;
&lt;p&gt;한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것이 컴파일이다
ex) JAVA -&amp;gt; bytecode&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전체 파일을 스캔하여 한꺼번에 번역&lt;/li&gt;
  &lt;li&gt;초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.&lt;/li&gt;
  &lt;li&gt;기계어 번역과정에서 많은 메모리를 사용한다.&lt;/li&gt;
  &lt;li&gt;전체 코드를 스캔하는 과정에서 모든 오류를 한꺼번에 출력해주기 때문에 실행 전에 오류를 알 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interpreter&quot;&gt;Interpreter&lt;/h2&gt;
&lt;p&gt;인터프리터(Interpreter)는 사람이 알아보기 쉬운 프로그래밍 언어로 작성한 코드를 한 줄 씩 즉시 기계어로 번역하는 번역기라고 생각하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 실행 시 한 번에 한 문장씩 번역한다.&lt;/li&gt;
  &lt;li&gt;한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.&lt;/li&gt;
  &lt;li&gt;컴파일러와 같은 오브젝트 코드 생성과정이 없기 때문에 메모리 효율이 좋다.&lt;/li&gt;
  &lt;li&gt;프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있기 때문에 사용성이 문제가 될수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;transpile&quot;&gt;Transpile&lt;/h2&gt;
&lt;p&gt;한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것이 트랜스파일이다.
ex) typeScript -&amp;gt; javaScript&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Cachestrategy</title>
        <link>/others/2024/05/23/Others-series-CacheStrategy.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-CacheStrategy.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/CacheStrategy.md&quot;&gt;Dictionary - Caching&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로젝트에서 Redis로 캐싱 전 찾아본&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;캐싱-전략&quot;&gt;캐싱 전략&lt;/h1&gt;
&lt;p&gt;캐싱 전략은 웹 서비스에서 시스템 향상을 기대할 수 있는 중요 기술이다.&lt;/p&gt;

&lt;h1 id=&quot;기본-지식&quot;&gt;기본 지식&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;cache hit : 캐시 스토어에 데이터가 있는 경우&lt;/li&gt;
  &lt;li&gt;cache miss : 캐시 스토어에 데이터가 없을 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;주요-고려-사항&quot;&gt;주요 고려 사항&lt;/h1&gt;
&lt;p&gt;캐시를 사용하면 데이터 정합성 문제가 발생한다. 따라서 적절한 캐시 읽기 전략(Read Cache Strategy)과 캐시 쓰기 전략(Write Cache Strategy)으로 
데이터 불일치 문제를 극복하면서 성능 또한 잡아야 한다.&lt;/p&gt;

&lt;h1 id=&quot;캐시-읽기-전략-read-cache-strategy-&quot;&gt;캐시 읽기 전략( Read Cache Strategy )&lt;/h1&gt;
&lt;h2 id=&quot;1-look-aside&quot;&gt;1. Look Aside&lt;/h2&gt;
&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Cache Aside 패턴&lt;/li&gt;
  &lt;li&gt;데이터를 찾을 때 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인 없으면 DB에서 조회&lt;/li&gt;
  &lt;li&gt;반복적 읽기가 많은 호출에 적합&lt;/li&gt;
  &lt;li&gt;캐시, DB가 분리되어 가용. 원하는 데이터만 별도로 구성하여 캐시에 저장&lt;/li&gt;
  &lt;li&gt;캐시, DB가 분리되어 있어 캐시 장애에 대응 가능&lt;/li&gt;
  &lt;li&gt;Cache Store, Data Store 간의 정합성 유지 문지가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;초기 조회시 DB를 무조건 조회해야 하므로 단건 호출 빈도가 높은 서비스에서는 적합하지 않다. 대신 반복적으로 동일 쿼리를 호출하는 경우 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;

  &lt;p&gt;[Cache Warming]
미리 Cache로 DB 데이터를 밀어 넣는 작업. 이 작업을 하지 않으면 초기 트래픽 증가 시 cache miss가 발생해서 부하가 급장할 수 있다.
expire되면 Thundering Herd가 발생할 수 있으므로 TTL 조정이 필요하다.&lt;/p&gt;

  &lt;p&gt;[Thundering Herd]
캐시 데이터가 휘발됐을 때 다수의 프로세스가 하나의 이벤트를 기다리며 Waiting에 있다 해당 이벤트가 발생했을 때 모든 프로세스들이 동시에
wake-up하며 자원을 낭비할 때 발생&lt;/p&gt;

  &lt;p&gt;-&amp;gt; 동일한 많은 요청이 들어왔을 때 하나의 Cache miss만 원본 서버에 요청하고 나머지 요청은 잠시 대기 시킨 후, 응답이 오면 그 응답을 반환하게 하는 방법으로 해결 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/readLookAside.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-read-through-패턴&quot;&gt;2. Read through 패턴&lt;/h2&gt;
&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;캐시에서만 데이터를 읽어오는 전략 (inline cache)&lt;/li&gt;
  &lt;li&gt;Look Aside와 비슷하지만 데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임하는 방식&lt;/li&gt;
  &lt;li&gt;데이터 조회 속도가 전체적으로 느림&lt;/li&gt;
  &lt;li&gt;데이터 조회를 전적으로 캐시에만 의지하므로 캐시 서버가 다운되면 서비스 이용에 문제가 생길 수 있음&lt;/li&gt;
  &lt;li&gt;위 문제는 Redis를 replication 또는 Cluster 구성으로 극복할 수 있다.&lt;/li&gt;
  &lt;li&gt;캐시, DB 간 데이터 동기화가 항상 이뤄져서 정합성 문제에서 자유로움&lt;/li&gt;
  &lt;li&gt;읽기가 많은 워크로드에 적합&lt;/li&gt;
  &lt;li&gt;Cache Aside와 비슷하지만 CacheStore 저장 주체가 Server냐, DataStore이냐 차이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/readThrough.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시-쓰기-전략-write-cache-strategy&quot;&gt;캐시 쓰기 전략 (Write Cache Strategy)&lt;/h1&gt;
&lt;h2 id=&quot;1-write-back&quot;&gt;1, Write Back&lt;/h2&gt;
&lt;h3 id=&quot;특정&quot;&gt;특정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Write Behind 패턴이라고도 불린다.&lt;/li&gt;
  &lt;li&gt;캐시오 DB 동기화를 비동기하기 떄문에 동기화 전략이 생략&lt;/li&gt;
  &lt;li&gt;데이터를 저장할 떄 DB에 바로 쿼리하지 않고 캐시에 모아서 일정 주기 배치 작업을 통해서 진행&lt;/li&gt;
  &lt;li&gt;캐시에 모아놨다 한 번에 쓰므로 쓰기 쿼리 비용을 줄일 수 있음&lt;/li&gt;
  &lt;li&gt;Write가 빈번하면서 Read하는데 많은 양의 Resource가 소모되는 서비스에 적합&lt;/li&gt;
  &lt;li&gt;데이터 정합성 확보&lt;/li&gt;
  &lt;li&gt;자주 사용되지 않은 불필요한 리소스 저장&lt;/li&gt;
  &lt;li&gt;캐시에서 오류가 생기면 데이터를 영구 소실&lt;/li&gt;
  &lt;li&gt;Write back 방식은 DB가 아니라 캐시에 먼저 저장하여 Queue로 사용하고, 특정 시점마다 DB로 flush 하는 방식이다.&lt;/li&gt;
  &lt;li&gt;DB에 장애가 생겨도 캐시가 살아있으면 서비스를 계속할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/writeBack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-write-through-패턴&quot;&gt;2. Write Through 패턴&lt;/h2&gt;
&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DB와 Cache에 동시에 데이터를 저장&lt;/li&gt;
  &lt;li&gt;데이터를 저장할 때 캐시에 먼저 저장하고 DB로 바로 저장&lt;/li&gt;
  &lt;li&gt;Read Through와 마찬가지로 DB 동기화를 캐시에 위임&lt;/li&gt;
  &lt;li&gt;DB와 캐시가 항상 동기화 되어 있어, 캐시 상테는 항상 최신&lt;/li&gt;
  &lt;li&gt;캐시와 백업 저장소 업데이트를 같이 해서 데이터 일관성을 유지할 수 있으서 안정적이다.&lt;/li&gt;
  &lt;li&gt;데이터 유실이 발생하면 안되는 곳에 사용&lt;/li&gt;
  &lt;li&gt;자주 사용하지 않는 불필요한 리소스를 저장할 수 있음&lt;/li&gt;
  &lt;li&gt;빈번한 Write가 생길 수 있음&lt;/li&gt;
  &lt;li&gt;기억 장치 속도가 느리면 CPU 유휴 시간 증가&lt;/li&gt;
  &lt;li&gt;캐시에 넣은 데이터를 저장만 하고 사용하지 않을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/writeThrough.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;WriteThrough, WriteBack 모두 쓰지 않은 데이터를 저장하며, 리소스 낭비를 줄이기 위해서 TTL을 설정해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-write-around&quot;&gt;3. Write Around&lt;/h2&gt;
&lt;h3 id=&quot;특징-3&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Write Through보다 빠름&lt;/li&gt;
  &lt;li&gt;모든 데이터는 DB에 저장&lt;/li&gt;
  &lt;li&gt;Cache miss가 발생하면 DB와 캐시에도 데이터를 저장&lt;/li&gt;
  &lt;li&gt;DB, Cache 간 데이터 정합성에 문제가 있을 수 있&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/writeAround.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시-읽기--쓰기-조합&quot;&gt;캐시 읽기 + 쓰기 조합&lt;/h1&gt;
&lt;h2 id=&quot;1-look-aside--write-around&quot;&gt;1. Look Aside + Write Around&lt;/h2&gt;
&lt;p&gt;Read는 (Cache || DB) -&amp;gt; ( hit - cache / miss - DB ) + Write는 DB로&lt;/p&gt;

&lt;h2 id=&quot;2-read-through--write-around&quot;&gt;2. Read Through + Write Around&lt;/h2&gt;
&lt;p&gt;Read는 Cache (hit -&amp;gt; cache / miss -&amp;gt; 캐시가 DB에서 당겨옴 ) + Write는 DB에&lt;/p&gt;

&lt;p&gt;(항상 DB에 쓰고 읽을 때 DB에서 읽어오므로)&lt;/p&gt;

&lt;h2 id=&quot;3-read-through--write-through&quot;&gt;3. Read Through + Write Through&lt;/h2&gt;
&lt;p&gt;Read는 Cache (hit -&amp;gt; cache / miss -&amp;gt; 캐시가 DB에서 당겨옴 ) + Write(Cache -&amp;gt; DB)&lt;/p&gt;

&lt;h1 id=&quot;저장-방식-지침&quot;&gt;저장 방식 지침&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;자주 사용되면서 자주 변경되지 않는 데이터를 캐싱한다.&lt;/li&gt;
  &lt;li&gt;캐시는 휘발성을 가져야 한다. ( 어느 정도 데이터 수집과 저장 주기를 가지도록 설계 해야 한다. )&lt;/li&gt;
  &lt;li&gt;데이터 유실, 정합성이 꺠질 수 있으므로 중요한 정보, 민감한 정보는 캐싱하지 않는 방향으로 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;파레토의 법칙 ( 8 : 2 법칙 )
전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;삭제-방식-지침&quot;&gt;삭제 방식 지침&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;영구 저장소 복사본으로 동작하므로 데이터 동기화가 필요하다.&lt;/li&gt;
  &lt;li&gt;캐시 구성에 만료 정책을 정해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cache-stampede-현상&quot;&gt;Cache Stampede 현상&lt;/h2&gt;
&lt;p&gt;대규모 트래픽에서 TTL을 너무 작게 하면 Key Expire 순간, 여러 프로세스가 Key를 조회하면 DB로 Duplicated read를 한다.
또 읽어온 값을 Redis에 Duplciate Write하는 경우도 발생할 수 있다. 따라서 쓸데 없는 작업을 수반하는 현상을 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;캐시-가용성&quot;&gt;캐시 가용성&lt;/h1&gt;
&lt;p&gt;캐시 구성하는 목적은 빠른 성능 확보와 데이터 전달에 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Cicd</title>
        <link>/others/2024/05/23/Others-series-CICD.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-CICD.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/CICD.md&quot;&gt;Dictionary - CI/CD&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;cicd&quot;&gt;CI/CD&lt;/h1&gt;

&lt;h2 id=&quot;cicontinuous-integration&quot;&gt;CI(Continuous Integration)&lt;/h2&gt;
&lt;p&gt;CI/CD의 “CI”는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미한다.
CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로,
여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;cd-continuous-delivery--deployment&quot;&gt;CD (Continuous Delivery / Deployment)&lt;/h2&gt;
&lt;p&gt;CI/CD의 “CD”는 지속적인 서비스 제공(Continuous Delivery) 및/또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용된다.
두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-delivery&quot;&gt;Continuous Delivery&lt;/h3&gt;
&lt;p&gt;이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리(예: GitHub 또는 컨테이너 레지스트리)에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 리포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다.
이는 개발팀과 비즈니스팀 간의 가시성과 커뮤니케이션 부족 문제를 해결해 준다.
지속적인 제공은 귀찮은 push 작업없이 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 한다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-deployment&quot;&gt;Continuous Deployment&lt;/h3&gt;
&lt;p&gt;란 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미한다.
이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결한다.
지속적인 배포는 파이프라인의 다음 단계를 자동화함으로써 지속적인 제공이 가진 장점을 활용한다.&lt;/p&gt;

&lt;h2 id=&quot;장점&quot;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;변경 사항을 자주 푸시하고자 하는 개발자와 안정적인 애플리케이션을 원하는 운영 담당자 사이의 마찰을 해결한다.&lt;/li&gt;
  &lt;li&gt;코드 변경을 사용자에게 푸시하기 전에 검증하기 위해 개발 팀은 지속적인 테스트를 실행해야 한다.&lt;/li&gt;
  &lt;li&gt;큰 변경보다 안정적으로 통합 및 테스트가 가능한 더 작은 규모의 증분적 코드 변경을 수행하도록 개발자를 독려한다.&lt;/li&gt;
  &lt;li&gt;새로운 기능을 위한 더 넓은 범위의 개발 작업을 수행하는 동시에 신속한 수정 요청까지 받는 팀에 작업의 유연성을 부여한다.&lt;/li&gt;
  &lt;li&gt;기능, 성능 및 데이터 중심 테스트를 더 많이 실행해서 더 높은 품질의 애플리케이션을 제공하고 프로덕션 결함을 줄일 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인&quot;&gt;파이프라인&lt;/h2&gt;
&lt;p&gt;컴퓨터 과학에서 데이터 파이프 라인 (일반적으로 파이프 라인이라고 함)은 제공된 데이터 또는 코드에 대해 사전 정의 된 작업을 수행하는 일련의 처리 단계다.
파이프 라인 사용의 목적은 반복적 인 프로세스를 자동화하여 시간을 절약하고 정밀도를 높이는 것이다.
파이프 라인의 이러한 장점은 CI / CD 인프라와의 호환성과 효율성을 높여준다. 특히 CI / CD 파이프 라인은 최신 버전의 소프트웨어 애플리케이션을 업데이트하고 제공하려는 일련의 처리 단계를 수행할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;빌드 (소프트웨어 컴파일),&lt;/li&gt;
  &lt;li&gt;테스트 (호환성 및 오류 검사)&lt;/li&gt;
  &lt;li&gt;릴리스 (버전 제어 저장소의 애플리케이션 업데이트)&lt;/li&gt;
  &lt;li&gt;배포 (개발에서 프로덕션 환경으로의 변환)&lt;/li&gt;
  &lt;li&gt;규정 준수 및 유효성 검사&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Authenticationandauthorization</title>
        <link>/others/2024/05/23/Others-series-AuthenticationAndAuthorization.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-AuthenticationAndAuthorization.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/AuthenticationAndAuthorization.md&quot;&gt;Dictionary - Authentication vs. Authorization&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;authentication-vs-authorization&quot;&gt;Authentication vs. Authorization&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;인증(Authentication) : 본인이 누구인지 확인 (로그인)&lt;/li&gt;
  &lt;li&gt;승인(Authorization) : 특정 리소스에 권한이 있는지 확인 (등급 권한)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;인증 (Authentication)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;인가 (Authorization)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;자격 증명 확인&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;권한 허가/거부&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;진행 방식&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비밀번호, 생체인식, 일회용 핀 또는 앱&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보안 팀에서 관리하는 설정 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 볼 수 있는가?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;예&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;아니오&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 직접 변경할 수 있는가?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부분적으로 가능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;불가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 전송&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ID 토큰 사용&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;액세스 토큰 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[test Series] 02 Mockito</title>
        <link>/test/2024/05/22/test-series-02-Mockito.html</link>
        <guid isPermaLink="true">/test/2024/05/22/test-series-02-Mockito.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/test/02.Mockito.md&quot;&gt;Dictionary - Mockito&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;mockito&quot;&gt;Mockito&lt;/h1&gt;

&lt;p&gt;직접 제어할 수 있는 가짜 객체를 지원하는 테스트 프레임워크다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;mocking
    &lt;ul&gt;
      &lt;li&gt;@Mock : 가짜 객체를 반환해주는 어노테이션&lt;/li&gt;
      &lt;li&gt;@Spy : Stub하지 @Mock과 비슷하지만 실제 객체를 할당하는 어노테이션&lt;/li&gt;
      &lt;li&gt;@InjectMocks: @Mock, @Spy를 자동으로 주입시키는 어노테이션&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stub
가짜 객체를 주입했을 때 원하는 동작을 오버라이딩하기 위해서
    &lt;ul&gt;
      &lt;li&gt;doReturn()&lt;/li&gt;
      &lt;li&gt;doNothing()&lt;/li&gt;
      &lt;li&gt;doThrow()
를 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 22 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[test Series] 01 Bdd</title>
        <link>/test/2024/05/22/test-series-01-BDD.html</link>
        <guid isPermaLink="true">/test/2024/05/22/test-series-01-BDD.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/test/01.BDD.md&quot;&gt;Dictionary - BDD&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;bddbehavior-driven-development&quot;&gt;BDD(Behavior-Driven Development)&lt;/h1&gt;

&lt;p&gt;시나리오를 기반으로 테스트하는 패턴을 의마한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;given : 시나리오 진행에 필요한 조건을 미리 설정해두는 단계&lt;/li&gt;
  &lt;li&gt;when : 시나리오를 진행 시 필요한 변화를 명시(mocking/ stubbing)&lt;/li&gt;
  &lt;li&gt;Then : 예상되는 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bddmockito&quot;&gt;BDDMockito&lt;/h2&gt;
&lt;h3 id=&quot;whenthenreturn&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when().thenReturn();&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;메소드를 실제 호출하지만 리턴 값을 정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;메소드 작업이 오래 걸린다면 끝까지 기다려야 한다.&lt;/li&gt;
  &lt;li&gt;실제 메소드를 호출하기에 호출 대상이 문제가 있으면 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;doreturnwhen&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doReturn().when();&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;실제 메소드 호출하지 않으면서 리턴 값을 정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;실제 메소드 호출하지 않기 때문에 호출 대상의 문제 여부는 확인할 수 없다.&lt;/li&gt;
  &lt;li&gt;void 리턴 메소드 stubbing 가능&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 22 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[nginx Series] 01 Reverseproxy</title>
        <link>/network/2024/05/22/nginx-series-01-ReverseProxy.html</link>
        <guid isPermaLink="true">/network/2024/05/22/nginx-series-01-ReverseProxy.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/Nginx/01.ReverseProxy.md&quot;&gt;Dictionary - Nginx&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;nginx-기본--reverseproxy&quot;&gt;Nginx 기본 + ReverseProxy&lt;/h1&gt;

&lt;h2 id=&quot;reverseproxy에-대한-기본-내용-참조-&quot;&gt;&lt;a href=&quot;../apache/01.ReverseProxy.md&quot;&gt;ReverseProxy에 대한 기본 내용 참조 &lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;config&quot;&gt;Config&lt;/h2&gt;

&lt;div class=&quot;language-nginx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;server_name&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;www.example.com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 띄어쓰기 민감한 편&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$http_x_forwarded_proto&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'http')&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kn&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;301&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$host$request_uri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;443&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;server_name&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;www.example.com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;rootPath&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;index.html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kn&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;/api&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://localhost:8080&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;syntax&quot;&gt;Syntax&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nginx -t&lt;/code&gt; 로 syntax 점검을 받을 수도 있다.&lt;/p&gt;
</description>
        <pubDate>Wed, 22 May 2024 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
