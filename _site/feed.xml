<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>newkayak12.github.io</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Thu, 23 May 2024 21:57:38 +0900</pubDate>
    
      <item>
        <title>[spring Series] 10.requiredargsconstructor</title>
        <link>/spring/2024/05/23/Spring-series-10.RequiredArgsConstructor.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-10.RequiredArgsConstructor.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/10.RequiredArgsConstructor.md&quot;&gt;Dictionary - Spring + Lombok-RequiredArgsConstructor&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;spring--requiredargsconstructor&quot;&gt;Spring + @RequiredArgsConstructor&lt;/h1&gt;

&lt;p&gt;spring 4.3부터 생성자가 하나만 있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowire&lt;/code&gt;를 기본으로 처리한다. 
이 부분이 Lombok의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequiredArgsConstructor&lt;/code&gt;와 궁합이 맞아 처리되는 것이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 09.applicationcontext</title>
        <link>/spring/2024/05/23/Spring-series-09.ApplicationContext.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-09.ApplicationContext.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/09.ApplicationContext.md&quot;&gt;Dictionary - Application Context&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;applicationcontext&quot;&gt;ApplicationContext&lt;/h1&gt;
&lt;p&gt;빈들의 생성과 의존성 주입 등의 역할을 하는 일종의 DI 컨테이너(애플리케이션을 실행하기 위한 황경)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListableBeanFactory&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HierarchicalBeanFactory&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MessageSource&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEventPublisher&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ResourcePatternResolver&lt;/code&gt; 를 상속 받음&lt;/p&gt;

&lt;h2 id=&quot;staticapplicationcontext&quot;&gt;StaticApplicationContext&lt;/h2&gt;
&lt;p&gt;빈 설정 메타 정보를 담은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanDefinition&lt;/code&gt;을 직접 만들고, 코드를 통해 IOC 등록하기 위해 사용되는 구현체이다.&lt;/p&gt;

&lt;h2 id=&quot;genericapplicationcontext&quot;&gt;GenericApplicationContext&lt;/h2&gt;
&lt;p&gt;XML 등의 외부에 있는 빈 설정 메타 정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanDefinitionReader&lt;/code&gt;로 읽어서 BeanDefinition을 정의하기 위해서 사용한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanDefinitionReader&lt;/code&gt; 구현체로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XmlBeanDefinitionReader&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PropertiesBeanDefinitionReader&lt;/code&gt; 등이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AbstractApplicationContext&lt;/code&gt;를 상속받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanDefinitionRegistry&lt;/code&gt;를 구현했다. 
내부에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultListableBeanFactory&lt;/code&gt;를 필드로 갖고 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;genericxmlapplicationcontext&quot;&gt;GenericXMLApplicationContext&lt;/h2&gt;
&lt;p&gt;XML 파일로 설정을 만들고 컨텍스트에서 XML 을 읽어서 사용하는 코드를 만들 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;webapplicationcontext&quot;&gt;WebApplicationContext&lt;/h2&gt;

&lt;h2 id=&quot;annotationconfigapplicationcontext&quot;&gt;AnnotationConfigApplicationContext&lt;/h2&gt;
&lt;p&gt;-&amp;gt; 일반 애플리케이션&lt;/p&gt;
&lt;h2 id=&quot;annotationconfigservletwebserverapplicationcontext&quot;&gt;AnnotationConfigServletWebServerApplicationContext&lt;/h2&gt;
&lt;p&gt;-&amp;gt; 서블릿 기반 웹 (Tomcat)&lt;/p&gt;
&lt;h2 id=&quot;annotationconfigreactivewebserverapplicationcontext&quot;&gt;AnnotationConfigReactiveWebServerApplicationContext&lt;/h2&gt;
&lt;p&gt;-&amp;gt; 리액터 Netty&lt;/p&gt;

&lt;h2 id=&quot;configurableapplicationcontext&quot;&gt;ConfigurableApplicationContext&lt;/h2&gt;
&lt;p&gt;거의 모든 애플리케이션 컨텍스트가 갖는 공통 애플리케이션 컨텍스트 인터페이스다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifeCycle&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Closable&lt;/code&gt;를 상속받는다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 08.autowired</title>
        <link>/spring/2024/05/23/Spring-series-08.Autowired.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-08.Autowired.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/08.Autowired.md&quot;&gt;Dictionary - Bean&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;abstractautowirecapablebeanfactory&quot;&gt;AbstractAutowireCapableBeanFactory&lt;/h1&gt;
&lt;p&gt;기본 빈 생성을 구현하는 추상 BeanFactory 상위 클래스. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RootBeanDefinition&lt;/code&gt; 클래스에서 지정한 모든 기능을 사용할 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AutowireCapableBeanFactory&lt;/code&gt; 인터페이스를 구현하며 빈 생성을 담당하는 createBean 메소드가 있다.&lt;/p&gt;

&lt;p&gt;Autowire 및 초기화를 제공하는 추상 beanFactory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowire&lt;/code&gt; 시 의존관계 주입이 필요한 Bean에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowire&lt;/code&gt; 처리를 한다.&lt;/p&gt;

&lt;h1 id=&quot;autowiredannotationbeanpostprocessor&quot;&gt;AutowiredAnnotationBeanPostProcessor&lt;/h1&gt;
&lt;p&gt;BeanPostProcessor를 상속 받고 있다. 내부 inject 메소드로 객체를 주입한다. 
&lt;a href=&quot;https://newkayak12.github.io/java/2024/05/23/07.Utils.md&quot;&gt;ReflectionUtils&lt;/a&gt;를 내부에서 사용하고 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 07.utils</title>
        <link>/spring/2024/05/23/Spring-series-07.Utils.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-07.Utils.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/07.Utils.md&quot;&gt;Dictionary - Spring Utils&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;beanutils&quot;&gt;BeanUtils&lt;/h1&gt;
&lt;p&gt;빈으로 만들 클래스 또는 객체에 대해 처리를 위한 Util을 제공한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;findMethod&lt;/li&gt;
  &lt;li&gt;findDeclaredMethod&lt;/li&gt;
  &lt;li&gt;getParameterNames&lt;/li&gt;
  &lt;li&gt;getResolvableConstructor&lt;/li&gt;
  &lt;li&gt;instantiateClass&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;reflectionutils&quot;&gt;ReflectionUtils&lt;/h1&gt;
&lt;p&gt;리플렉션 API를 편리하게 사용할 수 있도록 해준다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;accessibleConstructor&lt;/li&gt;
  &lt;li&gt;declaresException&lt;/li&gt;
  &lt;li&gt;findField&lt;/li&gt;
  &lt;li&gt;findMethod&lt;/li&gt;
  &lt;li&gt;getDeclaredMethods&lt;/li&gt;
  &lt;li&gt;getAllDeclaredMethods&lt;/li&gt;
  &lt;li&gt;getField&lt;/li&gt;
  &lt;li&gt;setField&lt;/li&gt;
  &lt;li&gt;invokeMethod&lt;/li&gt;
  &lt;li&gt;makeAccessible&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;filecopyutils&quot;&gt;FileCopyUtils&lt;/h1&gt;
&lt;p&gt;파일 복사를 위한 유틸, 파일을 바이트 배열로 복사하거나 문자열로 복사한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;copy&lt;/li&gt;
  &lt;li&gt;copyToByteArray&lt;/li&gt;
  &lt;li&gt;copyToString&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;systempropertyutils&quot;&gt;SystemPropertyUtils&lt;/h1&gt;
&lt;p&gt;시스템 property를 처리하기 위한 유틸&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;resolvePlaceholders&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;inputoutputstreamutils&quot;&gt;Input/OutputStreamUtils&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;copy&lt;/li&gt;
  &lt;li&gt;copyRange&lt;/li&gt;
  &lt;li&gt;copyToByteArray&lt;/li&gt;
  &lt;li&gt;copyToString&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;annotationutils&quot;&gt;AnnotationUtils&lt;/h1&gt;
&lt;p&gt;어노테이션, 메타 어노테이션을 핸들링하게 편하게 해주는 유틸&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;findAnnotation(Class&amp;lt;?&amp;gt; clazz, Class&lt;a&gt; annotationType) : 특정 clazz에서 annotationType으로 찾는다.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;findAnnotation(Method method, Class&lt;a&gt; annotationType) : Method로 순회하면서 annotationType으로 찾는다.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/AnnotationUtils.html&quot;&gt;참고&lt;/a&gt;
기본적으로 어노테이션을 찾는데 주력으로 한다.&lt;/p&gt;

&lt;h1 id=&quot;annotatedelementutils&quot;&gt;AnnotatedElementUtils&lt;/h1&gt;
&lt;p&gt;어노테이션 내용을 오버라이딩할 때 사용한다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 06.bean</title>
        <link>/spring/2024/05/23/Spring-series-06.Bean.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-06.Bean.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/06.Bean.md&quot;&gt;Dictionary - Bean&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;bean&quot;&gt;Bean&lt;/h1&gt;

&lt;h2 id=&quot;aware&quot;&gt;~Aware&lt;/h2&gt;
&lt;p&gt;콜백, 리스너, 옵저버 디자인 패넡이 혼합되어 있다.&lt;/p&gt;

&lt;h2 id=&quot;beannameaware&quot;&gt;BeanNameAware&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;객체가 컨테이너에 정의된 빈 이름을 인식하게 한다.&lt;/li&gt;
  &lt;li&gt;빈을 생성하는 시점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanName&lt;/code&gt;으로 이름을 얻어올 수 있다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean(name=&quot;&quot;)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;beanfactoryaware&quot;&gt;BeanFactoryAware&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;BeanFactory 객체를 주입하는데 사용된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanFactory&lt;/code&gt;를 통해서 beanFactory를 주입받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;beanfactory&quot;&gt;BeanFactory&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;빈을 생성하고 의존관계를 설정하는 기능을 담당하는 IOC 컨테이너&lt;/li&gt;
  &lt;li&gt;스프링 빈을 관리하고 조회하는 역할을 담당&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean()&lt;/code&gt;을 제공&lt;/li&gt;
  &lt;li&gt;Lazy-loading 을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;beandefinition&quot;&gt;BeanDefinition&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanDefinition&lt;/code&gt;을 기반으로 Bean을 생성한다.&lt;/li&gt;
  &lt;li&gt;상세
    &lt;ol&gt;
      &lt;li&gt;BeanClassName: 생성할 빈의 클래스 명&lt;/li&gt;
      &lt;li&gt;factoryBeanName: 팩토리 빈을 사용할 경우&lt;/li&gt;
      &lt;li&gt;factoryMethodName: 빈을 생성할 때 팩토리 메소드 이름&lt;/li&gt;
      &lt;li&gt;Scope: 싱글톤이 기본 값이다.&lt;/li&gt;
      &lt;li&gt;lazyInit: 스프링 컨테이너 생성시 Bean을 주입하는 것이 아니라 Proxy로 지연시켜서 생성할지 여부&lt;/li&gt;
      &lt;li&gt;initMethodName: 빈을 생성하고 의존 관계를 적용하고, 호출되는 초기화 메소드 명&lt;/li&gt;
      &lt;li&gt;DestroyMethodName: 빈의 생명 주기가 끝나고 제거되기 직전에 호출되는 메소드 명&lt;/li&gt;
      &lt;li&gt;Constructor arguments, Properties: 의존 관계 주입에서 사용&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;attributeaccessorsupport&quot;&gt;AttributeAccessorSupport&lt;/h2&gt;
&lt;p&gt;모든 메소드의 기본 구현을 제공, 서브클래싱으로 확장됨&lt;/p&gt;

&lt;h2 id=&quot;beanmetadataattributeaccessor&quot;&gt;BeanMetadataAttributeAccessor&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AttributeAccessorSupport&lt;/code&gt; 확장. 빈 메타 데이터를 정의로 담고 있다.&lt;/p&gt;

&lt;h2 id=&quot;abstractbeandefinition&quot;&gt;AbstractBeanDefinition&lt;/h2&gt;
&lt;p&gt;BeanDefinition의 추상 클래스&lt;br /&gt;
GenericBeanDefinition, RootBeanDefinition, ChildBeanDefinition의 뼈&lt;/p&gt;

&lt;h2 id=&quot;rootbeandefinition&quot;&gt;RootBeanDefinition&lt;/h2&gt;
&lt;p&gt;Spring Beanfactory의 특정 bean을 뒷받침&lt;/p&gt;

&lt;h2 id=&quot;genericbeandefinition&quot;&gt;GenericBeanDefinition&lt;/h2&gt;
&lt;p&gt;BeanDefinition 기본 형태라고 생각하면 된다. 클래스, Optional한 생성자 파라미터, 프로퍼티 값을 사요앟ㄹ 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;bean-scope&quot;&gt;Bean Scope&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Singleton : 싱글톤&lt;/li&gt;
  &lt;li&gt;Proto : 매번 다른 인스턴스 생성&lt;/li&gt;
  &lt;li&gt;Request : 웹 요청이 들어오고 나갈 때까지 유지&lt;/li&gt;
  &lt;li&gt;Session : 웹 세션이 생성되고 종료될 때까지&lt;/li&gt;
  &lt;li&gt;Application : 서블릿 컨텍스트와 같은 범위로 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;life-cycle&quot;&gt;Life cycle&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;BeanNameAware&lt;/li&gt;
  &lt;li&gt;BeanClassLoaderAware&lt;/li&gt;
  &lt;li&gt;BeanFactoryAware&lt;/li&gt;
  &lt;li&gt;EnvironmentAware&lt;/li&gt;
  &lt;li&gt;EmbeddedValueResolverAware&lt;/li&gt;
  &lt;li&gt;ResourceLoaderAware&lt;/li&gt;
  &lt;li&gt;MessageSourceAware&lt;/li&gt;
  &lt;li&gt;ApplicationContextAware&lt;/li&gt;
  &lt;li&gt;ServletContextAware&lt;/li&gt;
  &lt;li&gt;postProcessBeforeInitialization&lt;/li&gt;
  &lt;li&gt;Initializing Bean(afterPropertiesSet)&lt;/li&gt;
  &lt;li&gt;initMethod&lt;/li&gt;
  &lt;li&gt;postProcessAfterInitialization&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;beanfactorypostprocessor&quot;&gt;BeanFactoryPostProcessor&lt;/h2&gt;
&lt;p&gt;beanDefinition을 커스터마이징하게 도와준다. 모든 definition들이 로드 된 후 스프링의 startup 프로세스에 의해서 호출된다. 
그러나 아무런 Bean이 초기화된 상태는 아니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConfigBeanFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConfigurableListableBeanFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;


        &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DefaultListableBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerBeanDefinition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myBeanName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;


    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;beanpostprocessor&quot;&gt;BeanPostProcessor&lt;/h2&gt;
&lt;p&gt;Bean을 정의하고 컨테이너에 등록하기 전에 후처리 할 수 있도록 지원한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanPostProcessor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//생성 후 초기화 작업 이전&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//생성 후 초기화 작업 이후&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 05.bom</title>
        <link>/spring/2024/05/23/Spring-series-05.BOM.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-05.BOM.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/05.BOM.md&quot;&gt;Dictionary - BOM?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;bombill-of-materials&quot;&gt;BOM(Bill Of Materials)&lt;/h1&gt;
&lt;p&gt;BOM(Spring-boot-dependencies)는 스프링이 사용하는 여러 의존성 라이브러리 버전이 명시되어 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 04.eureka</title>
        <link>/spring/2024/05/23/Spring-series-04.Eureka.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-04.Eureka.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/04.Eureka.md&quot;&gt;Dictionary - Eureka&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;spring-eureka&quot;&gt;Spring Eureka&lt;/h1&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;eureka&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;allow-redirect&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#true/false &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 서버가 클라이언트 요청을 백업 서버/ 클러스터로 리디렉션 할 수 있는지 나타낸다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## true면 http 리디렉션을 새 서버 위치와 함께 클라인트로 보낼 수 있다.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;##    availability-zones: &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 리전의 가용 영역 목록을 가져옴&lt;/span&gt;

     &lt;span class=&quot;na&quot;&gt;backup-registry-impl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## BackupRegistry를 구현하는 구현의 이름을 가져온다. (레지스트리 정보에 대한 복원력이 필요할 때)&lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;cache-refresh-executor-exponential-back-oof-bound&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 시간 초과 발생 시 재시도 지연에 대한 최대 승수 값이다.&lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;cache-refresh-executor-thread-pool-size&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 초기화 할 cacheRefreshExecutor 쓰레드 풀 크기&lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;client-data-accept&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 클라이언트 데이터를 받을 유레카 이름&lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;disable-delta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 유레카 클라이언트가 변경된 부분만 가져올지 정합니다.    &lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;dollar-replacement&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;_&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## $대신할 문자열를 지정합니다.    &lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;escape-char-replacement&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;__&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## _대신할 문자열을 지정합니다.    &lt;/span&gt;
    
     &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## Eureka 클라이언트 활성화에 대한 설정이다.&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;eureka-connection-idle-timeout-second&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## HTTP 연결이 닫히기 전 idle을 유지할 수 있는 시간을 나타낸다.&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;eureka-server-connect-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 연결 초과되기 까지 대기하는 시간을 지정한다.&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;eureka-server-dns-name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DNS_NAME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 유레카 서버 목록을 가져 오기 위해 쿼리할 DNS 이름을 가져온다.&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;eureka-server-port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8761&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## Erureka Server port&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;eureka-server-read-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## read-timeout&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;eureka-server-total-connections&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 유레카 클라이언트에서 모든 유레카 서버로 허용되는 총 연결 수&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;eureka-server-total-connection-per-host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 유레카 클라이언트 - 서버 호스트 총 연결 수 &lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;eureka-service-url-poll-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 서버 정보의 변경을 폴링하는 빈도를 나타낸다.&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;fetch-registry&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 이 클라이언트가 유레카 레재스트리 정보를 가져와야하는지 여부를 나타낸다.&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;g-zip-content&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## eureka 서버에서 가져온 콘텐츠를 서버에서 지원할 때 압축할지 여부를 나타낸다.&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;initial-instance-info-replication-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;40&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 인스턴스 정보를 유레카 서버에 복제하는 초기 시간을 나타낸다.&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;instance-info-replication-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 유레카 서버에 복제 할 인스턴스 변경 사항을 복제하는 빈도&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;proxy-host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;proxy-port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;proxy-username&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;proxy-password&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 프록시 설정&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;registry-fetch-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 레지스트리 정보를 가져오는 빈도를 나타낸다.&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;service-url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;url&lt;/span&gt;
 
 &lt;span class=&quot;na&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;## 대시보드 설정&lt;/span&gt;
   
 &lt;span class=&quot;na&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;app-group-name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;앱 그룹 이름&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 애플리케이션 그룹 이름     &lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;appname&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;##  유레카에 등록할 이름을 가져온다.&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;health-check-url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## health check url 설정&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;health-check-url-path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/health&lt;/span&gt;

   &lt;span class=&quot;na&quot;&gt;home-page-url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;home-page-url-path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/&lt;/span&gt;
  
   &lt;span class=&quot;na&quot;&gt;instance-id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;## 인스턴스의 고유 아이디&lt;/span&gt;
   
   &lt;span class=&quot;na&quot;&gt;lease-expiration-duration-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;90&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;##  마지막 heartbeat - 인스턴스 제거 전 사이 시간을 지정한다.&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;lease-renewal-interval-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;##  하트 비트 인터벌을 정한다.( exipration-duration 보다 작아야 한다.)&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;prefer-ip-address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;##  호스트 이름 추측에 IP 주소를 사용해야 함을 나타내는 플래그&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 03.webflux</title>
        <link>/spring/2024/05/23/Spring-series-03.Webflux.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-03.Webflux.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/03.Webflux.md&quot;&gt;Dictionary - Webflux&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;webflux&quot;&gt;Webflux&lt;/h1&gt;
&lt;p&gt;SpringBoot Webflux는 서블릿을 버리고, 비동기로 진행하여 동시성을 최대화하여 가용성을 높히는 데 중점을 둔 프레임워크이다.
기본적으로 Java는 blocking code를 사용한다. Java는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.Publisher&lt;/code&gt;을 이용해서 ReactiveStreams를 구현해서 사용할 수 있다.
이에 대한 실제 구현체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RxJava&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reactor&lt;/code&gt;가 있다.&lt;/p&gt;

&lt;p&gt;추가로 Tomcat을 버리고 Netty를 채택해서 EventLoop 기반으로 처리하여 가용성을 더 높혔다.&lt;/p&gt;

&lt;p&gt;이를 사용하면&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메모리 가용성이 높아진다.&lt;/li&gt;
  &lt;li&gt;파이프 라인으로 pub/sub 프로세스를 연결하여 처리한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;reactive&quot;&gt;&lt;a href=&quot;https://newkayak12.github.io/java/2024/05/18/java-series-28-Reactive.html&quot;&gt;Reactive&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;java에서-비동기-처리&quot;&gt;Java에서 비동기 처리?&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Callback -&amp;gt; Callback Hell에 빠질 수 있음&lt;/li&gt;
  &lt;li&gt;Future -&amp;gt; CompletableFuture를 지원하긴 하지만 까다로움&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;백프레셔&quot;&gt;백프레셔&lt;/h2&gt;
&lt;p&gt;Pub/Sub의 균형이 무너질 때 생기는 형상이다. 소비보다 생성이 많을 때 발생한다. 이는 결국 메모리가 overflow 되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;로 이어진다.&lt;/p&gt;

&lt;h3 id=&quot;push&quot;&gt;push&lt;/h3&gt;
&lt;p&gt;Publisher가 이벤트를 밀어 넣는 형식 -&amp;gt; backpressure 발생할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;pull&quot;&gt;pull&lt;/h3&gt;
&lt;p&gt;Subscribe가 요청한 만큼만 전달&lt;/p&gt;

&lt;h3 id=&quot;cold-vs-hot&quot;&gt;Cold vs. Hot&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Cold -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subscribe&lt;/code&gt;로 이벤트 발현&lt;/li&gt;
  &lt;li&gt;Hot -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subscriber&lt;/code&gt;로 부터 시작하지 않는다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Publisher&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Emit&lt;/code&gt;하는 것을 기본으로 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;rxjava&quot;&gt;RxJava&lt;/h2&gt;
&lt;p&gt;ReactiveX(Netflix)에서 만들었다.&lt;/p&gt;

&lt;h3 id=&quot;publisher&quot;&gt;Publisher&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;한 건의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Single&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데이터가 없거나 한 건이면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;한 건 이상일 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observalbe&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rxjava에서-백프레셔-처리-방법&quot;&gt;RxJava에서 백프레셔 처리 방법&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observable&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;사용
```
| Observable
    &lt;ul&gt;
      &lt;li&gt;1000개 미만 데이터 발행시&lt;/li&gt;
      &lt;li&gt;적은 소스로 OOM 발생이 가능성이 낮을 경우&lt;/li&gt;
      &lt;li&gt;GUI 이벤트 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;| Flowable&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1000개 이상 데이터 발행 시&lt;/li&gt;
  &lt;li&gt;디스크 I/O&lt;/li&gt;
  &lt;li&gt;JDBC&lt;/li&gt;
  &lt;li&gt;네트워크 I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Backpressure 제어 전략&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;MISSING(BackpressureStrategy.MISSING) -&amp;gt; x&lt;/li&gt;
    &lt;li&gt;ERROR(BackpressureStrategy.ERROR) -&amp;gt; 발생시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MissingBackpressureException&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;BUFFER(BackpressureStrategy.BUFFER) -&amp;gt; 소비할 때까지 Queue, OOM 가능성 이씀&lt;/li&gt;
    &lt;li&gt;DROP(BackpressureStrategy.DROP) -&amp;gt; 소비하지 못한 데이터 버림&lt;/li&gt;
    &lt;li&gt;LATEST(BackpressureStrategy.LATEST) -&amp;gt; 받을 준비가 될 때까지 최신만 유지하고 버림&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
## Reactor
Pivotal에서 만들었다. 

### Publisher
1. 한 건은 `Mono`
2. 없거나 여러 건은 `Flux`

### Reactor에서 백프레셔 처리 방법
1. 버퍼링 -&amp;gt; OOM 가능성 있음
2. DROP -&amp;gt; `onBackpressureDrop()`으로 그냥 버려서 최악의 상황을 모면함
3. Latest -&amp;gt; `onBackpressureLatest()`으로 최근 이벤트만 유지
4. `flatMap()` -&amp;gt; 내부 Publisher로 변환하고 Merge하여 소비 속도 조절, 동시성 수준을 조절할 수 있어서 백프레셔 관리 가능(2번 째 파라미터로 동시성 제어)


### Operator

#### Create
1. just()
4. create()
2. fromStream()
3. fromIterable()

#### Sequence Control
1. flatMap() -&amp;gt; `map()` + 새로운 Sequence를 생성해서 내보 냄
2. concat() -&amp;gt; Publisher의 Sequence를 연결해서 emit
3. merge() -&amp;gt; Mono를 합침
4. zip() -&amp;gt; 여러 개의 Sequnce에서 emit 된 데이터를 결합

#### peeking
1. doOnNext() -&amp;gt; 처리되기 전 흐름에 영향 없이 무언가 하기 위해서 
2. doOnSuccess/doOnComplete -&amp;gt; 성공/완료 시
3. doOnError -&amp;gt; 에러 종료 시
4. doOnCancel -&amp;gt; 취소 시
5. doFirst -&amp;gt; 시작 시 
6. doOnSubscribe -&amp;gt; 구독 시
7. doOnRequest/doOnTerminate -&amp;gt; 요청/ 종료 시
8. log() -&amp;gt; Singal 이벤트 로깅

#### Filter
1. filter -&amp;gt; Filtering
2. take -&amp;gt; 통과 개수 지정

#### error
1. timeout -&amp;gt; timeOut 이내 emit 없으면 에러
2. retry -&amp;gt; 주어진 숫자만큼 재구독하도록

#### ignoreElement
1. then -&amp;gt; 작업 완료를 기다림
2. thenReturn -&amp;gt; then + return some Mono
3. thenMany -&amp;gt; then return + some Flux
4. distinct -&amp;gt; 중복 제거

#### split (Flux -&amp;gt; Flux&amp;lt;Flux&amp;lt;T&amp;gt;&amp;gt;)
1. window(int)
2. window(Duration)
3. buffer


#### toSynchronous
1. blockFirst/blockLast (flux)
2. toIterable/toStream (flux)
3. block (mono)
4. toFuture (mono)


### delay
1. delay/delayUntil -&amp;gt; 완료 연기

[참고 자료](https://colevelup.tistory.com/40)


-----------
# R2DBC ( Reactive Relational DataBase Connectivity )

JDBC 논 블로킹 버전이라고 이해하면 그나마 낫다.
## 장점
1. JDBC에서는 불가능한 논 블로킹 API를 제공한다.

## 단점
1. JDBC와 다르다. (JDBC에서 당연하게 사용하던 것들을 사용할 수 없다.)(caching, lazyLoading, write-behind 등)
2. 아직 성숙하지 않아서 공식적인 driver implementation이 없다.
3. R2DBC가 JDBC의 next가 되지 않을 가능성이 있다. (ProjectLoom은 JVM base DB Driver를 만들고 있다.)
[Java19, Loom](https://nipafx.dev/inside-java-newscast-27/)
[blogSpot](http://gunsdevlog.blogspot.com/2020/09/java-project-loom-reactive-streams.html)
4. JPA와 같은 관계성 매핑이 불가능하며, 캐싱, 영속성 컨텍스트 등을 제공하지 않는다.

## [QueryDsl](https://github.com/infobip/infobip-spring-data-querydsl)
JPA 처럼 queryDsl을 Third party로 지원하지만(QueryDsl도 thirdParty지만) 완벽하지 않다.


### 에러 사항

1. 네이밍 규칙
infobip Querydsl의 기본 네이밍 규칙이 Pascal이다. 이를 덮어 쓰기 위해서 Bean을 지정한다.
```java
@Configuration
public class QuerydslConfig {

    @Bean
    public NamingStrategy namingStrategy() {
        return new NamingStrategy(){
            @Override
            public String getTableName(Class&amp;lt;?&amp;gt; type) {
                return type.getSimpleName();
            }

            @Override
            public String getColumnName(RelationalPersistentProperty property) {
                return property.getName().substring(0, 1).toUpperCase() + property.getName().substring(1);
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/infobip/infobip-spring-data-querydsl?tab=readme-ov-file#R2DBCRequirements&quot;&gt;infobip querydsl README&lt;/a&gt;에서도
Flyway를 쓰던 SqlTemplate을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;으로 두던 하라고 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;템플릿 설정
```java
@Configuration
public class SqlTemplatesConfig {
 private final List&lt;String&gt; driver = Arrays.asList(&quot;mysql&quot;, &quot;maria&quot;);
 @Bean
 public SQLTemplates sqlTemplates (R2dbcProperties properties) throws SQLException {
     Boolean isStorageDB = driver.stream().map(driver -&amp;gt; properties.getUrl().contains(driver)).reduce(false, (p, n) -&amp;gt; p || n);&lt;/String&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; return isStorageDB ?
         MySQLTemplates.builder().escape('\\').quote().newLineToSingleSpace().build() :
         H2Templates.builder().quote().escape('\\').newLineToSingleSpace().build();  } }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;이 Template에 따라 Querydsl이 쿼리를 파싱하는 결과가 바뀐다. 뭐 예를 들어
```java

interface BoardQueryDslRepository extends QuerydslR2dbcRepository&amp;lt;Board, String&amp;gt; {
    
}

@Repository
@RequiredArgsConstructor
@Slf4j
class BoardRepository {
    private final BoardQueryDslRepository boardQuery;


    private BooleanBuilder condition(BoardType type, Language locale) {
        BooleanBuilder builder = new BooleanBuilder();
        if(Objects.nonNull(type)) board.type.eq(type);
        if(Objects.nonNull(locale)) builder.and(board.locale.eq(locale));

        return builder;
    }


    public Mono&amp;lt;Template&amp;gt; template(BoardType type, Language locale) {

        return boardQuery.query(query -&amp;gt; {
            return query.select(
                                new QBoardeDto(
                                        board.boardNo,
                                        board.boardType,
                                        board.locale,
                                        board.contents,
                                        board.lastModifiedDate
                                )
                        )
                        .from(template)
                        .where(this.condition(templateType, locale));
        }).one();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 있다면 where 절의 파라미터에 값을 바인딩할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'?'&lt;/code&gt;으로 네이밍을 잡아서 바인딩하려다 실패를 한다던가 하는 문제가 발생할 수 있다.
내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQLSQLTemplates&lt;/code&gt;인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instanceOf&lt;/code&gt;를 해서 파라미터 바인딩하는 것으로 보인다(Maria_r2dbc-connector). 따라서 기존에는 크게 신경 쓰지 않던 것에도
주의를 기울여야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MariaConnector에서 지원하지 않아서 Enum을 parameter로 던지면 codec 문제를 일으킨다(QueryDSL 기준) -&amp;gt; 해결 하지 못했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 02.actuator</title>
        <link>/spring/2024/05/23/Spring-series-02.Actuator.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-02.Actuator.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/02.Actuator.md&quot;&gt;Dictionary - Actuator&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;actuator&quot;&gt;Actuator&lt;/h1&gt;

&lt;p&gt;실행 중인 애플리케이션에 대한 정보를 제공한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;애플리케이션 환경에서 사용할 수 있는 구성 속성&lt;/li&gt;
  &lt;li&gt;애플리케이션에 포함된 다양한 패키지의 로깅 레벨&lt;/li&gt;
  &lt;li&gt;애플리케이션이 사용 중인 메모리&lt;/li&gt;
  &lt;li&gt;지정된 엔드 포인트가 받은 요청 횟수&lt;/li&gt;
  &lt;li&gt;애플리케이션의 건강 상태 정보&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Method&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Endpoint&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Default&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/aduitevents&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;audit 이벤트 리포트를 생성한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/beans&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;컨텍스트의 모든 빈을 리스트 업&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/conditions&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;성공 또는 실패한 자동 구성 조건의 내역을 생성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/configprop&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 구성 속성들을 현재 값과 같이 알려준다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET, POST, DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/env&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스프링에서 사용할 수 있는 모든 env를 보여준다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/env/{toMatch}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;특정 황경 속성 값을 보여준다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/health&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;건강상태를 보여준다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/heapdump&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;힙 덤프를 다운로드 한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/httptrace&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최근의 100개 요청을 tracing한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/info&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;개발자가 정의한 info를 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/loggers&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;패키지 - 로깅 레벨을 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET, POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/loggers/{name}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지정한 로거의 로깅레벨을 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/mappings&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP 매핑과 매핑을 처리하는 핸들러의 메소드들 내역을 제공&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/metrics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 메트릭 리스트 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/metrics/{name}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지정한 메트릭 값을 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/scheduledtasks&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스케쥴링된 모든 태스크의 내역을 제공&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/threaddump&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 애플리케이션 쓰레드의 내역을 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/shutdown&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플리케이션을 종료한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/refresh&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플리케이션 정보를 갱신한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;

  &lt;h3 id=&quot;refresh--yaml은-다시-불러온다-그러나-이미-주입된-bean은-다시-주입되지-않는다---아직까지-큰-실효성을-모르겠다&quot;&gt;Refresh =&amp;gt; Yaml은 다시 불러온다. 그러나 이미 주입된 Bean은 다시 주입되지 않는다. -&amp;gt; 아직까지 큰 실효성을 모르겠다.&lt;/h3&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[spring Series] 01.configuration</title>
        <link>/spring/2024/05/23/Spring-series-01.Configuration.html</link>
        <guid isPermaLink="true">/spring/2024/05/23/Spring-series-01.Configuration.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/spring/01.Configuration.md&quot;&gt;Dictionary - Spring Yaml settings&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;spring-configuration&quot;&gt;Spring Configuration&lt;/h1&gt;
&lt;h2 id=&quot;1-shutdown-gracefully&quot;&gt;1. Shutdown Gracefully&lt;/h2&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;graceful&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;##[default immediate]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spring&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;timeout-per-shutdown-phase&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2m&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러면 -9로 끝내는게 아니라 할 일을 다 마치고 종료된다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Transaction</title>
        <link>/others/2024/05/23/Others-series-Transaction.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Transaction.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/Transaction.md&quot;&gt;Dictionary - Transaction&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;

&lt;p&gt;격리 수준은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERIALIZABLE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE_READ&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_COMMITTED&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_UNCOMMITTED&lt;/code&gt;가 있으며, 왼쪽으로 가면 갈수록 격리성이 강해지며, 
오른쪽으로 가면 갈수록 동시성이 강해진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE_READ&lt;/code&gt;는 팬텀리드, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_COMMITTED&lt;/code&gt;는 팬텀리드, 반복 가능하지 않은 조회가 발생하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_UNCOMMITTED&lt;/code&gt;는 팬텀 리드, 반복 가능하지 않은
조회, 더티 리드가 발생할 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;격리-수준에-따라-발생하는-현상&quot;&gt;격리 수준에 따라 발생하는 현상&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;팬텀 리드 (Phantom read) : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.&lt;/li&gt;
  &lt;li&gt;반복 가능하지 않은 조회 (Non-repeatable read) : 한 트랜잭션 내의 같은 행이 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킨다.&lt;/li&gt;
  &lt;li&gt;더티 리드 (dirty read) : 반복 가능하지 않은 조회와 유사하며, 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아직 커밋되지 않은&lt;/code&gt; 행의 데이터를 읽을 수 있을 때 발생&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;격리-수준&quot;&gt;격리 수준&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Serializable : 트랜잭션을 순차적으로 진행시키는 것을 의미한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.&lt;/li&gt;
  &lt;li&gt;Repeatable_read : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만, 새로운 행을 추가하는 것을 막아주지는 않는다.&lt;/li&gt;
  &lt;li&gt;Read_committed : 기본 값이다. read_uncommitted와 다르게 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수는 있다.&lt;/li&gt;
  &lt;li&gt;read_uncommitted : 가장 낮은 격리 수준으로 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Semaphore And Mutex</title>
        <link>/others/2024/05/23/Others-series-Semaphore-and-Mutex.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Semaphore-and-Mutex.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/SemaphoreAndMutex.md&quot;&gt;Dictionary - Semaphore vs. Mutex&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;mutex&quot;&gt;Mutex&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로한 상호배제 기법&lt;/code&gt;
프로세스, 쓰레가 공유 자원을 lock()을 통해 잠금을 설정하고 사용한 뒤 unlock()으로 잠금 해제하는 객체 객체다.&lt;/p&gt;

&lt;h1 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Signaling mechanism. 현재 공유 자원에 접근할 수 있는 쓰레드, 프로세스 수를 나타내는 값을 둬서 상호배제를 이루는 기법&lt;/code&gt;
일반화된 뮤텍스, 간단한 정수 값과 두 가지 함수 wait 및 signal로 공유 자원에 대한 접근을 처리한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;은 자신의 차례가 올 때까지 기다리는 함수이며,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal()&lt;/code&gt;은 다음 프로세스로 순서를 넘겨주는 함수다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 세마포어
0, 1의 두 가지 값만 가질 수 있는 세마포어. 구현의 유사성으로 뮤텍스는 바이너리 세마포어라고 할 수 있지만 엄밀히 말하면 뮤텍스는 잠금 기반으로 상호 배제가 일어나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잠금 메커니즘&lt;/code&gt;이고, 세마포어는
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신호를 기반으로&lt;/code&gt; 상호 배제를 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신호 메커니즘이다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카운팅 세마포어
여러 개의 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는 데 사용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;monitor&quot;&gt;Monitor&lt;/h1&gt;
&lt;p&gt;모니터는 둘 이상의 쓰레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다.&lt;/p&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Process, Service And Daemon</title>
        <link>/others/2024/05/23/Others-series-Process,-Service-and-Daemon.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Process,-Service-and-Daemon.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/ProcessAndServiceAndDaemon.md&quot;&gt;Dictionary - Process vs. Service vs. Daemon&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;process-vs-service-vs-daemon&quot;&gt;Process vs. Service vs. Daemon&lt;/h1&gt;

&lt;h2 id=&quot;process&quot;&gt;Process&lt;/h2&gt;
&lt;p&gt;프로세스는 메모리에 적재되어 CPU에 의해 실행되는 컴퓨터 프로그램을 지칭한다. 각 프로세스는 고유한 프로세스 ID(PID)를 가지며, 운영체제는 프로세스 간의 자원 공유를 관리한다.
예를 들어, 웹 브라우저를 실행하는 경우 브라우저라는 프로그램은 하나의 프로세스로 실행되는 것이다. 그리고 프로세스는 눈에 보이는 프로세스(foreground process)와
눈에 보이지 않은 프로세스(background process)로 구분된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;foreground&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;background&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자와 상호작용하는 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스는 사용자와 상호작용하지 않고 시스템에서 실행되는 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최소화를 하더라도 눈에 보이는 프로세스를 포그라운드 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;눈에 보이지 않지만 뒤에서 일을 하고 있는 프로세스를 백그라운드 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터넷, 카카오톡, 메모장, 그림판 등 눈에 보이는 프로그램&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;백신 프로그램, 그래픽 드라이버, 마이크 드라이버 등 눈에 보이지 않는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;p&gt;서비스는 백그라운드에서 실행되는 응용 프로그램이다. 윈도우 서비스는 일반적으로 사용자 인터페이스를 필요로 하지 않는 작업(네트워크 서비스, 데이터베이스 서버, 백업 서비스) 등을 수행한다.
이러한 서비스들은 시스템이 부팅될 때 자동으로 시작되며, 사용자가 로그인하지 않은 상태에서도 계속해서 실행된다.
이렇게만 보면 데몬과 서비스의 차이가 잘 와닿지 않을 것인데, 윈도우 OS에서는 백그라운드에서 실행되는 응용 프로그램을 service 라 부르고 유닉스(리눅스) OS에서는 daemon 이라고 불린다고 보면 된다.&lt;/p&gt;

&lt;h2 id=&quot;daemon&quot;&gt;Daemon&lt;/h2&gt;
&lt;p&gt;데몬은 백그라운드에서 실행되는 프로그램으로, 사용자가 직접적으로 제어하지 않고 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다. 사용자의 요청을 기다리고 있다가
요청이 발생하면 이에 적절히 대응하는 리스너와 같은 역할을 한다. 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응 할 수 있도록 대기중인 프로세스를 말한다.&lt;/p&gt;

&lt;p&gt;예시)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;서비스 명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;데몬 명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux 슈퍼데몬&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xinetd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux 내 여러 서비스를 한번에 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;File Transfer Protocol&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;vsftpd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;File을 전송하는 서비스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Secure Shell Service&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sshd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;암호화 원격 작업이 가능한 서비스&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;service-vs-daemon&quot;&gt;Service vs. Daemon&lt;/h2&gt;

&lt;p&gt;Daemon 과 Service는 비슷한 개념이지만, 운영 체제 차이점 있다고 했다. 그외에도 사용처에도 차이가 있는데, 데몬은 일반적으로 서버에서 주로 사용되고, 서비스는 다른 프로그램이나 서비스를 지원하기 위해 실행된다.
데몬은 시스템에서 독립적으로 실행되고, 서비스는 시스템의 상태를 모니터링하고, 백그라운드에서 실행되는 애플리케이션을 제어하고, 작업을 수행하는 등의 역할 지원하는데 초점이 맞춰져 있다는 뜻이다.&lt;/p&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Os</title>
        <link>/others/2024/05/23/Others-series-OS.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-OS.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/OS.md&quot;&gt;Dictionary - OS&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;os&quot;&gt;OS&lt;/h1&gt;
&lt;p&gt;운영체제의 역할&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU 스케쥴링 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다.&lt;/li&gt;
  &lt;li&gt;메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지 관리한다.&lt;/li&gt;
  &lt;li&gt;디스크 파일 관리 : 디스크 파일을 어떤 방법으로 보관할지 관리한다.&lt;/li&gt;
  &lt;li&gt;I/O 디바이스 관리 : I/O 디바이스들과 컴퓨터 간의 데이터를 주고 받는 것을 관리한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/os.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시스템 호출(systemCall)이란 운영체제가 커널에 접근한기 위한 인터페이스이며, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다.&lt;/p&gt;

&lt;h1 id=&quot;컴퓨터의-요소&quot;&gt;컴퓨터의 요소&lt;/h1&gt;
&lt;p&gt;컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이뤄져 있다.&lt;/p&gt;

&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;CU(ControlUnit) : 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다.&lt;/li&gt;
  &lt;li&gt;레지스터 : 매우 빠른 임시기억 장치&lt;/li&gt;
  &lt;li&gt;산술논리연산장치 : 덧셈, 뺄셈 같은 두 숫자의 산술연산, 배타적 논리합, 곱 등같은 논리 연산을 계산하는 디지털 회로&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dma&quot;&gt;DMA&lt;/h2&gt;
&lt;p&gt;I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU에만  너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며, CPU의 일을 부담하는 역할을 한다.&lt;/p&gt;

&lt;h2 id=&quot;메모리&quot;&gt;메모리&lt;/h2&gt;
&lt;p&gt;메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음&lt;/li&gt;
  &lt;li&gt;캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음, L3도 있다.&lt;/li&gt;
  &lt;li&gt;주기억장치 : RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량이 보통&lt;/li&gt;
  &lt;li&gt;보조기억장치 : HDD, SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량 많음&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;
&lt;p&gt;캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목을 줄이기 위해서 사용하는 메모리를 말한다. 이를 통해 
데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;지역성의-원리&quot;&gt;지역성의 원리&lt;/h3&gt;
&lt;p&gt;자주 사용하는 데이터를 기반으로 설정해야 한다. 자주 사용하는 데이터에 대한 근거가 무엇일까? 시간 지역성(temporal locality), 공간 지역성(spatiaal locality)가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;시간 지역성
최근 사용한 데이터에 다시 접근하려는 특성을 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공간 지역성
최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스-히트&quot;&gt;캐시 미스, 히트&lt;/h3&gt;
&lt;p&gt;원하는 데이터를 찾는 것을 캐시 히트 반대를 캐시 미스라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-관리&quot;&gt;메모리 관리&lt;/h3&gt;
&lt;p&gt;가상 메모리는 메모리 관리 기법의 하나로 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;스와핑&quot;&gt;스와핑&lt;/h3&gt;
&lt;p&gt;가상 메모리에 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다. 이때 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 
HDD의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-폴트&quot;&gt;페이지 폴트&lt;/h3&gt;
&lt;p&gt;프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우 발생한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 없다면 트랩이 발생해서 운영체제에 알리게 된다.&lt;/li&gt;
  &lt;li&gt;OS는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.&lt;/li&gt;
  &lt;li&gt;해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체(스와핑)&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 갱신시킨 후 해당 명령을 다시 시&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;쓰레싱&quot;&gt;쓰레싱&lt;/h3&gt;
&lt;p&gt;Thrashing은 메모리의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터의 성능 저하를 초래한다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h3&gt;
&lt;p&gt;시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;연속 할당 : 메모리에 ‘연속적으로’ 공간을 할당하는 것을 의미
    &lt;ul&gt;
      &lt;li&gt;고정 분할 방식(fixed partition allocation) : 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어 있기 때문에 융통성이 없다. 또한 내부 단편화가 발생한다.&lt;/li&gt;
      &lt;li&gt;가변 불할 방식(variable partition allocation) : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 없지만 외부 단편화가 있을 수 있다. (최초 적합, 최적 적합, 최악 적합이 있다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;First Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Best Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Worst Fit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로세스의 크기와 가장 많이 차이가 나는 홀에 할당&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;

  &lt;p&gt;내부 단편화(Internal Fragmentation) : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
외부 단편화(External Fragmentation) : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 경우 
홀 (hole) : 할당할 수 있는 비어 있는 메모리 공간&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;불연속 할당
현대 OS가 쓰는 방법, 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것, 페이징 말고 세그맨테이션, 페이지드 세그멘테이션이 있다.
    &lt;ul&gt;
      &lt;li&gt;Paging : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다. 홀의 크긱가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.&lt;/li&gt;
      &lt;li&gt;Segmentation : 페이지가 아닌 의미 단위인 세그먼트로 나누는 방식이다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이뤄지는데, 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수도 있다. 이는 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않는 단점이 있다.&lt;/li&gt;
      &lt;li&gt;Paged Segmentation : 세그먼트로 나누는데, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;페이지 교체 알고리즘
offline : 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다. 
FIFO(First In First Out) : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미한다. 
LRU(Least Recently Used) : 참조가 가장 오래된 페이지를 바꾼다. 
NUR(Not Used Recently) : LRU에서 발, clock 알고리즘, 시계 방향으로 돌며 참조하면 1, 아니면 0. 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘
LFU(Least Frequently Used) : 가장 참조 횟수가 적은 페이지를 교체한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;프로세스-상태&quot;&gt;프로세스 상태&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/process.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;New : 프로세스 생성 상태, fork(), exec() 함수로 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;fork() : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수 (주소 공간만 복사)&lt;/li&gt;
  &lt;li&gt;exec() : 새롭게 프로세스를 생성하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ready : 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기, CPU 소유권이 넘어오기를 기다림
Ready Suspend : 메모리 부족으로 일시 중단된 상태&lt;/p&gt;

&lt;p&gt;Blocked : 어떤 이벤크가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다. 
Blocked Suspend : 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태&lt;/p&gt;

&lt;p&gt;Terminated : 메모리와 CPU 소유권을 모두 놓고 가는 상태부모가 자식 프로세스를 강제로 비자발적 종료로 종료되는 것도 있다. 자식 프로세스가 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process kill로 프로세스를 종료할 때 발&lt;/p&gt;

&lt;h2 id=&quot;컨텍스트-스위칭&quot;&gt;컨텍스트 스위칭&lt;/h2&gt;
&lt;p&gt;PCB를 기반으로 프로세스 상태를 저장하고 로드시키는 과정, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;PCB ( Process Control Block ) : 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 프로세스 제어 블록이라고도 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;쓰레드-멀티-쓰레딩&quot;&gt;쓰레드, 멀티 쓰레딩&lt;/h2&gt;
&lt;p&gt;쓰레드 : 프로셋의 실행 가능한 가장 작은 단위
멀티쓰레드 : 프로세스 내 여러 개의 쓰레드, 멀티 쓰레드로 처리하는 기법 쓰레드끼리 자원을 공유하기 때문에 효율성이 높음&lt;/p&gt;

&lt;h2 id=&quot;공유-자원&quot;&gt;공유 자원&lt;/h2&gt;
&lt;p&gt;shared resource는  시스템 안에서 각 프로세스, 쓰레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원이나 변수를 의미한다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을
경쟁 상태(race condition)이라고 한다.  동시 접근 시 타이밍, 순서 등이 결과에 영향을 준다.&lt;/p&gt;

&lt;h2 id=&quot;임계-영역&quot;&gt;임계 영역&lt;/h2&gt;
&lt;p&gt;둘 이상의 프로세스, 쓰레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 말한다. 임계영역을 해결하는 방법은 뮤텍스, 세마포어, 모니터 세 가지가 있다. 
모두 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;상호 배제(mutual exclusion)
한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.&lt;/p&gt;

  &lt;p&gt;한정 대기(bounded waiting)
특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하면 안 된다.&lt;/p&gt;

  &lt;p&gt;융통성(progress)
만약 어떠한 프로세스도 임계 영역을 사용하지 않으면 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며, 이 때 프로세스끼리 서로 방해하지 않는다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;SemaphoreAndMutex.md&quot;&gt;세마포어, 뮤텍스, 모니터&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착-상태deadlock의-원인&quot;&gt;교착 상태(Deadlock)의 원인&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가&lt;/li&gt;
  &lt;li&gt;점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태&lt;/li&gt;
  &lt;li&gt;비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다.&lt;/li&gt;
  &lt;li&gt;환형 대기 : 프로세스A는 프로세스B의 자원을 요구하고, 프로세스B는 A의 자원을 요고하는 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자원 할당 시 조건이 설림하지 않도록 설계&lt;/li&gt;
  &lt;li&gt;교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;은행원 알고리즘&lt;/code&gt;을 쓴다.&lt;/li&gt;
  &lt;li&gt;교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.&lt;/li&gt;
  &lt;li&gt;거의 일어나지 않지만 처리하는데 비용이 크다. 그래서 사용자에게 판단을 위임한다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>[others Series] Network</title>
        <link>/others/2024/05/23/Others-series-Network.html</link>
        <guid isPermaLink="true">/others/2024/05/23/Others-series-Network.html</guid>
        <description>&lt;p&gt;from &lt;a href=&quot;https://github.com/newkayak12/Dictionary/blob/master/cs/Network.md&quot;&gt;Dictionary - Network&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;network&quot;&gt;Network&lt;/h1&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;LAN : Local Area Network&lt;/li&gt;
  &lt;li&gt;MAN : Metropolitan Area Network&lt;/li&gt;
  &lt;li&gt;WAN : Wide Area Network&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tcpip-4계층---osi-7계층&quot;&gt;TCP/IP 4계층 - OSI 7계층&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/layer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcpip-4계층&quot;&gt;TCP/IP 4계층&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;L4 (애플리케이션 계층) : FTP/ HTTP/ SSH/ SMTP/ DNS -&amp;gt; 프로토콜 계층&lt;/li&gt;
  &lt;li&gt;L3 (전송 계층): TCP/ UDP/ QUIC -&amp;gt; 송,수신자를 연결하는 계층&lt;/li&gt;
  &lt;li&gt;L2 (인터넷 계층) : IP/ ARP/ ICMP -&amp;gt; 네트워크 패킷을 IP주소로 지정된 목적지로 전송하기 위해서 사용하는 계층&lt;/li&gt;
  &lt;li&gt;L1 (링크 계층) : ethernet -&amp;gt; 전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달하며 장치 간의 신호를 주고 받는 규칙을 정하는 계층&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;osi-7&quot;&gt;OSI 7&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;L7 (응용 계층) : HTTP/ FTP/ SMTP/ POP3/ IMAP/ Telnet과 같은 프로토콜이 있다. -&amp;gt; 응용 서비스를 수행 (L7 스위치)&lt;/li&gt;
  &lt;li&gt;L6 (표현 계층) : 코드 간의 번역을 담당하며, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 덜어준다. -&amp;gt; MIME 인코딩, 암호화 같은 동작을 수행 (압축, 포장, 암호화)&lt;/li&gt;
  &lt;li&gt;L5 (세션 계층) : 데이터가 통신하기 위한 노리적 연결을 한다. -&amp;gt; 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 (duplex, half-duplex, full-duplex), TCP/IP 세션을 만들고 없애는 책임을 가진다.&lt;/li&gt;
  &lt;li&gt;L4 (전송 계층) : 통신을 활성화 하기 위한 계층 단대단 오류제어 및 흐름 제어(UDP/TCP) -&amp;gt; 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있으며 연결 기반이다. (이는 전송계층이 패킷들의 전송이 유효한지 확인하고 실패한 패킷들을 다시 전송한다는 것이다.)&lt;/li&gt;
  &lt;li&gt;L3 (네트워크 계층) : 라우팅이 가장 중요한 기능이다. -&amp;gt; IP주소 부여, 라우팅 (라우터, L3 스위치)&lt;/li&gt;
  &lt;li&gt;L2 (데이터 링크 계층) : 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보 전달을 수행할 수 있도록 도와주는 역할을 한다. -&amp;gt; mac을 가지고 통신한다. 이 계층에서 전송되는 단위를 프레임이라고 한다. (L2 스위치, 브리지)&lt;/li&gt;
  &lt;li&gt;L1 (물리 계층) : 전기적, 기계적 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송한다. -&amp;gt; 단순 전기적 신호를 변환해서 주고 받는다. ( NIC, 리피터, AP)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
