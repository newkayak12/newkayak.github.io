<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>newkayak12.github.io</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>https://github.com/newkayak12/newkayak12.github.io/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Sat, 15 Jun 2024 23:15:35 +0900</pubDate>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-60.Optimize.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-60.Optimize.html</guid>
        <description>&lt;h1 id=&quot;최적화는-신중히&quot;&gt;최적화는 신중히&lt;/h1&gt;

&lt;p&gt;성능 떄문에 견고한 구조를 희생하지는 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라. 고민 해볼만한 문구다. 이 말은 완성하기 전에는 성능을 무시하라는 말이 아니다.
구현상 문제는 여러 변 다듬어 최적화할 수 있지만 이키텍쳐는 수정하기가 어렵다. 따라서 설계부터 탄탄해야한다는 의미와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;성능을 제한하는 설계를 피하라.&lt;/li&gt;
  &lt;li&gt;API 설계시 성능에 주는 영향을 고려하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 정도를 고민해보면 될 것 같다. 보통 잘 설계하면 성능이 잘 나온다. 그러니 이미 망친 설계에서 좋은 성능을 위해 노력하는 건 앞 뒤가 맞지 않는다.
만약 해야만 한다면 프로파일링 도구에 도움을 받는 것도 좋다.&lt;/p&gt;

&lt;h1 id=&quot;컨벤션을-다르자&quot;&gt;컨벤션을 다르자.&lt;/h1&gt;

&lt;p&gt;자바는 컨벤션이 잘 정립됐다. 그리고 언어 명세에도 기술되어 있다. 이 규칙들은 특별한 이유가 없는 한 반드시 따라야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;역도메인을 패키지 이름으로 하는 것&lt;/li&gt;
  &lt;li&gt;각 요소는 8자 이하의 짧은 단어로 축약 (utilities 보다는 utils)&lt;/li&gt;
  &lt;li&gt;클래스, 인터페이스 일므은 하나 이상의 단어 조합으로, upper camel case&lt;/li&gt;
  &lt;li&gt;메소드 필드명은 lower camel case&lt;/li&gt;
  &lt;li&gt;상수는 upper case&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그외 get, set으로 시작하는 형태는 javaBeans 명세에 뿌리를 두고 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-59.Native.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-59.Native.html</guid>
        <description>&lt;h1 id=&quot;네이티브-메소드는-신중히-사용하라&quot;&gt;네이티브 메소드는 신중히 사용하라&lt;/h1&gt;

&lt;p&gt;자바 네이티브 인터페이스( Java Native Interface, JNI )는 자바 프로그램이 네이티브 메소드를 호출하는 기술이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;레지스트리 같은 플랫폼 특화 기능을 사용한다.&lt;/li&gt;
  &lt;li&gt;네이티브 코드로 작성된 기존 라이브러리를 사용한다.&lt;/li&gt;
  &lt;li&gt;성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;플랫폼 특화 기능을 활용하려면 네이티브 메소드를 사용해야 한다. 자바가 성숙해지면서 점차 네이티브 메소드를 사용할 일이 줄어든다. 그 예시가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process api&lt;/code&gt;다.
그러나 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다. 이미 자바가 성숙됐다.&lt;/p&gt;

&lt;p&gt;또한 네이티브 메소드에는 심각한 단점이 있다. 네이티브 언어가 안전하지 않으므로 네이티브 메소드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다.
뿐만 아니라 CG 관장 영역이 아니므로 메모리를 자동으로 회수하거나 추적조차 불가하다. 마지막으로 네이티브 - 자바 간 접착 코드(glueCode)가 필요한데 번거로운 작업이다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-58.UseInterfaceAsType.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-58.UseInterfaceAsType.html</guid>
        <description>&lt;h1 id=&quot;객체는-인터페이스를-사용해서-참조하자&quot;&gt;객체는 인터페이스를 사용해서 참조하자.&lt;/h1&gt;

&lt;p&gt;인터페이스를 구현하고 인터페이스를 타입으로 사용할 수 있다. 이렇게 인터페이스를 타입으로 사용하면 매개변수로서, 반환 값으로서, 변수, 필드로서 유연성을 갖게 된다.
단, 인터페이스 규약 이외 기능을 제공하고, 코드가 이에 기대서 작동한다면 일관성이 무너져 코드가 실패할 가능성이 있다. 그럴 경우 해당 기능을 인터페이스에 
기입하여, 필수 구현 항목으로 지정하는 것이 나을 수 있다.&lt;/p&gt;

&lt;p&gt;물론 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다. 혹은 클래스 기반으로 작성됐다면 어쩔 수 없다. 마지막으로 특정 클래스에 국한되어 특별한 기능을
제공한다면 인터페이스 타입을 포기할 수밖에 없다. 적합한 인터페이스가 없다면 클래스 계층 구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하는게 좋다.&lt;/p&gt;

&lt;h1 id=&quot;리플렉션&quot;&gt;리플렉션?&lt;/h1&gt;

&lt;p&gt;리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.&lt;/li&gt;
  &lt;li&gt;리플렉션을 이용하면 코드가 지저분하고 장황해진다.&lt;/li&gt;
  &lt;li&gt;성능이 떨어진다. (처음에만 느리다고들 한다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;물론 리플렉션을 아주 제한된 형태로만 사용해야 장점만 취할 수 있다. 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해서 사용하자.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-57.BoxingIsHeavy.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-57.BoxingIsHeavy.html</guid>
        <description>&lt;h1 id=&quot;박싱은-무겁다-기본-타입을-사용하자&quot;&gt;박싱은 무겁다. 기본 타입을 사용하자.&lt;/h1&gt;

&lt;p&gt;기본 타입과 박싱된 타입의 차이는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;기본 타입은 값만 가지고 있으나 박싱 타입은 식별성을 갖는다.&lt;/li&gt;
  &lt;li&gt;기본 타입은 언제나 유효하지만 박싱 타입을 null을 가질 수 있다.&lt;/li&gt;
  &lt;li&gt;기본 타입이 박싱 타입보다 시간, 메모리 사용면에서 더 효율적이다.&lt;/li&gt;
  &lt;li&gt;기본 타입은 동등 연산자로 비교가 가능하지만 박싱은 기본타입으로 바꿔서 비교해야 한다. ( 기본/ 박싱을 비교하면 자동으로 박싱이 풀린다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 이유로 식별성을 갖거나 제네릭으로 사용하거나 null을 식별값으로 가져야만 한다면 사용을 고려해봄직 하다. 마지막으로 리플렉션을 통해 메소드를 호출할 때도 박싱된 타입을
사용해야 한다.&lt;/p&gt;

&lt;h1 id=&quot;충족되는-타입이-있다면-문자열은-피하자&quot;&gt;충족되는 타입이 있다면 문자열은 피하자.&lt;/h1&gt;

&lt;p&gt;문자열은 문자열이다. 다른 값을 표현하기 위한 수단으로는 부적합하다. 또한 혼합 타입을 대신하기에도 적절하지 않다. 정말 해당 타입인지, 값이 맞는지 파싱하고 검증하고
굉장히 손이 많이 간다. 당연히 오류 가능성도 커진다.&lt;/p&gt;

&lt;h1 id=&quot;문자열-연결----은-피하자&quot;&gt;문자열 연결 (“” + “”) 은 피하자.&lt;/h1&gt;

&lt;p&gt;문자열 역시 + 연산자로 합칠 수 있다. 굉장히 편리하다. 문자열은 값 타입이 아니다. 문자열 연결을 본격적으로 사용하면 성능 저하를 면치 못할 것이다. 문자열 연결 
연산자로 n개를 이으면 n^2에 비례햔다. 앞서 말한 듯 값 타입이 아니라 양 쪽 내용을 복사해서 새롭게 만들어야 한다. 차라리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuffer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;를 사용하자.&lt;/p&gt;

&lt;p&gt;추가로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringTokenizer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String.split()&lt;/code&gt;으로 문자열을 분할할 수도 있다. 이는 상황에 따라 속도가 다른데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringTokenizer&lt;/code&gt;가 빠른 경우는&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Delimiter가 하나라면 Tokenizer&lt;/li&gt;
  &lt;li&gt;Delimiter가 ascii 값이라면&lt;/li&gt;
  &lt;li&gt;순회하는게 아니라면&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;의 경우가 있다. 보통 tokenizer가 빠르다. split이 내부에서 정규 표현식을 사용해서 처리하기 떄문이다. 그러나&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Delimiter가 여러 개면 내부에서 여러 번 스캐닝 작업을 한다.&lt;/li&gt;
  &lt;li&gt;유니코드라면 색인이 느리다.&lt;/li&gt;
  &lt;li&gt;hasMoreToken, nextToken을 호출하면 그 때마다 풀 스캔을 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;는 특징으로 tokenizer가 빠를 때도 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-56.FloatingPoint.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-56.FloatingPoint.html</guid>
        <description>&lt;h1 id=&quot;부동-소수점-이슈&quot;&gt;부동 소수점 이슈&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://newkayak12.github.io/java/2024/05/18/java-series-22-FloatingPoint.html&quot;&gt;blog&lt;/a&gt;에서 다룬 바와 같이 부동소수 계산에는 정밀도가 
떨어진다는 문제가 있다. 그래서 소수점이 있는 금융 계산에 치명적이다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt;을 사용해야 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-55.EnhancedFor.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-55.EnhancedFor.html</guid>
        <description>&lt;h1 id=&quot;for-each&quot;&gt;For-Each&lt;/h1&gt;

&lt;p&gt;for가 while보다 낫지만 그래도 너무 지저분하다. for-each(enhanced for statement)을 쓰면 인덱스를 위한 변수와 이를 증감 시키는 코드를 작성하지 않아도
해당 반복자의 요소를 모두 순회할 수 있다.&lt;/p&gt;

&lt;p&gt;단, 몇 가지 상황에서 사용하지 못할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파괴적 필터링(destructive filtering) : 컬렉션/배열을 순회하면서 선택 원소를 제거한다면 인덱스의 변화가 생길 수 있다.&lt;/li&gt;
  &lt;li&gt;변형(transforming) : 리스트/배열에 인덱스로 접근해서 요소를 수행해야 한다면 인덱스가 필요해서 사용하지 못할 수 있다.&lt;/li&gt;
  &lt;li&gt;병렬 반복 : 여러 컬렉션/배열을 병렬로 순회해야 한다면 인덱스로 조절하는게 쉬울 수도 있다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/15/Effective-java-series-54.LocalVariable.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/15/Effective-java-series-54.LocalVariable.html</guid>
        <description>&lt;h1 id=&quot;지역변수-범위-최소화&quot;&gt;지역변수 범위 최소화&lt;/h1&gt;

&lt;p&gt;지역 변수 범위를 줄이는 기법은 ‘가장 처음에 쓸 때 선언하기’가 있다. 그러나 미리 선언하면 코드가 어수선해지 쉽상이다. 또한 너무 고민 없이 선언하면 변수가 쓰이는
범위보다 너무 앞서 선언하게 되거나, 다 쓴 뒤에도 살아있게 될 수 있다. 또한, 지역변수는 대부분 선언과 동시에 초기화를 해야하는데 초기화 정보가 모자라도 선언을 하는
일을 맞닥뜨리게 될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;while-vs-for&quot;&gt;while vs for&lt;/h2&gt;
&lt;p&gt;for가 낫다. while은 안에서 사용하는 변수를 바깥에서 선언해야할 때가 있다. 그러면 그 이름의 변수를 다른 의미로 아래에서 또 사용해야 한다면?
실수하기 쉽다. for는 for 블록에서 선언하므로 크게 문제가 되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{...}&lt;/span&gt;


&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{...}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//이러면 안돌고 지나간다.&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메소드를-잘게-쪼개기&quot;&gt;메소드를 잘게 쪼개기&lt;/h2&gt;
&lt;p&gt;메소드를 기능 단위로 단일 책임을 지우면 그게 최고다. 또한 이러면 메소드 단위가 작아져 지역 범위를 최소화할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-53.Optional.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-53.Optional.html</guid>
        <description>&lt;h1 id=&quot;옵셔널-반환은-신중히&quot;&gt;옵셔널 반환은 신중히&lt;/h1&gt;

&lt;p&gt;옵셔널이 나오기 전, 예외를 던지거나 null을 반환하거나 했다. 그러나 이는 에외를 예외답게 사용하지 않는다는 점과 stackTrace 캡쳐에 리소스가 크게 든다는 점
NPE에 시달려야 한다는 점 불편한 점이 많았다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt;은 자바 8에 추가 됐다. Optional은 원소 1개를 최대로 가지는 불변 컬렉션이다. Optional에서는 null이면 에러를 던질 수도, 기본 값을 할당할 수도 있다.
NPE에서 비교적 자유로워진다. 예외검사와 NullCheck를 모두 겸할 수 있다. 굉장히 편리하지만 무조건 좋은건 아니다.&lt;/p&gt;

&lt;p&gt;Collection, Stream, Array 같은 컨테이너 타입은 Optional로 감싸면 원타입도 무거운데 optional로 감싸서 리소스가 너무 많이 든다. 박싱 타입도 같은 이유로
지양하면 좋다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalInt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalLong&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionalDouble&lt;/code&gt;을 제공한다. 기본 타입으로 말이다. 또한 Optional를 컬렉션 키로 하는 것도 지양하자.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-52.IfNullReturnArray.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-52.IfNullReturnArray.html</guid>
        <description>&lt;h1 id=&quot;null-대신-빈-컬렉션이나-배열을-반환하자&quot;&gt;null 대신 빈 컬렉션이나 배열을 반환하자&lt;/h1&gt;

&lt;p&gt;컨테이너(배열, 컬렉션)이 비었을 때 선택지는 null, 빈 컨테이너 둘 중 하나다. null을 값으로 생각하면 null을 리턴할 수도 있다. 그러나 NPE 등 고려할 것들이
많아진다. 혹자는 빈 컨테이너 생성도 리소스라고 할지 모른다. 그러나 오히려 방어 로직이 훨씬 골치아픈 일이 될 수도 있다. 결론적으로 말하면 그렇고 하나씩 따져보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;빈 컨테이너 생성? 성능에 큰 영향이 가지 않는다. : 이 정도 리소스 할당은 전혀 문제가 되지 않는 정도의 컴퓨팅 성능을 보인다.&lt;/li&gt;
  &lt;li&gt;빈 컨테이너를 그냥 반환하면 된다. : 빈 컨테이너를 확인하고 null을 반환하는 것보다 훨씬 간편하고 의미적으로도 맞다.&lt;/li&gt;
  &lt;li&gt;정말로 신경쓰이면 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptyList()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptyMap()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection.emptySet()&lt;/code&gt;을 반환하는 방법이 있다. 배열도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new int[0]&lt;/code&gt;을 반환하면 된다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-51.ReallyUseVarArgs.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-51.ReallyUseVarArgs.html</guid>
        <description>&lt;h1 id=&quot;가변인수는-신중히&quot;&gt;가변인수는 신중히&lt;/h1&gt;

&lt;p&gt;가변 인수를 호출하면 인수 개수와 길이가 같은 배열을 만들도 배열에 저장해서 가변인수 메소드에 건낸다. 인수 개수는 런타임에 알 수 있다. 이런 불확실성은 왠지 모르게
불편해지는 부분이다. 더군다나 인수가 1개 이상 필요한데, 가변 인수를 안 넘기면? 원소가 0인 배열이 만들어지고 이를 위한 방어 로직을 짜야한다.&lt;/p&gt;

&lt;p&gt;이 경우 꼭 필요한 원소는 파라미터로 선언하고 그 다음부터 가변인수로 만들면?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//이거 대신&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//이렇게 바꾸면?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;성능적으로 보면? 권장하지 않는다. 이 비용은 감당하기 싫으면서 유연성이 필요하다면?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;스프링에 있는 Jooq가 이런식으로 구현해놓은 경우가 있다. 이러면 마지막 케이스는 정말 극소수가 될거다. 자연스레 비용이 준다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-50.ConsiderOverload.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-50.ConsiderOverload.html</guid>
        <description>&lt;h1 id=&quot;다중-정의는-신중히&quot;&gt;다중 정의는 신중히&lt;/h1&gt;

&lt;p&gt;다중 정의된 메소드는 컴파일 타임에 정해진다. 그런데! 매개변수가 일전의 다중 정의 매개변수들을 모두 포함할 수 있는 
다중정의라면? 해당 메소드 외는 호출될 가능성이 없다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overloading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 파라미터가 Collection&amp;lt;?&amp;gt;인 메소드만 열심히 호출된다. 다중정의한 메소드는 객체 런타임 타입은 중요하지 않다. 오로지 컴파일 타임에,
오직 매개변수의 컴파일 타입에 의해 결정된다. 다중 정의는 혼동을 일으킬 여지가 있는 방식이다. 안전하게 하려면 매개변수 수가 같은 다중정의는 지양하는 것이 좋다.
더구나 가변인수를 사용하는 메소드는 아예 꿈도 꾸지 않는게 좋다. 차라리 이름을 다르게 짓는게 낫다.&lt;/p&gt;

&lt;p&gt;가장 좋은 방법은 위의 여지가 없는 아예 명확히 구분되는 형식으로 다중정의하는 것이 최고다. 다중 정의의 실효성이야 확실하니 말이다.
예를 들어&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;의 경우에서 remove는 (Object o), (int index)가 있다. 여기서&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;던지면&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;둘&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;중&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;어떤걸&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;실행할까&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boxing된&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다중 정의의 최상의 결과는 언제 어떤 메소드가 불리는지는 모르는데 아주 명확히 잘 작동하는 경우다. 신경 쓸 게 없는 경우말이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-49.MethodSignature.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-49.MethodSignature.html</guid>
        <description>&lt;h1 id=&quot;메소드-시그니처를-신중히-설계하자&quot;&gt;메소드 시그니처를 신중히 설계하자.&lt;/h1&gt;

&lt;p&gt;고민할 점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메소드 이름을 신중히 짓자.&lt;/li&gt;
  &lt;li&gt;편의 메소드를 너무 많이 만들지 말자.&lt;/li&gt;
  &lt;li&gt;매개변수는 구성을 고민하자. 매개변수는 최대 4개 정도가 좋다. 특히 같은 타입이 연달아 나오면 문제가 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3번은 아래와 같은 기술로 헤쳐나갈 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메소드를 쪼개거나&lt;/li&gt;
  &lt;li&gt;매개변수를 묶는 컨테이너 클래스를 만들거나&lt;/li&gt;
  &lt;li&gt;1 + 2의 빌더 패턴을 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여담으로 매개변수 타입은 클래스보다 인터페이스가 나을 수 있다. 그러면 유연성이 올라간다. 또한 단순 boolean 보다는 직관성을 위해서 Enum 두 개가 나을 수도 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-48.DepensiveClone.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-48.DepensiveClone.html</guid>
        <description>&lt;h1 id=&quot;방어적-복사본을-고려하자&quot;&gt;방어적 복사본을 고려하자.&lt;/h1&gt;

&lt;p&gt;자바는 시스템의 다른 부분과는 별개다. 그래서 불변식이 자연스레 지켜진다. 그럼에도 불변식을 지키기 위한 노력은 계속된다. 우리는 개발할 때 누군가는 이를 무너뜨리려한다고
가정하고 방어적으로 프로그램을 작성해야 한다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Date&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getter&lt;/code&gt;로 리턴해도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setYear&lt;/code&gt;같은 메소드를 콜하면 원본이 변경되므로
불변식을 지킬 수 없다. 이런 경우 아예 복사본을 던질 수도 있다.&lt;/p&gt;

&lt;p&gt;매개변수 유효성 검사에서도 그 전에 방어적 복사본을 두고 복사본으로 검사하면 특히 멀티쓰레딩 환경에서 원본을 지킬 수 있다는 장점이 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면 이상하다 정상일지 아닐지 모르는 객체를 복사한다? 그러나 위에 기술한 바와 같이 멀티 쓰레딩 환경에서는 찰나에 어떤 문제가 생길지 모른다.
검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격을 받을 경우 위 코드는 방어할 수 있다. 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone&lt;/code&gt;을 사용하지 않았는데,
clone 재정의로 어떻게 될지 모른다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;


&lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;period&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;방어적 복사본을 반환해서 위의 불변식을 해치는 상황을 막을 수 있다. 방어적 복사가 불변 객체만을 위한건 아니다. 메소드든 생성자든 클라이언트가 제공한 객체의 참조를
내부의 자료구조에 보관해야 한다면 그 객체가 잠재적으로 변경될 수 있는지 확인해야 한다. 확실할 수 없다면 복사본을 만들자.&lt;/p&gt;

&lt;p&gt;방어적 복사가 항상 옳은건 아니다. 성능 저하가 수반되고 항상 사용할 수 있는 건 아니다. 또한, 호출자가 컴포넌트 내부를 수정하지 않을거라는 확신이 있다면 방어적 복사를
생략할 수도 있다. 또한 생략으로 영향이 클라이언트에게만 간다고 확신한다면 생략할 수도 있다.&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/13/Effective-java-series-47.ChechParameter.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/13/Effective-java-series-47.ChechParameter.html</guid>
        <description>&lt;h1 id=&quot;매개변수가-유효한지-검사하라&quot;&gt;매개변수가 유효한지 검사하라&lt;/h1&gt;

&lt;p&gt;인덱스 값은 음수이면 안되며, 객체 참조는 null이 아니어야 한다. 뭐 이런 제약은 문서화 해서 남겨야 한다. 또한 메소드 시작점에 검사해서 오류를 미리 방지해야 한다.
이 검사를 소홀이 하면 메소드 수행 중간 에러를 던지거나, 잘 실행됐는데 잘못된 결과를 반환하거나, 메소드 결과는 정상이지만 나중에 보면 객체가 오염되어 있다던가
결론적으로 실패 원자성을 어기는 결과를 낳을 수 있다.&lt;/p&gt;

&lt;p&gt;이런 검사를 위해서 자바7에서 추가된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Objects.requireNonNull&lt;/code&gt; 등의 유틸 메소드로 검사를 하는 방법이 있다. 자바9에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkFromIndexSize&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkFromToIndex&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkIndex&lt;/code&gt; 등의 메소드가 추가됐다. 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt;로 유효성 검증을 할 수도 있다.&lt;/p&gt;

&lt;p&gt;또한 생성자 매개변수 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않도록 하기 위해서 필요하다. 몸체 실행 전, 그러니까 시작하자마자 검사해야한다는
규칙에도 예외는 있다. 유효성 검사 비용이 너무 높거나 실용적이지 않으면 혹은 계산 중 암묵적으로 검사가 수행될 때말이다. 그러나 암묵적 유효성 검사는 어디까지나
암묵적이다. 실패 원자성을 해칠 여지가 여전히 존재한다.&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Effective java</title>
        <link>/effective_java/2024/06/12/Effective-java-series-46.ParallelStream.html</link>
        <guid isPermaLink="true">/effective_java/2024/06/12/Effective-java-series-46.ParallelStream.html</guid>
        <description>&lt;h1 id=&quot;병렬-스트림&quot;&gt;병렬 스트림?&lt;/h1&gt;

&lt;p&gt;자바 7부터 고성능 병렬 분해(Parallel decom-position) 프레임워크인 포크-조인을 추가했다. 자바 8부터는 병렬 파이프라인을 병렬 실행할 수 있는 스트림을 지원한다.
이를 통해 동시성 프로그램을 작성하기 쉬워지고 있다. 그러나 남용하면 안된다.&lt;/p&gt;

&lt;p&gt;보통 병렬 스트림을 사용하면 무조건 더 빨라질거라고 생각하지만 그렇지 않다. 예를 들어 스트림을 병렬으로 나누느라 리소스를 더 가져간다거나 혹은 실패할 수도 있다.
또한 중간 연산으로 limit을 사용하면 병렬 연산의 의미가 퇴색된다. limit을 사용하면 CPU 코어가 남으면 원소를 더 처리하고 제한 개수 이후 결과는 버려도 된다고
가정한다. 이는 계산 하나하나 연산이 오래걸리는 작업이라면 버릴 결과를 위해서 연산을 하는 것과 같다.&lt;/p&gt;

&lt;p&gt;따라서 리소스, 병렬로 나눴을 때 효용성을 고려해야 한다. 스트림 소스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;의 인스턴스거나 배열
int 범위, long 범위일 경우 효과가 좋다. 이들의 공통점은 순차적으로 실행할 때 참조 지역성이 뛰어다는 것이다.&lt;/p&gt;

&lt;p&gt;또한 종단 연산 중 reduction에 적합하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anyMatch&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allMatch&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noneMatch&lt;/code&gt; 같은 연산 말이다. 가변 축소하는
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect&lt;/code&gt;는 그다지 병렬에 적합하지 않다.&lt;/p&gt;

&lt;p&gt;정리하면 스트림 병렬에는 주의해야 한다. 항상 행복한 결과가 있지는 않다. 성능이 나빠지거나 예상치 못한 동작을 발생할 수 있다. 또한 병렬화에 드는 추가 비용을 상쇄할 정도의
결과가 나오지 않으면 단일 스트림이 낫다.&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jun 2024 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
